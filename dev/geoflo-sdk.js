/*!
 * /*!
 *  * GeoFlo SDK
 *  * Version 1.0.11
 *  * Generated on: 2025-02-04T16:35:33.364Z
 *  * /
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Control.js":
/*!************************!*\
  !*** ./src/Control.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Control
 * @description This module is responsible for creating and managing the control buttons in the Geoflo application.
 * @param {Array} controls - An array of control objects to be added to the map.
 * @param {Object} options - An object containing options for the control buttons.
 * @returns {Object} Returns the Control object.
 */

const Control = function (controls, options={}) {
    const geoflo = this.geoflo;

    this.controls = controls;
    this.options = options;

    var rgba = function (hex, alpha) {
        hex = hex.trim();


        if (hex.includes('rgba')) {
            hex = this.hex(hex);
        } else {
            if (!hex || [4, 7].indexOf(hex.length) === -1) { return false }

            hex = hex.substr(1);

            if (hex.length === 3) {
                hex = hex.split('').map(function (el) { return el + el + ''; }).join('');
            }
        }

        var r = parseInt(hex.slice(0, 2), 16),
            g = parseInt(hex.slice(2, 4), 16),
            b = parseInt(hex.slice(4, 6), 16);
        
        return alpha !== undefined ? "rgba(" + r + " " + g + " " + b + " / " + alpha + "%)" : "rgb(" + r + " " + g + " " + b + ")";
    }

    var hex = function (rgba) {
        var a,
            rgb = rgba.replace(/\s/g, '').match(/^rgba?\((\d+),(\d+),(\d+),?([^,\s)]+)?/i),
            alpha = (rgb && rgb[4] || "").trim(),
            hex = rgb ? (rgb[1] | 1 << 8).toString(16).slice(1) + (rgb[2] | 1 << 8).toString(16).slice(1) + (rgb[3] | 1 << 8).toString(16).slice(1) : rgba;

        if (alpha !== "") {
            a = alpha;
        } else {
            a = 1;
        }

        a = ((a * 255) | 1 << 8).toString(16).slice(1)
        hex = hex + a;
        return hex;
    }



    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name enable
     * @description Enables the control buttons.
     * @param {Object} control - The control object to enable.
     * @returns {Object} Returns the control object.
     */
    this.enable = function (position) {
        this.position = position || 'top-center';
        geoflo.map.addControl(this, this.position);
    }

    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name disable
     * @description Disables the control buttons.
     * @returns {Object} Returns the control object.
     */
    this.disable = function () {
        geoflo.map.removeControl(this);
    }



    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name onAdd
     * @description Adds the control buttons to the map.
     * @param {Object} map - The map object to add the control buttons to.
     * @returns {Object} Returns the control object.
     */
    this.onAdd = function(map) {
        if (!this.options) return false;
        if (this.options.attribution) return this.setAttribution(map);
        this.setTheme(options.colors || geoflo.options.colors);
        geoflo.fire('control.add', { control: this, element: this.element });
        return this.element;
    }

    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name onRemove
     * @description Removes the control buttons from the map.
     * @returns {Object} Returns the control object.
     */
    this.onRemove = function() {
        geoflo.fire('control.remove', { element: this.element, control: this });
    }



    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name setAttribution
     * @description Sets the attribution for the control buttons.
     * @returns {Object} Returns the control object.
     */
    this.setAttribution = function () {
        var attr = Attr(geoflo, this.control, options);
        Object.assign(this, attr)

        this.setTheme(options.colors || geoflo.options.colors);
        geoflo.fire('control.add', { control: this, element: this.element });
        return this.element;
    }

    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name setMode
     * @description Sets the mode for the control buttons.
     * @param {String} mode - The mode to set the control buttons to.
     * @returns {Object} Returns the control object.
     */
    this.setMode = function (mode) {
        geoflo.setActiveButton(!mode ? 'select' : mode === 'draw' ? mode : mode)
    }

    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name setTheme
     * @description Sets the theme for the control buttons.
     * @param {Object} colors - The colors to set the theme to.
     * @returns {Object} Returns the control object.
     */
    this.setTheme = function(colors) {
        if (!colors) { return console.error('Control colors not provided!') };

        colors.primaryColor ? document.documentElement.style.setProperty('--' + geoflo.id + '-primary-color', rgba(colors.primaryColor)) : false;
        colors.primaryBackground ? document.documentElement.style.setProperty('--' + geoflo.id + '-primary-background', rgba(colors.primaryBackground)) : false;
        colors.primaryText ? document.documentElement.style.setProperty('--' + geoflo.id + '-primary-text', rgba(colors.primaryText)) : false;
        colors.primaryBorder ? document.documentElement.style.setProperty('--' + geoflo.id + '-primary-border', rgba(colors.primaryBorder)) : false;

        colors.secondaryColor ? document.documentElement.style.setProperty('--' + geoflo.id + '-secondary-color', rgba(colors.secondaryColor)) : false;
        colors.secondaryBackground ? document.documentElement.style.setProperty('--' + geoflo.id + '-secondary-background', rgba(colors.secondaryBackground)) : false;
        colors.secondaryText ? document.documentElement.style.setProperty('--' + geoflo.id + '-secondary-text', rgba(colors.secondaryText)) : false;
        colors.secondaryBorder ? document.documentElement.style.setProperty('--' + geoflo.id + '-secondary-border', rgba(colors.secondaryBorder)) : false;

        geoflo.fire('theme.change', { colors: colors });
        return this.getTheme();
    }

    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name setControl
     * @description Sets the control buttons.
     * @param {Array} controls - The control buttons to set.
     * @returns {Object} Returns the control object.
     */
    this.setControl = function (controls) {
        if (!controls) return false;

        var buttons;

        this.element = document.createElement('div');
        this.element.className = geoflo.id + '-control-wrap';

        this.control = document.createElement('div');
        this.control.className = geoflo.statics.constants.classes.PREDEFINED_CONTROL_BASE + ' ' + geoflo.statics.constants.classes.PREDEFINED_CONTROL_GROUP;

        this.element.appendChild(this.control);

        if (Array.isArray(controls)) {
            buttons = Buttons(this.control, controls);
            Object.assign(this, buttons);
        }
        
        this.enable(buttons.position);
    }


    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name getTheme
     * @description Gets the theme for the control buttons.
     * @returns {Object} Returns the theme for the control buttons.
     */
    this.getTheme = function() {
        return geoflo.options.colors;
    }

    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name getButtons
     * @description Gets the control buttons.
     * @returns {Object} Returns the control buttons.
     */
    this.getButtons = function () {
        return this._buttons;
    }

    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name getControl
     * @description Gets the control buttons.
     * @param {String} id - The id of the control button to get.
     * @returns {Object} Returns the control button.
     */
    this.getControl = function (id) {
        var nodes = this.control.childNodes;
        if (!nodes.length) return;

        var control;

        if (id) nodes.forEach(function(n) { if (n.classList.contains(id)) control = n });
        return control;
    }


    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name showControl
     * @description Shows the control buttons.
     * @param {String} id - The id of the control button to show.
     * @returns {Object} Returns the control button.
     */
    this.showControl = function (id) {
        var control = this.getControl(id);
        if (!control) return false;
        
        control.style.display = this.position.includes('center') ?  'flex' : 'block';
        return control;
    }

    /**
	 * @function
     * @memberof module:geoflo.Control
	 * @name hideControl
     * @description Hides the control buttons.
     * @param {String} id - The id of the control button to hide.
     * @returns {Object} Returns the control button.
     */
    this.hideControl = function (id) {
        var control = this.getControl(id);
        if (!control) return false;

        control.style.display = 'none';
        return control;
    }


    this.setControl(controls);

    function Buttons (element, controls) {
        if (!controls || !element) return false;
    
        var classTypes = ['mode', 'feature', 'mouse'];
        var buttonElements = {};
        var buttonOptions = {};
        var activeButton = null;
        var currentControl;
        var position;
        
    
        var currentMapClasses = {
            mode: null,
            feature: null,
            mouse: null
        };
    
        var nextMapClasses = {
            mode: null,
            feature: null,
            mouse: null
        };
    
    
    
        const mouseleave = function (event) {
            if (!geoflo.currentMode) return false;
            geoflo.currentMode.handleOffMap ? geoflo.currentMode.handleOffMap(event) : false;
        }
    
        const mouseover = function (event) {
            if (!geoflo.currentMode) return false;
            geoflo.currentMode.handleOnMap ? geoflo.currentMode.handleOnMap(event) : false;
        }
    
        controls.forEach(function (control) {
            if (!getControlOptions(control)) control.show = false;
            setPosition(control);
            createButtons(element, control);
        })
    
        return {
            setActiveButton: setActiveButton,
            queueMapClasses: queueMapClasses,
            updateMapClasses: updateMapClasses,
            removeButtons: removeButtons,
            getButtonOptions: getButtonOptions,
            getButtonElements: getButtonElements,
            position: position
        };
        
    
        function queueMapClasses(options) {
            nextMapClasses = geoflo.Utilities.extend(nextMapClasses, options);
        }
    
        function updateMapClasses() {
            if (!geoflo.container)
                return;
    
            var classesToRemove = [];
            var classesToAdd = [];
    
            classTypes.forEach(function(type) {
                if (nextMapClasses[type] === currentMapClasses[type])
                    return;
    
                classesToRemove.push(type + '-' + currentMapClasses[type]);
                if (nextMapClasses[type] !== null) {
                    classesToAdd.push(type + '-' + nextMapClasses[type]);
                }
            });
    
            if (classesToRemove.length > 0) {
                var _geoflo$container$classL;
    
                (_geoflo$container$classL = geoflo.container.classList).remove.apply(_geoflo$container$classL, classesToRemove);
            }
    
            if (classesToAdd.length > 0) {
                var _geoflo$container$classL2;
    
                (_geoflo$container$classL2 = geoflo.container.classList).add.apply(_geoflo$container$classL2, classesToAdd);
            }
    
            currentMapClasses = geoflo.Utilities.extend(currentMapClasses, nextMapClasses);
        }
    
    
    
        function createTitle(options) {
            return '' + options.title + (options.key ? ' (' + options.key + ')' : "");
        }
    
        function createButtons (element, control) {
            var buttons = document.createElement('div');
            var group = (control.group ? control.group.toUpperCase() : control.attribution ? 'ATTR' : 'NONE') + '_GROUP';
            
            element.appendChild(buttons);
    
            buttons.className = '' + geoflo.statics.constants.classes[group] + ' ' + control.type;
            buttons.style.display = control.show ? position.includes('center') ?  'flex' : 'block' : 'none';
    
            control.show && control.divider ? element.appendChild(createDivider()) : false;
    
            buttons.addEventListener('mouseover', mouseover);
            buttons.addEventListener('mouseleave', mouseleave);
    
            addButtons(control, buttons);
    
            return buttons;
        }
    
        function createBaseButton(id, options) {
            if (!currentControl || !currentControl.buttons[id]) return false;
    
            var position = options.position;
            var button = options.button || document.createElement('button');
    
            options.key = geoflo.options.keys && geoflo.options.keys[id] ? geoflo.options.keys[id] : options.key;
    
            if (options.title) { button.setAttribute('title', createTitle(options)); }
            options.container.appendChild(button);
    
            options["id"] = id;
            options["button"] = button;
    
            options.add = function (opts={}) {
                this.button.style.display = 'flex';
                this.onAdd ? this.onAdd(opts) : this;
            }
    
            options.remove = function (opts={}) {
                this.button.style.display = 'none';
                this.onRemove ? this.onRemove(opts) : this;
            }
    
            options.activate = function () {
                this.button.classList.remove(options.inactiveClass);
                this.button.classList.add(options.activeClass);
                this.button.classList.add(geoflo.statics.constants.classes.ACTIVE_BUTTON);
                this.activated = true;
            }
    
            options.deactivate = function () {
                button.classList.remove(options.activeClass);
                button.classList.remove(geoflo.statics.constants.classes.ACTIVE_BUTTON);
                button.classList.add(options.inactiveClass);
                this.activated = false;
            }
    
            options.dontShow ? button.style.display = 'none' : false;
    
            buttonElements[id] = button;
            buttonOptions[id] = options;
    
            if (position) {
                position = position.includes('right') ? 'left' :
                position.includes('left') ? 'right' :
                position.includes('bottom') ? 'top' :
                position.includes('top') ? 'bottom' :
                'absolute';
            }
    
            options.container.tooltipPosition = position;
            geoflo.addTooltip(options.container, button, createTitle(options));
            return button;
        }
    
        function createControlButton(id) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    
            var button = createBaseButton(id, options);
            if (!button) return false;
    
            button.className = geoflo.statics.constants.classes.CONTROL_BUTTON + ' ' + options.className;
    
            button.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();

                if (options.onClick) return options.onClick(e.target, options);
    
                if (e.target === activeButton) {
                    deactivateButtons();
                    options.onDeactivate ? options.onDeactivate(options) : false;
                } else if (options.onActivate(options)) {
                    setActiveButton(id);
                }
            }, true);
    
            return button;
        }
    
        function createOptionButton(id) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    
            var button = createBaseButton(id, options);
            if (!button) return false;
    
            button.className = '' + geoflo.statics.constants.classes.CONTROL_BUTTON;
    
            if (geoflo.options[options.name] && geoflo.options[options.name].enable) {
                button.classList.add(options.activeClass);
                button.classList.add(geoflo.statics.constants.classes.ACTIVE_BUTTON);
            } else {
                button.classList.add(options.inactiveClass);
            }
    
            button.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                if (!geoflo.options[options.name]) { geoflo.options[options.name] = {}; }
    
                if (geoflo.options[options.name].enable) {
                    if (options.onDeactivate) options.onDeactivate(options);
                } else {
                    options.onActivate(options);
                }
            }, true);
    
            return button;
        }
    
        function createActionButton(id) {
            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    
            var button = createBaseButton(id, options);
            if (!button) return false;
    
            button.className = geoflo.statics.constants.classes.ACTION_BUTTON + ' ' + options.className;
    
            if (id === 'locate' && geoflo.locate) if (geoflo.locate.control) geoflo.locate.control._container.remove();
    
            button.addEventListener('click', function(e) {
                e.preventDefault();
                e.stopPropagation();
                options.onActivate(options);
            }, true);
    
            return button;
        }
    
        function createDivider() {
            var divider = document.createElement('div');
            divider.className = '' + geoflo.statics.constants.classes.DIVIDER;
            return divider;
        }
    
    
        function setPosition (control) {
            if (!position) {
                if (!control.position) throw new Error('The first control needs to have a position')
                position = control.position;
            }
        }
    
    
        function deactivateButtons() {
            if (!activeButton) return;
            activeButton.classList.remove(geoflo.statics.constants.classes.ACTIVE_BUTTON);
            activeButton = null;
        }
    
        function setActiveButton(id) {
            deactivateButtons();
    
            var button = !id && geoflo.editMode ? buttonElements['edit'] : !id ? buttonElements['select'] : id === 'edit' ? buttonElements['select'] : buttonElements[id];
            if (!button) return;
    
            if (button && id !== 'trash') {
                if (button.title.includes('Draw ')) {
                    if (button.title.includes(geoflo.currentMode.type)) {
                        button.classList.add(geoflo.statics.constants.classes.ACTIVE_BUTTON);
                        activeButton = button;
                    }
                } else {
                    button.classList.add(geoflo.statics.constants.classes.ACTIVE_BUTTON);
                }
            }
        }
    
    
        function addButtons(control, buttons) {
            currentControl = control;
    
            if (control.type === 'modes') {
                createControlButton("select", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_SELECT,
                    key: "s",
                    title: 'Select Features',
                    onAdd: function () {
                        if ((geoflo.editMode || geoflo.drawMode)) {
                            geoflo.getButtons('edit').remove();
                            geoflo.getButtons('save').add();
                        } else if (geoflo.hasSelection()) {
                            geoflo.getButtons('save').remove();
                            geoflo.getButtons('edit').add();
                        } else {
                            geoflo.getButtons('save').remove();
                            geoflo.getButtons('edit').remove();
    
                            geoflo.getButtons('undo').remove();
                            geoflo.getButtons('cancel').remove();
                            geoflo.getButtons('redo').remove();
    
                            geoflo.getButtons('import').add();
                            geoflo.getButtons('export').add();
                            geoflo.getButtons('clear').add();
                        }
                    },
                    onActivate: function onActivate() {
                        geoflo.noSelect = false;
                        geoflo.setMode();
                        return true;
                    },
                    onDeactivate: function onDeactivate() {
                        geoflo.noSelect = true;
                    }
                });
    
                createControlButton("edit", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_EDIT,
                    key: "Enter",
                    title: 'Edit Feature',
                    dontShow: true,
                    onAdd: function () {
                        geoflo.getButtons('select').remove();
                        this.button.classList.remove(geoflo.statics.constants.classes.ACTIVE_BUTTON);
                        this.button.style.display = 'flex';
                        this.button.style['background-color'] = geoflo.options.colors.secondaryBackground;
                    },
                    onActivate: function onActivate() {
                        geoflo.editFeature();
                        geoflo.getButtons('save').add();
                    },
                    onDeactivate: function onDeactivate() {
                        geoflo.currentMode.deactivate();
                    },
                    onRemove: function (e) {
                        geoflo.getButtons('save') ? false : createSelect(e);
                    }
                });
    
                createControlButton("save", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_FINSIH,
                    key: "Enter",
                    title: 'Save Edit',
                    dontShow: true,
                    onAdd: function (e) {
                        geoflo.getButtons('select').remove();
                        geoflo.getButtons('edit').remove();
    
                        geoflo.getButtons('import').remove();
                        geoflo.getButtons('export').remove();
                        geoflo.getButtons('clear').remove();
    
                        geoflo.getButtons('undo').add();
                        geoflo.getButtons('cancel').add();
                        geoflo.getButtons('redo').add();
    
                        this.button.style['background-color'] = geoflo.options.colors.secondaryColor;
                    },
                    onActivate: function onActivate(e) {
                        geoflo.options.repeatDraw = false;
                        geoflo.getButtons('repeat').deactivate();
                        geoflo.currentMode.handleClick({ finish: true })
                    }
                });
            } else if (control.type === 'options') {
                createActionButton("import", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_IMPORT,
                    key: "u",
                    title: 'Import Features',
                    onActivate: function onActivate() {
                        return geoflo.loadFeatures();
                    }
                });
        
                createActionButton("export", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_EXPORT,
                    key: "d",
                    title: 'Export Features',
                    onActivate: function onActivate() {
                        return geoflo.saveFeatures();
                    }
                });
    
                createActionButton("clear", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_CLEAR,
                    key: "Delete",
                    title: 'Delete Selected or All Features',
                    onActivate: function onActivate() {
                        geoflo.deleteUserData();
                        geoflo.getButtons('select').add();
                        return true;
                    }
                });
    
                createActionButton("undo", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_UNDO,
                    key: "u",
                    title: 'Undo Edit',
                    dontShow: true,
                    onActivate: function onActivate() {
                        return geoflo.currentMode.handleUndo()
                    }
                });
        
                createActionButton("redo", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_REDO,
                    key: "r",
                    title: 'Redo Edit',
                    dontShow: true,
                    onActivate: function onActivate() {
                        return geoflo.currentMode.handleRedo()
                    }
                });
    
                createActionButton("cancel", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_CANCEL,
                    key: "Escape",
                    title: 'Cancel Edit',
                    dontShow: true,
                    onActivate: function onActivate() {
                        geoflo.options.repeatDraw = false;
                        geoflo.getButtons('repeat').deactivate();
                        return geoflo.cancelEdit();
                    }
                });
            } else if (control.type === 'actions') {
                createOptionButton("snapping", {
                    container: buttons,
                    name: "snapping",
                    title: 'Enable/Disable Snapping',
                    activeClass: geoflo.id + '-snapping-enabled',
                    inactiveClass: geoflo.id + '-snapping-disabled',
                    onActivate: function onActivate() {
                        return geoflo.activateSnapping();
                    },
                    onDeactivate: function onDeactivate() {
                        return geoflo.deactivateSnapping();
                    }
                });
        
                createOptionButton("pinning", {
                    container: buttons,
                    name: "pinning",
                    title: 'Enable/Disable Pinning',
                    activeClass: geoflo.id + '-pinning-enabled',
                    inactiveClass: geoflo.id + '-pinning-disabled',
                    onActivate: function onActivate() {
                        return geoflo.activatePinning();
                    },
                    onDeactivate: function onDeactivate() {
                        return geoflo.deactivatePinning();
                    }
                });
        
                createOptionButton("routing", {
                    container: buttons,
                    name: "routing",
                    title: 'Enable/Disable Routing',
                    activeClass: geoflo.id + '-routing-enabled',
                    inactiveClass: geoflo.id + '-routing-disabled',
                    onActivate: function onActivate() {
                        return geoflo.activateRouting();
                    },
                    onDeactivate: function onDeactivate() {
                        return geoflo.deactivateRouting();
                    }
                });
    
                createOptionButton("exploring", {
                    container: buttons,
                    name: "exploring",
                    title: `Enable/Disable Exploring`,
                    activeClass: geoflo.id + '-exploring-enabled',
                    inactiveClass: geoflo.id + '-exploring-disabled',
                    onActivate: function onActivate() {
                        return geoflo.activateExploring();
                    },
                    onDeactivate: function onDeactivate() {
                        return geoflo.deactivateExploring();
                    }
                });
        
                createOptionButton("painting", {
                    container: buttons,
                    name: "painting",
                    title: 'Enable/Disable Painting',
                    activeClass: geoflo.id + '-painting-enabled',
                    inactiveClass: geoflo.id + '-painting-disabled',
                    onActivate: function onActivate() {
                        return geoflo.activatePainting();
                    },
                    onDeactivate: function onDeactivate() {
                        return geoflo.deactivatePainting();
                    }
                });
            } else if (control.type === 'types') {
                createControlButton("polyline", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_LINE,
                    key: "l",
                    title: 'Draw Polyline',
                    onActivate: function onActivate() {
                        return geoflo.setMode({
                            mode: geoflo.statics.constants.modes.DRAW,
                            type: "Polyline"
                        });
                    },
                    onDeactivate: function onDeactivate() {
                        geoflo.currentMode.deactivate();
                        geoflo.setMode();
                    }
                });
        
                createControlButton("polygon", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_POLYGON,
                    key: "p",
                    title: 'Draw Polygon',
                    onActivate: function onActivate() {
                        return geoflo.setMode({
                            mode: geoflo.statics.constants.modes.DRAW,
                            type: "Polygon"
                        });
                    },
                    onDeactivate: function onDeactivate() {
                        geoflo.currentMode.deactivate();
                        geoflo.setMode();
                    }
                });
        
                createControlButton("rectangle", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_RECTANGLE,
                    key: "r",
                    title: 'Draw Rectangle',
                    onActivate: function onActivate() {
                        return geoflo.setMode({
                            mode: geoflo.statics.constants.modes.DRAW,
                            type: "Rectangle"
                        });
                    },
                    onDeactivate: function onDeactivate() {
                        geoflo.currentMode.deactivate();
                        geoflo.setMode();
                    }
                });
        
                createControlButton("circle", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_POINT,
                    key: "o",
                    title: 'Draw Circle',
                    onActivate: function onActivate() {
                        return geoflo.setMode({
                            mode: geoflo.statics.constants.modes.DRAW,
                            type: "Circle"
                        });
                    },
                    onDeactivate: function onDeactivate() {
                        geoflo.currentMode.deactivate();
                        geoflo.setMode();
                    }
                });
    
                createControlButton("text", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_TEXT,
                    key: "t",
                    title: 'Draw Text',
                    onActivate: function onActivate() {
                        return geoflo.setMode({
                            mode: geoflo.statics.constants.modes.DRAW,
                            type: "Text"
                        });
                    },
                    onDeactivate: function onDeactivate() {
                        geoflo.currentMode.deactivate();
                        geoflo.setMode();
                    }
                });
        
                createControlButton("icon", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_ICON,
                    key: "i",
                    title: 'Draw Icon',
                    onActivate: async function onActivate() {
                        return geoflo.setMode({
                            mode: geoflo.statics.constants.modes.DRAW,
                            type: "Icon"
                        });
                    },
                    onDeactivate: function onDeactivate() {
                        geoflo.currentMode.deactivate();
                        geoflo.setMode();
                    }
                });
            } else if (control.type === 'utils') {
                createControlButton("repeat", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_REPEAT,
                    key: "`",
                    title: 'Repeat Selected Mode',
                    onClick: function (target, options) {
                        geoflo.options.repeatDraw = !geoflo.options.repeatDraw;
                        geoflo.options.repeatDraw ? options.activate() : options.deactivate();
                    }
                });

                createActionButton("zoom", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_ZOOM_IN_FEATURES,
                    key: "x",
                    title: 'Zoom to Extent',
                    onActivate: function onActivate() {
                        return geoflo.zoomToFeatures();
                    }
                });
        
                createActionButton("refresh", {
                    container: buttons,
                    className: geoflo.statics.constants.classes.CONTROL_BUTTON_REFRESH,
                    key: "q",
                    title: 'Refresh',
                    onActivate: function onActivate() {
                        return geoflo.refresh();
                    }
                });
            }
    
            /* createActionButton("delete-snap", {
                container: action2Group,
                className: geoflo.statics.constants.classes.CONTROL_BUTTON_DELETE_SNAP,
                title: 'Delete Snap Layer Features',
                onAction: function onAction() {
                    return geoflo.deleteMeshData();
                }
            }); */
    
            /* createControlButton("cut", {
                container: controlGroup,
                className: geoflo.statics.constants.classes.CONTROL_BUTTON_CUT,
                key: "a",
                title: 'Cut Features',
                onActivate: function onActivate() {
                    return geoflo.setMode(geoflo.statics.constants.modes.CUT);
                }
            }); */
    
            /* createActionButton("combine", {
                container: action2Group,
                className: geoflo.statics.constants.classes.CONTROL_BUTTON_COMBINE_FEATURES,
                title: 'Combine Features',
                key: '+',
                onAction: function onAction() {
                    return geoflo.combineFeatures();
                }
            }); */
    
            /* createActionButton("group-elements", {
                container: action2Group,
                className: geoflo.statics.constants.classes.CONTROL_BUTTON_GROUP_FEATURES,
                key: "g",
                title: 'Group Similar Features',
                onAction: function onAction() {
                    return geoflo.groupFeatures();
                }
            });
    
            createActionButton("ungroup-elements", {
                container: action2Group,
                className: geoflo.statics.constants.classes.CONTROL_BUTTON_UNGROUP_FEATURES,
                key: "G",
                title: 'Ungroup Similar Features',
                onAction: function onAction() {
                    return geoflo.ungroupFeatures();
                }
            }); */
    
            /* createActionButton("create-polygon", {
                container: action2Group,
                className: geoflo.statics.constants.classes.CONTROL_BUTTON_CREATE_POLYGON,
                key: 'p',
                title: 'Create Polygon from Selected Feature',
                onAction: function onAction() {
                    return geoflo.createPolygon();
                }
            }); */
    
            /* createActionButton("hide-selected", {
                container: action2Group,
                className: geoflo.statics.constants.classes.CONTROL_BUTTON_HIDE_SELECTED,
                title: 'Hide Selected Feature',
                onAction: function onAction() {
                    return geoflo.hideFeatures();
                }
            }); */
        }

        function removeButtons() {
            Object.keys(buttonElements).forEach(function(buttonId) {
                var button = buttonElements[buttonId];
    
                if (button.parentNode) {
                    button.parentNode.removeChild(button);
                } else if (button) {
                    button.remove();
                }
    
                delete buttonElements[buttonId];
                delete buttonOptions[buttonId];
            });
        }
    
    
        function getControlOptions (control) {
            if (!control) return false;
            var controls = geoflo.options.controls && typeof geoflo.options.controls === 'object';
            var dontShow = controls ? !geoflo.options.controls[control.type] : false
            return  dontShow || control.dontShow || !geoflo.options.controls ? false : true;
        }
    
        function getButtonOptions() {
            return buttonOptions;
        }
    
        function getButtonElements() {
            return buttonElements;
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Control);

/***/ }),

/***/ "./src/Draw.js":
/*!*********************!*\
  !*** ./src/Draw.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Draw
 * @description This module provides the functionality for drawing features on the map.
 * @returns {Object} The current instance for method chaining.
 * 
 */
const Draw = function () {
    const geoflo = this.geoflo;

    this.id = 'draw';

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name canHandle
	 * @description Checks if the given modeName is equal to the constant mode DRAW.
	 * @param {string} modeName - The name of the mode to be checked.
	 * @returns {boolean} Returns true if the modeName is equal to DRAW, false otherwise.
	 */
    this.canHandle = function (modeName) {
        return geoflo.statics.constants.modes.DRAW === modeName;
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name activate
	 * @description This function activates the drawing mode with the provided options. It sets up the necessary properties and event listeners for drawing features on the map.
	 * @param {Object} options - The options for activating the drawing mode.
	 * @param {Object} [options.feature] - The feature to be edited or drawn.
	 * @param {String} [options.type] - The type of feature to be drawn.
	 * @param {Object} [options.lngLat] - The longitude and latitude coordinates for drawing.
	 * @param {String} [options.id] - The unique identifier for the feature.
	 * @returns {Object} Returns the current instance for method chaining.
	 */
    this.activate = function (options={}) {
        if (this.activated) return false;
        if (geoflo.currentMode.id !== this.id) return options.mode = this.id, geoflo.setMode(options);

        this.activated = true;
        this._handleHistory = this.handleHistory.bind(this);
        this.history = [];
        this.undo = [];

        if (options.feature) options.type = editMode(options.feature);
        geoflo.drawMode = !geoflo.editMode;
        
        var lngLat = options.lngLat;
        delete options.lngLat;

        var newType = this.type = options.type;
        var properties = options.feature ? options.feature.properties : options;
        
        this.properties = Object.assign({}, properties);
        delete this.properties.mode;
        delete this.properties.location;

        const id = options.id || properties.id || URL.createObjectURL(new Blob([])).slice(-36);

        this.properties.id = id;
        this.properties.type = newType;

        geoflo.setButtons();
        geoflo.setActiveButton(newType);
        
        if (geoflo.Utilities.isPoint(geoflo.hotFeature, newType)) this.isPoint = true;

        geoflo.fire('draw.activate', {
            id: id,
            type: newType,
            activated: this.activated,
            editing: geoflo.editMode,
            feature: geoflo.hotFeature || options.feature,
            properties: this.properties
        })

        geoflo.on('source.hot', this._handleHistory);
        if (lngLat) this.handleMove({ lngLat: lngLat });
        geoflo.options.painting.enable || (geoflo.mobile && newType === 'Rectangle') ? geoflo.activatePainting() : false;

        geoflo.refreshMeshData();
        this.updateHotSource();

        setTimeout(function() { geoflo.Features.removeFeatures(id); }, 100);
        return this;
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name deactivate
	 * @description Deactivates the draw feature by canceling the current edit, cleaning up the draw, setting buttons, and handling events.
	 * @param {boolean} cancel - Flag to determine if the edit should be canceled.
	 * @param {boolean} standby - Flag to indicate if the feature is in standby mode.
	 * @param {object} feature - The feature to be deactivated.
	 */
    this.deactivate = function (options={}) {
        if (!this.activated) return false;
        const type = options.type || this.type;
        if (options.cancel) this.cancelEdit(options.standby, options.feature);
        cleanupDraw(this);
        geoflo.setButtons();
        geoflo.off('source.hot', this._handleHistory);
        geoflo.fire('draw.deactivate', { activated: this.activated });
        setTimeout(function() { geoflo.map.getSource(geoflo.statics.constants.sources.SELECT).setData(turf.featureCollection([])); }, 300);
        !geoflo.options.repeatDraw ? geoflo.setMode() : geoflo.setMode({ mode: geoflo.statics.constants.modes.DRAW, type: type });
    }



	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name updateHotSource
	 * @description This function updates the hot source feature with new properties and assigns it to the geoflo.hotFeature. It then updates the data of the VERTEX and HOT sources on the map with the updated feature.
	 * @param {Object} feature - The feature object to be updated.
	 * @param {Object} properties - The new properties to be assigned to the feature.
	 * @returns {Object} The updated hot source feature.
	 */
    this.updateHotSource = function (feature, properties) {
        if (feature) geoflo.hotFeature = feature;
        if (!geoflo.hotFeature || geoflo.overpassDownloading) return;
        geoflo.hotFeature.properties = geoflo.Utilities.assignDeep(geoflo.hotFeature.properties, properties || {});
        geoflo.hotFeature.properties.style = geoflo.hotFeature.properties.style || {};
        geoflo.map.getSource(geoflo.statics.constants.sources.VERTEX).setData(turf.featureCollection([geoflo.hotFeature]));
        geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([geoflo.hotFeature]));
        return geoflo.hotFeature;
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name deleteVertex
	 * @description Deletes a vertex from the current feature being edited on the map.
	 * @param {number} index - The index of the vertex to be deleted.
	 * @returns {void}
	 */
    this.deleteVertex = function (index) {
        if (geoflo.hotFeature) {
            const coords = geoflo.hotFeature.geometry.coordinates;
            index = index !== undefined ? index : coords.length - 1;

            if (coords.length > 1) {
                coords.splice(index, 1);
                geoflo.lastClick = { coords: coords[coords.length - 1] };

                if (coords.length > 0) {
                    geoflo.snapFeature = turf.point(coords[coords.length - 1]);
                } else {
                    geoflo.snapFeature = null;
                }

                if (coords.length > 1) {
                    geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([geoflo.hotFeature]));
                } else {
                    geoflo.hotFeature = null;
                    geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([]));
                }

                geoflo.fire('vertex.delete', { coords: coords, index: index, feature: geoflo.hotFeature })
            }

            if (geoflo.lastMouseEvent) {
                geoflo.currentMode.handleMove ? geoflo.currentMode.handleMove(geoflo.lastMouseEvent) : false;
            }
        } else if (geoflo.snapFeature) {
            geoflo.snapFeature = null;
            geoflo.lastClick = null;
            geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([]));
        }
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name getFeature
	 * @description Retrieves the hot feature from the context.
	 * @returns {any} The hot feature stored in the context.
	 */
    this.getFeature = function () {
        return geoflo.hotFeature;
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name selectFeature
	 * @description Selects a feature based on the provided ID.
	 * @param {string} id - The ID of the feature to be selected.
	 * @returns {boolean} Returns false if no ID is provided, otherwise returns the result of selecting the feature.
	 */
    this.selectFeature = function (id) {
        if (!id) return false;
        geoflo.setMode();
        return geoflo.currentMode.selectFeature(id);
    }

	/** 
	 * @function
     * @memberof module:geoflo.Draw
	 * @name saveEdit
	 * @description This function saves the edited feature in the map.
	 * @param {Object} feature - The feature to be saved.
	 * @returns {boolean} - Returns true if the feature is successfully saved, false otherwise.
	 */
    this.saveEdit = function (feature) {
        var hot = geoflo.hotFeature;
        if (!hot) return false;

        var type = hot.properties.type || feature.properties.type || this.type;
        feature = feature || hot;

        this.savingEdit = true;
        return finishDraw(type, feature);
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name cancelEdit
	 * @description This function cancels the current editing operation by setting the 'cancelled' flag to true. If the 'feature' parameter is not provided or does not have a 'type' property, it sets 'geoflo.hotFeature' to null and finishes the draw process. It then sets the 'standby' property, updates 'geoflo.hotFeature', fires a 'draw.cancel' event with the feature, and returns the result of 'finishDraw()'.
	 * @param {boolean} standby - The standby value to set.
	 * @param {object} feature - The feature being edited.
	 * @returns {any} The result of the 'finishDraw()' function.
	 */
    this.cancelEdit = function (standby, feature) {
        this.cancelled = true;
        if (!feature || !feature.properties.type) return geoflo.hotFeature = null, finishDraw();
        this.standby = standby;
        geoflo.hotFeature = feature;
        geoflo.fire('draw.cancel', { feature: feature });
        return finishDraw();
    }



	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleDown
	 * @description Handles the mouse or touch down event on the map. Updates the mouse/touch position, adds a vertex if allowed, and sets features for pinning.
	 * @param {Object} event - The event object containing information about the mouse or touch event.
	 * @returns {void}
	 */
    this.handleDown = function (event) {
        var point;

        geoflo.mouseIsDown = [event.lngLat.lng, event.lngLat.lat];

        if (event.touch) {
            geoflo.touchDown = true;
            point = turf.point(geoflo.mouseIsDown);
            onVertex(getVertex(point));
        }
        
        if (geoflo.canAddVertex) {
            point = addVertex(geoflo.canAddVertex, event);
            return onVertex(getVertex(point), true);
        }

        geoflo.Pinning.setFeatures(geoflo.snappedVertex);
        startIdleTime();
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleUp
	 * @description This function is responsible for handling the mouse up event during drawing and editing operations on the map. It checks various conditions and triggers corresponding actions based on the context and user interactions.
	 * @param {Event} event - The mouse up event object.
	 * @returns {void}
	 */
    this.handleUp = function (event) {
        geoflo.mouseIsDown = false;
        geoflo.touchDown = false;

        if (geoflo.Painting.enabled) return geoflo.Painting.handleUp(event);
        if (geoflo.addedVertexOnLine && !geoflo.dragMoving) return;
        if (event.touch && geoflo.touchMoving) return geoflo.dragMoving = false;

        if (geoflo.Utilities.isPoint(geoflo.hotFeature) && geoflo.snappedVertex) return geoflo.editMode ? this.saveEdit() : finishDraw(this.type);

        if (geoflo.snappedVertex && geoflo.dragMoving && !geoflo.mapMoving && this.type !== 'Rectangle') {
            geoflo.gamepadDrag = event.gamepad;

            var isLastIndex = geoflo.Utilities.isLastIndex(geoflo.dragIndex, geoflo.hotFeature);
            isLastIndex = isLastIndex ? isLastIndex : geoflo.Utilities.isPolygon(geoflo.hotFeature) && geoflo.dragIndex == 0 ? true : false;
           
            var coords = geoflo.Utilities.getLastIndexCoords(geoflo.hotFeature);

            onVertex(getVertex(turf.point(geoflo.snappedVertex)));
            this.updateHotSource();
            if (isLastIndex) setTimeout(function() { geoflo.lastClick = { coords: coords } }, 100)
        }
        
        geoflo.pinableFeatures = [];
        geoflo.mouseIsIdle = false;
        addText.call(this, this.type, geoflo.snapFeature);
        geoflo.refreshMeshData();
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleClick
	 * @description This function processes the click event for drawing features on the map. It determines the action based on the event type and context state, such as editing mode, touch input, vertex addition, and gamepad interaction.
	 * @param {Object} event - The event object containing information about the click event.
	 * @returns {Object} The updated event object or the result of the drawing action.
	 */
    this.handleClick = function (event) {
        if (event.finish) return geoflo.editMode ? this.saveEdit() : finishDraw(this.type);
        if (event.touch && geoflo.touchMoving) return geoflo.touchMoving = false, geoflo.Snapping.setFeature(), this.updateHotSource();
        if (event.touch) geoflo.touchClick = true;

        if (geoflo.addedVertexOnLine) {
            geoflo.Snapping.setFeature();
            this.updateHotSource();
            onVertex(getVertex(geoflo.addedVertexOnLine));
            this.handleDrag(event);
            geoflo.dragMoving = false;
            geoflo.gamepadDrag = false
            geoflo.mouseIsIdle = false;
            return event;
        }

        if (geoflo.gamepadDrag) return geoflo.gamepadDrag = false;

        if (geoflo.editMode && (this.type === 'Polygon' || this.type === 'Text')) return;

        if (!this.firstClick && !geoflo.drawStarted) {
            geoflo.drawStarted = true;
            geoflo.fire('draw.start', { type: this.type, editing: geoflo.editMode, coords: [event.lngLat.lng, event.lngLat.lat] });
        } else {
            geoflo.fire('vertex.add', { type: this.type, coords: [event.lngLat.lng, event.lngLat.lat] });
        }

        var lastPoint = geoflo.closestPoint || { coords: [event.lngLat.lng, event.lngLat.lat] };
        var point = turf.point(lastPoint.coords);

        point.properties = this.properties;
        point.source = this.source;

        geoflo.lastMove = lastPoint.coords.length > 1 ? { lat: lastPoint.coords[lastPoint.coords.length-1][1], lng: lastPoint.coords[lastPoint.coords.length-1][0] } : false;        

        if (!geoflo.startPoint) {
            if (this.type === 'Rectangle') {
                geoflo.startPoint = lastPoint.coords;

                geoflo.hotFeature = turf.polygon([[
                    geoflo.startPoint,
                    [event.lngLat.lng, event.lngLat.lat],
                    [geoflo.startPoint[0], event.lngLat.lat],
                    geoflo.startPoint
                ]]);
    
                return geoflo.Utilities.setProperty(geoflo.hotFeature, 'type', this.type);
            } else if (this.type === 'Polygon') {
                geoflo.startPoint = lastPoint.coords;
            }
        }
        
        if (!geoflo.snapFeature && lastPoint) geoflo.snapFeature = lastPoint;

        if (needsToFinish(this.type, lastPoint.coords)) return finishDraw(this.type, point);
        
        this.firstClick = geoflo.firstClick ? false : { coords: lastPoint.coords };

        geoflo.lastClick = lastPoint;
        geoflo.firstClick = geoflo.firstClick ? geoflo.firstClick : { coords: lastPoint.coords };
        geoflo.Snapping.setFeature();
        addText.call(this, this.type);
        geoflo.Exploring.setFeatures(lastPoint.coords, { set: true });
        delete geoflo.touchClick;
        return this.updateHotSource();
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleMove
	 * @description This function determines the behavior based on the event type and context state. It handles various actions such as dragging, painting, snapping, routing, and snapping to points.
	 * @param {Object} event - The event object containing information about the mouse or touch event.
	 * @returns {boolean} Returns false in certain conditions to prevent default behavior.
	 */
    this.handleMove = function (event) {
        if (event.touch && geoflo.mouseIsDown) geoflo.touchMoving = true;
        if (geoflo.overpassDownloading) return false;
        if (geoflo.mouseIsDown && geoflo.canAddVertex) return false;
        if (geoflo.canDragMove && geoflo.snappedVertex && geoflo.mouseIsDown) return this.handleDrag(event);
        if (geoflo.mouseIsDown && geoflo.Painting.enabled) return this.handlePainting(event);
        if (event.touch && geoflo.touchMoving) return geoflo.snapFeature = false;

        var button = !event.originalEvent ? false : event.originalEvent.buttons !== undefined ? event.originalEvent.buttons : event.originalEvent.which;
        if (button === 1) return false;

        var calculateRoute = geoflo.Routing.enabled;
        if (event.originalEvent && event.originalEvent.altKey) calculateRoute = false;

        var snapToPoint = geoflo.Snapping.enabled;
        if (event.originalEvent && event.originalEvent.shiftKey) snapToPoint = false;

        var evtCoords = [event.lngLat.lng, event.lngLat.lat];
        var isPoint = geoflo.Utilities.isPoint(geoflo.hotFeature);
        var editPolygon = geoflo.editMode && (this.type === 'Polygon' || this.type === 'Rectangle');
        var point = turf.point(evtCoords);
        var snapFeature = null;

        if (editPolygon) {
            snapFeature = point;
        } else if (snapToPoint) {
            snapFeature = geoflo.Snapping.setClosest(evtCoords, isPoint);
        } else if (!isPoint) {
            snapFeature = geoflo.Snapping.updateFeature(evtCoords);
        } else if (isPoint) {
            snapFeature = point;
        }

        if (calculateRoute) snapFeature = geoflo.Routing.getClosest() || snapFeature;
        if (!snapFeature) snapFeature = point;

        geoflo.Snapping.addFeature(snapFeature, this.properties, editPolygon);
        onVertex(getVertex(point));
        
        if (!snapFeature && this.isPoint) delete this.isPoint;
        if (editPolygon && calculateRoute) geoflo.map.getSource(geoflo.statics.constants.sources['ROUTE']).setData(turf.featureCollection([]));

        if (this.type === 'Rectangle') return this.handleRectangle(event);
        if (this.type === 'Icon') return this.handleIcon(event, geoflo.snapFeature);
        if (this.type === 'Text') return this.handleText(event, geoflo.snapFeature);
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleDrag
	 * @description This function is responsible for handling the drag event of a vertex on the map. It updates the position of the vertex based on the user's interaction and triggers various actions accordingly.
	 * @param {Object} event - The event object containing information about the drag event.
	 * @returns {boolean} Returns false if the drag index is not valid.
	 */
    this.handleDrag = function (event) {
        var validIndex = geoflo.dragIndex > -1;
        
        if (!validIndex) {
            offVertex();
            if (geoflo.mouseIsDown && geoflo.Painting.enabled) this.handlePainting(event);
            return false;
        }

        !event.gamepad ? event.originalEvent.stopPropagation() : false;

        geoflo.dragMoving = true;
        geoflo.lastDragMove = 0;
        geoflo.snappedVertex = [event.lngLat.lng, event.lngLat.lat];
        geoflo.bypassRouting = true; //!event.gamepad ? event.originalEvent.altKey : false;
        geoflo.bypassSnapping = !event.gamepad ? event.originalEvent.shiftKey : false;
        geoflo.lastIndex = geoflo.Utilities.isLastIndex(geoflo.dragIndex, geoflo.hotFeature);

        var vertex = turf.point(geoflo.snappedVertex);

        if (geoflo.lastIndex) geoflo.lastClick = { coords: geoflo.snappedVertex };

        if (this.type === 'Circle' || this.type === 'Icon' || this.type === 'Image') {
            if (!geoflo.Painting.enabled) geoflo.hotFeature.geometry.coordinates = geoflo.snappedVertex;
        } else {
            var isLastIndex = geoflo.Utilities.isLastIndex(geoflo.dragIndex, geoflo.hotFeature);
            geoflo.hotFeature.geometry.coordinates[geoflo.dragIndex] = geoflo.snappedVertex;

            if (this.type === 'Polygon') {
                if (isLastIndex) geoflo.hotFeature.geometry.coordinates[0] = geoflo.snappedVertex;
                if (geoflo.dragIndex == 0) geoflo.hotFeature.geometry.coordinates[geoflo.hotFeature.geometry.coordinates.length -1] = geoflo.snappedVertex;
            }
        }

        geoflo.Utilities.setProperty(geoflo.hotFeature, 'type', this.type);
        geoflo.Utilities.setProperty(vertex, 'type', this.type);
        geoflo.map.getSource(geoflo.statics.constants.sources.ROUTE).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([geoflo.hotFeature]));
        geoflo.map.getSource(geoflo.statics.constants.sources.VERTEX).setData(turf.featureCollection([vertex]));
        geoflo.fire('vertex.drag', { type: this.type, coords: [event.lngLat.lng, event.lngLat.lat], feature: geoflo.hotFeature, vertex: vertex });
        geoflo.Pinning.updateFeatures();
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleTouch
	 * @description This function is responsible for handling touch events and triggering corresponding actions.
	 * @param {Event} event - The touch event object.
	 * @returns {void}
	 */
    this.handleTouch = function (event) {
        event.touch = true;

        if (event.type === 'touchstart') {
            this.handleDown(event);
        } else if (event.type === 'touchend') {
            this.handleUp(event);
            this.handleClick(event);
        } else if (event.type === 'touchmove') {
            this.handleMove(event);
        }
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleOffMap
	 * @description This function is triggered when an off-map event occurs and clears the data of a specific source on the map.
	 * @param {Event} event - The event object triggering the function.
	 */
    this.handleOffMap = function (event) {
        if (geoflo.map.getSource(geoflo.statics.constants.sources.SNAP)) geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([]));
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleOnMap
	 * @description This function updates the data of the SNAP source on the map with the snapFeature.
	 * @param {Event} event - The event triggering the function.
	 */
    this.handleOnMap = function (event) {
        if (geoflo.map.getSource(geoflo.statics.constants.sources.SNAP) && geoflo.snapFeature) geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([geoflo.snapFeature]));
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handlePainting
	 * @description This function is triggered when painting on the map. It disables drag pan, sets the map class to 'painting', and updates the feature coordinates.
	 * @param {Object} event - The event object triggering the function.
	 * @returns {boolean} Returns false if mouse is not down or no coordinates are available, otherwise updates the feature coordinates.
	 */
    this.handlePainting = function (event) {
        if (!geoflo.mouseIsDown) return false;
        geoflo.map.dragPan.disable();
        geoflo.setMapClass('painting');

        var snapCoords = geoflo.snapFeature && !geoflo.Painting.feature;
        var coords = event.lngLat && event.lngLat.lng ? [event.lngLat.lng, event.lngLat.lat] : false;
        if (snapCoords) coords = geoflo.snapFeature.geometry.coordinates;

        if (!coords) return false;
        return geoflo.Painting.updateFeature(coords);
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleRectangle
	 * @description Handles the creation and manipulation of a rectangle feature on a map.
	 * @param {Object} event - The event object triggering the function.
	 * @returns {void}
	 */
    this.handleRectangle = function (event) {
        if (geoflo.editMode && geoflo.hotFeature) geoflo.startPoint = geoflo.hotFeature.geometry.coordinates[0][0];
        if (!geoflo.startPoint) return;
        if (!geoflo.dragMoving) geoflo.Utilities.setProperty(geoflo.hotFeature, 'type', this.type);
        geoflo.dragMoving = true;

        var coords = geoflo.snapFeature ? geoflo.snapFeature.geometry.coordinates : [event.lngLat.lng, event.lngLat.lat];

        if (geoflo.dragIndex > -1) {
            var startPoint = geoflo.dragIndex == 0 || geoflo.dragIndex == 4 ? 4 : geoflo.dragIndex;
            var endPoint = startPoint == 1 ? 3 : startPoint == 2 ? 4 : startPoint == 3 ? 1 : 2;
            var leftPoint = endPoint == 1 ? 4 : endPoint == 2 ? 1 : endPoint == 3 ? 2 : 3
            var rightPoint = leftPoint == 1 ? 3 : leftPoint == 2 ? 4 : leftPoint == 3 ? 1 : 2;

            updateCoordinate(geoflo.hotFeature, "0." + startPoint, coords[0], coords[1]);
            updateCoordinate(geoflo.hotFeature, "0." + leftPoint, coords[0], geoflo.startPoint[1]);
            updateCoordinate(geoflo.hotFeature, "0." + rightPoint, geoflo.startPoint[0], coords[1]);
            updateCoordinate(geoflo.hotFeature, "0." + endPoint, geoflo.startPoint[0], geoflo.startPoint[1] );
        } else {
            updateCoordinate(geoflo.hotFeature, "0.1", coords[0], geoflo.startPoint[1]);
            updateCoordinate(geoflo.hotFeature, "0.2", coords[0], coords[1]);
            updateCoordinate(geoflo.hotFeature, "0.3", geoflo.startPoint[0], coords[1]);
            updateCoordinate(geoflo.hotFeature, "0.4", geoflo.startPoint[0], geoflo.startPoint[1] );
        }

        geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([geoflo.hotFeature]));
        geoflo.map.getSource(geoflo.statics.constants.sources.VERTEX).setData(turf.featureCollection([geoflo.hotFeature]));
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleText
	 * @description Handles text input events and logs relevant properties.
	 * @param {Event} event - The event object triggering the function.
	 * @param {string} feature - The feature to be handled.
	 */
    this.handleText = function (event, feature) {
        console.log('handleText', this.properties, geoflo.snapFeature);
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleIcon
	 * @description Handles the icon based on the event and feature provided.
	 * @param {Event} event - The event triggering the function.
	 * @param {Object} feature - The feature object to be handled.
	 */
    this.handleIcon = function (event, feature) {
        console.log('handleIcon', this.properties, geoflo.snapFeature);
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleContext
	 * @description Handles the context of dragging and moving a feature vertex.
	 * @param {Event} event - The event triggering the context handling.
	 * @returns {void}
	 */
    this.handleContext = function (event) {
        if (!geoflo.canDragMove || !geoflo.snappedVertex) return;
        
        var validIndex = geoflo.dragIndex > -1;
        if (!validIndex) return;

        geoflo.hotFeature.geometry.coordinates.splice(geoflo.dragIndex, 1);

        geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([geoflo.hotFeature]));
        geoflo.map.getSource(geoflo.statics.constants.sources.VERTEX).setData(turf.featureCollection([geoflo.hotFeature]));
        geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([]));
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleHistory
	 * @description Handles the history of features in the current mode.
	 * @param {Object} event - The event triggering the history update.
	 * @returns {void}
	 */
    this.handleHistory = function handleHistory (event) {
        if (geoflo.dragMoving) return;

        var history = geoflo.currentMode.history;
        var date = new Date();
        
        var features = event.detail.data.features;
        if (!features || !features.length) return;

        var feature = geoflo.Utilities.cloneDeep(features[0]);
        feature.historyDate = date;
        history.push(feature);

        geoflo.fire('feature.history', { type: geoflo.currentMode.type, feature: feature, history: history });
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleUndo
	 * @description This function is responsible for undoing the last action performed in the application. It retrieves the history and undo arrays from the current mode, pops the last feature from the history, sets the undo flag to true for the feature, updates the hotFeature, pushes the feature to the undo array, and updates the map source data with the hotFeature.
	 * @returns {void}
	 */
    this.handleUndo = function () {
        return alert("UNDER DEVELOPMENT");
        var history = geoflo.currentMode.history;
        var undo = geoflo.currentMode.undo;

        var feature = history.pop();

        feature.undo = true;
        geoflo.hotFeature = feature;

        undo.push(geoflo.hotFeature);
        geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([geoflo.hotFeature]));
    }

	/**
	 * @function
     * @memberof module:geoflo.Draw
	 * @name handleRedo
	 * @description Handles the redo functionality (currently under development).
	 * @returns {void}
	 */
    this.handleRedo = function () {
        return alert("UNDER DEVELOPMENT");
        var redo = false
    }






    function editMode (feature) {
        var type = geoflo.Features.getType(feature);
        if (!type) return alert('No Feature Type Found');

        const id = feature.id;
    
        geoflo.currentMode.type = type;
        geoflo.currentMode.source = feature.source;
        geoflo.editMode = true;
        geoflo.hotFeature = feature;
    
        geoflo.Utilities.setProperty(geoflo.hotFeature, 'type', type);
        geoflo.Utilities.setProperty(geoflo.hotFeature, 'edit', true);

        geoflo.map.getSource(geoflo.statics.constants.sources.SELECT).setData(turf.featureCollection([]));
    
        if (type === 'Polygon') {
            geoflo.hotFeature = turf.polygonToLine(geoflo.hotFeature);
        }
        
        if (type === 'Circle' || type === 'Icon' || type === 'Image') {
            geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([]));
        } else if (type === 'Text') {
            geoflo.map.getSource(geoflo.statics.constants.sources.HOTTEXT).setData(turf.featureCollection([geoflo.hotFeature]));
            addText.call(geoflo.currentMode, type, geoflo.hotFeature);
        } else {
            geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([geoflo.hotFeature]));
            geoflo.map.getSource(geoflo.statics.constants.sources.VERTEX).setData(turf.featureCollection([geoflo.hotFeature]));
        }

        var coords = geoflo.Utilities.isPoint(geoflo.hotFeature) ? geoflo.hotFeature.geometry.coordinates : geoflo.hotFeature.geometry.coordinates[geoflo.hotFeature.geometry.coordinates.length - 1];
        geoflo.lastClick = { coords: coords };
        geoflo.firstClick = { coords: coords };
        return geoflo.currentMode.type;
    }

    function finishDraw (type, point, text) {
        var feature;
        var cancelled = geoflo.currentMode.cancelled;

        if (geoflo.editMode && !geoflo.currentMode.savingEdit && !cancelled) return geoflo.currentMode.saveEdit(point);
    
        if (cancelled || !type) {
            finishText();

            if (geoflo.hotFeature) {
                geoflo.removeSelection();
                geoflo.removeFeature(geoflo.hotFeature.id, true);
                geoflo.addFeatures([geoflo.hotFeature], true);
            }

            geoflo.Pinning.resetFeatures();

            if (!geoflo.editMode) geoflo.fire('draw.cancel', { cancel: true, feature: geoflo.hotFeature });
            return false;
        } else if (type === 'Text' && !text) {
            return addText.call(geoflo.currentMode, type, point);
        } else if (geoflo.hotFeature) {
            if (geoflo.Utilities.isPoint(geoflo.hotFeature)) {
                var coords = Array.isArray(geoflo.hotFeature.geometry.coordinates[0]) ?
                geoflo.hotFeature.geometry.coordinates[0] :
                [geoflo.hotFeature.geometry.coordinates[0], geoflo.hotFeature.geometry.coordinates[1]]
    
                point = geoflo.Painting.enabled || geoflo.currentMode.savingEdit ? point : turf.point(coords);
                feature = point;
            } else if (geoflo.Utilities.isPolygon(geoflo.hotFeature, type)) {
                geoflo.hotFeature.geometry.type = "Polygon";

                if (type === 'Rectangle') {
                    geoflo.endPoint ? updateCoordinate(geoflo.hotFeature, "0.2", geoflo.endPoint[0], geoflo.endPoint[1]) : false;
                } else {
                    geoflo.hotFeature.geometry.coordinates.push(geoflo.hotFeature.geometry.coordinates[0]);
                    geoflo.hotFeature.geometry.coordinates = [geoflo.hotFeature.geometry.coordinates];
                }
            } else if (geoflo.Utilities.isLineString(geoflo.hotFeature, type)) {
                if (type === 'Polygon') {
                    geoflo.hotFeature.geometry.type = type;
                    geoflo.hotFeature.geometry.coordinates.push(geoflo.hotFeature.geometry.coordinates[0]);
                    geoflo.hotFeature.geometry.coordinates = [geoflo.hotFeature.geometry.coordinates];
                } else if (type === 'Rectangle') {
                    geoflo.endPoint ? updateCoordinate(geoflo.hotFeature, "0.2", geoflo.endPoint[0], geoflo.endPoint[1]) : false;
                }
            } else if (point) {
                feature = point;
            }
    
            if (geoflo.Painting.enabled) {
                var tolerance = geoflo.options.painting.tolerance;
    
                geoflo.hotFeature = type === 'Circle' ? geoflo.hotFeature : turf.simplify(geoflo.hotFeature, {
                    mutate: true,
                    tolerance: typeof tolerance === 'function' ? tolerance(geoflo.map) : tolerance,
                    highQuality: true
                });

                if (geoflo.startPoint) geoflo.hotFeature.geometry.coordinates[0] = geoflo.startPoint;
            }
        } else if (point) {
            feature = point;
        }
    
        feature = geoflo.Exploring.currentFeature || feature || geoflo.hotFeature;
        if (!feature || !geoflo.currentMode.activated) return geoflo.currentMode.deactivate();

        feature = geoflo.Features.addFeature(feature, geoflo.currentMode.source, geoflo.currentMode.properties);
        geoflo.fire('draw.finish', { feature: feature, pinned: geoflo.Pinning.getFeatures(), type: type, editing: geoflo.editMode });
        return geoflo.currentMode.deactivate();
    }

    function finishText (e, type, feature) {
        var marker = geoflo.textMarker;
        if (!marker) return false;

        var element = marker.getElement();
        var text = element.value;
    
        if (!text.length || geoflo.currentMode.cancelled) return marker.remove(), geoflo.textInput = false, addText.call(this, type, feature);
    
        var coords = [element.getAttribute('lng'), element.getAttribute('lat')];
        type = type || element.getAttribute('type');

        geoflo.currentMode.properties.text = text;
        
        var feature = {
            "type": "Feature",
            "properties": {
                type: type,
                text: text
            },
            "geometry": {
              "type": "Point",
              "coordinates": coords
            }
        }
        
        marker.remove();
        finishDraw(type, feature, text);
    }

    function cleanupDraw (mode) {
        geoflo.map.getSource(geoflo.statics.constants.sources.ROUTE).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources.VERTEX).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources.HOTTEXT).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources.SELECT).setData(turf.featureCollection([]));
    
        geoflo.deleteMeshData();
    
        mode.history = [];
        mode.undo = [];
        mode.type = null;
        mode.cancelled = false;
        mode.activated = false;
        mode.savingEdit = false;

        geoflo.editMode = false;
        geoflo.drawMode = false;

        delete geoflo.startPoint;
        delete geoflo.lastClick;
        delete geoflo.firstClick;
        delete geoflo.endPoint;
        delete geoflo.snapFeature;
        delete geoflo.hotFeature;
        delete geoflo.drawStarted;
        delete geoflo.dragMoving;
        delete geoflo.editing;
        delete geoflo.textMarker;
        delete geoflo.textInput;
        delete geoflo.touchMoving;
        delete geoflo.touchDown;
        delete geoflo.pinningFeatures;
        delete geoflo.pinnedFeatures;
        delete geoflo.canDragMove;
        delete geoflo.canAddVertex;
        delete geoflo.dragIndex;
        delete geoflo.addedVertexOnLine;
        delete geoflo.snappedVertex;
    }

    function getVertex (point) {
        var hotFeature = geoflo.hotFeature;
        var vertex;
    
        if (geoflo.dragMoving) return false;
        if (!hotFeature) return false;
    
        var closest = geoflo.Snapping.getClosest(point.geometry.coordinates);
        var coords = closest.coords;
        var type = closest.point ? closest.point.type : false;
        
        if (!type) return false;
    
        if (!coords && type === 'linepoint' && closest.point.borders) {
            var segment = turf.lineString([closest.point.border1, closest.point.border2]);
            vertex = turf.along(segment, closest.point.distance1);
            coords = vertex.geometry.coordinates;
        }
    
        if (!coords) return false;

        point = turf.point(coords); 

        var isLineVertex = geoflo.Utilities.isLineString(hotFeature) && type === 'vertex';
        var nearestVertex = isLineVertex ? turf.nearestPointOnLine(hotFeature, point) : false;
           
        vertex = nearestVertex || point;
        vertex.properties.type = type;
    
        geoflo.fire('vertex.find', { vertex: vertex, feature: geoflo.hotFeature, closest: closest });
        return vertex;
    }
    
    function addVertex (point, event) {
        var feature;
    
        if (event && point) {
            var coords = geoflo.hotFeature.geometry.coordinates;
            var line = turf.lineString(coords);
            var start = turf.point(coords[0])
            var split = turf.lineSlice(start, point, line);
            var index = split.geometry.coordinates.length - 1;
            var vertex = split.geometry.coordinates[index];
    
            point = turf.point(vertex);
            
            line.geometry.coordinates.splice.apply(line.geometry.coordinates, [index, 0].concat([vertex]));
    
            line = turf.cleanCoords(line);
            feature = turf.truncate(line, { precision: 6, coordinates: 2, mutate: true });
            geoflo.hotFeature.geometry.coordinates = feature.geometry.coordinates;
            geoflo.hotFeature = geoflo.Utilities.cloneDeep(geoflo.hotFeature);
        } else if (point) {
            geoflo.canDragMove = true;
            geoflo.canAddVertex = point;
        }
    
        return point;
    }
    
    function onVertex (vertex, add) {
        var hotFeature = geoflo.hotFeature;
        var dragIndex = null;
    
        if (geoflo.dragMoving) return offVertex();
        if (!hotFeature || !vertex) return offVertex();
        
        geoflo.updateMeshData();
    
        var type = vertex.properties.type;
        var index = vertex.properties.index || vertex.properties.index == 0;
    
        dragIndex = index ? vertex.properties.index : geoflo.currentMode.type === 'Circle' || geoflo.currentMode.type === 'Icon' || geoflo.currentMode.type === 'Image' ? 0 : false;
    
        geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([vertex]));
        geoflo.map.getSource(geoflo.statics.constants.sources.VERTEX).setData(turf.featureCollection([geoflo.hotFeature]));
    
        if (type === 'linepoint') return addVertex(vertex);
    
        geoflo.map.dragPan.disable();
        geoflo.dragIndex = dragIndex;
        geoflo.addedVertexOnLine = add ? vertex : false;
        geoflo.canAddVertex = false;
        geoflo.canDragMove = true;
        geoflo.snappedVertex = vertex.geometry.coordinates;
        geoflo.Pinning.setFeatures(geoflo.snappedVertex);
        geoflo.fire('vertex.on', { vertex: vertex, index: dragIndex, feature: geoflo.hotFeature });
    }
    
    function offVertex () {
        if (geoflo.mouseIsDown && geoflo.Painting.enabled) return false;

        if (geoflo.hotFeature && geoflo.snappedVertex) {
            geoflo.lastIndex ? geoflo.lastClick = { coords: geoflo.snappedVertex } : false;
            geoflo.fire('vertex.off', { vertex: false, index: geoflo.dragIndex, feature: geoflo.hotFeature })
        }
    
        geoflo.map.dragPan.enable();
        geoflo.dragMoving = false;
        geoflo.canDragMove = false;
        geoflo.snappedVertex = null;
        geoflo.dragIndex = -1;
        geoflo.mouseIsDown = geoflo.touchDown || false;
        geoflo.pinableFeatures = [];
        geoflo.lastIndex = false;
        geoflo.canAddVertex = false;
        geoflo.addedVertexOnLine = false
    }

    function addText (type, feature) {
        feature = feature || geoflo.hotFeature;
        if (!feature) return false;

        type = type || feature.properties.type;
        feature.properties.type = type;

        if (type !== 'Text') return //geoflo.Features.setText(feature);
        if (geoflo.textInput) return finishText(false, type, feature);
        
        var lngLat = { lng: feature.geometry.coordinates[0], lat: feature.geometry.coordinates[1] }
        var el = geoflo.textInput = document.createElement('input');

        el.value = feature.properties.text || '';
        el.className = 'text-marker';

        el.setAttribute('contenteditable', 'true');
        el.setAttribute('autocorrect', 'off');
        el.setAttribute('spellcheck', 'false');
        el.setAttribute('placeholder', 'Press Enter or Select Button When Done...');
        el.setAttribute('type', type);
        el.setAttribute('lng', lngLat.lng);
        el.setAttribute('lat', lngLat.lat);
        
        geoflo.textMarker = new mapboxgl.Marker(el).setLngLat(lngLat).addTo(geoflo.map);
        geoflo.textMarker.setOffset([0, -25])

        el.addEventListener("submit", finishText);
        el.addEventListener("keydown", inputText);
        el.addEventListener("paste", handlePaste);
        el.focus();

        geoflo.fire('text.add', { feature: feature, marker: geoflo.textMarker, type: type });
    
        function inputText (e) {
            if ([32, 37, 38, 39, 40].indexOf(e.keyCode) > -1) {
                e.stopPropagation();
            } else if(e.keyCode === 13) {
                e.preventDefault();
                finishText(e);
            }
        }

        function handlePaste (e) {
            var clipboardData, pastedData;
            e.stopImmediatePropagation();
            e.preventDefault();
            clipboardData = e.clipboardData || window.clipboardData;
            pastedData = clipboardData.getData('text/plain').slice(0, CHAR_LIMIT);
            e.target.innerText = pastedData;
        }
    }

    function updateCoordinate (f, t, e, n) {
        var o = t.split(".")
            , r = parseInt(o[0], 10)
            , i = parseInt(o[1], 10);
        void 0 === f.geometry.coordinates[r] && (f.geometry.coordinates[r] = []),
        f.geometry.coordinates[r][i] = [e, n]
    }

    function updateRectangle (event, type) {
        if (type !== 'Rectangle') return false;
        
        var geometry = geoflo.hotFeature.geometry;
        var coords = geometry.coordinates;
        const coordType = geometry.type;
        //coords = coordType === 'Linestring' ? coords : coords[0];
    
        if (geoflo.currentVertexPosition === 2) {
            const getpXY3 = calculatepXY3(geometry, event, type);
            if (getpXY3[2]) return updateCoordinate(`0.${geoflo.currentVertexPosition + 1}`, getpXY3[2][0], getpXY3[2][1]);
            return geoflo.hotFeature;
        }
    
        updateCoordinate(`0.${geoflo.currentVertexPosition}`, event.lngLat.lng, event.lngLat.lat);
        geoflo.currentVertexPosition++;
        updateCoordinate(`0.${geoflo.currentVertexPosition}`, event.lngLat.lng, event.lngLat.lat);
    
        function calculatepXY3 (geometry, event, type) {
            var coords = geometry.coordinates;
        
            const pXY0 = coords[0];
            const pXY0_3857 = geoflo.Utilities.degrees2meters(pXY0);
            const pXY1 = coords[1];
            const pXY1_3857 = geoflo.Utilities.degrees2meters(pXY1);
            let pXY2_3857 = geoflo.Utilities.degrees2meters([event.lngLat.lng, event.lngLat.lat]);
            const mouse_3857 = geoflo.Utilities.degrees2meters([event.lngLat.lng, event.lngLat.lat]);
        
            if (pXY0_3857[0] === pXY1_3857[0]) {
                pXY2_3857 = [mouse_3857[0], pXY1_3857[1]];
            } else if (pXY0_3857[1] === pXY1_3857[1]) {
                pXY2_3857 = [pXY1_3857[0], mouse_3857[1]];
            } else {
                const vector1_3857 = (pXY1_3857[1] - pXY0_3857[1]) / (pXY1_3857[0] - pXY0_3857[0]);
                const vector2_3857 = -1.0 / vector1_3857;
        
                if (Math.abs(vector2_3857) < 1) {
                    pXY2_3857[1] = vector2_3857 * (mouse_3857[0] - pXY1_3857[0]) + pXY1_3857[1];
                } else {
                    pXY2_3857[0] = pXY1_3857[0] + (pXY2_3857[1] - pXY1_3857[1]) / vector2_3857;
                }
            }
        
            const vector_3857 = [pXY1_3857[0] - pXY0_3857[0], pXY1_3857[1] - pXY0_3857[1]];
            const pXY3_3857 = [pXY2_3857[0] - vector_3857[0], pXY2_3857[1] - vector_3857[1]];
            const pXY2G = geoflo.Utilities.meters2degrees(pXY2_3857);
            const pXY3G = geoflo.Utilities.meters2degrees(pXY3_3857);
        
            return [coords, pXY2G, pXY3G];
        }
    
        return false;
    }

    function startIdleTime () {
        var ready = setInterval(function() {
            if (geoflo.mouseIsDown) {
                geoflo.lastDragMove += 1;
                checkIdleMove();
            } else {
                geoflo.lastDragMove = 0;
                geoflo.mouseIsIdle = false;
                clearInterval(ready);
            }
        }, 1);
    }
    
    function checkIdleMove () {
        if (geoflo.lastDragMove < geoflo.options.pinning.idle) return geoflo.mouseIsIdle = false, false;
        geoflo.mouseIsIdle = true;
        geoflo.Snapping.setVertex();
        geoflo.Pinning.updateFeatures();
        return true;
    }

    function needsToFinish (type, coords) {
        var types = ['Circle', 'Icon', 'Text', 'Image'];
        if (!type) return true;
        if (types.includes(type)) return true;
        if (type === 'Rectangle' && geoflo.startPoint) return geoflo.endPoint = coords, true;
        if (type === 'Polygon' && geoflo.snappedVertex && geoflo.startPoint && geoflo.Utilities.isPointEqual(geoflo.startPoint, geoflo.snappedVertex)) return true;
        if (geoflo.snappedVertex && geoflo.Utilities.isLastIndex(geoflo.dragIndex, geoflo.hotFeature)) return true
        if (geoflo.lastClick && geoflo.Utilities.isPointEqual(geoflo.lastClick.coords, coords)) return true;
        return false;
    }

    function constrainFeatureMovement (geojsonFeatures, delta) {
        // "inner edge" = a feature's latitude closest to the equator
        let northInnerEdge = geoflo.statics.constants.LAT_MIN;
        let southInnerEdge = geoflo.statics.constants.LAT_MAX;
        // "outer edge" = a feature's latitude furthest from the equator
        let northOuterEdge = geoflo.statics.constants.LAT_MIN;
        let southOuterEdge = geoflo.statics.constants.LAT_MAX;
    
        let westEdge = geoflo.statics.constants.LNG_MAX;
        let eastEdge = geoflo.statics.constants.LNG_MIN;
    
        geojsonFeatures.forEach((feature) => {
            //const bounds = extent(feature); Need to add Turf bounds here
            const featureSouthEdge = bounds[1];
            const featureNorthEdge = bounds[3];
            const featureWestEdge = bounds[0];
            const featureEastEdge = bounds[2];
            if (featureSouthEdge > northInnerEdge) northInnerEdge = featureSouthEdge;
            if (featureNorthEdge < southInnerEdge) southInnerEdge = featureNorthEdge;
            if (featureNorthEdge > northOuterEdge) northOuterEdge = featureNorthEdge;
            if (featureSouthEdge < southOuterEdge) southOuterEdge = featureSouthEdge;
            if (featureWestEdge < westEdge) westEdge = featureWestEdge;
            if (featureEastEdge > eastEdge) eastEdge = featureEastEdge;
        });
    
    
        // These changes are not mutually exclusive: we might hit the inner
        // edge but also have hit the outer edge and therefore need
        // another readjustment
        const constrainedDelta = delta;
    
        if (northInnerEdge + constrainedDelta.lat > geoflo.statics.constants.LAT_RENDERED_MAX) {
            constrainedDelta.lat = geoflo.statics.constants.LAT_RENDERED_MAX - northInnerEdge;
        }
        if (northOuterEdge + constrainedDelta.lat > geoflo.statics.constants.LAT_MAX) {
            constrainedDelta.lat = geoflo.statics.constants.LAT_MAX - northOuterEdge;
        }
        if (southInnerEdge + constrainedDelta.lat < geoflo.statics.constants.LAT_RENDERED_MIN) {
            constrainedDelta.lat = geoflo.statics.constants.LAT_RENDERED_MIN - southInnerEdge;
        }
        if (southOuterEdge + constrainedDelta.lat < geoflo.statics.constants.LAT_MIN) {
            constrainedDelta.lat = geoflo.statics.constants.LAT_MIN - southOuterEdge;
        }
        if (westEdge + constrainedDelta.lng <= geoflo.statics.constants.LNG_MIN) {
            constrainedDelta.lng += Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
        }
        if (eastEdge + constrainedDelta.lng >= geoflo.statics.constants.LNG_MAX) {
            constrainedDelta.lng -= Math.ceil(Math.abs(constrainedDelta.lng) / 360) * 360;
        }
    
        return constrainedDelta;
    }

    function calculateOrientedAnglePolygon (feature) {
        var geometry = feature.geometry;
        var coords = geometry.coordinates;
        const coordType = geometry.type;
        coords = coordType === 'Linestring' ? coords : coords[0];
    
        const pXY0 = coords[0];
        const pXY0_3857 = geoflo.Utilities.degrees2meters(pXY0);
        const pXY1 = coords[1];
        const pXY1_3857 = geoflo.Utilities.degrees2meters(pXY1);
        const angleStdGraus = Math.atan2(pXY1_3857[1] - pXY0_3857[1], pXY1_3857[0] - pXY0_3857[0]) * 180 / Math.PI;
    
        let angleSudGraus = -1.0 * (angleStdGraus + 90);
        const angle = angleSudGraus < 0 ? angleSudGraus + 360 : angleSudGraus;
        return parseFloat((angle).toFixed(2));
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Draw);

/***/ }),

/***/ "./src/Events.js":
/*!***********************!*\
  !*** ./src/Events.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const events = [
    'map.enable',
    'map.disable',
    'map.ready',
    'map.redraw',
    'map.refresh',
    'mode.change',
    'theme.change',
    'sources.add',
    'source.add',
    'source.hot',
    'layers.add',
    'layers.remove',
    'layer.add',
    'control.add',
    'control.remove',
    'features.zoom',
    'features.add',
    'features.delete',
    'features.update',
    'features.import',
    'features.export',
    'features.offset',
    'feature.add',
    'feature.delete',
    'feature.select',
    'feature.deselect',
    'feature.update',
    'feature.history',
    'select.load',
    'select.add',
    'select.remove',
    'select.activate',
    'select.deactivate',
    'draw.activate',
    'draw.deactivate',
    'draw.start',
    'draw.finish',
    'draw.cancel',
    'mesh.load',
    'text.add',
    'icon.add',
    'vertex.find',
    'vertex.on',
    'vertex.off',
    'vertex.add',
    'vertex.drag',
    'vertex.dragsnap',
    'vertex.delete',
    'overpass.add',
    'snapping.activate',
    'snapping.deactivate',
    'snapping.add',
    'snapping.refresh',
    'snapping.delete',
    'pinning.activate',
    'pinning.deactivate',
    'pinning.add',
    'pinning.update',
    'routing.activate',
    'routing.deactivate',
    'routing.add',
    'painting.activate',
    'painting.deactivate',
    'painting.start',
    'painting.update',
    'gamepad.init',
    'gamepad.add',
    'gamepad.remove',
    'gamepad.hold',
    'gamepad.press',
    'gamepad.release',
    'gamepad.connect',
    'gamepad.disconnect',
    'locate.on',
    'locate.off',
    'locate.update'
]

/**
 * @mixin
 * @memberof module:geoflo
 * @name Events
 * @description This module handles various map and user interaction events for the geoflo application.
 * @param {Object} geoflo - The geoflo instance to which the events are bound.
 * @returns {Object} An object containing methods to add and remove event listeners.
 * @function addEventListeners - Adds event listeners to the map and other elements.
 * @function removeEventListeners - Removes event listeners from the map and other elements.
 */

const Events = function (geoflo) {
    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mapMoveStart
     * @description Handles the `movestart` event on the map.
     * @param {Object} event - The event object containing map movement details.
     */
    const mapMoveStart = function (event) {
        geoflo.mapMoving = event;
        if (geoflo.settingExtent) return;
        if (geoflo.locate) geoflo.locate.onMapMove(event);
        geoflo.setIcon(event);
    };

    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mapMoving
     * @description Handles the `move` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing map movement details.
     */
    const mapMoving = function (event) {
        geoflo.mapMoving = event;
        if (geoflo.settingExtent) return;
        geoflo.setIcon(event);
        geoflo.setCenterMarker();
        geoflo.locate && geoflo.locate.following ? geoflo.setMapClass('disable') : false;
    };

    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mapMoveEnd
     * @description Handles the `moveend` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing map movement details.
     */
    const mapMoveEnd = function (event) {
        geoflo.mapMoving = false;
        if (geoflo.settingExtent) return;
        geoflo.onMapMove(event);
        if (geoflo.locate) geoflo.locate.onMapMove(event);
        geoflo.setIcon(event);
    };

    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mouseMove
     * @description Handles the `mousemove` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing mouse movement details.
     */
    const mouseMove = function (event) {
        var painting = geoflo.options.painting && geoflo.options.painting.enable;
        painting = painting && geoflo.currentMode && geoflo.currentMode.id === 'draw';
        
        geoflo.locate && geoflo.locate.following ? geoflo.setMapClass('disable') :
        geoflo.dragMoving ? geoflo.setMapClass('grabbing') :
        geoflo.addingVertexOnLine || geoflo.canAddVertex ? geoflo.setMapClass('pointer') :
        geoflo.canDragMove ? geoflo.setMapClass('grab') :
        painting? geoflo.setMapClass('painting') :
        geoflo.setMapClass('pointer');

        geoflo.lastMouseEvent = event;
        if (!geoflo.currentMode) return;
        geoflo.currentMode.handleMove ? geoflo.currentMode.handleMove(event) : false;
    };

    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mouseDown
     * @description Handles the `mousedown` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing mouse movement details.
     */
    const mouseDown = function (event) {
        var painting = geoflo.options.painting && geoflo.options.painting.enable;
        painting = painting && geoflo.currentMode && geoflo.currentMode.id === 'draw';
        
        geoflo.locate && geoflo.locate.following ? geoflo.setMapClass('disable') :
        painting? geoflo.setMapClass('painting') :
        geoflo.dragMoving ? geoflo.setMapClass('grabbing') :
        geoflo.addingVertexOnLine ? geoflo.setMapClass('grabbing') :
        geoflo.canDragMove ? geoflo.setMapClass('grab') :
        geoflo.lastClick ? geoflo.setMapClass('grabbing') :
        geoflo.setMapClass('pointer');
        
        geoflo.mouseIsDown = [event.lngLat.lng, event.lngLat.lat];
        geoflo.currentMode.handleDown ? geoflo.currentMode.handleDown(event) : false;
    };    
    
    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mouseUp
     * @description Handles the `mouseup` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing mouse movement details.
     */
    const mouseUp = function (event) {
        geoflo.mouseIsDown = false;
        geoflo.locate && geoflo.locate.following ? geoflo.setMapClass('disable') : geoflo.setMapClass('pointer');
        geoflo.currentMode.handleUp ? geoflo.currentMode.handleUp(event) : false;
    };

    
    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mouseClick
     * @description Handles the `click` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing mouse movement details.
     */
    const mouseClick = async function (event) {
        if (event.type.includes('preclick')) return geoflo.currentMode.handlePreclick ? geoflo.currentMode.handlePreclick(event) : false;
        geoflo.currentMode.handleClick ? geoflo.currentMode.handleClick(event) : false;
    };

    
    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mouseDrag
     * @description Handles the `drag` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing mouse movement details.
     */
    const mouseDrag = function (event) {
        geoflo.locate && geoflo.locate.following ? geoflo.setMapClass('disable') :
        geoflo.dragMoving ? geoflo.setMapClass('grabbing') :
        geoflo.canDragMove ? geoflo.setMapClass('grab') :
        geoflo.setMapClass('move');

        geoflo.currentMode.handleDrag ? geoflo.currentMode.handleDrag(event) : false;
    };

    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mouseleave
     * @description Handles the `mouseleave` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing mouse movement details.
     */
    const mouseleave = function (event) {
        geoflo.currentMode.handleOffMap ? geoflo.currentMode.handleOffMap(event) : false;
    };

    /**
     * @function
     * @memberof module:geoflo.Events
     * @name mouseover
     * @description Handles the `mouseover` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing mouse movement details.
     */
    const mouseover = function (event) {
        geoflo.currentMode.handleOnMap ? geoflo.currentMode.handleOnMap(event) : false;
    };

    /**
     * @function
     * @memberof module:geoflo.Events
     * @name keypress
     * @description Handles the `keypress` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing keypress details.
     */
    const keypress = function (event) {
        if (geoflo.textMarker) return;
        
        console.log("keycode: ", event.keyCode, " =>", event.key, " | Code:", event.code, " Event:", event);
        const buttonOptions = geoflo.getButtons();

        let keyHandled = false;

        Object.keys(buttonOptions).forEach((buttonId) => {
            const option = buttonOptions[buttonId];
            const key = geoflo.options.keys[buttonId];

            if (key === event.key) {
                option.button.click();
                keyHandled = true;
            } else if (key === event.keyCode) {
                option.button.click();
                keyHandled = true;
            } else if (option.keycode && option.keycode === event.keyCode) {
                option.button.click();
                keyHandled = true;
            }
        });

        if (geoflo.options.commands) {
            geoflo.options.commands.forEach(function (c) {
                if (c.key === event.keyCode || c.key === event.key || c.key === event.code) {
                    if (!c.command || typeof c.command !== 'function') return;
                    c.command(event, geoflo, c);
                    keyHandled = true;
                }
            })
        }

        if (keyHandled) return keyHandled;

        if (event.key.includes('Arrow')) {}

        geoflo.currentKeyPress = event.key;

        switch (event.code) {
            case "Enter": {
                geoflo.setMode();
                break;
            }
            case "NumpadEnter": {
                geoflo.setMode();
                break;
            }
            case "Escape": {
                geoflo.hotFeature = null;
                geoflo.setMode();
                break;
            }
            case "Home": {
                geoflo.moveSelectedFeatures(1);
                break;
            }
            case "End": {
                geoflo.moveSelectedFeatures(-1);
                break;
            }
            case "Delete": {
                if (geoflo.mode === geoflo.statics.constants.modes.SELECT) {
                    if (geoflo.hasSelection()) { geoflo.removeSelection(); }
                } else if (geoflo.mode === geoflo.statics.constants.modes.DRAW) {
                    geoflo.currentMode.deleteVertex();
                }
                break;
            }
        }
    };

    /**
     * @function
     * @memberof module:geoflo.Events
     * @name keyrelease
     * @description Handles the `keyrelease` event on the map, updating icons and tracking movements.
     * @param {Object} event - The event object containing keypress details.
     */
    const keyrelease = function (event) {
        console.log("keyrelease: ", event);
        geoflo.currentKeyPress = false;
    };

    /**
     * @function
     * @memberof module:geoflo.Events
     * @name touchstart
     * @description Handles the touchstart event by delegating to the current mode's handleTouch method if it exists.
     * @param {Event} event - The touchstart event object.
     */
    const touchstart = function (event) {
        geoflo.currentMode.handleTouch ? geoflo.currentMode.handleTouch(event) : false;
    };

    /**
     * @function
     * @name touchend
     * @memberof module:geoflo.Events
     * @description Handles the touchend event by invoking the handleTouch method of the current mode if it exists.
     *
     * @param {Event} event - The touchend event object.
     * @returns {boolean} Returns false if the handleTouch method does not exist; otherwise, it returns undefined.
     */
    const touchend = function (event) {
        geoflo.currentMode.handleTouch ? geoflo.currentMode.handleTouch(event) : false;
    };
    
    /**
     * @function
     * @name touchmove
     * @memberof module:geoflo.Events
     * @description Handles the touchmove event by invoking the handleTouch method of the current mode if it exists.
     *
     * @param {Event} event - The touchmove event object.
     * @returns {boolean} Returns false if the handleTouch method does not exist.
     */
    const touchmove = function (event) {
        geoflo.currentMode.handleTouch ? geoflo.currentMode.handleTouch(event) : false;
    };

    /**
     * @function
     * @name touchcancel
     * @memberof module:geoflo.Events
     * @description Handles the touch cancel event by invoking the handleTouch method of the current mode if it exists.
     *
     * @param {Event} event - The touch cancel event object.
     * @returns {boolean} Returns false if the handleTouch method does not exist; otherwise, it returns the result of the handleTouch method.
     */
    const touchcancel = function (event) {
        geoflo.currentMode.handleTouch ? geoflo.currentMode.handleTouch(event) : false;
    };

    /**
     * @function
     * @name gamepadconnected
     * @memberof module:geoflo.Events
     * @description Handles the event when a gamepad is connected and adds it to the geoflo instance.
     *
     * @param {Event} event - The event object containing information about the connected gamepad.
     * @returns {void} This function does not return a value.
     */
    const gamepadconnected = function (event) {
        geoflo.addGamepad(event.gamepad || event.detail.gamepad);
    };

    /**
     * @function
     * @name gamepaddisconnected
     * @memberof module:geoflo.Events
     * @description Handles the event when a gamepad is disconnected and removes it from the geoflo system.
     *
     * @param {Event} event - The event object containing information about the disconnected gamepad.
     * @returns {void} This function does not return a value.
     */
    const gamepaddisconnected = function (event) {
        geoflo.removeGamepad(event.gamepad || event.detail.gamepad);
    };

    /**
     * @function
     * @name handleOrientation
     * @memberof module:geoflo.Events
     * @description Updates the orientation of the geoflo object based on the device's orientation event.
     *
     * @param {Event} event - The orientation event containing alpha, beta, and gamma values.
     * @returns {void} This function does not return a value.
     */
    const handleOrientation = function (event) {
        geoflo.updateOrientation({
            alpha: event.alpha,
            beta: event.beta,
            gamma: event.gamma
        })
    };

    /**
     * @function
     * @name dragStart
     * @memberof module:geoflo.Events
     * @description Handles the drag start event for an element.
     *
     * @param {Event} event - The event object representing the drag start event.
     * @returns {void} This function does not return a value.
     */
    const dragStart = function (event) {
        //if (geoflo.locate && geoflo.locate.following) return event.originalEvent.preventDefault();
    };

    /**
     * @function
     * @name rotatePitch
     * @memberof module:geoflo.Events
     * @description Adjusts the map's pitch based on the provided event, setting the map class to 'grabbing', updating the icon, and repositioning the center marker.
     *
     * @param {Object} event - The event object that contains information about the interaction.
     * @returns {void} This function does not return a value.
     */
    const rotatePitch = function (event) {
        geoflo.setMapClass('grabbing');
        geoflo.setIcon(event);
        geoflo.setCenterMarker({ transform: true });
    };



    /**
     * @function
     * @name fireEvent
     * @memberof module:geoflo.Events
     * @description Triggers a custom event on the geoflo map based on the provided event object.
     *
     * @param {Object} event - The event object containing details about the event.
     * @param {string} event.type - The type of the event, which includes the action and target information.
     * @param {Object} event.detail - Additional details associated with the event.
     * @returns {void} This function does not return a value.
     */
    const fireEvent = function fireEvent (event) {
        const name = event.type.split(':')[1];
        
        const detail = {
            data: event.detail,
            type: name.split('.')[0],
            action: name.split('.')[1],
            target: geoflo,
        }

        const details = { name: name, detail: detail };
        geoflo.map.fire(geoflo.id, details);
    }

    /**
     * @function
     * @name contextMenu
     * @memberof module:geoflo.Events
     * @description Handles the context menu event by invoking the current mode's context handling function if it exists.
     *
     * @param {Event} event - The event object representing the context menu event.
     * @returns {boolean} Returns false if the current mode does not have a context handler.
     */
    const contextMenu = function (event) {
        geoflo.currentMode.handleContext ? geoflo.currentMode.handleContext(event) : false;
    }

    /**
     * @function
     * @name sourceData
     * @memberof module:geoflo.Events
     * @description Processes the source data from an event and triggers an action based on the source ID.
     *
     * @param {Object} event - The event object containing source data.
     * @param {string} event.sourceDataType - The type of the source data.
     * @param {string} event.sourceId - The ID of the source.
     * @param {Object} event.source - The source object containing data.
     * @param {string} event.type - The type of the event.
     * @returns {boolean} Returns false if the source data type is invalid or if the source ID is not present; otherwise, it triggers an event based on the source ID.
     */
    const sourceData = function (event) {
        if (!event.sourceDataType || !event.sourceDataType === 'content' || !event.sourceId) return false;
        const id = event.sourceId;

        const detail = {
            id: id,
            data: event.source.data,
            type: event.type,
            target: geoflo,
        }

        id === geoflo.statics.constants.sources.HOT ? geoflo.fire('source.hot', detail) : false;
    }

    

    /**
     * @function
     * @name addEventListeners
     * @memberof module:geoflo.Events
     * @description Attaches various event listeners to the map and container for handling user interactions and map events.
     *
     * @returns {void} This function does not return a value.
     */
    function addEventListeners () {
        geoflo.map.on("movestart", mapMoveStart);
        geoflo.map.on("move", mapMoving);
        geoflo.map.on("moveend", mapMoveEnd);
        geoflo.map.on("mousemove", mouseMove);

        geoflo.map.on('preclick', mouseClick);
        geoflo.map.on('click', mouseClick);
        geoflo.map.on('tap', mouseClick);

        geoflo.map.on('dragstart', dragStart);
        geoflo.map.on('drag', mouseDrag);
        geoflo.map.on('mousedown', mouseDown);
        geoflo.map.on('mouseup', mouseUp);

        geoflo.map.on('rotatestart', rotatePitch);
        geoflo.map.on('pitchstart', rotatePitch);
        geoflo.map.on('rotate', rotatePitch);
        geoflo.map.on('pitch', rotatePitch);

        geoflo.map.on('touchstart', touchstart);
        geoflo.map.on('touchend', touchend);
        geoflo.map.on('touchmove', touchmove);
        geoflo.map.on('touchcancel', touchcancel);

        geoflo.map.on('contextmenu', contextMenu);
        geoflo.map.on('sourcedata', sourceData);

        events.forEach(function(event) { geoflo.map.on(geoflo.id + ':' + event, fireEvent); })

        geoflo.container.addEventListener('keydown', keypress);
        geoflo.container.addEventListener('keyup', keyrelease);
        geoflo.container.addEventListener('mouseover', mouseover);
        geoflo.container.addEventListener('mouseleave', mouseleave);

        window.addEventListener("gamepadconnected", gamepadconnected);
        window.addEventListener("gamepaddisconnected", gamepaddisconnected);
        window.addEventListener("deviceorientation", handleOrientation, true);
    }

    /**
     * @function
     * @name removeEventListeners
     * @memberof module:geoflo.Events
     * @description Removes various event listeners from the map and container to prevent further interactions.
     *
     * @returns {void} This function does not return a value.
     */
    function removeEventListeners () {
        geoflo.map.off("movestart", mapMoveStart);
        geoflo.map.off("move", mapMoving);
        geoflo.map.off("moveend", mapMoveEnd);
        geoflo.map.off("mousemove", mouseMove);

        geoflo.map.off('preclick', mouseClick);
        geoflo.map.off('click', mouseClick);
        geoflo.map.off('tap', mouseClick);

        geoflo.map.off('dragstart', dragStart);
        geoflo.map.off('drag', mouseDrag);
        geoflo.map.off('mousedown', mouseDown);
        geoflo.map.off('mouseup', mouseUp);

        geoflo.map.off('rotatestart', rotatePitch);
        geoflo.map.off('pitchstart', rotatePitch);

        geoflo.map.off('touchstart', touchstart);
        geoflo.map.off('touchend', touchend);
        geoflo.map.off('touchmove', touchmove);
        geoflo.map.off('touchcancel', touchcancel);
        
        geoflo.map.off('contextmenu', contextMenu);
        geoflo.map.off('sourcedata', sourceData);

        events.forEach(function(event) { geoflo.map.off(geoflo.id + ':' + event, fireEvent); })

        geoflo.container.removeEventListener('keydown', keypress);
        geoflo.container.removeEventListener('mouseover', mouseover);
        geoflo.container.removeEventListener('mouseleave', mouseleave);

        window.removeEventListener("gamepadconnected", gamepadconnected);
        window.removeEventListener("gamepaddisconnected", gamepaddisconnected);
        window.removeEventListener("deviceorientation", handleOrientation, true);
    }

    return {
        addEventListeners,
        removeEventListeners
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Events);

/***/ }),

/***/ "./src/Exploring.js":
/*!**************************!*\
  !*** ./src/Exploring.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Exploring
 * @description This mixin provides the exploring functionality for the GeoFlo application. It allows users to explore features on the map by creating a buffer around the feature and snapping to nearby features.
 * @param {Object} mode - The mode object containing the type of mode.
 * @returns {Object} The Exploring object.
 */
const Exploring = function (mode) {
    const geoflo = this.geoflo;
    this.type = mode.type;

	/**
     * Activates the exploring functionality by enabling the 'exploring' option.
     * @function
     * @name activate
     * @memberof module:geoflo.Exploring
     * @description Activates by setting the 'enabled' property to true and enabling the 'exploring' option.
     * @returns {void}
     */
    this.activate = function () {
        this.enabled = true;
        geoflo.options['exploring'].enable = true;
    }

	/**
	 * @function
     * @memberof module:geoflo.Exploring
	 * @name deactivate
	 * @description This function sets the 'enabled' and 'currentMatch' properties to false, and disables the 'exploring' option in the context.
	 */
    this.deactivate = function () {
        this.enabled = false;
        this.currentMatch = false;
        geoflo.options['exploring'].enable = false;
    }


	/**
	 * @function
     * @memberof module:geoflo.Exploring
	 * @name setFeatures
	 * @description This function sets features on the map based on the provided coordinates and options. It calculates the buffer based on the map zoom level and retrieves features within the buffer area. If routing is enabled, it calculates the route between two points.
	 * @param {Array<number>} coords - The coordinates to set features around.
	 * @param {Object} [options={}] - Additional options for setting features.
	 * @returns {boolean} Returns false if the function is not executed successfully.
	 */
    this.setFeatures = function (coords, options={}) {
        if (geoflo.mapMoving || !this.enabled || geoflo.currentMode.id !== 'draw') return false;
        
        if (!geoflo.Routing.enabled) {
            if (geoflo.hotFeature) geoflo.hotFeature.geometry.coordinates.pop();
            var fromPoint = geoflo.currentMode.firstClick || !geoflo.hotFeature ? geoflo.firstClick.coords : geoflo.hotFeature.geometry.coordinates[geoflo.hotFeature.geometry.coordinates.length - 1];
            var coords = [fromPoint, coords];
            if (geoflo.Utilities.isPointEqual(coords[0], coords[1])) return false;
            return this.getRoute(coords, options);
        }

        if (geoflo.map.getZoom() < geoflo.options.exploring.minZoom) return alert(`Zoom must be lower than ${geoflo.options.exploring.minZoom}`);

        var buffer = options.buffer || ((geoflo.options.exploring.buffer * Math.pow(2, Math.max(1, 19 - geoflo.map.getZoom()))) / 100);
        var polygon = turf.bboxPolygon([ geoflo.map.getBounds().getWest(), geoflo.map.getBounds().getSouth(), geoflo.map.getBounds().getEast(), geoflo.map.getBounds().getNorth() ]);

        if (coords) polygon = turf.polygon(turf.buffer(turf.point(coords), buffer).geometry.coordinates);

        geoflo.map.getSource(geoflo.statics.constants.sources['SNAP']).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources['ROUTE']).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources['VERTEX']).setData(turf.featureCollection([polygon]));

        this.getFeatures(turf.bbox(polygon)).then(features => { setFeatures(features, options); });
    }

	/**
	 * @function
     * @memberof module:geoflo.Exploring
	 * @name setFeature
	 * @description This function creates a line feature using the given coordinates and updates the current match based on the options. It also triggers an event and updates the source data on the map.
	 * @param {Array} coords - The coordinates to create the line feature. Default is an empty array.
	 * @param {Object} options - Additional options for setting the feature, such as the starting point. Default is an empty object.
	 * @returns {Object} The updated feature based on the provided coordinates and options.
	 */
    this.setFeature = function (coords=[], options={}) {
        if (!geoflo.hotFeature) return false;
        if (!coords.length) return geoflo.hotFeature;

        var feature = turf.lineString(coords);
        feature.geometry.coordinates[0] = options.start || feature.geometry.coordinates[0];

        if (this.currentMatch) feature = turf.lineString(geoflo.Utilities.combineSameTypeFeatures([this.currentMatch, feature]));
        this.currentMatch = feature;

        geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([]));
        geoflo.fire('exploring.match', { route: this.currentMatch });
        return mode.updateHotSource(this.currentMatch);
    }


	/**
	 * @function
     * @memberof module:geoflo.Exploring
	 * @name getFeatures
	 * @description Retrieves features based on the provided bounds using Overpass API.
	 * @param {Array} bounds - An array containing the bounding box coordinates [minLon, minLat, maxLon, maxLat].
	 * @returns {Promise<Array>} An array of GeoJSON features within the specified bounds.
	 */
    this.getFeatures = async function (bounds) {
        if (!bounds || !bounds.length || bounds.length != 4) return false;

        var tag = `way["highway"](${bounds[1]} , ${bounds[0]} , ${bounds[3]} , ${bounds[2]});`;

        if (geoflo.map.getZoom() < 12) {
            tag = `way["highway"="motorway"](${bounds[1]} , ${bounds[0]} , ${bounds[3]} , ${bounds[2]});`
            /* way["highway"="primary"](${bounds[1]} , ${bounds[0]} , ${bounds[3]} , ${bounds[2]});
            way["highway"="secondary"](${bounds[1]} , ${bounds[0]} , ${bounds[3]} , ${bounds[2]});` */
        }

        geoflo.overpassDownloading = true;

        const query = '[out:json][timeout:25];(' + tag + ');out body;>;out skel qt;';
        const data = await fetch("//overpass-api.de/api/interpreter?data=" + query, { method: 'GET' } );
        const response = await data.json();
        const geojson = convertFromOverpassToGeojson(response);
        return geojson && geojson.features ? geojson.features : [];
    }

	/**
	 * @function
     * @memberof module:geoflo.Exploring
	 * @name getMatch
	 * @description This function takes an array of coordinates and optional options to fetch a matched route from the OSRM API.
	 * @param {Array} coords - An array of coordinates to match the route against.
	 * @param {Object} options - Optional parameters for customization.
	 * @param {Object} options.feature - Optional feature to match against.
	 * @param {Number|Function} options.radius - Optional radius for matching or a function to calculate it.
	 * @param {String} options.profile - Optional profile for routing (default: 'driving').
	 * @param {Boolean} options.set - Optional flag to set the feature if matching is successful.
	 * @returns {Promise<Array|Boolean>} The matched route response object or false if no coordinates are provided or matching fails.
	 */
    this.getMatch = async function (coords=[], options={}) {
        if (!coords.length) return false;

        var tolerance = geoflo.options.exploring.tolerance;
        var feature = options.feature || turf.cleanCoords(turf.lineString(coords));
        feature = turf.simplify(feature, { mutate: true, tolerance: typeof tolerance === 'function' ? tolerance(geoflo.map) : tolerance, highQuality: true });

        var coordinates = feature.geometry.coordinates;
        if (coordinates.length < 2) return false;

        geoflo.overpassDownloading = true;

        options.radius = options.radius || 50;
        options.profile = options.profile || 'driving';
        coords = coordinates.join(';');

        const radiuses = coordinates.map(() => options.radius).join(';');

        const query = 'https://router.project-osrm.org/match/v1/' + options.profile + '/' + coords +
            '?overview=simplified' +
            '&radiuses=' + radiuses +
            '&generate_hints=false' +
            '&skip_waypoints=true' +
            '&gaps=ignore' +
            '&annotations=nodes' +
            '&tidy=true' +
            '&geometries=geojson';

        const match = await fetch(query, { method: 'GET' } );
        const response = await match.json();

        geoflo.overpassDownloading = false;
        if (response.code !== 'Ok') alert(`${response.code} - ${response.message}.`);
        return !options.set ? response : !response.matchings || !response.matchings.length ? feature : this.setFeature(response.matchings[0].geometry.coordinates, options);
    }

	/**
	 * @function
     * @memberof module:geoflo.Exploring
	 * @name getRoute
	 * @description Retrieves a route based on the provided coordinates using the OSRM routing service.
	 * @param {Array} coords - Array of coordinates representing the route.
	 * @param {Object} options - Additional options for the route calculation.
	 * @param {Object} options.feature - Feature object to use for the route calculation.
	 * @param {String} options.profile - Profile type for the route calculation (default: 'driving').
	 * @param {Boolean} options.set - Flag to indicate whether to set the route as a feature.
	 * @returns {Promise<Array|Boolean>} The route response object or false if no coordinates are provided or the route calculation fails.
	 */
    this.getRoute = async function (coords=[], options={}) {
        var feature = options.feature ? options.feature : !coords.length ? false : turf.cleanCoords(turf.lineString(coords));
        if (!feature) return false;
        
        var coordinates = feature.geometry.coordinates;
        if (coordinates.length < 2) return false;

        geoflo.overpassDownloading = true;
        options.profile = options.profile || 'driving';
        coords = coordinates.join(';');

        const query = 'https://router.project-osrm.org/route/v1/' + options.profile + '/' + coords +
            '?overview=simplified' +
            '&continue_straight=true' +
            '&annotations=nodes' +
            '&geometries=geojson';

        const match = await fetch(query, { method: 'GET' } );
        const response = await match.json();

        geoflo.overpassDownloading = false;
        if (response.code !== 'Ok') alert(`${response.code} - ${response.message}.`);
        return !options.set ? response : !response.routes || !response.routes.length ? feature : this.setFeature(response.routes[0].geometry.coordinates, options);
    }
    


    if (geoflo.options['exploring'].enable) this.activate();



    function convertFromOverpassToGeojson(op) {
        const elementsById = {};

        op.elements.forEach((element) => {
            const key = `${element.type}-${element.id}`;
            elementsById[key] = element;
        });

        const wayToPoints = function (way) {
            const line = [];
            way.nodes.forEach((nodeId) => {
                const key = `node-${nodeId}`;
                const nodeElement = elementsById[key];
                if (nodeElement) {
                    line.push([nodeElement.lon, nodeElement.lat]);
                } else {
                    console.error("Node ", key, " missing");
                }
            });
            return line;
        };

        const lineStrings = [];

        op.elements.forEach((element) => {
            if (element.type === "way") {
                const line = wayToPoints(element);
                if (line.length > 1) {
                    lineStrings.push(turf.lineString(line, element.tags));
                }
            } else if (element.type === "relation") {
                element.members.forEach((member) => {
                    const memberType = member.type;
                    if (memberType === "way") {
                        const key = `way-${member.ref}`;
                        const way = elementsById[key];
                        const line = wayToPoints(way);
                        if (line.length > 1) {
                            lineStrings.push(turf.lineString(line, element.tags));
                        }
                    }
                });
            }
        });

        return geoflo.turf.featureCollection(lineStrings);
    }

    function setFeatures(features=[]) {
        geoflo.overpassDownloading = false;
        if (geoflo.mapMoving || !geoflo.Exploring.enabled || geoflo.currentMode.id !== 'draw') return geoflo.updateMeshData([], true);
        geoflo.map.getSource(geoflo.statics.constants.sources.VERTEX).setData(turf.featureCollection([]));
        geoflo.Snapping.addFeature(geoflo.snapFeature);
        geoflo.setMeshFeatures(features);
        geoflo.currentMode.updateHotSource();
        geoflo.fire('overpass.add', { features: features });
        if (!geoflo.currentMode.firstClick) return features;
        var points = turf.explode(turf.featureCollection(features))
        var closestPoint = turf.nearestPoint(turf.point(geoflo.currentMode.firstClick.coords), points);
        geoflo.lastClick = { coords: closestPoint.geometry.coordinates };
        return features;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Exploring);

/***/ }),

/***/ "./src/Features.js":
/*!*************************!*\
  !*** ./src/Features.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Features
 * @description This module provides the features functionality for the Geoflo application. It allows users to add, remove, update, and retrieve features from the map.
 * @returns {Object} Returns the Features object.
 * @throws {Error} Throws an error if no map object is provided.
 */
const Features = function () {
    const geoflo = this.geoflo;
    if (!geoflo.map) { throw new Error('No map object provided!') }

    const coldFeatures = [];
    this.offsetLines = false;

    
	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name getColdFeatures
	 * @description This function returns an array of cold features.
	 * @return {Array} An array of cold features.
	 */
    this.getColdFeatures = function () {
        return coldFeatures;
    };

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name getFeatureById
	 * @description Retrieves a feature by its ID from a given source. If the ID is an array with multiple IDs, it retrieves multiple features. If the ID is an object, it tries to extract the ID from the object's parent, properties, or id fields.
	 * @param {string|number|Array} id - The ID or array of IDs of the feature(s) to retrieve.
	 * @returns {Object|Array} The feature or array of features corresponding to the provided ID(s).
	 */
    this.getFeatureById = function (id) {
        if (Array.isArray(id) && id.length > 1) return this.getFeaturesById(id);
        if (typeof id === 'object') id = id.parent || id.properties.parent || id.id || id.properties.id;
        return getFeatureById(id);
    };

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name getFeaturesById
	 * @description Retrieves features by their IDs.
	 * @param {Array} ids - An array of feature IDs to retrieve.
	 * @returns {Array} - An array of features corresponding to the provided IDs.
	 */
    this.getFeaturesById = function (ids) {
        const addedIds = [];
        const result = [];

        ids.forEach((id) => {
            const feature = this.getFeatureById(id);
            if (feature && !addedIds.includes(id)) addedIds.push(id), result.push(feature);
        }, this);

        return result;
    };

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name getType
	 * @description This function returns the type of the input feature.
	 * @param {any} feature - The feature whose type needs to be determined.
	 * @returns {string} The type of the input feature.
	 */
    this.getType = function (feature) {
        return getType(feature);
    }

	/**
	 * @function
     * @memberof module:geoflo.Features getUnit
	 * @name getUnit
	 * @description Retrieves the unit associated with a given feature type from the context options.
	 * @param {Object} feature - The feature object for which the unit needs to be retrieved.
	 * @returns {string|boolean} The unit associated with the feature type if found, otherwise false.
	 */
    this.getUnit = function (feature) {
        if (!feature) return false;

        var type = feature.properties.type;
        if (!type) return false;

        if (!geoflo.options.units || !geoflo.options.units[type]) return false;

        return geoflo.options.units[type];
    };

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name getUnits
	 * @param {Object} feature - The feature for which units need to be calculated.
	 * @returns {number} - The calculated units (length or area) of the feature.
	 */
    this.getUnits = function (feature) {
        var unit = this.getUnit(feature);
        if (!unit || !feature) return false;

        var units = 1;
        var type = feature.properties.type;

        if (type === "Polyline") {
            units = turf.length(feature, { units: 'meters' });
        } else if (type === 'Polygon') {
            units = turf.area(feature);
        } else if (type === 'Rectangle') {
            units = turf.area(feature);
        }

        return units;
    };



	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name setFeaturesState
	 * @description Sets the state of multiple features in a map.
	 * @param {Array} features - An array of features to set the state for.
	 * @param {boolean} state - The state to set for the features.
	 * @returns {Array} - The updated array of features with the new state.
	 */
    this.setFeaturesState = function (features=[], state) {
        if (!state || !features.length) return [];
        
        features.forEach(function(feature) {
            var id = feature.id || feature.properties.id;
            if (geoflo.hotFeature && geoflo.hotFeature.id === id) return;
            this.setFeatureState(id, state);
        }, this)

        return features;
    };

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name setFeatureState
	 * @description This function sets the state of a feature and its children in the map by updating their feature state.
	 * @param {string} id - The ID of the parent feature.
	 * @param {object} state - The state object to set for the features.
	 * @returns {array} - An array of features whose state was updated.
	 */
    this.setFeatureState = function (id, state) {
        if (!state || !id) return false;

        var features = getFeaturesByParent(id);
        
        features.forEach(function(feature) {
            var id = feature.id || feature.properties.id;
            geoflo.map.setFeatureState({ source: feature.source, id: id }, state);
        })

        return features;
    };

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name setText
	 * @description Sets text features on the map based on the provided features.
	 * @param {Object} features - The features to set text on.
	 * @returns {boolean} Returns false if no features are provided or if the features array is empty.
	 */
    this.setText = function (features=[]) {
        if (!geoflo.options.showFeatureText) return false;

        var source = geoflo.statics.constants.sources.HOTTEXT;

        this.textFeatures = [];

        if (features.features) features = features.features;
        if (!Array.isArray(features)) features = [features];

        features.forEach(function (feature) {
            var type = feature.properties.type;
            if (!type) return;

            this.currentType = type;

            if (type === 'Polyline' && geoflo.Utilities.isValidLineString(feature) && geoflo.options.showLineUnits) {
                turf.segmentEach(feature, setLineText.bind(this));
            } else {
                source = geoflo.statics.constants.sources.SELECT;
                var feat = geoflo.Utilities.cloneDeep(feature);
                
                feat.properties = {
                    type: 'Text',
                    text: feature.properties.text,
                    style: feature.properties.style
                }
                
                this.textFeatures.push(feat);
            }
        }, this)
        
        geoflo.map.getSource(source).setData(turf.featureCollection(this.textFeatures));

        delete this.textFeatures;
        delete this.currentType;
    }



	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name addFeature
	 * @description This function adds a feature to the map with the given properties. It cleans the coordinates, truncates them, assigns deep properties, sets the source, and removes unnecessary properties before adding the feature to the map.
	 * @param {Object} feature - The feature object to be added to the map.
	 * @param {Object} [properties={}] - Additional properties to be assigned to the feature.
	 * @returns {Object} The feature object that was added to the map.
	 */
    this.addFeature = function (feature, source, properties={}) {
        if (!feature || !feature.properties) return false;
        
        feature = turf.cleanCoords(feature);
        feature = turf.truncate(feature, { precision: 6, coordinates: 3, mutate: true });

        feature.properties = geoflo.Utilities.assignDeep(properties, feature.properties);
        feature.source = source || feature.source || feature.properties.source || geoflo.statics.constants.sources.COLD;
        
        delete feature.properties.source;
        delete feature.properties.painting;
        delete feature.properties.edit;
        delete feature.properties.new;
        delete feature.properties.selected;
        delete feature.properties.hidden;
        delete feature.properties.offset;
        
        feature.properties.style = feature.properties.style || {};

        this.addUnits(feature);
        this.addFeatures([feature]);
        return feature;
    };

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name addFeatures
	 * @description This function takes an array of features and adds them to the map. It also updates the source if any changes are made.
	 * @param {Array} features - An array of features to be added to the map.
	 * @param {boolean} unselect - A flag indicating whether to unselect the features.
	 * @returns {Array} The array of features that were added to the map.
	 */
    this.addFeatures = function (features, unselect, id) {
        var update;
        var sources = [];

        features.forEach((feature) => {
            feature.id = feature.id || feature.properties.id || URL.createObjectURL(new Blob([])).slice(-36);
            if (id && feature.id !== id) return false;

            feature.source = feature.source || feature.properties.source || geoflo.statics.constants.sources.COLD;
            feature.properties.id = feature.id;
            feature.properties.type = this.getType(feature);

            var index = coldFeatures.findIndex(function(f) { if (f.id === feature.id || f.properties.id === feature.id) return f; });

            if (index > -1) {
                this.setFeatureState(feature.id, { hidden: !unselect });
                coldFeatures[index] = feature;
                update = !unselect;
            } else {
                update = !this.updatingFeatures;
                coldFeatures.push(feature);
            }

            if (unselect) delete feature.properties._selected;
            if (update && !sources.includes(feature.source)) sources.push(feature.source);
        }, this);

        if (update) this.updateSource(sources);
        return features;
    };

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name addUnits
	 * @description Adds units to a feature's geometry based on the specified conversion or default unit.
	 * @param {Object} feature - The feature object to which units will be added.
	 * @param {String} convertTo - The unit to which the feature's units will be converted. If not provided, the default unit will be used.
	 * @returns {Object} The feature object with added units.
	 */
    this.addUnits = function (feature, convertTo) {
        var unit = convertTo || this.getUnit(feature);
        if (!unit) return false;

        var units = this.convertUnits(feature, null, convertTo);

        feature.geometry.units = units;
        feature.geometry.unit = unit;
        return feature;
    };

    /**
     * @function
     * @name selectFeatures
     * @memberof module:geoflo.Features
     * @description Selects features from a given array and marks them as selected if they are not already selected.
     *
     * @param {Array} features - An array of feature objects to be selected.
     * @returns {Array|boolean} Returns an array of selected features if any features were selected, otherwise returns false.
     */
    this.selectFeatures = function (features) {
        if (!features || !features.length) return false;

        var selected = geoflo.getSelectedFeatures();

        features.forEach(function (feature) {
            var id = feature.id || feature.properties.id;
            var index = selected.findIndex((f) => { return f.id === id || f.properties.id === id });

            if (index > -1) return false;

            feature.properties._selected = true;
            selected.push(feature);
        })

        return selected;
    }



	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name updateFeatures
	 * @description This function updates the coordinates of features in a map based on the provided coordinates. It iterates through the features array, retrieves the original feature by ID, and updates its geometry coordinates based on the feature type. It then adds units to the updated feature and updates the source of the map.
	 * @param {Array} features - An array of features to update.
	 * @param {Array} coords - The new coordinates to set for the features.
	 */
    this.updateFeatures = function(features, options={}) {
        features = features || geoflo.getFeatures();

        var sources = [];
        var selectedFeatures = geoflo.getSelectedFeatures();
        var coords = options.coords || null;

        this.updatingFeatures = true;

        features.forEach(function(feature) {
            var id = feature.id || feature.properties.id;
            if (!id) return false;

            var originalFeature = this.getFeatureById(id);
            if (!originalFeature || originalFeature === undefined) return this.addFeature(feature);

            var selected = selectedFeatures.find((feature) => { return feature.id === id || feature.properties.id === id });

            if (selected && !geoflo.noSelect) {
                selected.geometry.coordinates = feature.geometry.coordinates;
                selected.properties = feature.properties;
                selected.properties._selected = true;
                /* geoflo.Layers.getLayer(geoflo.statics.constants.sources.SELECT).forEachLayer(function (layer) { }) */
                return geoflo.map.getSource(geoflo.statics.constants.sources.SELECT).setData(turf.featureCollection(selectedFeatures));
            } else if (!sources.includes(originalFeature.source)) {
                sources.push(originalFeature.source);
            }
            
            if (options.type === 'pinning' && coords) {
                originalFeature.geometry.type === 'Point' ? originalFeature.geometry.coordinates = coords :
                originalFeature.geometry.type === 'Polygon' && coords ? originalFeature.geometry.coordinates[0][feature.index] = coords :
                originalFeature.geometry.type === 'LineString' && coords ? originalFeature.geometry.coordinates[feature.index] = coords :
                false;
            } else {
                originalFeature.geometry.coordinates = feature.geometry.coordinates;
                originalFeature.properties = feature.properties;
            }

            options.addUnits ? this.addUnits(originalFeature) : false;
        }, this);

        this.updatingFeatures = false;

        if (!sources.length) return false;
        return this.updateSource(sources);
    };

    

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name updateSource
	 * @description Updates the source of the current object with the provided sources.
	 * @param {Array} sources - An array of sources to update the current object with.
	 * @returns {any} The result of calling the updateSource function with the provided sources.
	 */
    this.updateSource = function (sources) {
        return updateSource.call(this, sources);
    };



	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name removeFeatures
	 * @description This function removes features from the map based on the provided ID or array of IDs. It updates the map source after removing the features.
	 * @param {string|string[]} id - The ID or array of IDs of the features to be removed.
	 * @param {boolean} remove - A flag indicating whether to remove the features or not.
	 * @returns {Object[]} An array containing the removed features.
	 */
    this.removeFeatures = function (id, remove) {
        const removedFeatures = [];

        var feature;
        var sources;

        if (Array.isArray(id) && remove) {
            sources = id.map(function(layer) { return layer.details ? layer.details.id : layer.id ? layer.id : layer });

            coldFeatures.forEach((feature) => {
                if (!sources.includes(feature.source)) return;
                var index = coldFeatures.findIndex((f) => { return feature.id === f.id || feature.properties.id === f.id });
                if (index > -1) removedFeatures.push(...coldFeatures.splice(index, 1));
            })

            this.updateSource(sources);
        } else {
            feature = remove ? coldFeatures.findIndex((feature) => { return feature.id === id || feature.properties.id === id }) :
            coldFeatures.find((feature) => { return feature.id === id || feature.properties.id === id });

            if (remove) {
                if (feature > -1) {
                    removedFeatures.push(...coldFeatures.splice(feature, 1));
                    sources = removedFeatures.map((feature) => { return feature.source });
                }
                
                this.updateSource(sources);
            } else {
                removedFeatures.push(feature);
                this.setFeatureState(id, { hidden: true });
            }
        }

        return removedFeatures;
    };

	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name deleteFeatures
	 * @description Deletes all features from the coldFeatures array and updates the source.
	 * @params {Array} coldFeatures - The array of features to be deleted.
	 * @returns {void}
	 */
    this.deleteFeatures = function () {
        coldFeatures.splice(0, coldFeatures.length);
        this.updateSource();
    };
    


	/**
	 * @function
     * @memberof module:geoflo.Features
	 * @name convertUnits
	 * @description Converts the given units of a feature to the specified target units based on the feature type (Polyline, Polygon, or Rectangle).
	 * @param {Object} feature - The feature object containing properties like type.
	 * @param {number} units - The units to be converted.
	 * @param {string} convertTo - The target units to convert to (optional).
	 * @returns {number} The converted units in the target unit format.
	 */
    this.convertUnits = function (feature, units, convertTo) {
        if (!feature) return 0;
        
        var type = feature.properties.type;
        var unit = convertTo || this.getUnit(feature);

        units = units || this.getUnits(feature);
        
        if (type === "Polyline") {
            units = Math.round(turf.convertLength(units, 'meters', unit));
        } else if (type === 'Polygon') {
            units = Math.round(turf.convertArea(units, 'meters', unit));
        } else if (type === 'Rectangle') {
            units = Math.round(turf.convertArea(units, 'meters', unit));
        }

        units = units ? Number(units.toFixed(2)) : 0;
        return units;
    };

    


    function getFeatureById(id) {
        var feature = coldFeatures.find((feature) => { return feature.id === id || feature.properties.id === id });
        feature = feature || geoflo.getSelectedFeatures().find((feature) => { return feature.id === id || feature.properties.id === id });
        return feature;
    };

    function getFeaturesByParent (id) {
        var feature = typeof id === 'object' && id.id ? id : getFeatureById(id);
        if (!feature || !feature.source || !geoflo.map.getSource(feature.source) || !geoflo.map.getSource(feature.source)._data) return [];
        var field = geoflo.options.offsetOverlappingLines ? 'parent' : 'id';
        var features = geoflo.map.getSource(feature.source)._data.features.filter(function(f) { return f[field] === id || f.properties[field] === id });
        return features;
    };

    function createTextFeatures (feature) {
        var isLine = geoflo.Utilities.isValidLineString(feature);
        var segments = [];

        if (isLine) {
            turf.segmentEach(feature, function (currentSegment) {
                var segment = geoflo.Utilities.cloneDeep(currentSegment);
                var footage = Math.round(turf.length(segment, { units: 'miles' }) * 5280);
                var mileage = Number(turf.length(segment, { units: 'miles' }).toFixed(3));
                footage = Number(footage.toFixed(2));
                mileage = Number(mileage.toFixed(2));

                segment.properties.footage = footage;
                segment.properties.mileage = mileage;
                segment.properties.text = `${mileage} miles`;;
                segments.push(segment);
            });
        }

        return segments;
    };

    function updateSource (sources=[]) {
        var sourceFeatures = {};
        var unsourceFeatures = [];
        var textSource = geoflo.map.getSource(geoflo.statics.constants.sources.COLDTEXT);
        var coldSource = geoflo.map.getSource(geoflo.statics.constants.sources.COLD);

        geoflo.updatingSource = true;

        textSource ? textSource.setData(turf.featureCollection([])) : false;
        coldSource ? coldSource.setData(turf.featureCollection([])) : false;

        geoflo.map.getSource(geoflo.statics.constants.sources.SELECT).setData(turf.featureCollection([]));

        coldFeatures.forEach((feature) => {
            delete feature.properties.new;
            delete feature.properties.offset;

            var source = feature.source;
            if (sources.length && !sources.includes(source)) return;
            if (!source) return unsourceFeatures.push(feature);
            if (!sourceFeatures[source]) sourceFeatures[source] = [];
            sourceFeatures[source].push(feature);
        })

        if (!coldFeatures.length) {
            geoflo.Layers.getCustomLayers().forEach((layer) => {
                if (!layer.details || !layer.details.source) return;
                var source = layer.details.source;
                if (!geoflo.map.getSource(source)) return false;
                geoflo.map.getSource(source).setData(turf.featureCollection([]));
            })
        }

        Object.entries(sourceFeatures).forEach((entry) => {
            var source = entry[0];
            var features = entry[1];
            if (!geoflo.map.getSource(source)) return unsourceFeatures.push(features);
            setLineOffset(features, source);
        })

        setLineOffset(unsourceFeatures.flat(), geoflo.statics.constants.sources.COLD);
        setTimeout(() => {this.setFeaturesState(coldFeatures, { hidden: false }); }, 100);
        geoflo.fire('features.update', { features: coldFeatures });
        sourceFeatures = null;
        unsourceFeatures = null;
        geoflo.updatingSource = false;
        return coldFeatures;
    };

    function setLineText (segment) {
        segment = geoflo.Utilities.cloneDeep(segment);
        segment.properties.type = this.currentType;
        
        var text = turf.point(segment.geometry.coordinates[1]);
        var units = this.getUnits(segment);
        var unit = 'feet';

        units = this.convertUnits(segment, units, unit);

        text.properties.units = units;
        text.properties.unit = unit;
        text.properties.text = `${units} ${unit}`;
        text.properties.transform = 'uppercase';
        text.properties.anchor = 'bottom-left';

        this.textFeatures.push(text);
        return text;
    }

    function setLineOffset (features, source) {
        if (!features || !features.length || !source || !geoflo.map.getSource(source)) return false;
        if (!geoflo.options.offsetOverlappingLines) return geoflo.map.getSource(source).setData(turf.featureCollection(features));

        var mesh = new geoflo.Mesh(features, true);
        var offset = mesh.getFeatures();

        offset.forEach(function (feature) {
            var f = features.find(function (fe) { return fe.id === feature.parent });
            if (!f) return;
            feature.source = source;
            feature.properties.style = f.properties.style || feature.properties.style;
            setOverlapOffset(offset, feature)
        });

        geoflo.map.getSource(source).setData(turf.featureCollection(offset));
        geoflo.fire('features.offset', { features: features, offset: offset, source: source });

        mesh = null;
        offset = null;
    };

    function setOverlapOffset (features, feature) {
        if (!geoflo.options.offsetOverlappingLines) return false;
        if (!isPolyline(feature)) return false;
        if (feature.properties.offset) return false;

        var offset = 6;
        var overlaps = [];

        features.forEach(function (f) {
            if (!isPolyline(f)) return false;
            if (f.parent === feature.parent) return false;
            if (f.properties.offset) return false;

            var overlap = turf.booleanOverlap(f, feature) || turf.booleanWithin(f, feature);
            if (!overlap) return false;

            overlaps.push(f)
        }, this)

        overlaps.forEach(function (f) {
            f.properties.offset = offset;
            offset = offset * 2;
        }, this)
    };

    function setWithinOffset (features) {
        if (!geoflo.options.offsetOverlappingLines) return false;

        const adder = 4;
        const miles = 0.00189394; // 10 Feet
        const explode = turf.explode(turf.featureCollection(features))
        
        if (!explode || !explode.features.length) return;

        explode.features.forEach(function(feature) {
            if (feature.properties.offset) return false;

            var buffer = turf.buffer(feature, miles, {units: 'miles'});
            var within = turf.pointsWithinPolygon(explode, buffer);

            if (!within || !within.features.length) return;

            var offset = adder;

            within.features.forEach(function (f) {
                if (f.properties.id === feature.properties.id || f.properties.offset) return;
                f.properties.offset = offset;
                offset = offset + adder;
            })            
        })
    };

    function isPolyline (feature) {
        if (!feature) return false;
        let type = geoflo.Layers.getLayerType(feature.source);
        return turf.getType(feature) === 'LineString';
    };

    function isPolygon (feature) {
        if (!feature) return false;
        let type = geoflo.Layers.getLayerType(feature.source);
        return turf.getType(feature) === 'Polygon' || feature.properties.type === 'Polygon' || type === 'Polygon';
    };

    function isRectangle (feature) {
        if (!feature) return false;
        let type = geoflo.Layers.getLayerType(feature.source);
        return turf.getType(feature) === 'Polygon' && feature.properties.type === 'Rectangle' || type === 'Rectangle';
    };

    function isPoint (feature) {
        if (!feature) return false;
        let type = geoflo.Layers.getLayerType(feature.source);
        if (turf.getType(feature) === 'Point' && (!feature.properties.type || feature.properties.type === 'Circle')) return true;
        if (turf.getType(feature) === 'Point' && (type === 'Point' || type === 'Circle')) return true;
        return turf.getType(feature) === 'Point' && (feature.properties.type !== 'Text' && feature.properties.type !== 'Icon' && feature.properties.type !== 'Image');
    };

    function isText (feature) {
        if (!feature) return false;
        let type = geoflo.Layers.getLayerType(feature.source);
        if (type === 'Text') return true;
        return turf.getType(feature) === 'Point' && feature.properties.type === 'Text';
    };

    function isIcon (feature) {
        if (!feature) return false;
        let type = geoflo.Layers.getLayerType(feature.source);
        if (type === 'Icon') return true;
        return turf.getType(feature) === 'Point' && feature.properties.type === 'Icon';
    };

    function isImage (feature) {
        if (!feature) return false;
        let type = geoflo.Layers.getLayerType(feature.source);
        if (type === 'Image') return true;
        return turf.getType(feature) === 'Point' && feature.properties.type === 'Image';
    };

    function getType (feature) {
        if (!feature) return null;
        
        return isRectangle(feature) ? 'Rectangle' :
        isPolygon(feature) ? 'Polygon' :
        isPolyline(feature) ? 'Polyline' :
        isText(feature) ? 'Text' :
        isIcon(feature) ? 'Icon' :
        isImage(feature) ? 'Image' :
        isPoint(feature) ? 'Circle' :
        null;
    };
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Features);

/***/ }),

/***/ "./src/Gamepad.js":
/*!************************!*\
  !*** ./src/Gamepad.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Gamepad
 * @description This module provides the gamepad functionality for the Geoflo application. It allows users to interact with the map using a gamepad controller.
 * @param {Object} gamepad - The gamepad object to be initialized.
 * @param {Object} options - The options for gamepad initialization. Comes from geoFlo.options.gamepad.
 * @returns {Object} The current object instance.
 */
const Gamepad = function (gamepad) {
    const geoflo = this.geoflo;

    if (!supported()) throw new Error('Gamepads are not supported on your browser!');
    
    const control = this;

    this.options = geoflo.options.gamepad;

    const layout = {
        "select": 'Select',
        "start": 'Start',
        "power": 'Power',
        "button0": 'B',
        "button1": 'A',
        "button2": 'Y',
        "button3": 'X',
        "button4": 'BumpLeft',
        "button5": 'BumpRight',
        "button6": 'TrigLeft',
        "button7": 'TrigRight',
        "button8": 'Select',
        "button9": 'Start',
        "button10": 'JoyLeftClick',
        "button11": 'JoyRightClick',
        "button12": 'DpadUp',
        "button13": 'DpadDown',
        "button14": 'DpadLeft',
        "button15": 'DpadRight',
        "button16": 'Power',
        "button17": 'Misc',
        "up0": 'JoyLeftUp',
        "down0": 'JoyLeftDown',
        "right0": 'JoyLeftRight',
        "left0": 'JoyLeftLeft',
        "up1": 'JoyRightUp',
        "down1": 'JoyRightDown',
        "right1": 'JoyRightRight',
        "left1": 'JoyRightLeft',
        "l1": 'BumpLeft',
        "r1": 'BumpRight',
        "l2": 'TrigLeft',
        "r2": 'TrigRight'
    }


    function clamp(x, y) {
        let m = Math.sqrt(x*x + y*y); // Magnitude (length) of vector

        // If the length greater than 1, normalize it (set it to 1)
        if (m > 1) {
            x /= m;
            y /= m;
        }

        return [x, y];
    }

    function deadzone(x, y, deadzone=0.2) {
        let m = Math.sqrt(x*x + y*y);

        if (m < deadzone)
            return [0, 0];

        let over = m - deadzone;  // 0 -> 1 - DEADZONE
        let nover = over / (1 - deadzone);  // 0 -> 1

        let nx = x / m;
        let ny = y / m;

        return [nx * nover, ny * nover];
        
    }

    function request() {
        control.refresh();
        requestAnimationFrame(request);
    }

    function supported() {
        return (window.navigator.getGamepads && typeof window.navigator.getGamepads === 'function') ||
            (window.navigator.getGamepads && typeof window.navigator.webkitGetGamepads === 'function') ||
            false;
    }

    function qs(s, p) {
        if (p) {
            return p.querySelector(s);
        }
        return document.querySelector(s);
    }

    function on(eventName, callback) {
        return control.associateEvent(eventName, callback, 'action');
    }

    function after(eventName, callback) {
        return control.associateEvent(eventName, callback, 'after');
    }

    function before(eventName, callback) {
        return control.associateEvent(eventName, callback, 'before');
    }

    function addEventListeners(_this, gamepad) {
        if (!gamepad || !layout) return false;

        Object.entries(layout).forEach(function (entry) {
            var key = entry[0];
            var val = entry[1];

            before(key, function (value) { return _this.onEvent('press', key, val, value); });
            on(key, function (value) { return _this.onEvent('hold', key, val, value); });
            after(key, function (value) { return _this.onEvent('release', key, val, value); });
        })
    }

    function deepAssign(target, source, {isMutatingOk = false, isStrictlySafe = false} = {}) {
        target = isMutatingOk ? target : clone(target, isStrictlySafe);

        for (const [key, val] of Object.entries(source)) {
            if (val !== null && typeof val === `object`) {
                if (target[key] === undefined) {
                    target[key] = {};
                }
    
                target[key] = deepAssign(target[key], val, {isMutatingOk: true, isStrictlySafe});
            } else {
                target[key] = val;
            }
        }

        function clone(obj, isStrictlySafe = false) {
            try {
                return JSON.parse(JSON.stringify(obj));
            } catch(err) {
                if (isStrictlySafe) { throw new Error() }
                console.warn(`Unsafe clone of object`, obj);
                return {...obj};
            }
        }

        return target;
    }

    function calculateIntermediatePoint(point1, point2, perc) {
        var lat1 = degreesToRadians(point1[1]);
        var lng1 = degreesToRadians(point1[0]);
        var lat2 = degreesToRadians(point2[1]);
        var lng2 = degreesToRadians(point2[0]);

        var deltaLat = lat2 - lat1;
        var deltaLng = lng2 - lng1;
        
        var calcA = Math.sin(deltaLat / 2) * Math.sin(deltaLat / 2) + Math.cos(lat1) * Math.cos(lat2) * Math.sin(deltaLng / 2) * Math.sin(deltaLng / 2);
        var calcB = 2 * Math.atan2(Math.sqrt(calcA), Math.sqrt(1 - calcA));
        
        var A = Math.sin((1 - perc) * calcB) / Math.sin(calcB);
        var B = Math.sin(perc * calcB) / Math.sin(calcB);
        
        var x = A * Math.cos(lat1) * Math.cos(lng1) + B * Math.cos(lat2) * Math.cos(lng2);
        var y = A * Math.cos(lat1) * Math.sin(lng1) + B * Math.cos(lat2) * Math.sin(lng2);
        var z = A * Math.sin(lat1) + B * Math.sin(lat2);
        
        var lat3 = Math.atan2(z, Math.sqrt(x * x + y * y));
        var lng3 = Math.atan2(y, x);
        
        return [radiansToDegrees(lng3), radiansToDegrees(lat3)]
    }

    function pointAtPercent(p0, p1, percent) {
        var x;
        if (p0.x !== p1.x)
            x = p0.x + percent * (p1.x - p0.x);
        else
            x = p0.x;
    
        var y;
        if (p0.y !== p1.y)
            y = p0.y + percent * (p1.y - p0.y);
        else
            y = p0.y;
    
        var p = {
            x: x,
            y: y
        };
    
        return p;
    }

    function degreesToRadians(degrees) {
        return degrees * (Math.PI / 180);
    }
        
    function radiansToDegrees(radians) {
        return radians * (180 / Math.PI );
    }

    





	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name init
	 * @description This function initializes the gamepad with the specified options. It fires an event to notify the gamepad initialization, sets the gamepad, adds event listeners, and requests animation frame.
	 * @param {Object} gamepad - The gamepad object to be initialized.
	 * @param {Object} options - The options for gamepad initialization.
	 * @returns {Object} The current object instance.
	 */
    this.init = function (gamepad, options) {
        if (!gamepad) return false;
        if (!this.options.enable) return console.error('Gamepad option is not enabled!')
        geoflo.map.fire(geoflo.id + ':gamepad.init', { detail: { gamepad: gamepad } });
        this.setGamepad(gamepad);
        addEventListeners(this, this.gamepad);
        requestAnimationFrame(request);
        return this;
    }

	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name refresh
	 * @description Refreshes the gamepad state by checking button presses, axes values, and triggers.
	 * @params {void}
	 * @returns {void}
	 */
    this.refresh = function () {
        var gamepads = window.navigator.getGamepads();

        for (var i = 0; i < gamepads.length; i++) {
            var gamepad = gamepads[this.gamepad.id];
            var j;

            if (!gamepad || !gamepad.connected) { continue; }

            for (j = 0; j < gamepad.buttons.length; j++) {
                var button = gamepad.buttons[j];
                var value = button.value;
                var name = this.gamepad.layout[`button${j}`]

                if (button.pressed) {
                    if (!this.gamepad.pressed[name]) {
                        this.gamepad.pressed[name] = true;
                        this.gamepad.buttonActions[j].before ? this.gamepad.buttonActions[j].before(value) : false;
                    }

                    this.gamepad.buttonActions[j].action ? this.gamepad.buttonActions[j].action(value) : false;
                } else if (this.gamepad.pressed[name]) {
                    delete this.gamepad.pressed[name];
                    this.gamepad.buttonActions[j].after ? this.gamepad.buttonActions[j].after(value) : false;
                }
            }

            var axesBoxCount = ((gamepad.axes.length + 1) / 2)|0;
                
            for (j = 0; j < axesBoxCount; j++) {
                var valueX, valueY, value;
                var last_odd_axis = j == axesBoxCount - 1 && gamepad.axes.length % 2 == 1;

                valueX = gamepad.axes[j*2];
                valueY = last_odd_axis ? 0 : gamepad.axes[j*2 + 1];
                [valueX, valueY] = deadzone(valueX, valueY);    
                [valueX, valueY] = clamp(valueX, valueY);
                value = [Number(valueX.toFixed(2)), Number(valueY.toFixed(2))];

                const val = gamepad.axes[j + axesBoxCount].toFixed(4);
                const axe = Math.floor(j / 2);
                this.gamepad.axeValues[axe][j % 2] = val;

                var rightTrigger = value[0] >= this.options.joystick.min;
                var leftTrigger = value[0] <= -this.options.joystick.min;
                var upTrigger = value[1] <= -this.options.joystick.min;
                var downTrigger = value[1] >= this.options.joystick.min;

                this.trigger('right', rightTrigger, j, value);
                this.trigger('left', leftTrigger, j, value);
                this.trigger('down', downTrigger, j, value);
                this.trigger('up', upTrigger, j, value);
            }
        }
    }

	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name trigger
	 * @description This function handles triggering actions based on gamepad input. It checks if a specific button or axis is triggered and performs corresponding actions.
	 * @param {string} id - The identifier of the gamepad input.
	 * @param {boolean} triggered - Indicates if the input is triggered.
	 * @param {number} index - The index of the input.
	 * @param {number[]} value - The value of the input.
	 */
    this.trigger = function (id, triggered, index, value) {
        var actions = this.gamepad.axesActions;
        var name = this.gamepad.layout[`${id}${index}`];
        var pressed = this.gamepad.pressed

        if (triggered) {
            if (!pressed[name]) {
                pressed[name] = true;
                actions[index][id].before ? actions[index][id].before(value) : false
            }

            value = [this.options.joystick.max * value[0], this.options.joystick.max * value[1]]
            actions[index][id].action ? actions[index][id].action(value) : false;
        } else if (pressed[name]) {
            delete pressed[name];

            if (!pressed['JoyLeftUp'] && !pressed['JoyLeftDown'] && !pressed['JoyLeftLeft'] && !pressed['JoyLeftRight']) {
                actions[0][id].after ? actions[0][id].after(value) : false;
            }

            if (!pressed['JoyRightUp'] && !pressed['JoyRightDown'] && !pressed['JoyRightLeft'] && !pressed['JoyRightRight']) {
                actions[1][id].after ? actions[1][id].after(value) : false;
            }
        }
    }

    /**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name remove
	 * @description Disconnects and removes the gamepad object.
	 * @param {Object} gamepad - The gamepad object to be disconnected and removed.
	 * @returns {void}
	 */
    this.remove = function() {
        this.gamepad.disconnect ? this.gamepad.disconnect() : false;
        this.gamepad.remove ? this.gamepad.remove() : false;
        this.gamepad = null;
    }




	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name setMap
	 * @description This function updates the map properties using the handleMove function and sets the center, zoom, pitch, and bearing accordingly.
	 * @param {Function} handleMove - The function used to handle map movement.
	 * @returns {Object} The updated map object with new properties.
	 */
    this.setMap = function (handleMove) {
        const map = geoflo.map;
        const transform = map.transform;
        
        this.map = this.map || {
            center: map.getCenter(),
            zoom: map.getZoom(),
            pitch: map.getPitch(),
            bearing: map.getBearing()
        }
        
        var center = this.map.center.x ? this.map.center : this.map.center.lat ? this.map.center : new mapboxgl.LngLat(this.map.center[0], this.map.center[1])
        center = center.x ? transform.pointLocation(center) : center;

        transform.center = center;
        transform.bearing = this.map.bearing;
        transform.zoom = this.map.zoom;
        transform.pitch = this.map.pitch;

        map._update();

        if (this.options.crosshairs && geoflo.centerMarker) this.setMarker();
        if (handleMove) geoflo.currentMode.handleMove({ lngLat: !this.options.camera.free ? this.map.center : map.getCenter(), gamepad: this })
        return this.map;
    }

	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name setContainer
	 * @description Creates a new HTML element with the specified tag name and class name, appends it to a container if provided, and sets it as the container property of the current object.
	 * @param {string} tagName - The tag name of the HTML element to create.
	 * @param {string} className - The class name to assign to the created element (optional).
	 * @param {HTMLElement} container - The container element to append the created element to (optional).
	 * @returns {HTMLElement} The created HTML element.
	 */
	
    this.setContainer = function (tagName, className, container) {
        const el = window.document.createElement(tagName);
        if (className !== undefined) el.className = className;
        if (container) container.appendChild(el);
        this.container = el;
        return el;
    }

	/**
	 * @function
     * @memberof module:geoflo.Gamepad 
	 * @name setLocation
	 * @description This function updates the visibility, left, and top properties of the container element based on the provided value.
	 * @param {Array<number>} value - An array containing the x and y coordinates for the new location.
	 * @returns {DOMRect} The bounding rectangle of the container element after the location is set.
	 */
    this.setLocation = function (value) {
        this.container.style.visibility = this.options.debug ? 'visible' : 'hidden';
        this.container.style.left = (value[0] + 1) / 2 * 100 + '%';
        this.container.style.top = (value[1] + 1) / 2 * 100 + '%';
        return this.container.getBoundingClientRect();
    }

	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name setMarker
	 * @description Sets a marker on the map using the center coordinates provided by the context.
	 * @return {Object} Returns the marker object created on the map.
	 */
    this.setMarker = function () {
        return geoflo.setCenterMarker({ gamepad: true });
    }

	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name setGamepad
	 * @description Initializes a gamepad object with specific properties based on the provided gamepad input.
	 * @param {Object} gamepad - The gamepad object to be processed.
	 * @returns {Object} - The processed gamepad object with defined properties.
	 */
    this.setGamepad = function (gamepad) {
        var options = {
            type: gamepad.id,
            connected: gamepad.connected,
            id: gamepad.index,
            buttons: gamepad.buttons.length,
            layout: layout,
            axes: Math.floor(gamepad.axes.length / 2),
            axeValues: [],
            hapticActuator: null,
            vibrationMode: -1,
            vibration: false,
            mapping: gamepad.mapping,
            buttonActions: {},
            axesActions: {},
            pressed: {}
        }

        for (let x = 0; x < options.buttons; x++) {
            options.buttonActions[x] = () => ({ action: () => { }, after: () => { }, before: () => { } });
        }

        for (let x = 0; x < options.axes; x++) {
            options.axesActions[x] = {
                down: () => ({ action: () => { }, after: () => { }, before: () => { } }),
                left: () => ({ action: () => { }, after: () => { }, before: () => { } }),
                right: () => ({ action: () => { }, after: () => { }, before: () => { } }),
                up: () => ({ action: () => { }, after: () => { }, before: () => { } })
            };

            options.axeValues[x] = [0, 0];
        }

        if (gamepad.hapticActuators) {
            if (typeof gamepad.hapticActuators.pulse === 'function') {
                options.haptic = gamepad.hapticActuators;
                options.vibrationMode = 0;
                options.vibration = true;
            } else if (gamepad.hapticActuators[0] && typeof gamepad.hapticActuators[0].pulse === 'function') {
                options.haptic = gamepad.hapticActuators[0];
                options.vibrationMode = 0;
                options.vibration = true;
            }
        }
        
        if (gamepad.vibrationActuator) {
            if (typeof gamepad.vibrationActuator.playEffect === 'function') {
                options.haptic = gamepad.vibrationActuator;
                options.vibrationMode = 1;
                options.vibration = true;
            }
        }

        this.gamepad = options;
        this.hasJoysticks = options.axes > 0 && Object.values(this.gamepad.layout).map(function(m) { return m.includes('Joy') }).filter(function (b) { return b }).length > 0;
        return this.gamepad;
    }

	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name setCenter
	 * @description This function calculates the new center of the map based on the input values and gamepad controls. It handles both joystick and D-pad inputs to adjust the map center accordingly.
	 * @param {Object} value - The value used to calculate the new center of the map.
	 * @param {boolean} free - A boolean flag indicating if the map center should be set freely.
	 * @param {boolean} dpad - A boolean flag indicating if the D-pad controls are used for setting the map center.
	 * @returns {boolean} Returns true after setting the map center.
	 */
	
    this.setCenter = function (value, free, dpad) {
        var center = geoflo.map.getCenter();
        var pressed = this.gamepad.pressed;
        var type = this.hasJoysticks ? 'Joy' : 'Dpad';
        var diag = Object.keys(pressed).filter(function(p) { return p.includes(type) }).length > 1;
        
        var start = free || dpad ? center : false;
        start = geoflo.hotFeature && !start ? geoflo.lastMove || center : false;
        start = !start ? center : start;

        var end;
    
        if (dpad) {
            var bearing = this.map.bearing;
            bearing = pressed['Up'] ? bearing :
            pressed['Down'] ? bearing + 180 :
            pressed['Left'] ? bearing - 90 :
            pressed['Right'] ? bearing + 90 :
            bearing;

            var dest = turf.destination(turf.point(start), distance, bearing).geometry.coordinates;

            lngLats = free ? { lng: dest[1], lat: dest[0] } : dest;
        } else if (value) {
            var location = this.setLocation(value);
            var coords = location && location.x ? [location.x, location.y] : false;
            
            end = geoflo.map.unproject(coords);
            
            var percent = diag ? this.options.pan.speed / 2 : this.options.pan.speed;
            var mid = calculateIntermediatePoint([start.lng, start.lat], [end.lng, end.lat], percent)
            mid = geoflo.map.getPitch() > 60 ? calculateIntermediatePoint([start.lng, start.lat], [mid[0], mid[1]], 0.4) : mid;

            end = mid;
            geoflo.lastMove = end;
        } else {
            var coords = geoflo.hotFeature ? geoflo.hotFeature.geometry.coordinates : false;
            end = free ? geoflo.map.getCenter() :
            coords ? { lat: coords[coords.length-1][1], lng: coords[coords.length-1][0] } : geoflo.map.getCenter();
            geoflo.lastMove = false;
            this.setLocation([0, 0]);
        }

        this.map.center = end;
        return this.setMap(true);
    }
    
	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name setBearing
	 * @description This function updates the bearing of the map by adjusting it with the specified value and direction.
	 * @param {number | Array<number>} value - The value to adjust the bearing by. If dpad is false, it should be an array of numbers, otherwise a single number.
	 * @param {boolean} left - Indicates the direction of adjustment. If true, the bearing is decreased; otherwise, it is increased.
	 * @param {boolean} dpad - Specifies whether the value is coming from a dpad input.
	 * @returns {boolean} Returns the result of calling the setMap function after updating the bearing.
	 */
    this.setBearing = function (value, left, dpad) {
        var bearing = this.map.bearing;
        var bearingMulti = !dpad ? Math.abs(value[0]) : value;
    
        if (left) {
            bearing = bearing - (this.options.bearing.speed * bearingMulti)
        } else {
            bearing = bearing + (this.options.bearing.speed * bearingMulti)
        }

        this.map.bearing = bearing;
        return this.setMap();
    }
    
	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name setPitch
	 * @description This function adjusts the pitch of the map by a specified amount in the given direction.
	 * @param {number|Array<number>} value - The value or array of values to adjust the pitch by.
	 * @param {boolean} up - A boolean indicating whether the pitch should be increased (true) or decreased (false).
	 * @param {boolean} dpad - A boolean flag to determine if the value is coming from a D-pad input.
	 * @returns {boolean} Returns true if the map is successfully updated with the new pitch.
	 */
    this.setPitch = function (value, up, dpad) {
        var pitch = this.map.pitch;
        var pitchMulti = !dpad ? Math.abs(value[1]) : value;

        if (pitch < 0) pitch = 0;
        if (pitch > this.options.pitch.max) pitch = this.options.pitch.max;
    
        if (up) {
            pitch = pitch + (this.options.pitch.speed * pitchMulti);
        } else {
            pitch = pitch - (this.options.pitch.speed * pitchMulti);
        }
        
        this.map.pitch = pitch;
        return this.setMap();
    }
    
	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name setZoom
	 * @description This function adjusts the zoom level of a map based on the provided value and direction.
	 * @param {number} value - The amount by which to change the zoom level.
	 * @param {boolean} out - A flag indicating whether to zoom out (true) or zoom in (false).
	 * @param {boolean} dpad - A flag indicating the direction of the zoom change.
	 * @returns {boolean} - Returns the result of setting the map with the new zoom level.
	 */
    this.setZoom = function (value, out, dpad) {
        var zoom = this.map.zoom;
    
        if (out) {
            zoom = zoom - ( this.options.zoom.speed * Math.abs(value) )
        } else {
            zoom = zoom + ( this.options.zoom.speed * Math.abs(value) )
        }
        
        this.map.zoom = zoom;
        return this.setMap();
    }

	/**
	 * @function
     * @memberof module:geoflo.Gamepad
	 * @name setSpeed
	 * @description This function calculates the speed of panning based on the provided value and direction. It ensures that the speed falls within the specified minimum and maximum values.
	 * @param {number} value - The value that influences the speed of panning.
	 * @param {boolean} down - A boolean flag indicating the direction of panning (true for down, false for up).
	 * @returns {number} The updated speed of panning after applying the calculations.
	 */
    this.setSpeed = function (value, down) {
        var speed = this.options.pan.speed > this.options.pan.min ?
            this.options.pan.speed :
            this.options.pan.max && this.options.pan.speed > this.options.pan.max ?
            this.options.pan.min :
            this.options.pan.min;

        speed = down ? speed - this.options.pan.min : speed + this.options.pan.min;

        speed = speed < this.options.pan.min ? this.options.pan.min :
        this.options.pan.max && speed > this.options.pan.max ? this.options.pan.max :
        speed;

        return this.options.pan.speed = speed * Math.abs(value);
    }


	/**
	 * @function
     * @memberof module:geoflo.Gamepad associateEvent
	 * @name associateEvent
	 * @description This function allows the user to associate an event with a callback function for a specific button or axis on the gamepad.
	 * @param {string} eventName - The name of the event to associate with the callback function.
	 * @param {function} callback - The callback function to be executed when the event occurs.
	 * @param {string} type - The type of event (e.g., 'press', 'release') to associate with the callback function.
	 * @returns {object} The updated gamepad object with the associated event and callback function.
	 */
    this.associateEvent = function(eventName, callback, type) {
        if (eventName.match(/^button\d+$/)) {
            const buttonId = parseInt(eventName.match(/^button(\d+)$/)[1]);

            if (buttonId >= 0 && buttonId < this.gamepad.buttons) {
                this.gamepad.buttonActions[buttonId][type] = callback;
            } else {
                console.log(buttonId, 'This button is not on gamepad')
            }

        } else if (eventName === 'start') {
            this.gamepad.buttonActions[9][type] = callback;
        } else if (eventName === 'select') {
            this.gamepad.buttonActions[8][type] = callback;
        } else if (eventName === 'r1') {
            this.gamepad.buttonActions[5][type] = callback;
        } else if (eventName === 'r2') {
            this.gamepad.buttonActions[7][type] = callback;
        } else if (eventName === 'l1') {
            this.gamepad.buttonActions[4][type] = callback;
        } else if (eventName === 'l2') {
            this.gamepad.buttonActions[6][type] = callback;
        } else if (eventName === 'power') {
            if (this.gamepad.buttons >= 17) {
                this.gamepad.buttonActions[16][type] = callback;
            } else {
                error(MESSAGES.INVALID_BUTTON);
            }
        } else if (eventName.match(/^(up|down|left|right)(\d+)$/)) {
            const matches = eventName.match(/^(up|down|left|right)(\d+)$/);
            const direction = matches[1];
            const axe = parseInt(matches[2]);

            if (axe >= 0 && axe < this.gamepad.axes) {
                this.gamepad.axesActions[axe][direction][type] = callback;
            } else {
                error(MESSAGES.INVALID_BUTTON);
            }
        } else if (eventName.match(/^(up|down|left|right)$/)) {
            const direction = eventName.match(/^(up|down|left|right)$/)[1];
            this.gamepad.axesActions[0][direction][type] = callback;
        }

        return this.gamepad;
    }

    this.onInit = function (options) {
        this.initiated = true;
        this.setContainer('div', 'gamepad', geoflo.map.getContainer());
        this.setMarker();
        this.setMap();
    }

    this.onEvent = function (type, key, action, value) {
        var pressed = {[action]: true};
        var lngLat = this.options.camera.free ? geoflo.map.getCenter() : geoflo.lastMove ? geoflo.lastMove : geoflo.map.getCenter();

        var options = {
            name: action,
            type: type,
            key: key,
            value: value,
            mode: geoflo.currentMode,
            gamepad: this,
            lngLat: lngLat,
            geoflo: geoflo,
            originalEvent: {}
        }

        if (!this.initiated) this.onInit(options);

        geoflo.map.fire(geoflo.id + ':gamepad.' + type, { detail: options });

        if (pressed['JoyLeftUp'] || pressed['JoyLeftDown'] || pressed['JoyLeftLeft'] || pressed['JoyLeftRight']) this.options.mapping['JoyLeftMove'](options);
        if (pressed['JoyRightUp'] || pressed['JoyRightDown'] || pressed['JoyRightLeft'] || pressed['JoyRightRight']) this.options.mapping['JoyRightMove'](options);

        if (pressed['JoyLeftClick']) this.options.mapping['JoyLeftClick'](options);
        if (pressed['JoyRightClick']) this.options.mapping['JoyRightClick'](options);

        if (pressed['BumpLeft']) this.options.mapping['BumpLeft'](options);
        if (pressed['BumpRight']) this.options.mapping['BumpRight'](options);

        if (pressed['TrigLeft']) this.options.mapping['TrigLeft'](options);
        if (pressed['TrigRight']) this.options.mapping['TrigRight'](options);

        if (pressed['A']) this.options.mapping['A'](options);
        if (pressed['B']) this.options.mapping['B'](options);
        if (pressed['X']) this.options.mapping['X'](options);
        if (pressed['Y']) this.options.mapping['Y'](options);

        if (pressed['Start']) this.options.mapping['Start'](options);
        if (pressed['Select']) this.options.mapping['Select'](options);
        if (pressed['Power']) this.options.mapping['Power'](options);
        if (pressed['Home']) this.options.mapping['Home'](options);
        if (pressed['Misc']) this.options.mapping['Misc'](options);

        if (pressed['DpadUp']) this.options.mapping['DpadUp'](options);
        if (pressed['DpadDown']) this.options.mapping['DpadDown'](options);
        if (pressed['DpadLeft']) this.options.mapping['DpadLeft'](options);
        if (pressed['DpadRight']) this.options.mapping['DpadRight'](options);
    }

    this.onDisconnect = function (gamepad) {
        if (!gamepad || !this.gamepad) return false;
        if (this.gamepad.id !== gamepad.id) throw new Error('Gamepad id does not match!');
        this.gamepad.remove();
        this.gamepad = null;
    }


    this.init(gamepad);
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Gamepad);

/***/ }),

/***/ "./src/Layers.js":
/*!***********************!*\
  !*** ./src/Layers.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Layers
 * @description This module provides the layer functionality for the Geoflo application. It allows users to add, remove, and manipulate layers on the map.
 * @param {Object} options - The options object to configure the object.
 * @returns {Object} Returns the Layers object.
 */

const Layers = function () {
    const geoflo = this.geoflo;
    if (!geoflo.map) throw new Error('No map object provided!');

    const Layers = this;
    const map = geoflo.map;
    const id = geoflo.id;

    const layerTypes = {
        Polygon: ['-fill', '-border'],
        Polyline: ['-line', '-dash', '-buffer'],
        Point: ['-circle', '-icon', '-cluster-circle', '-cluster-icon', '-count-icon', '-count-text'],
        Image: ['-image'],
        All: ['-fill', '-border', '-line', '-dash', '-buffer', '-circle', '-icon', '-cluster-circle', '-cluster-icon', '-count-icon', '-count-text', '-image']
    }

    this.options = {};
    this.sources = [];
    this.layers = [];
    this._layers = [];
    this._sources = [];

	/** 
	 * @function
     * @memberof module:geoflo.Layers
	 * @name init
	 * @description Initializes the object with the provided options and refreshes it.
	 * @param {Object} options - The options object to configure the object.
	 * @returns {Object} The refreshed object with the updated options.
	 */
    this.init = function (options={}) {
        this.options = Object.assign(this.options, options);

        this.defaultLayers = [
            {
                source: geoflo.statics.constants.sources.COLD,
                id: id + '-fill-cold',
                type: 'fill',
                layout: {},
                filter: ["==", "$type", "Polygon"],
                paint: {
                    'fill-color': geoflo.options.colors.secondaryCold,
                    'fill-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 0.3]
                }
            },
            {
                source: geoflo.statics.constants.sources.COLD,
                id: id + '-line-cold',
                type: 'line',
                layout: {
                    'line-cap': 'round',
                    'line-join': 'miter'
                },
                paint: {
                    'line-color': geoflo.options.colors.primaryCold,
                    'line-width': 4,
                    'line-gap-width': ["match", ["get", "type"], "Polygon", 0, 0],
                    'line-offset': ['case', ["boolean", ["has", "offset"], true], ["get", "offset"], 0],
                    'line-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 1]
                }
            },
            {
                source: geoflo.statics.constants.sources.COLD,
                id: id + '-circle-cold',
                filter: ['all', ['==', ['get', 'type'], 'Circle'], ["!=", ["geometry-type"], "Polygon"] ],
                type: 'circle',
                paint: {
                    'circle-radius': { 'base': 6, 'stops': [[10, 8], [14, 10]] },
                    'circle-stroke-width': 1,
                    'circle-color': geoflo.options.colors.primaryCold,
                    'circle-stroke-color': geoflo.options.colors.secondaryCold,
                    'circle-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 1],
                    'circle-stroke-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 1]
                }
            },
            {
                source: geoflo.statics.constants.sources.COLD,
                id: id + '-icon-cold',
                type: 'symbol',
                filter: ['==', ['get', 'type'], 'Icon'],
                layout: {
                    'visibility': 'visible',
                    'icon-optional': true,
                    'text-field': ['get', 'primaryIcon', ['get','style', ['properties']]],
                    'text-size': {
                        'base': 16,
                        'stops': [[10, 16], [14, 12]]
                    },
                    'text-line-height': 1,
                    'text-padding': 0,
                    'text-offset': [0, 0.2],
                    'text-justify': 'auto',
                    'text-anchor': 'center',
                    'text-allow-overlap': true,
                    'text-font': ['Font Awesome 6 Pro Solid'],
                    'text-ignore-placement': true
                },
                paint: {
                    'text-translate-anchor': 'viewport',
                    'text-halo-width': 0,
                    'text-halo-color': geoflo.options.colors.primaryCold,
                    'text-color': geoflo.options.colors.secondaryBackground,
                    'text-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 1]
                }
            },
            {
                source: geoflo.statics.constants.sources.COLD,
                id: id + '-text-cold',
                type: 'symbol',
                filter: ["==", "$type", "Point"],
                layout: {
                    "symbol-placement": "point",
                    'text-field': ['get', 'text'],
                    'text-font': ['DIN Pro Regular', 'DIN Pro Italic', 'Arial Unicode MS Regular', 'DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                    'text-keep-upright': true,
                    'text-size': 18,
                    'text-justify': ['get', 'justify'],
                    'text-letter-spacing': 0.05,
                    'text-line-height': 1.2,
                    'text-max-angle': 10,
                    'text-offset': [0,0],
                    'text-padding': 2,
                    'text-rotate': 0,
                    'text-transform': ['get', 'transform']
                },
                paint: {
                    'text-color': geoflo.options.colors.primaryCold,
                    'text-halo-color': geoflo.options.colors.primaryBackground,
                    'text-halo-width': 0.5,
                    'text-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 1]
                }
            },
            {
                source: geoflo.statics.constants.sources.COLD,
                id: id + '-text-icon-cold',
                type: 'symbol',
                filter: ['==', ['get', 'type'], 'Text'],
                layout: {
                    'visibility': 'visible',
                    'icon-optional': true,
                    'text-field': ['get', 'primaryIcon', ['get','style', ['properties']]],
                    'text-size': {
                        'base': 16,
                        'stops': [[10, 16], [14, 12]]
                    },
                    'text-line-height': 1,
                    'text-padding': 0,
                    'text-offset': [0, 0.2],
                    'text-justify': 'auto',
                    'text-anchor': 'center',
                    'text-allow-overlap': true,
                    'text-font': ['Font Awesome 6 Pro Solid'],
                    'text-ignore-placement': true
                },
                paint: {
                    'text-translate-anchor': 'viewport',
                    'text-halo-width': 0,
                    'text-halo-color': geoflo.options.colors.primaryCold,
                    'text-color': geoflo.options.colors.secondaryBackground,
                    'text-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 1]
                }
            },
            {
                id: geoflo.statics.constants.layers.MESH + '-line',
                source: geoflo.statics.constants.sources.MESH,
                type: "line",
                paint: {
                    "line-color": geoflo.options.colors.primaryBase,
                    "line-width": 2,
                    "line-opacity": 0.3
                }
            },
            {
                id: geoflo.statics.constants.layers.MESH + '-circle',
                source: geoflo.statics.constants.sources.MESH,
                type: 'circle',
                paint: {
                    'circle-radius': 2,
                    'circle-color': geoflo.options.colors.primaryBase,
                    'circle-opacity': 0.3
                }
            },
            {
                source: geoflo.statics.constants.sources.HOT,
                id: id + '-fill-hot',
                type: 'fill',
                layout: {},
                filter: ["==", "$type", "Polygon"],
                paint: {
                    'fill-color': geoflo.options.colors.secondaryHot,
                    'fill-opacity': ['case', ["boolean", ["has", "new"], true], 0.5, 0.1],
                }
            },
            {
                'source': geoflo.statics.constants.sources.HOT,
                'id': id + '-line-hot',
                'type': 'line',
                'layout': {
                    'line-cap': 'round',
                    'line-join': 'round'
                },
                'paint': {
                    'line-color': geoflo.options.colors.primaryHot,
                    'line-width': 4,
                    'line-dasharray': [1,2],
                }
            },
            {
                'source': geoflo.statics.constants.sources.HOT,
                'id': id + '-point-hot',
                'filter': ['==', '$type', 'Point'],
                'type': 'circle',
                //'filter': ["==", 0, ['number', ['get', 'painting']]],
                'paint': {
                    'circle-radius': ["match", ["get", "type"], "Circle", 8, 4],
                    'circle-stroke-width': 1,
                    'circle-color': geoflo.options.colors.primaryHot,
                    'circle-stroke-color': geoflo.options.colors.secondaryHot
                }
            },
            {
                source: geoflo.statics.constants.sources.HOT,
                id: id + '-icon-hot',
                filter: ['==', ['get', 'type'], 'Icon'],
                type: 'symbol',
                layout: {
                    'visibility': 'visible',
                    'icon-optional': true,
                    'text-field': ['get', 'primaryIcon', ['get','style', ['properties']]],
                    'text-size': {
                        'base': 16,
                        'stops': [[10, 16], [14, 12]]
                    },
                    'text-line-height': 1,
                    'text-padding': 0,
                    'text-offset': [0, 0.2],
                    'text-justify': 'auto',
                    'text-anchor': 'center',
                    'text-allow-overlap': true,
                    'text-font': ['Font Awesome 6 Pro Solid'],
                    'text-ignore-placement': true
                },
                paint: {
                    'text-translate-anchor': 'viewport',
                    'text-halo-color': geoflo.options.colors.primaryHot,
                    'text-halo-width': 0, //[ 'case', ['boolean', ['feature-state', 'hover'], false], 0.5, 0 ],
                    'text-color': geoflo.options.colors.secondaryHot
                }
            },
            {
                source: geoflo.statics.constants.sources.HOT,
                id: id + '-image-hot',
                filter: ['==', ['get', 'type'], 'Image'],
                type: 'symbol',
                layout: {
                    'visibility': 'visible',
                    'icon-image': ['get', 'primaryImage', ['get','style', ['properties']]],
                    'icon-size': ['interpolate', ['linear'], ['zoom'], 1, 0.4, 15, 1],
                    'icon-allow-overlap': true,
                    'icon-anchor': 'bottom'
                }
            },
            {
                'source': geoflo.statics.constants.sources.HOTTEXT,
                'id': id + '-text-hot',
                'type': 'symbol',
                'layout': {
                    'symbol-placement': 'point',
                    'text-field': ['get', 'text'],
                    'text-font': ['Arial Unicode MS Regular', 'DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                    'text-keep-upright': true,
                    'text-anchor': ['get','anchor'],
                    'text-size': 18,
                    'text-justify': ['get','justify'],
                    'text-letter-spacing': 0.1,
                    'text-line-height': 1.2,
                    'text-max-angle': 10,
                    'text-offset': [0, -1.5],
                    'text-padding': 2,
                    'text-rotate': 0,
                    'text-transform': ['get', 'transform']
                },
                'paint': {
                    'text-color': geoflo.options.colors.primaryText,
                    'text-halo-color': geoflo.options.colors.primaryBackground,
                    'text-halo-width': 1,
                    'text-opacity': 1,
                }
            },
            {
                'source': geoflo.statics.constants.sources.SNAP,
                'id': id + '-point-snap',
                'type': 'circle',
                'filter': ['==', '$type', 'Point'],
                'paint': {
                    'circle-radius': ["match", ["get", "type"], "Circle", 6, "Icon", 0, 6],
                    'circle-stroke-width': 2,
                    'circle-color': geoflo.options.colors.primarySnap,
                    'circle-stroke-color': geoflo.options.colors.secondarySnap
                }
            },
            {
                source: geoflo.statics.constants.sources.SNAP,
                id: id + '-icon-snap',
                type: 'symbol',
                filter: ['==', ['get', 'type'], 'Icon'],
                layout: {
                    'visibility': 'visible',
                    'icon-optional': true,
                    'text-field': ['get', 'primaryIcon', ['get','style', ['properties']]],
                    'text-size': {
                        'base': 18,
                        'stops': [[10, 18], [14, 16]]
                    },
                    'text-line-height': 1,
                    'text-padding': 0,
                    'text-offset': [0,0.2],
                    'text-justify': 'auto',
                    'text-anchor': 'center',
                    'text-allow-overlap': true,
                    'text-font': ['Font Awesome 6 Pro Solid'],
                    'text-ignore-placement': true
                },
                paint: {
                    'text-translate-anchor': 'viewport',
                    'text-halo-color': geoflo.options.colors.primarySnap,
                    'text-halo-width': 0, //[ 'case', ['boolean', ['feature-state', 'hover'], false], 0.5, 0 ],
                    'text-color': geoflo.options.colors.secondarySnap
                }
            },
            {
                source: geoflo.statics.constants.sources.SNAP,
                id: id + '-image-snap',
                filter: ['==', ['get', 'type'], 'Image'],
                type: 'symbol',
                layout: {
                    'visibility': 'visible',
                    'icon-image': ['get', 'primaryImage', ['get','style', ['properties']]],
                    'icon-size': ['interpolate', ['linear'], ['zoom'], 1, 0.4, 15, 1],
                    'icon-allow-overlap': true,
                    'icon-anchor': 'bottom'
                }
            },
            {
                'source': geoflo.statics.constants.sources.SNAP,
                'id': id + '-line-snap',
                'type': 'line',
                //'filter': ["==", "$type", "LineString"],
                'layout': {
                    'visibility': 'visible',
                    'line-cap': 'round',
                    'line-join': 'round'
                },
                'paint': {
                    'line-color': geoflo.options.colors.secondarySnap,
                    'line-width': 4,
                    'line-dasharray':[1,2]
                }
            },
            {
                'source': geoflo.statics.constants.sources.ROUTE,
                'id': id + '-line-route',
                'type': 'line',
                'filter': ["==", "$type", "LineString"],
                'layout': {
                    'visibility': 'visible',
                    'line-cap': 'round',
                    'line-join': 'round'
                },
                'paint': {
                    'line-color': geoflo.options.colors.error,
                    'line-width': 4,
                    'line-dasharray':[]
                }
            },
            {
                'source': geoflo.statics.constants.sources.VERTEX,
                'id': id + '-point-vertex',
                'type': 'circle',
                'filter': ['==', "$type", 'LineString'],
                'paint': {
                    'circle-radius': 4,
                    'circle-stroke-width': 3,
                    'circle-color': geoflo.options.colors.primaryVertex,
                    'circle-stroke-color': geoflo.options.colors.secondaryVertex
                }
            },
            {
                'source': geoflo.statics.constants.sources.GAMEPAD,
                'id': id + '-gamepad',
                'type': 'symbol',
                'layout': {
                    'visibility': 'visible',
                    'icon-image': 'gamepad',
                    'icon-size': 0.25
                }
            }
        ]
    
        this.selectLayers = [{
            'source': geoflo.statics.constants.sources.SELECT,
            'id': id + '-line-select',
            'type': 'line',
            'layout': {
                'visibility': 'visible',
                'line-cap': 'round',
                'line-join': 'round'
            },
            'paint': {
                'line-color': geoflo.options.colors.secondarySelect,
                'line-width': 4,
            },
            'metadata': { types: ['Polyline', 'Polygon', 'Rectangle'] }
        },
        {
            'source': geoflo.statics.constants.sources.SELECT,
            'id': id + '-fill-select',
            'type': 'fill',
            'layout': {},
            'filter': ["==", "$type", "Polygon"],
            'paint': {
                'fill-color': geoflo.options.colors.primarySelect,
                'fill-opacity': 0.4
            },
            'metadata': { types: ['Polygon', 'Rectangle'] }
        },
        {
            'source': geoflo.statics.constants.sources.SELECT,
            'id': id + '-point-select',
            'filter': ['all', ['!=', ['get', 'type'], 'Text'], ["==", ["geometry-type"], "Point"] ],
            'type': 'circle',
            'layout': {
                'visibility': 'visible',
            },
            'paint': {
                'circle-radius': 12,
                'circle-stroke-width': 3,
                'circle-color': geoflo.options.colors.primarySelect,
                'circle-stroke-color': geoflo.options.colors.secondarySelect,
                'circle-stroke-opacity': 1,
                'circle-opacity': 0.8
            },
            'metadata': { types: ['Point', 'Circle', 'Marker', 'Icon'] }
        },
        {
            'source': geoflo.statics.constants.sources.SELECT,
            'id': id + '-symbol-select',
            'filter': ['==', ['get', 'type'], 'Icon'],
            'type': 'symbol',
            'layout': {
                'visibility': 'visible',
                'icon-optional': true,
                'symbol-placement': 'point',
                'text-rotation-alignment': 'viewport',
                'text-field': ['get', 'primaryIcon', ['get','style', ['properties']]],
                'text-rotate': ['get', 'rotate', ['get','style', ['properties']]],
                'text-size': 14,
                'text-line-height': 1,
                'text-padding': 0,
                'text-offset': [0, 0.2],
                'text-justify': 'auto',
                'text-anchor': 'center',
                'text-allow-overlap': true,
                'text-font': ['Font Awesome 6 Pro Solid'],
                'text-ignore-placement': true
            },
            'paint': {
                'text-translate-anchor': 'viewport',
                'text-halo-color': geoflo.options.colors.secondarySelect,
                'text-halo-width': 2,
                'text-color': geoflo.options.colors.primaryBackground,
            },
            'metadata': { types: ['Icon'] }
        },
        {
            'source': geoflo.statics.constants.sources.SELECT,
            'id': id + '-text-select',
            'filter': ['==', ['get', 'type'], 'Text'],
            'type': 'symbol',
            'layout': {
                'visibility': 'visible',
                "symbol-placement": "point",
                'text-rotation-alignment': 'viewport',
                'text-field': ['get', 'text'],
                'text-font': ['DIN Pro Regular', 'DIN Pro Italic', 'Arial Unicode MS Regular', 'DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                'text-keep-upright': true,
                'text-allow-overlap': true,
                'text-size': 18,
                'text-justify': ['get', 'justify'],
                'text-letter-spacing': 0.12,
                'text-line-height': 1.2,
                'text-max-angle': 10,
                'text-offset': [0,1.5],
                'text-padding': 2,
                'text-rotate': 0,
                'text-transform': ['get', 'transform']
            },
            'paint': {
                'text-color': geoflo.options.colors.primaryBackground,
                'text-halo-color': geoflo.options.colors.primaryColor,
                'text-halo-width': 2,
                'text-opacity': 1,
            },
            'metadata': { types: ['Text'] }
        },
        {
            'source': geoflo.statics.constants.sources.SELECT,
            'id': id + '-image-select',
            'filter': ['==', ['get', 'type'], 'Image'],
            'type': 'symbol',
            'layout': {
                'visibility': 'visible',
                'icon-image': ['get', 'primaryImage', ['get','style', ['properties']]],
                'icon-size': ['interpolate', ['linear'], ['zoom'], 1, 0.4, 15, 1],
                'icon-allow-overlap': true,
                'icon-anchor': 'bottom'
            },
            'metadata': { types: ['Image'] }
        }]

        return this.refresh({ init: true });
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name refresh
	 * @description This function refreshes the map by removing existing layers and sources, adding default layers and sources, and rebuilding the layers.
	 * @param {Object} options - Optional parameter for additional options.
	 * @returns {Array} - An array of layers after the refresh operation.
	 */
    this.refresh = async function (options={}) {
        if (options.select) return geoflo.Layers.moveLayers(this.selectLayers);
        if (!options.init) return this.init(options);
        
        var layers = geoflo.Utilities.cloneDeep(this._layers);

        this._layers = [];
        this._sources = [];

        this.removeEventListeners();
        this.removeLayers(this.defaultLayers);
        this.removeLayers(this.selectLayers);
        this.removeSources(Object.values(geoflo.statics.constants.sources));

        this.addEventListeners();
        this.addSources(Object.values(geoflo.statics.constants.sources));
        this.addLayers(this.defaultLayers, this.options);
        await buildLayers.call(this, layers);
        this.addLayers(this.selectLayers, this.options);

        setTimeout(function() { geoflo.Layers.moveLayers(this.selectLayers); }, 250);
        return this.getLayers();
    }




	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name setCustomLayers
	 * @description This function takes an array of custom layers and options, builds the layers using the buildLayers function, and returns the resulting layers.
	 * @param {Array} layers - An array of custom layers to be processed.
	 * @param {Object} options - Additional options for building the layers.
	 * @returns {Promise<Array>} The processed custom layers.
	 */
    this.setCustomLayers = async function (layers, options) {
        if (!layers) return [];
        return await buildLayers.call(this, layers, options);
    }


	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getCustomLayers
	 * @description Retrieves the custom layers stored in the object.
	 * @returns {Array} An array containing the custom layers.
	 */
    this.getCustomLayers = function () {
        return this._layers;
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name hasCustomLayers
	 * @description This function determines if there are any custom layers present in the application.
	 * @returns {number} The number of custom layers available.
	 */
    this.hasCustomLayers = function () {
        return this.getCustomLayers().length;
    }

    


	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getFeatures
	 * @description Retrieves the features from a source based on the provided ID.
	 * @param {string} id - The ID of the source to retrieve features from.
	 * @returns {Array} An array of features from the specified source, or an empty array if the source or features are not found.
	 */
    this.getFeatures = function (id) {
        var source = this.getSource(id);
        if (!source || !source._data) return [];
        return source._data.features;
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getSelection
	 * @description This function determines the selected feature based on the provided features array and coordinates.
	 * @param {Array} features - An array of features to select from.
	 * @param {Object} coords - The coordinates of the selected feature.
	 * @returns {boolean} Returns true if a feature is selected, false otherwise.
	 */
    this.getSelection = function (features=[], coords) {
        var feature = features && features.length ? features[0] : false;
        if (!feature) return false;
        if (feature.properties.cluster) return Layers.onClusterClick(feature, coords), false;
        return true;
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getType
	 * @description This function takes a geometry type as input and returns the corresponding general type (Polygon, Polyline, or Point).
	 * @param {string} type - The type of geometry to be evaluated.
	 * @returns {string|boolean} Returns the general type of the geometry (Polygon, Polyline, Point) or false if the type is not recognized.
	 */
    this.getType = function (type) {
        return type === 'Polygon' || type === 'Rectangle' ? 'Polygon' :
        type === 'Polyline' || type === 'LineString' || type === 'Line' ? 'Polyline' :
        type === 'Point' || type === 'Circle' || type === 'Marker' || type === 'Icon' || type === 'Text' ? 'Point' :
        type === 'Image' ? 'Image' :
        false;
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getSources
	 * @description Retrieves the sources stored in the object.
	 * @returns {Array} An array containing the sources.
	 */
    this.getSources = function () {
        return this.sources;
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getSource
	 * @description Retrieves a specific source object by its ID from the list of sources.
	 * @param {string} id - The ID of the source to retrieve.
	 * @returns {object|boolean} The source object with the specified ID if found, otherwise false.
	 */
    this.getSource = function (id) {
        if (!id) return false;
        var sources = this.getSources();
        return sources.find(function(source) { return source.id === id })
    }

	/** 
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getSourceIds
	 * @description Retrieves the IDs of all sources.
	 * @returns {Array} An array of source IDs.
	 */
    this.getSourceIds = function () {
        return this.getSources().map(function (s) { return s.id });
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getLayers
	 * @description Retrieves the layers array from the object.
	 * @returns {Array} The layers array.
	 */
    this.getLayers = function () {
        return this.layers;
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getLayer
	 * @description Retrieves a layer based on the provided ID or source ID.
	 * @param {string} id - The ID of the layer to retrieve.
	 * @returns {object|boolean} The layer object if found, or false if not found.
	 */
    this.getLayer = function (id, custom) {
        if (!id) return false;
        var layers = custom ? this.getCustomLayers() : this.getLayers();
        var layer = layers.find(function(layer) { return layer.id === id });
        if (!layer) layer = layers.filter(function(layer) { return layer.source === id });
        return layer;
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name getLayerIds
	 * @description Retrieves the IDs of the layers provided or the default layers if none are provided.
	 * @param {Array} layers - An array of layer objects.
	 * @returns {Array} An array of layer IDs.
	 */
    this.getLayerIds = function (layers) {
        var _layers = layers || this.getCustomLayers();
        return _layers.map(function (l) { return l.id });
    }

    this.getLayerType = function (id) {
        let type = '';
        const layer = this.getLayer(id, true);
        if (layer && layer.details) type = layer.details.type;
        return type;
    }



    

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name addSources
	 * @description Adds multiple sources to the context with the given options.
	 * @param {Array} sources - An array of sources to be added.
	 * @param {Object} options - Additional options for adding the sources.
	 * @returns {Array} - An array of all the added sources.
	 */
    this.addSources = function (sources=[], options={}) {
        sources.forEach(function(source) { this.addSource(source, false, options) }, this);
        geoflo.fire('sources.add', { sources: this.getSources() });
        return this.getSources();
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name addSource
	 * @description This function adds a new source to the map using the provided ID and type. It also accepts optional configuration options for the source.
	 * @param {string} id - The unique identifier for the source.
	 * @param {string} type - The type of the source (e.g., 'geojson', 'vector', 'raster', etc.).
	 * @param {Object} [options={}] - Additional configuration options for the source (e.g., features, promoteId, clusterMaxZoom, clusterRadius).
	 * @returns {Object} The newly added source object.
	 */
    this.addSource = function (id, type, options={}) {
        if (!id) throw new Error('No source was provided!');
        
        var opts = { type: options.type || "geojson", data: turf.featureCollection(options.features || []), promoteId: options.promoteId || 'id' };
        if (type && type === 'Point' && !options.noCluster) { opts = Object.assign(opts, { cluster: true, clusterMaxZoom: options.clusterMaxZoom || 14, clusterRadius: options.clusterRadius || 50 }) }

        map.addSource(id, opts);
        this.sources.push(map.getSource(id));
        geoflo.fire('source.add', { id: id, source: this.getSource(id) })
        return this.getSource(id);
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name addLayers
	 * @description Adds multiple layers to the map.
	 * @param {Array} layers - An array of layers to be added to the map.
	 * @param {Object} options - Additional options for adding the layers.
	 * @returns {Array} - An array of layers that have been added to the map.
	 */
    this.addLayers = function (layers=[], options={}) {
        layers.forEach(function(layer, index) { this.addLayer(layer, options, index) }, this);
        geoflo.fire('layers.add', { layers: this.getLayers() });
        buildEvents.call(this);
        return this.getLayers();
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name addLayer
	 * @description This function adds a layer to the map with the provided options. It also updates the layer's metadata, adds the layer to the map, and pushes the layer to the layers array. It triggers a 'layer.add' event and returns the added layer.
	 * @param {Object} layer - The layer object to be added to the map.
	 * @param {Object} [options={}] - Additional options for the layer.
	 * @returns {Object} The added layer.
	 */
    this.addLayer = function (layer, options={}, index) {
        if (!layer || !layer.id) return false;        
        layer.metadata = layer.metadata || options;

        if (map.getLayer(layer.id)) {
            if (!this.layers.find(function(l) { return l.id === layer.id })) this.layers.push(layer);
            return this.getLayer(layer.id);
        }

        map.addLayer(layer);

        layer = map.getLayer(layer.id);
        if (!layer) return console.error(id, 'Layer Not Added!');

        this.layers.push(layer);
        geoflo.fire('layer.add', { id: layer.id, layer: this.getLayer(layer.id) });
        return this.getLayer(layer.id);
    }

    this.addTextLayer = function (options={}) {
        var layers = options.select ? this.getLayer(geoflo.statics.constants.sources.SELECT) : this.getCustomLayers();
        var field = options.field || 'text';

        this.removeTextLayer(options);

        layers.forEach(function(layer) {
            var id = layer.id + '-Text';

            var filter = ['all', ['==', ["geometry-type"], 'Point'], ["has", field] ];
            if (options.filter) filter = options.filter;
            if (!options.select && options.ids) filter = ['in', 'id', ...options.ids];

            var layout = Object.assign({}, {
                'visibility': 'visible',
                'symbol-placement': 'point',
                'text-rotation-alignment': 'viewport',
                'text-field': ['get', field],
                'text-keep-upright': true,
                'text-allow-overlap': true,
                'text-anchor': 'top',
                'text-size': 12,
                'text-justify': 'center',
                'text-letter-spacing': 0.25,
                'text-line-height': 1.2,
                'text-max-angle': 10,
                'text-offset': [0, 0.5],
                'text-padding': 2,
                'text-rotate': 0,
                'text-transform': 'none',
                'text-font': ['Arial Unicode MS Regular', 'DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                'text-ignore-placement': false,
                'text-max-width': 15
            }, layer.text ? layer.text.layout || {} : {}, options.layout);

            var paint = Object.assign({}, {
                'text-translate-anchor': 'viewport',
                'text-halo-color': ['get', 'primaryColor', ['get','style', ['properties']]],
                'text-halo-width': 1.2,
                'text-color': ['get', 'secondaryColor', ['get','style', ['properties']]],
                'text-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, ['get', 'opacity', ['get','style', ['properties']]]]
            }, layer.text ? layer.text.paint || {} : {}, options.paint);

            var style = {
                id: id,
                type: 'symbol',
                source: layer.source || layer.details.source || id,
                slot: 'top',
                filter: filter,
                layout: layout,
                paint: paint,
                metadata: { text: true, name: id }
            }
            
            if (!map.getLayer(id)) map.addLayer(style);
            this.layers.push(map.getLayer(id));
        }, this);

        this.showTextLayers = true;
    }





	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name removeSources
	 * @description Removes sources from the map.
	 * @param {Array} sources - An array of source IDs to be removed. If not provided, it defaults to all source IDs.
	 * @returns {void}
	 */
    this.removeSources = function (sources) {
        sources = sources || this.getSourceIds();
        sources.forEach(function(id) { this.removeSource(id) }, this);
        geoflo.fire('sources.remove', { removed: true })
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name removeSource
	 * @description This function removes a source from the map and the internal sources array based on the provided id.
	 * @param {string} id - The id of the source to be removed.
	 * @returns {string} The id of the removed source.
	 */
    this.removeSource = function (id) {
        if (!id) return false;
        if (map.getSource(id)) map.removeSource(id);

        var index = -1;
        index = this.sources.findIndex(function(l) { return l.id === id });
        if (index > -1) this.sources.splice(index, 1);
        
        geoflo.fire('source.remove', { removed: id });
        return id;
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name removeLayers
	 * @description Removes multiple layers from the context.
	 * @param {Array} layers - An array of layer objects to be removed.
	 * @returns {Array} - An array of IDs of the removed layers.
	 */
    this.removeLayers = function (layers) {
        var ids = this.getLayerIds(layers);
        this.removeTextLayer();
        ids.forEach(function(id) { this.removeLayer(id) }, this);
        geoflo.fire('layers.remove', { removed: ids });
        return ids;
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name removeLayer
	 * @description This function removes a layer from the map and the layers array based on the provided id.
	 * @param {string} id - The id of the layer to be removed.
	 * @returns {string} The id of the removed layer.
	 */
    this.removeLayer = function (id) {
        if (!id) return false;
        if (map.getLayer(id)) map.removeLayer(id);

        var index = -1;
        index = this.layers.findIndex(function(l) { return l.id === id });
        if (index > -1) this.layers.splice(index, 1);

        geoflo.fire('layer.remove', { removed: id });
        return id;
    }

    this.removeTextLayer = function (options={}) {
        var layers = this.getLayers();
        layers.forEach(function(layer) { if (layer.metadata.text && map.getLayer(layer.id)) map.removeLayer(layer.id) }, this);
        this.showTextLayers = false;
    }



	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name moveLayers
	 * @description Moves the specified layers on the map.
	 * @param {Array} layers - An array of layer objects to be moved on the map.
	 * @returns {void}
	 */
    this.moveLayers = function (layers) {
        layers = !layers ? this.defaultLayers || [] : layers;
        layers.forEach(function (layer) { if (geoflo.map.getLayer(layer.id)) geoflo.map.moveLayer(layer.id) })
    }



	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name addEventListeners
	 * @description Attaches event listeners based on the provided options.
	 * @param {Object} options - An object containing configuration options for event listeners.
	 * @returns {Object} - The result of the buildEvents function with the provided options.
	 */
    this.addEventListeners = function (options={}) {
        return buildEvents.call(this, { on: true })
    }

	/**
	 * @function
     * @memberof module:geoflo.Layers
	 * @name removeEventListeners
	 * @description Removes event listeners from the element.
	 * @param {Object} options - An object containing options for removing event listeners.
	 * @param {boolean} options.off - A boolean flag to indicate whether to turn off event listeners.
	 * @returns {void}
	 */
    this.removeEventListeners = function (options={}) {
        return buildEvents.call(this, { off: true })
    }

    /**
     * @function
     * @name onClusterClick
     * @memberof module:geoflo.Layers
     * @description Handles the click event on a cluster feature, expanding the cluster if applicable.
     *
     * @param {Object} feature - The cluster feature that was clicked.
     * @returns {boolean} Returns false if the feature does not have a source; otherwise, it performs an action without returning a value.
     */
    this.onClusterClick = function (feature) {
        if (!feature.source) return false;

        var source = map.getSource(feature.source);

        source.getClusterExpansionZoom(feature.properties.cluster_id, function(err,zoom) {
            if (!err) map.easeTo({ center: feature.geometry.coordinates, zoom: zoom + 2 });
        });
    }

    /**
     * @function
     * @name onLayerMouseover
     * @memberof module:geoflo.Layers
     * @description Handles the mouseover event on a layer, highlighting the features if certain conditions are met.
     *
     * @param {Object} event - The event object containing information about the mouseover event.
     * @returns {boolean} Returns false if editing, drawing, or viewing actions are active, if the layer is importing, or if there are no features; otherwise, it highlights the features.
     */
    this.onLayerMouseover = function(event) {
        return 

        var Map = app.Map;
        if (Map.getActions().editing || Map.getActions().drawing || Map.getActions().viewing) { return false };
        if (app[app.ns('layer')]._importing) { return false }
        if (!event.features.length) { return false }

        Map.setHighlight({ clear: true, features: event.features});
    }

    /**
     * @function
     * @name onLayerMouseout
     * @memberof module:geoflo.Layers
     * @description Handles the mouseout event for a layer, removing highlights if certain conditions are met.
     *
     * @param {Object} event - The event object associated with the mouseout event.
     * @returns {boolean} Returns false if the map is in editing, drawing, or viewing mode, or if the layer is being imported; otherwise, it returns undefined.
     */
    this.onLayerMouseout = function(event) {
        return 

        var Map = app.Map;
        if (Map.getActions().editing || Map.getActions().drawing || Map.getActions().viewing) { return false };
        if (app[app.ns('layer')]._importing) { return false }
        
        Map._removeHighlight();
    }


    this.init();


    async function buildLayers (layers=[], options={}) {
        await buildText.call(this);
        if (!layers.length) return false;
        await Promise.all(layers.map(layer => buildLayer.call(this, layer, options)));
        setTimeout(function() { geoflo.Layers.moveLayers(); }, 250);
        if (this.showTextLayers) this.addTextLayer();
        return this.getLayers();
    }

    async function buildLayer (layer, opts) {
        var details = !layer.details && layer.id ? layer : layer.details || {};
        var options = layer.options || {};
        var layers = layer.layers || [];
        var features = layer.features || [];
        var hasFeatures = features && features.length;
        var style = layer.style || false;
        var error;

        if (!details.id || !details.type) error = true;

        const type = details.type === 'ALL' ? 'ALL' : this.getType(details.type);
        if (!type) error = true;

        var metadata = { type: details.type} ;
        details.default ? metadata.default = true : metadata.custom = true;
        details.name ? metadata.name = details.name : false;

        var source = details.source || details.id;
        metadata.source = source;

        if (details.style) delete details.style;

        var settings = {
            type: type,
            source: source,
            id: details.id,
            types: layerTypes[type],
            style: style || {},
            filter: layer.filter,
            images: layer.images,
            details: details,
            options: options,
            layers: layers
        }

        if (type === 'ALL') {
            const promises = Object.keys(layerTypes).filter(key => key !== 'All').map(async key => {
                const layerConfig = { ...settings, type: key, types: layerTypes[key] };

                return key === 'Image' ? buildImage.call(this, layerConfig, options) :
                       key === 'Polygon' ? buildPolygon.call(this, layerConfig, options) :
                       key === 'Polyline' ? buildPolyline.call(this, layerConfig, options) :
                       key === 'Point' ? buildPoint.call(this, layerConfig, options) : [];
            });
    
            const results = await Promise.all(promises);
            layers = results.flat();
        } else {
            layers = type === 'Image' ? await buildImage.call(this, settings, options) :
            type === 'Polygon' ? await buildPolygon.call(this, settings, options) :
            type === 'Polyline' ? await buildPolyline.call(this, settings, options) :
            type === 'Point' ? await buildPoint.call(this, settings, options) : [];
        }
        
        this.removeLayers(layers);
        this.removeSource(source);
        this.addSource(source, type, options);
        this.addLayers(layers, metadata);

        removeLayer.call(this, { layer: details.id, source: source });

        settings.metadata = metadata;

        if (metadata.custom) {
            this._layers.push(settings);
            this._sources.push({ id: source, type: type, options: options });
        }

        if (hasFeatures) geoflo.Features.addFeatures(features);
        
        return new Promise((resolve, reject) => {
            if (error) return resolve(error);

            const ready = setInterval(() => {
                const feats = geoflo.Layers.getFeatures(metadata.source);
                if (hasFeatures && !feats.length) return;
                if (!map.getSource(metadata.source)) return;
                clearInterval(ready);
                resolve({ layer: settings, features: feats });
            }, 1);
        });
    }

    async function buildText () {
        const map = geoflo.map;

        return new Promise(async function (resolve, reject) {
            const url = 'https://docs.mapbox.com/mapbox-gl-js/assets/popup.png';

            if (map.hasImage('text-marker')) return resolve(true);

            map.loadImage(url, async function(error, image) {
                if (error) return reject(error);
                if (map.hasImage('text-marker')) return resolve(image);
                
                map.addImage('text-marker', image, {
                    content: [25, 25, 115, 100],
                    stretchX: [[25, 115]],
                    stretchY: [[25, 100]],
                    pixelRatio: 2,
                    sdf: false
                });
                
                return resolve(image);
            });
        });
    }

    async function buildImage (settings={}, options={}) {
        if (!settings.source) return [];

        var layers = [];
        var source = settings.source;

        for (var i = 0; i < settings.types.length; i++) {
            var type = settings.types[i];
            var style = settings.style;
            var id = settings.id + type;
            var layout, paint;

            if (!settings.images || !settings.images.length) continue;

            for (var j = 0; j < settings.images.length; j++) {
                var image = settings.images[j];
                if (!image) continue;

                var img = await loadImage(image);
                if (!img) continue;
                
                map.hasImage(image.id) ?
                map.updateImage(image.id, img, {pixelRatio: 2}) :
                map.addImage(image.id, img, {pixelRatio: 2});
            }

            layout = Object.assign({}, {
                'visibility': options.visibility || 'visible',
                'icon-image': ['get', 'primaryImage', ['get','style', ['properties']]],
                'icon-size': ['interpolate', ['linear'], ['zoom'], 1, 0.6, 10, 0.8, 15, 1],
                'icon-allow-overlap': true,
                'icon-anchor': 'bottom'
            }, style.image ? style.image.layout || {} : {});

            paint = Object.assign({}, {
                'icon-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0,
                    ['case', ["boolean", ["feature-state", "hidden"], true], 0,
                    ['get', 'opacity', ['get','style', ['properties']]]]]
            }, style.image ? style.image.paint || {} : {});

            style = {
                id: id,
                type: 'symbol',
                source: source,
                slot: style.slot || 'top',
                filter: settings.filter || ['==', "$type", "Point"],
                layout: layout,
                paint: paint
            }

            if (!style) continue;
            layers.push(style)
        }

        return layers;
    }

    async function buildPolygon (settings={}, options={}) {
        if (!settings.source) return [];

        var layers = [];
        var source = settings.source;

        for (var i = 0; i < settings.types.length; i++) {
            var type = settings.types[i];
            var style = settings.style;
            var id = settings.id + type;
            var layout, paint;

            if (type.includes('border')) {
                layout = Object.assign({}, {
                    'visibility': options.visibility || 'visible',
                }, style.border ? style.border.layout || {} : {});

                paint = Object.assign({}, {
                    'line-color': ['get', 'primaryColor', ['get','style', ['properties']]],
                    'line-width': ['case', ["boolean", ['has', 'width', ['get','style', ['properties']]], true], ['get', 'width', ['get','style', ['properties']]], 2],
                    'line-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 0.8]
                }, style.border ? style.border.paint || {} : {});

                style = {
                    id: id,
                    type: 'line',
                    source: source,
                    slot: style.slot || 'bottom',
                    filter: style.border ? style.border.filter || ['==', "$type", "Polygon"] : ['==', '$type', 'Polygon'],
                    layout: layout,
                    paint: paint
                }
            } else if (type.includes('fill')) {
                layout = Object.assign({}, {
                    'visibility': options.visibility || 'visible',
                }, style.fill ? style.fill.layout || {} : {});

                paint = Object.assign({}, {
                    'fill-color': ['get', 'secondaryColor', ['get','style', ['properties']]],
                    'fill-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 0.5]
                }, style.fill ? style.fill.paint || {} : {});

                style = {
                    id: id,
                    type: 'fill',
                    source: source,
                    slot: style.slot || 'bottom',
                    filter: style.fill ? style.fill.filter || ['==', "$type", "Polygon"] : ['==', '$type', 'Polygon'],
                    layout: layout,
                    paint: paint
                }
            }

            if (!style) continue;
            layers.push(style)
        }

        return layers;
    }

    async function buildPolyline (settings={}, options={}) {
        if (!settings.source) return [];

        var layers = [];
        var source = settings.source;

        for (var i = 0; i < settings.types.length; i++) {
            var type = settings.types[i];
            var style = settings.style;
            var id = settings.id + type;
            var layout, paint;

            if (type.includes('line')) {
                layout = Object.assign({}, {
                    'visibility': options.visibility || 'visible',
                    'line-miter-limit': 2,
                    'line-join': 'round',
                    'line-cap': 'round'
                }, style.line ? style.line.layout || {} : {});

                paint = Object.assign({}, {
                    'line-color': ['get', 'primaryColor', ['get','style', ['properties']]],
                    'line-width': ['case', ["boolean", ['has', 'width', ['get','style', ['properties']]], true], ['get', 'width', ['get','style', ['properties']]], 4],
                    'line-offset': ['case', ["boolean", ["has", "offset"], true], ["get", "offset"], 0],
                    'line-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, 1]
                }, style.line ? style.line.paint || {} : {});

                style = {
                    id: id,
                    type: 'line',
                    source: source,
                    slot: style.slot || 'middle',
                    filter: style.line ? style.line.filter || ['==', "$type", "LineString"] : ['==', '$type', 'LineString'],
                    layout: layout,
                    paint: paint
                }
            }

            if (!style) continue;
            layers.push(style)
        }

        return layers;
    }

    async function buildPoint (settings={}, options={}) {
        if (!settings.source) return [];

        var layers = [];
        var source = settings.source;
        var dontRender = false; //map.getStyle().imports && map.getStyle().imports.length;

        for (var i = 0; i < settings.types.length; i++) {
            var type = settings.types[i];
            var style = settings.style;
            var id = settings.id + type;
            var layout, paint;

            if (type.includes('circle')) {
                if (options.noCircle) continue;

                layout = Object.assign({}, {
                    'visibility': options.visibility || 'visible',
                }, style.circle ? style.circle.layout || {} : {});

                paint = Object.assign({}, {
                    'circle-radius': 10,
                    'circle-stroke-width': 2,
                    'circle-color': ['get', 'secondaryColor', ['get','style', ['properties']]],
                    'circle-stroke-color': ['get', 'primaryColor', ['get','style', ['properties']]],
                    'circle-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, ['case', ["boolean", ["feature-state", "hidden"], true], 0, ['get', 'opacity', ['get','style', ['properties']]]]],
                    'circle-stroke-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, ['case', ["boolean", ["feature-state", "hidden"], true], 0, ['get', 'opacity', ['get','style', ['properties']]]]]
                }, style.circle ? style.circle.paint || {} : {});

                style = {
                    id: id,
                    type: 'circle',
                    source: source,
                    slot: style.slot || 'top',
                    filter: style.circle ? style.circle.filter || ['==', "$type", "Point"] : ['==', "$type", "Point"],
                    layout: layout,
                    paint: paint
                }

                if (type.includes('cluster')) {
                    if (options.noCluster) continue;
                    style.filter = ['has', 'point_count'];
                    style.paint['circle-color'] = options.secondaryColor || geoflo.options.colors.secondaryColor;
                    style.paint['circle-stroke-color'] = options.primaryColor || geoflo.options.colors.primaryColor;
                }
            } else if (type.includes('icon')) {
                if (dontRender) continue;

                layout = Object.assign({}, {
                    'visibility': options.visibility || 'visible',
                    'icon-optional': true,
                    'text-field': ['get', 'primaryIcon', ['get','style', ['properties']]],
                    'text-rotate': ['get', 'rotate', ['get','style', ['properties']]],
                    'text-rotation-alignment': 'viewport',
                    'text-size': 14,
                    'text-line-height': 1,
                    'text-padding': 0,
                    'text-offset': [0, 0.2],
                    'text-justify': 'auto',
                    'text-anchor': 'center',
                    'text-allow-overlap': true,
                    'text-font': ['Font Awesome 6 Pro Solid'],
                    'text-ignore-placement': true
                }, style.icon ? style.icon.layout || {} : {});

                paint = Object.assign({}, {
                    'text-translate-anchor': 'viewport',
                    'text-halo-color': ['get', 'primaryColor', ['get','style', ['properties']]],
                    'text-halo-width': 0,
                    'text-color': ['get', 'primaryColor', ['get','style', ['properties']]],
                    'text-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, ['case', ["boolean", ["feature-state", "hidden"], true], 0, ['get', 'opacity', ['get','style', ['properties']]]]]
                }, style.icon ? style.icon.paint || {} : {});

                style = {
                    id: id,
                    type: 'symbol',
                    source: source,
                    slot: style.slot || 'top',
                    filter: style.icon ? style.icon.filter || ['==', "$type", "Point"] : ['==', "$type", "Point"],
                    layout: layout,
                    paint: paint
                }

                if (type.includes('cluster')) {
                    if (options.noCluster) continue;
                    style.filter = ['has', 'point_count'];
                    style.layout['text-field'] = options.primaryIcon || '';
                    style.paint['text-halo-color'] = options.secondaryColor || geoflo.options.colors.secondaryCold;
                    style.paint['text-color'] = options.primaryColor || geoflo.options.colors.secondaryText;
                } else if (type.includes('count')) {
                    if (options.noCluster) continue;
                    style.filter = ['has', 'point_count'];

                    style.layout = {
                        'visibility': options.visibility || 'visible',
                        'icon-optional': true,
                        'text-field': options.countIcon || '',
                        'text-size': {
                            'base': 14,
                            'stops': [[10, 16], [14, 14]]
                        },
                        'text-line-height': 1,
                        'text-padding': 0,
                        'text-offset': [0.5, -0.6],
                        'text-justify': 'auto',
                        'text-anchor': 'center',
                        'text-allow-overlap': true,
                        'text-font': ['Font Awesome 6 Pro Solid'],
                        'text-ignore-placement': true
                    }

                    style.paint = {
                        'text-translate-anchor': 'viewport',
                        'text-color': options.countIconColor || geoflo.options.colors.primaryText,
                        'text-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, ['get', 'opacity', ['get','style', ['properties']]]]
                    }
                }
            } else if (type.includes('text')) {
                if (dontRender) continue;

                if (type.includes('count')) {
                    if (options.noCluster) continue;

                    layout = Object.assign({}, {
                        'text-field': ['get', 'point_count_abbreviated'],
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': {
                            'base': 14,
                            'stops': [[10, 14], [14, 12]]
                        },
                        'text-offset': [0.55, -0.9],
                    }, style.text ? style.text.layout || {} : {});
    
                    paint = Object.assign({}, {
                        'text-color': options.countTextColor || geoflo.options.colors.secondaryText,
                        'text-opacity': ['case', ["boolean", ["feature-state", "hidden"], true], 0, ['get', 'opacity', ['get','style', ['properties']]]]
                    }, style.text ? style.text.paint || {} : {});
    
                    style = {
                        id: id,
                        type: 'symbol',
                        source: source,
                        slot: style.slot || 'top',
                        filter: ['has', 'point_count'],
                        layout: layout,
                        paint: paint
                    }
                }
            }

            if (!style) continue;
            layers.push(style)
        }

        return layers;
    }

    function buildEvents (options={}) {
        var ids = this.getLayerIds();
        if (!ids.length) return;

        if (options.off) {
            map.off('mousemove', ids, this.onLayerMouseover);
            map.off('mouseleave', ids, this.onLayerMouseout);
        } else if (options.on) {
            map.on('mousemove', ids, this.onLayerMouseover);
            map.on('mouseleave', ids, this.onLayerMouseout);
        } else if (!options) {
            buildEvents({ off: true });
            buildEvents({ on: true })
        }
    }

    function removeLayer (options) {
        if (!options) return false;
        var layer = this._layers.findIndex((e) => { return e.id === options.layer });
        var source = this._sources.findIndex((e) => { return e.id === options.source });
        if (layer !== -1) this._layers.splice(layer, 1);
        if (source !== -1) this._sources.splice(source, 1);
    }

    async function loadImage (options={}) {
        if (!options.url || !options.id) return false;
        return new Promise(async function (resolve, reject) {
            const url = options.url + '?' + new Date().getTime();
            map.loadImage(url, function(error, image) { return error ? reject(error) : resolve(image); });
        });
    }

    function loadImageAsDataURL(imageUrl, callback) {
        /* loadImageAsDataURL(options.url, (data) => {
            options.data = data;
            const svgMarker = createSVGMarker(options);
            svgToImage(svgMarker, (img) => resolve(img) );
        }); */
        
        const img = new Image();
        img.setAttribute('crossOrigin', 'anonymous');
        img.onload = () => {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);
            const dataURL = canvas.toDataURL("image/png");
            callback(dataURL);
        };
        img.src = imageUrl + '?' + new Date().getTime();
    }

    function createSVGMarker(options={}) {
        const svgNS = "http://www.w3.org/2000/svg";

        const data = options.data;
        const width = options.width;
        const height = options.height;
        const borderWidth = options["stroke-width"] || 5;

        const svg = document.createElementNS(svgNS, "svg");
        svg.setAttribute("width", width);
        svg.setAttribute("height", height);
        svg.setAttribute("viewBox", `0 0 ${width + 2 * borderWidth} ${height + 2 * borderWidth}`);
    
        const marker = document.createElementNS(svgNS, "ellipse");
        marker.setAttribute("cx", (width + 2 * borderWidth) / 2);
        marker.setAttribute("cy", (height + 2 * borderWidth) / 2);
        marker.setAttribute("rx", width / 2);
        marker.setAttribute("ry", height / 2);
        marker.setAttribute("fill", 'transparent');
        marker.setAttribute("stroke", options.stroke || geoflo.getColors().secondaryBackground);
        marker.setAttribute("stroke-width", borderWidth);
    
        const image = document.createElementNS(svgNS, "image");
        image.setAttributeNS("http://www.w3.org/1999/xlink", "href", data);
        image.setAttribute("x", borderWidth);
        image.setAttribute("y", borderWidth);
        image.setAttribute("width", width);
        image.setAttribute("height", height);
        image.setAttribute("preserveAspectRatio", "xMidYMid slice");
        image.setAttribute("clip-path", "ellipse()");
    
        svg.appendChild(marker);
        svg.appendChild(image);
    
        return svg;
    }
    
    function svgToImage(svgElement, callback) {
        const svgData = new XMLSerializer().serializeToString(svgElement);
        const svgBlob = new Blob([svgData], { type: "image/svg+xml;charset=utf-8" });
        const url = URL.createObjectURL(svgBlob);
        const img = new Image();

        img.onload = () => { URL.revokeObjectURL(url), callback(img); };
        img.src = url;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Layers);

/***/ }),

/***/ "./src/Locate.js":
/*!***********************!*\
  !*** ./src/Locate.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Locate
 * @description This module provides the geolocation functionality for the Geoflo application. It allows users to locate their current position on the map and track their location.
 * @returns {Object} Returns the Locate object.
 */
const Locate = function () {
    const geoflo = this.geoflo;

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name init
	 * @description This function initializes the geolocation control on the map with the specified options.
	 * @param {Object} options - The options for configuring the geolocation control.
	 * @param {boolean} [options.enableHighAccuracy=true] - Whether to enable high accuracy for geolocation.
	 * @param {boolean} [options.trackUserLocation=true] - Whether to track the user's location.
	 * @param {boolean} [options.showUserHeading=true] - Whether to show the user's heading.
	 * @param {boolean} [options.showAccuracyCircle=false] - Whether to show the accuracy circle.
	 * @returns {Object} The current instance of the map with the geolocation control added.
	 */
    this.init = function (options={}) {
        this.options = geoflo.Utilities.extend({}, options);

        this.control = new mapboxgl.GeolocateControl({
            positionOptions: { enableHighAccuracy: true },
            trackUserLocation: true,
            showUserHeading: true,
            showAccuracyCircle: false
        });

        this.control.on('geolocate', this.onControlEvent.bind(this))
        geoflo.map.addControl(this.control, 'top-right');
        //this.ready();
        return this;
    }

    this.hide = function () {
        this.control._container.style.display = 'none';
    }

    this.show = function () {
        this.control._container.style.display = 'block';
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name ready
	 * @description This function checks if the geolocate button is available in the control and then calls the build function.
	 * @params {Object} control - The control object containing the geolocate button.
	 * @returns {void}
	 */
    this.ready = function () {
        var _this = this;
        var control = this.control;

        var ready = setInterval(function() {
            if (!control._geolocateButton) return;
            _this.build();
            return clearInterval(ready);
        }, 1);
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name build
	 * @description This function hides the user location dot marker and the associated button.
	 * @params {void} None
	 * @returns {void}
	 */
    this.build = function () {
        this.button = this.control._geolocateButton;
        this.marker = this.control._userLocationDotMarker;
        this.button.addEventListener('click', this.onControlEvent.bind(this));
        //this.getButton().style.display = 'none';
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name update
	 * @description This function updates the map bearing and center based on the provided options.
	 * @param {Object} options - The options object.
	 * @param {number} options.alpha - The alpha value.
	 * @returns {void}
	 */
    this.update = function (options={}) {
        const alpha = options.alpha;
        const heading = this.heading();
        const bearing = this.bearing();
        const following = this.following;
        if (!heading || !following || geoflo.mapMoving) return;
        geoflo.map.setBearing(heading - 1);
        geoflo.map.setCenter(this.marker._lngLat);
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name heading
	 * @description Retrieves the heading value from the control object.
	 * @returns {string} The heading value from the control object.
	 */
    this.heading = function () {
        return this.control._heading;
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name bearing
	 * @description This function retrieves the current bearing of the map.
	 * @returns {number} The bearing of the map.
	 */
    this.bearing = function () {
        return geoflo.map.getBearing();
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name locate
	 * @description Initiates the process of locating the user's current position on the map.
	 * @returns {void}
	 */
    this.locate = function () {
        this.locating = true;
        this.unlocated = false;
        this.control._follow = this.following = false;
        addClasses(this.button, ['mapboxgl-ctrl-geolocate-waiting']);
        geoflo.fire('locate.on', { state: this.state() });
        return this.control.trigger();
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name relocate
	 * @description Relocates the geolocation control to the user's current location. If the control is set to follow the user's location, it changes the state to 'ACTIVE_LOCK'. Adds the 'mapboxgl-ctrl-geolocate-active' class to the button element. Triggers the control
	 * @params {void}
	 * @returns {void}
	 */
    this.relocate = function () {
        if (this.following) this.state('ACTIVE_LOCK');
        addClasses(this.button, ['mapboxgl-ctrl-geolocate-active']);
        return this.control.trigger();
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name unlocate
	 * @description Sets the state to 'ACTIVE_LOCK', disables following, enables drag pan on the map, and triggers the control.
	 * @returns {Object} The result of triggering the control.
	 */
    this.unlocate = function () {
        this.state('ACTIVE_LOCK');
        this.control._follow = this.following = false;
        geoflo.map.dragPan.enable();
        this.unlocated = true;
        geoflo.fire('locate.off', { state: this.state() });
        return this.control.trigger();
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name follow
	 * @description Enables the follow functionality for the geolocate control. When activated, adds a specific class to the button, disables drag panning on the map, and sets the follow state to true.
	 * @params {Object} geoflo - The context object containing the map and control references.
	 * @returns {boolean} - Returns true to indicate that the follow functionality has been enabled.
	 */
    this.follow = function () {
        addClasses(this.button, ['mapboxgl-ctrl-geolocate-follow']);
        geoflo.map.dragPan.disable();
        return this.control._follow = this.following = true;
    }

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name state
	 * @description This function is used to get or set the state of the control. If a state parameter is provided, it sets the control's watch state to that value. If no state parameter is provided, it returns the current watch state of the control.
	 * @param {boolean} state - The state to set for the control.
	 * @returns {boolean} - The current watch state of the control.
	 */
    this.state = function (state) {
        return state ? this.control._watchState = state : this.control._watchState;
    }



	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name getButton
	 * @description Returns the geolocate button element from the control.
	 * @returns {Element} The geolocate button element.
	 */
    this.getButton = function () {
        return this.control._geolocateButton;
    }


    

	/**
	 * @function
     * @memberof module:geoflo.Locate
	 * @name removeClasses
	 * @description This function removes classes related to geolocation control from a button element.
	 * @params {Element} button - The button element from which classes will be removed.
	 */
    this.removeClasses = function () {
        var button = this.button;
        if (!button) return;
        button.classList.remove('mapboxgl-ctrl-geolocate-waiting');
        button.classList.remove('mapboxgl-ctrl-geolocate-active');
        button.classList.remove('mapboxgl-ctrl-geolocate-active-error');
        button.classList.remove('mapboxgl-ctrl-geolocate-background');
        button.classList.remove('mapboxgl-ctrl-geolocate-background-error');
        button.classList.remove('mapboxgl-ctrl-geolocate-follow');
    }



    /**
     * @function
     * @name onAdd
     * @memberof module:geoflo.Locate
     * @description Logs the event object to the console.
     *
     * @param {Event} event - The event object that is triggered when an action occurs.
     * @returns {void} This function does not return a value.
     * 
     * @author Solutegrate
     * @copyright 2025
     */
    this.onAdd = function (event) {
        console.log(event)
    }

    /**
     * @function
     * @name onControlEvent
     * @memberof module:geoflo.Locate
     * @description Handles control events, updating the marker and managing the state based on the event details.
     *
     * @param {Object} event - The event object containing details about the control event.
     * @param {Object} event.coords - The coordinates associated with the event, if available.
     * @param {HTMLElement} event.target - The target element that triggered the event.
     * @returns {void} This function does not return a value.
     * 
     * @author Solutegrate
     * @copyright 2025
     */
    this.onControlEvent = function (event) {
        //this.button = this.button || event.button;
        this.marker = this.control._userLocationDotMarker;

        this.removeClasses();

        if (event.coords) {
            this.onLocate(event)
        } else if (event.target === this.button) {
            console.error('Locate: ', this.state(), event, this.button);
            geoflo.map.dragPan.enable();
            if (this.state() === 'OFF') return this.locate();
            if (this.state() === 'BACKGROUND' && !this.following) return this.relocate();
            if (this.state() === 'ACTIVE_LOCK' && !this.following) return this.follow();
            this.unlocate();
        } 
    }

    /**
     * @function
     * @name onLocate
     * @memberof module:geoflo.Locate
     * @description Handles the location update event, updating the current location and firing an event with the new state.
     *
     * @param {Object} event - The event object containing location data.
     * @param {Object} event.coords - The coordinates of the current location.
     * @returns {void} This function does not return a value.
     * 
     * @author Solutegrate
     * @copyright 2025
     */
    this.onLocate = function (event) {
        if (this.state() === 'ACTIVE_LOCK' && this.locating) {
            this.locating = false;
            this.currentLocation = event.coords;
            addClasses(this.button, ['mapboxgl-ctrl-geolocate-active']);
        }

        geoflo.fire('locate.update', { locating: this.locating, coords: event.coords, state: this.state() });
    }

    /**
     * @function
     * @name onMapMove
     * @memberof module:geoflo.Locate
     * @description Handles the map movement event, updating the button classes based on the current state and conditions.
     *
     * @param {Object} event - The event object representing the map movement.
     * @returns {void} This function does not return a value.
     * 
     * @author Solutegrate
     * @copyright 2025
     */
    this.onMapMove = function (event) {
        if (!this.button || this.following || this.unlocated) return;
        if (this.state() === 'ACTIVE_LOCK') return addClasses(this.button, ['mapboxgl-ctrl-geolocate-active']);
        addClasses(this.button, ['mapboxgl-ctrl-geolocate-background']);
    }

    this.init();

    function addClasses (button, classes=[]) {
        if (!button) return;
        classes.forEach(function(c) { c ? button.classList.add(c) : false })
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Locate);

/***/ }),

/***/ "./src/Mesh.js":
/*!*********************!*\
  !*** ./src/Mesh.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Mesh
 * @description This module provides the mesh functionality for the Geoflo application. It allows users to create a mesh of features by splitting them into segments and checking for intersections.
 * @param {Array} originalFeatures - An array of features to be added to the mesh.
 * @param {boolean} linesOnly - A flag indicating whether only lines should be added to the mesh.
 * @returns {Object} Returns the Mesh object.
 */
const Mesh = function (originalFeatures, linesOnly) {
    var segmentId = 1;
    var allSegments = [];
    var featureIndex = {};

    const geoflo = this.geoflo;

	/**
	 * @function
     * @memberof module:geoflo.Mesh
	 * @name addNewFeatures
	 * @description This function takes new features, splits them into segments, checks for intersections, and updates the existing segments accordingly.
	 * @param {Array} features - An array of new features to be added.
	 * @return {Array} Returns an array containing all mesh segments.
	 */
    this.addNewFeatures = function(features) {
        var allNewFeatures = splitAndCheckForIntersections(features);
        var newSegments = splitIntoTwoPointSegmentsAndAddIds(allNewFeatures);
        var segmentsWithCutPoints = checkForIntersections(newSegments, allSegments);
        allSegments = [].concat(geoflo.Utilities.consumableArray(cutSegments(allSegments, segmentsWithCutPoints)), geoflo.Utilities.consumableArray(cutSegments(newSegments, segmentsWithCutPoints)));
        return this.getFeatures();
    };

	/**
	 * @function
     * @memberof module:geoflo.Mesh
	 * @name getFeatures
	 * @description Returns all of the features in the mesh.
	 * @return {Array} Returns an array containing all feature segments.
	 */
    this.getFeatures = function() {
        return allSegments;
    };

	/**
	 * @function
     * @memberof module:geoflo.Mesh
	 * @name splitSegmentAtPoint
	 * @description This function takes a segment ID and coordinates of a point to split the segment. It creates two new segments by splitting the original segment at the specified point and updates the feature index.
	 * @param {string} segmentId - The ID of the segment to be split.
	 * @param {Array<number>} pointCoords - The coordinates of the point where the segment should be split.
	 */
    this.splitSegmentAtPoint = function(segmentId, pointCoords) {
        var feature = featureIndex[segmentId];
        if (feature !== undefined) {
            var pos = allSegments.indexOf(feature);
            allSegments.splice(pos, 1);
            var line1 = geoflo.Utilities.createLineWithLength([pointCoords, feature.geometry.coordinates[0]]);
            var line2 = geoflo.Utilities.createLineWithLength([pointCoords, feature.geometry.coordinates[1]]);
            addFeatureToIndex(line1);
            addFeatureToIndex(line2);
            allSegments.push(line1, line2);
        } else {
            console.error("splitSegmentAtPoint: no original feature for id ", segmentId);
        }
    };

	/**
	 * @function
     * @memberof module:geoflo.Mesh
	 * @name getFeaturesFromIndex
	 * @description This function takes an array of features and retrieves the corresponding features from an index based on their IDs.
	 * @param {Array} features - The array of features to retrieve from the index.
	 * @returns {Array} The array of features retrieved from the index.
	 */
    this.getFeaturesFromIndex = function(features) {
        var result = [];
        features.forEach(function(feature) {
            var id = feature.id || feature.properties.id;
            var originalFeature = featureIndex[id];
            if (originalFeature !== undefined) {
                result.push(originalFeature);
            }
        });
        return result;
    };

	/**
	 * @function
     * @memberof module:geoflo.Mesh
	 * @name getFeatureById
	 * @description Retrieves a feature by its ID.
	 * @param {number} id - The ID of the feature to retrieve.
	 * @returns {object} The feature object corresponding to the provided ID.
	 */
    this.getFeatureById = function(id) {
        return getFeatureById(id);
    };

	/**
	 * @function
     * @memberof module:geoflo.Mesh
	 * @name getFeaturesByParentId
	 * @description Retrieves features based on the parent ID. The parent ID is used to retrieve cold features associated with the segment.
	 * @param {number} id - The parent ID to retrieve features for.
	 * @returns {Array} - An array of features associated with the parent ID.
	 */
    this.getFeaturesByParentId = function(id) {
        return getFeaturesByParentId(id);
    };

	/**
	 * @function
     * @memberof module:geoflo.Mesh
	 * @name removeFeature
	 * @description Removes a feature with the specified ID.
	 * @param {number} id - The ID of the feature to be removed.
	 * @returns {boolean} - Returns true if the feature was successfully removed, false otherwise.
	 */
    this.removeFeature = function (id) {
        return removeFeature(id);
    };


    if (originalFeatures) allSegments = splitAndCheckForIntersections(originalFeatures);


    function addFeatureToIndex(feature, parent) {
        if (featureIndex[segmentId] || getFeatureById(segmentId)) return false;

        featureIndex[segmentId] = feature;
        feature.id = segmentId;
        feature.parent = parent;

        geoflo.Utilities.setProperty(feature, 'id', segmentId);
        geoflo.Utilities.setProperty(feature, 'parent', parent);

        segmentId++;
        return true;
    }

    function addClickSegementsToMesh() {
        if (!geoflo.options.snapping.enable) return false;
    
        var meshFeatures = [];
    
        if (geoflo.closestPoint && geoflo.closestPoint.borders && geoflo.closestPoint.id !== undefined) {
            geoflo.meshIndex.splitSegmentAtPoint(geoflo.closestPoint.id, geoflo.closestPoint.coords);
            geoflo.updateMeshData();
        }
    
        if (geoflo.snapFeature) {
            if (geoflo.snapFeature.geometry.type === "LineString") {
                if (!geoflo.Utilities.isEmptyLineString(geoflo.snapFeature)) {
                    meshFeatures.push(geoflo.snapFeature);
                }
            } else if (geoflo.snapFeature.geometry.type === "Point") {
                geoflo.Utilities.setProperty(geoflo.snapFeature, 'startPoint', true);
                geoflo.startPoint = geoflo.Utilities.cloneDeep(geoflo.snapFeature);
                meshFeatures.push(geoflo.snapFeature);
            }
        }
    
        if (meshFeatures.length > 0) geoflo.addFeaturesToMesh(meshFeatures);
    }

    function coordinatesToLineStrings(coords, result, parent) {
        var firstPoint = turf.truncate(turf.point(coords[0]), { precision: 7, coordinates: 2, mutate: true });
        var secondPoint = null;

        for (var index = 1; index < coords.length; index++) {
            secondPoint = turf.truncate(turf.point(coords[index]), { precision: 7, coordinates: 2, mutate: true });
            
            if (!geoflo.Utilities.isPointEqual(firstPoint.geometry.coordinates, secondPoint.geometry.coordinates)) {
                var line = turf.lineString([firstPoint.geometry.coordinates, secondPoint.geometry.coordinates]);
                var added = addFeatureToIndex(line, parent);
                added ? result.push(line) : false;
            }

            firstPoint = secondPoint;
        }
    }

    function splitIntoTwoPointSegmentsAndAddIds(features) {
        var result = [];
        if (!features || !features.length) return result;

        features.forEach(function(feature) {
            var type = feature.geometry.type;
            var id = feature.parent || feature.properties.parent || feature.id || feature.properties.id;
            var added;

            if (linesOnly && type !== "LineString" && !feature.properties.unfill) {
                feature = geoflo.Utilities.cloneDeep(feature);
                added = addFeatureToIndex(feature, id);
                return added ? result.push(feature) : false;
            }

            if (type === "MultiPolygon") {
                feature.geometry.coordinates.forEach(function(coords) {
                    coords.forEach(function(subCoords) {
                        coordinatesToLineStrings(subCoords, result, id);
                    });
                });
            } else if (type === "Polygon") {
                feature.geometry.coordinates.forEach(function(coords) {
                    coordinatesToLineStrings(coords, result, id);
                });
            } else if (type === "MultiLineString") {
                feature.geometry.coordinates.forEach(function(coords) {
                    coordinatesToLineStrings(coords, result, id);
                });
            } else if (type === "LineString") {
                coordinatesToLineStrings(feature.geometry.coordinates, result, id);
            } else if (type === "Point") {
                feature = geoflo.Utilities.cloneDeep(feature);
                added = addFeatureToIndex(feature, id);
                added ? result.push(feature) : false;
            }
        });

        return result;
    }

    function appendCutFeatures(segmentsWithCutPoints, feature, cutPointFeatures) {
        var id = feature.id || feature.properties.id;
        var segCutPoints = segmentsWithCutPoints[id];
    
        if (segCutPoints === undefined) {
            segCutPoints = [];
            segmentsWithCutPoints[id] = segCutPoints;
        }
    
        cutPointFeatures.forEach(function(feature) {
            var newCutPoint = geoflo.Utilities.reducePrecision(feature.geometry.coordinates);
            var cutPoint = segCutPoints.findIndex(function(element) { return element[0] === newCutPoint[0] && element[1] === newCutPoint[1]; });
            if (cutPoint === -1) { segCutPoints.push(newCutPoint); }
        });
    };

    function checkForIntersections(knownSegments, newSegments) {
        var segmentsWithCutPoints = {};

        var processIntersectionPoint = function processIntersectionPoint(point, feature1, feature2) {
            var pointCoords = point.geometry.coordinates;
            var seg1Coords = feature1.geometry.coordinates;
            var seg2Coords = feature2.geometry.coordinates;
            var addFeature1Point = false;
            var addFeature2Point = false;
            var closestPointAdded = false;

            if (!geoflo.Utilities.isPointEqual(pointCoords, seg1Coords[0]) && !geoflo.Utilities.isPointEqual(pointCoords, seg1Coords[1])) {
                var endpoint1 = turf.point(seg1Coords[0]);
                var endpoint2 = turf.point(seg1Coords[1]);
                var distanceEndpoint1 = turf.distance(point, endpoint1);
                var distanceEndpoint2 = turf.distance(point, endpoint2);

                var closestEndpoint = distanceEndpoint1 < distanceEndpoint2 ? endpoint1 : endpoint2;

                var pointOnLine = turf.pointOnLine(feature2, closestEndpoint);
                if (pointOnLine.properties.dist < geoflo.statics.constants.MIN_DISTANCE) {
                    appendCutFeatures(segmentsWithCutPoints, feature2, [closestEndpoint]);
                    closestPointAdded = true;
                } else {
                    addFeature1Point = true;
                }
            }
            if (!geoflo.Utilities.isPointEqual(pointCoords, seg2Coords[0]) && !geoflo.Utilities.isPointEqual(pointCoords, seg2Coords[1])) {
                var _endpoint = turf.point(seg2Coords[0]);
                var _endpoint2 = turf.point(seg2Coords[1]);
                var _distanceEndpoint = turf.distance(point, _endpoint);
                var _distanceEndpoint2 = turf.distance(point, _endpoint2);

                var _closestEndpoint = _distanceEndpoint < _distanceEndpoint2 ? _endpoint : _endpoint2;

                var _pointOnLine = turf.pointOnLine(feature1, _closestEndpoint);
                if (_pointOnLine.properties.dist < geoflo.statics.constants.MIN_DISTANCE) {
                    appendCutFeatures(segmentsWithCutPoints, feature1, [_closestEndpoint]);
                    closestPointAdded = true;
                } else {
                    addFeature2Point = true;
                }
            }

            if (!closestPointAdded) {
                if (addFeature1Point) {
                    appendCutFeatures(segmentsWithCutPoints, feature1, [point]);
                }
                if (addFeature2Point) {
                    appendCutFeatures(segmentsWithCutPoints, feature2, [point]);
                }
            }
        };

        var checkIfPointInCloseRange = function checkIfPointInCloseRange(feature, coords) {
            var pointOnline = turf.pointOnLine(feature, turf.point(coords));
            if (pointOnline.properties.dist < geoflo.statics.constants.MIN_DISTANCE) {
                if (!geoflo.Utilities.isPointAtVertex(feature.geometry.coordinates, coords)) {
                    appendCutFeatures(segmentsWithCutPoints, feature, [pointOnline]);
                    return true;
                }
            }
            return false;
        };

        var sameSegments = knownSegments === newSegments;

        for (var knownIndex = 0; knownIndex < knownSegments.length; knownIndex++) {
            var segmentFeature1 = knownSegments[knownIndex];
            var feature1Type = segmentFeature1.geometry.type;

            for (var newIndex = sameSegments ? knownIndex + 1 : 0; newIndex < newSegments.length; newIndex++) {
                var segmentFeature2 = newSegments[newIndex];
                var feature2Type = segmentFeature2.geometry.type;
                var id = segmentFeature2.id || segmentFeature2.properties.id;

                if (feature1Type === "LineString" && feature2Type === "LineString") {
                    if (geoflo.Utilities.isOverlapping(segmentFeature1, segmentFeature2)) {
                        var intersectionPoints = turf.lineIntersect(segmentFeature1, segmentFeature2).features;

                        if (intersectionPoints.length > 0) {
                            if (intersectionPoints.length > 1) console.error(intersectionPoints.length + " intersection points received");
                            var point = intersectionPoints[0];
                            processIntersectionPoint(point, segmentFeature1, segmentFeature2);
                        } else {
                            var seg1Coords = segmentFeature1.geometry.coordinates;
                            var seg2Coords = segmentFeature2.geometry.coordinates;
                            checkIfPointInCloseRange(segmentFeature1, seg2Coords[0]);
                            checkIfPointInCloseRange(segmentFeature1, seg2Coords[1]);
                            checkIfPointInCloseRange(segmentFeature2, seg1Coords[0]);
                            checkIfPointInCloseRange(segmentFeature2, seg1Coords[1]);
                        }

                        if (getFeatureById(id)) {
                            console.log('Existing Line: ', segmentFeature2)
                            var pos = allSegments.indexOf(getFeatureById(id));
                            allSegments.splice(pos, 1);
                        }
                    }
                } else if (feature1Type === "Point" || feature2Type === "Point") {
                    if (feature2Type === "Point" && feature2Type === "Point") {
                        console.log("Point & Point");
                    } else {
                        console.log("Point & LineString");
                        var _point = feature1Type === "Point" ? segmentFeature1 : segmentFeature2;
                        var line = feature1Type === "LineString" ? segmentFeature1 : segmentFeature2;

                        id = _point.id || _point.properties.id;

                        if (checkIfPointInCloseRange(line, _point.geometry.coordinates)) {
                            segmentsWithCutPoints[id] = [];
                        }
                    }

                    if (getFeatureById(id)) {
                        console.log('Existing Point: ', segmentFeature2)
                        var pos = allSegments.indexOf(getFeatureById(id));
                        allSegments.splice(pos, 1);
                    }
                }
            }
        }

        return segmentsWithCutPoints;
    }

    function cutSegments(newSegments, segmentsWithCutPoints) {
        var result = [];

        newSegments.forEach(function(segment) {
            var id = segment.id || segment.properties.id;

            if (segment.geometry.type === "LineString") {
                var cutPoints = segmentsWithCutPoints[id];

                if (cutPoints !== undefined) {
                    var fc = turf.lineSplit(segment, turf.multiPoint(cutPoints));
                    turf.featureEach(fc, function(feature) {
                        var length = turf.lineDistance(feature);
                        if (length > geoflo.statics.constants.MIN_SEGMENT_LENGTH) {
                            geoflo.Utilities.setProperties(feature, { length: length });
                            addFeatureToIndex(feature);
                            result.push(feature);
                        } else {
                            console.error("0 length feature (", length, ") after line split: ", JSON.stringify(feature));
                        }
                    });
                } else {
                    var length = turf.lineDistance(segment);
                    if (length > geoflo.statics.constants.MIN_SEGMENT_LENGTH) {
                        geoflo.Utilities.setProperties(segment, { length: length });
                        result.push(segment);
                    } else {
                        console.error("0 length feature (", length, ") existing segment: ", JSON.stringify(segment));
                    }
                }
            } else {
                var _cutPoints = segmentsWithCutPoints[id];

                if (_cutPoints === undefined) {
                    result.push(segment);
                }
            }
        });

        return result;
    }

    function splitAndCheckForIntersections(newFeatures) {
        var newFeaturesSegments = splitIntoTwoPointSegmentsAndAddIds(newFeatures);
        if (linesOnly) return newFeaturesSegments;
        var newFeaturesWithCutPoints = checkForIntersections(newFeaturesSegments, newFeaturesSegments);
        return cutSegments(newFeaturesSegments, newFeaturesWithCutPoints);
    }

    function getFeatureById(id) {
        return allSegments.find(function(f) { return f.id === id || f.properties.id === id }) 
    }

    function getFeaturesByParentId(id) {
        return allSegments.filter(function(f) { return f.parent === id || f.properties.parent === id })
    }

    function removeFeature(id) {
        var features = getFeaturesByParentId(id);
        
        if (features && features.length) {
            features.forEach(function(feature) {
                var pos = allSegments.indexOf(feature);
                allSegments.splice(pos, 1);
            })
            
            geoflo.updateMeshData();
        }

        return allSegments;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Mesh);

/***/ }),

/***/ "./src/Options.js":
/*!************************!*\
  !*** ./src/Options.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Options
 * @description Options for the Geoflo map.
 * @property {string} theme - The theme of the map. Default is 'dark'.
 * @property {boolean} showLineUnits - Show line units. Default is false.
 * @property {boolean} showFeatureText - Show feature text. Default is true.
 * @property {object} controls - Controls for the map.
 * @property {boolean} controls.options - Show options control. Default is true.
 * @property {boolean} controls.modes - Show modes control. Default is true.
 * @property {boolean} controls.utils - Show utilities control. Default is true.
 * @property {boolean} controls.types - Show types control. Default is true.
 * @property {boolean} controls.actions - Show actions control. Default is true.
 * @property {object} map - Map options.
 * @property {string} map.container - Map container. Default is 'map'.
 * @property {array} map.center - Map center. Default is [-95.52816680236892, 39.56431143986035].
 * @property {number} map.zoom - Map zoom. Default is 3.5.
 * @property {number} map.maxPitch - Maximum pitch of the map. Default is 50.
 * @property {string} map.projection - Map projection. Default is 'mercator'.
 * @property {string} map.style - Map style. Default is 'mapbox://styles/mapbox/dark-v11'.
 * @property {boolean} map.hash - Enable map hash navigation. Default is true.
 * @property {array} map.extent - Map bounding extent.
 * @property {object} keys - Keyboard shortcuts.
 * @property {string} keys.import - Import key. Default is 'u'.
 * @property {string} keys.export - Export key. Default is 'd'.
 * @property {string} keys.delete - Delete key. Default is 'Delete'.
 * @property {string} keys.cancel - Cancel key. Default is 'Escape'.
 * @property {string} keys.select - Select key. Default is 'Escape'.
 * @property {string} keys.edit - Edit key. Default is 'Enter'.
 * @property {string} keys.refresh - Refresh key. Default is 'r'.
 * @property {string} keys.snapping - Snapping key. Default is '!'.
 * @property {string} keys.pinning - Pinning key. Default is '@'.
 * @property {string} keys.routing - Routing key. Default is '#'.
 * @property {string} keys.exploring - Exploring key. Default is '$'.
 * @property {string} keys.painting - Painting key. Default is '%'.
 * @property {string} keys.polyline - Polyline key. Default is '1'.
 * @property {string} keys.polygon - Polygon key. Default is '2'.
 * @property {string} keys.rectangle - Rectangle key. Default is '3'.
 * @property {string} keys.circle - Circle key. Default is '4'.
 * @property {string} keys.text - Text key. Default is '5'.
 * @property {object} units - Measurement units for different geometries.
 * @property {string} units.Polyline - Polyline unit. Default is 'feet'.
 * @property {string} units.Polygon - Polygon unit. Default is 'acres'.
 * @property {string} units.Rectangle - Rectangle unit. Default is 'acres'.
 * @property {string} units.Icon - Icon unit. Default is 'feature'.
 * @property {string} units.Circle - Circle unit. Default is 'feature'.
 * @property {string} units.Marker - Marker unit. Default is 'feature'.
 * @property {object} colors - Color scheme settings.
 * @property {string} colors.error - Error color. Default is '#ff7676'.
 * @property {string} colors.primaryColor - Primary color. Default is '#d7ef7e'.
 * @property {string} colors.primaryBackground - Primary background color. Default is '#5a5a5a'.
 * @property {string} colors.primaryText - Primary text color. Default is '#c5c5c5'.
 * @property {string} colors.primaryBorder - Primary border color. Default is '#6fafdb'.
 * @property {string} colors.secondaryColor - Secondary color. Default is '#6fafdb'.
 * @property {string} colors.secondaryBackground - Secondary background color. Default is '#333333'.
 * @property {string} colors.secondaryText - Secondary text color. Default is '#333333'.
 * @property {object} select - Selection options.
 * @property {boolean} select.popup - Enable selection popups. Default is false.
 * @property {boolean} select.multiple - Allow multiple selection. Default is false.
 * @property {object} snapping - Snapping settings.
 * @property {boolean} snapping.enable - Enable snapping to features. Default is false.
 * @property {boolean} snapping.pixels - Pixel-based snapping. Default is false.
 * @property {number} snapping.distance - Snapping distance in kilometers.
 * @property {number} snapping.tolerance - Snapping tolerance in kilometers.
 * @property {object} routing - Routing settings.
 * @property {boolean} routing.enable - Enable routing functionality. Default is false.
 * @property {number} routing.precision - Routing coordinate precision.
 * @property {object} pinning - Pinning settings.
 * @property {boolean} pinning.enable - Enable feature pinning. Default is false.
 * @property {number} pinning.buffer - Pinning buffer distance in kilometers.
 * @property {number} pinning.idle - Idle time before updating pinned features.
 * @property {object} exploring - Exploring settings.
 * @property {boolean} exploring.enable - Enable feature exploration. Default is false.
 * @property {number} exploring.minZoom - Minimum zoom level for exploration. Default is 9.
 * @property {number} exploring.buffer - Exploration buffer distance in kilometers.
 * @property {number} exploring.tolerance - Exploration coordinate simplification tolerance.
 * @property {object} painting - Painting settings.
 * @property {boolean} painting.enable - Enable painting mode. Default is false.
 * @property {number} painting.tolerance - Painting coordinate simplification tolerance.
 * @property {object} gamepad - Gamepad configuration settings.
 * @property {boolean} gamepad.enable - Enable gamepad support. Default is true.
 * @property {boolean} gamepad.debug - Enable gamepad debugging. Default is false.
 * @property {boolean} gamepad.crosshairs - Show crosshairs on the map. Default is true.
 * @property {object} gamepad.joystick - Joystick settings.
 * @property {number} gamepad.joystick.min - Minimum joystick threshold. Default is 0.2.
 * @property {number} gamepad.joystick.max - Maximum joystick threshold. Default is 0.7.
 * @property {object} gamepad.pan - Pan settings.
 * @property {number} gamepad.pan.speed - Pan speed. Default is 0.001.
 * @property {object} gamepad.zoom - Zoom settings.
 * @property {number} gamepad.zoom.speed - Zoom speed. Default is 0.008.
 */


const Options = {
    theme: 'dark',
    showLineUnits: false,
    showFeatureText: true,
    controls: {
        options: true,
        modes: true,
        utils: true,
        types: true,
        actions: true
    },
    map: {
        container: 'map',
        center: [-95.52816680236892, 39.56431143986035],
        zoom: 3.5,
        opacity: 1,
        maxPitch: 50,
        projection: 'mercator',
        style: 'Standard',
        hash: true,
        extent: [[[-127.3638459,49.6212752],[-73.7295136,49.6212752],[-73.7295136,24.7473201],[-127.3638459,24.7473201],[-127.3638459,49.6212752]]],
        styles: [
            { title: "Standard", uri: "mapbox://styles/mapbox/standard" },
            { title: "Satellite", uri: "mapbox://styles/mapbox/standard-satellite" },
            { title: "Dark", uri: "mapbox://styles/mapbox/dark-v11" },
            { title: "Light", uri: "mapbox://styles/mapbox/light-v11" },
            { title: "Outdoors", uri: "mapbox://styles/mapbox/outdoors-v12" },
            { title: "Streets", uri: "mapbox://styles/mapbox/navigation-night-v1" }
        ]
    },
    keys: {
        import: 'u',
        export: 'd',
        delete: 'Delete',
        cancel: 'Escape',
        select: 'Escape',
        edit: 'Enter',
        refresh: 'r',
        snapping: '!',
        pinning: '@',
        routing: '#',
        exploring: '$',
        painting: '%',
        polyline: '1',
        polygon: '2',
        rectangle: '3',
        circle: '4',
        text: '5'
    },
    commands: [{
        key: '.',
        modifier: false,
        /**
         * @function
         * @name command
         * @memberof module:geoflo.Options.commands
         * @description Executes a command based on the current mode and geoflo context.
         *
         * @param {Object} event - The event object containing details about the command execution.
         * @param {Object} geoflo - The geoflo context containing map and mode information.
         * @param {string} command - The command identifier to be executed.
         * @returns {void} This function does not return a value.
         */
        command: function (event, geoflo, command) {
            var options = { lngLat: geoflo.map.getCenter() }
            
            if (geoflo.currentMode.id === 'draw') {
                geoflo.currentMode.handleUp(options); 
                geoflo.currentMode.handleClick(options);
            } else {
                geoflo.currentMode.handleClick(options);
            }
        }
    }],
    units: {
        Polyline: 'feet',
        Polygon: 'acres',
        Rectangle: 'acres',
        Icon: 'feature',
        Circle: 'feature',
        Marker: 'feature'
    },
    colors: {
        error: '#ff7676',

        primaryColor: "#d7ef7e",
        primaryBackground: "#5a5a5a",
        primaryText: "#c5c5c5",
        primaryBorder: "#6fafdb",
        
        secondaryColor: "#6fafdb",
        secondaryBackground: "#333333",
        secondaryText: "#333333",
        secondaryBorder: "#404040",

        primarySelect: "#d7ef7e",
        primaryEdit: "#d7ef7e",
        primaryHot: "#242424",
        primaryCold: "#333333",
        primarySnap: "#d7ef7e",
        primaryBase: "#c5c5c5",
        primaryDebug: "#ff7676",
        primaryVertex: "#d7ef7e",

        secondarySelect: "#c5c5c5",
        secondaryEdit: "#c5c5c5",
        secondaryHot: "#333333",
        secondaryCold: "#c5c5c5",
        secondarySnap: "#c5c5c5",
        secondaryBase: "#5a5a5a",
        secondaryDebug: "#d7ef7e",
        secondaryVertex: "#333333"
    },
    select: {
        popup: false,
        multiple: false
    },
    snapping: {
        enable: false, // Enables snapping to features
        pixels: false, // still working on this
        distance: 200 * 1.609344, // 200 miles to kilometers. Calculated by zoom level: (distance * Math.pow(2, Math.max(1, 19 - map.getZoom()))) / 100000
        tolerance: 0.002 // kilometers. Distance from the last click to hide/show mouse line
    },
    routing: {
        enable: false, // find shortest path
        precision: 0.0000015 // rounding coords to create topology. Higher the number will close gaps in lines and allow to find path
    },
    pinning: {
        enable: false, // Enables pinning (glueing) features together at vertices/points. When editing/dragging a point, all pinned points will move together.
        buffer: (50 / 5280) * 1.609344, // 50 feet to miles to kilometer. Pin features within a 50 foot radius. False for exact point location.
        idle: 20 // milliseconds of how long to idle after updating pinned features before checking for nearby features to snap to (helps with editing performance)
    },
    exploring: {
        enable: false,
        minZoom: 9,
        buffer: (5000 / 5280) * 1.609344, // 300 feet to miles to kilometer. Download roadways within a 300 foot radius.
        tolerance: 0.00001 // How much tolerance to simplify coordinates. Can be a function with map argument.
    },
    moving: {
        enable: false, // Enables moving feature
        distance: (3 / 5280) * 1.609344 // 3 feet to miles to kilometer. The distance in which to move the feature
    },
    painting: {
        enable: false, // Enables painting drawing for linestrings and polygons
        tolerance: 0.000005 // How much tolerance to simplify coordinates. Can be a function with map argument.
    },
    gamepad: {
        enable: true,
        debug: false,
        crosshairs: true,
        joystick: {
            min: 0.2,
            max: 0.7
        },
        camera: {
            free: true
        },
        pan: {
            speed: 0.001,
            min: 0.001,
            max: 0.05
        },
        bearing: {
            speed: 0.8
        },
        pitch: {
            speed: 1.5,
            max: 70
        },
        zoom: {
            speed: 0.008
        },
        rumble: {
            startDelay: 0,
            duration: 200,
            weakMagnitude: 1.0,
            strongMagnitude: 1.0
        },
        mapping: {
            /**
             * @function
             * @name Select
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles different types of events: press, hold, and release. 
             * On release, it triggers the click action for the 'clear' button.
             *
             * @param {Object} event - The event object containing details about the event.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.geoflo - The context object that contains methods related to the event.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'Select': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    event.geoflo.getButtons('clear').button.click();
                }
            },
            /**
             * @function
             * @name Start
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles different types of events such as press, hold, and release for gamepad interactions.
             *
             * @param {Object} event - The event object containing details about the input event.
             * @param {string} event.type - The type of the event (press, hold, release).
             * @param {Object} event.gamepad - The gamepad object associated with the event.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joysticks.
             * @param {Object} event.mode - The current mode of the application.
             * @param {string} event.mode.id - The identifier for the current mode.
             * @param {Object} event.geoflo - The context object used to interact with the application.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'Start': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    if (event.gamepad.hasJoysticks) {
                        var button = event.mode.id === 'select' ? 'edit' : 'select';
                        event.geoflo.getButtons(button).button.click();
                    }
                }
            },
            /**
             * @function
             * @name Power
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles different types of power events such as press, hold, and release.
             *
             * @param {Object} event - The event object that contains information about the power event.
             * @param {string} event.type - The type of the event, which can be 'press', 'hold', or 'release'.
             * @param {Object} event.geoflo - The context object that provides access to UI elements.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'Power': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    event.geoflo.getButtons('save').button.click();
                }
            },
            /**
             * @function
             * @name Menu
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles different types of menu events such as press, hold, and release.
             *
             * @param {Object} event - The event object that contains information about the event.
             * @param {string} event.type - The type of the event, which can be 'press', 'hold', or 'release'.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'Menu': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    
                }
            },
            /**
             * @function
             * @name Misc
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles different types of events related to gamepad interactions, including press, hold, and release actions.
             *
             * @param {Object} event - The event object containing details about the gamepad interaction.
             * @param {string} event.type - The type of the event, which can be 'press', 'hold', or 'release'.
             * @param {Object} event.gamepad - The gamepad object associated with the event.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joystick controls.
             * @param {Object} event.geoflo - The context object providing access to the map and buttons.
             * @param {Object} event.geoflo.map - The map object that contains methods for getting the center and zoom level.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'Misc': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    if (event.gamepad.hasJoysticks) {
                        event.geoflo.getButtons('zoom').button.click();
    
                        var ready = setInterval(function() {
                            if (!ctx.mapMoving) {
                                clearInterval(ready);
                                event.gamepad.map.center = event.geoflo.map.getCenter();
                                event.gamepad.map.zoom = event.geoflo.map.getZoom();
                            }
                        }, 1);
                    }
                }
            },
            /**
             * @function
             * @name A
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles different types of events such as press, hold, and release for gamepad interactions.
             *
             * @param {Object} event - The event object containing details about the gamepad interaction.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.gamepad - The gamepad object associated with the event.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joysticks.
             * @param {Object} event.gamepad.pressed - An object representing the pressed buttons on the gamepad.
             * @param {Object} event.geoflo - The context object for the event.
             * @returns {Function|undefined} Returns the result of the JoyLeftClick function if certain conditions are met; otherwise, it performs a button click action or
             * returns undefined.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'A': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    if (!event.gamepad.hasJoysticks) {
                        if (!event.gamepad.pressed['BumpLeft'] && !event.gamepad.pressed['BumpRight']) {
                            return this['JoyLeftClick'](event);
                        }
                    } else {
                        event.geoflo.getButtons('routing').button.click();
                    }
                }
            },
            /**
             * @function
             * @name B
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles different types of events related to a gamepad button press, hold, and release actions.
             *
             * @param {Object} event - The event object containing details about the button action.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.gamepad - The gamepad object associated with the event.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joysticks.
             * @param {Object} event.gamepad.pressed - An object representing the pressed buttons on the gamepad.
             * @param {Object} event.geoflo - The context object for the event.
             * @returns {Function|undefined} Returns the result of the JoyRightClick function if certain conditions are met, otherwise returns undefined.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'B': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    if (!event.gamepad.hasJoysticks) {
                        if (!event.gamepad.pressed['BumpLeft'] && !event.gamepad.pressed['BumpRight']) {
                            return this['JoyRightClick'](event);
                        }
                    } else {
                        event.geoflo.getButtons('painting').button.click();
                    }
                }
            },
            /**
             * @function
             * @name Y
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles gamepad events for pressing, holding, and releasing buttons.
             *
             * @param {Object} event - The event object containing information about the gamepad action.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.gamepad - The gamepad object that contains the state of the gamepad.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joysticks.
             * @param {Object} event.gamepad.pressed - An object representing the pressed buttons on the gamepad.
             * @param {function} event.gamepad.setSpeed - A function to set the speed of the gamepad.
             * @param {Object} event.geoflo - The context object used to interact with the gamepad.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'Y': function (event) {
                if (event.type === 'press') {
                    if (!event.gamepad.hasJoysticks) {
                        if ((event.gamepad.pressed['BumpLeft'] || event.gamepad.pressed['BumpRight'])) event.gamepad.setSpeed(event.value, false);
                    }
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    if (event.gamepad.hasJoysticks) {
                        event.geoflo.getButtons('snapping').button.click();
                    }
                }
            },
            /**
             * @function
             * @name X
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles gamepad events for press, hold, and release actions.
             *
             * @param {Object} event - The event object containing details about the gamepad action.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.gamepad - The gamepad object that contains the state of the gamepad.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joysticks.
             * @param {Object} event.gamepad.pressed - An object representing the buttons that are currently pressed.
             * @param {function} event.gamepad.setSpeed - A method to set the speed of the gamepad.
             * @param {Object} event.geoflo - The context object that provides access to the gamepad's buttons.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'X': function (event) {
                if (event.type === 'press') {
                    if (!event.gamepad.hasJoysticks) {
                        if ((event.gamepad.pressed['BumpLeft'] || event.gamepad.pressed['BumpRight'])) event.gamepad.setSpeed(event.value, true);
                    }
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    if (event.gamepad.hasJoysticks) {
                        event.geoflo.getButtons('pinning').button.click();
                    }
                }
            },
            /**
             * @function
             * @name JoyLeftMove
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles the joystick left movement events, including press, hold, and release actions.
             *
             * @param {Object} event - The event object containing details about the joystick action.
             * @param {string} event.type - The type of the event (press, hold, or release).
             * @param {Object} event.gamepad - The gamepad object associated with the event.
             * @param {boolean} event.value - The value indicating the direction or state of the joystick.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'JoyLeftMove': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    event.gamepad.setCenter(event.value, event.gamepad.options.camera.free) // Pan map
                } else if (event.type === 'release') {
                    event.gamepad.setCenter(false, event.gamepad.options.camera.free) // Reset map center
                }
            },
            /**
             * @function
             * @name JoyRightMove
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles the movement of the gamepad based on the event type and name.
             *
             * @param {Object} event - The event object containing details about the input.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {string} event.name - The name of the input event (e.g., 'Up', 'Down', 'Left', 'Right').
             * @param {number} event.value - The value associated with the input event.
             * @param {Object} event.gamepad - The gamepad object that handles movement.
             * @param {function} event.gamepad.setPitch - Function to set the pitch of the map.
             * @param {function} event.gamepad.setBearing - Function to set the bearing of the map.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'JoyRightMove': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    if (event.name.includes('Up') || event.name.includes('Down')) {
                        event.gamepad.setPitch(event.value, event.name.includes('Up')); // Pitch map
                    } else if (event.name.includes('Left') || event.name.includes('Right')) {
                        event.gamepad.setBearing(event.value, event.name.includes('Left')); // Rotate map
                    }
                } else if (event.type === 'release') {
                    
                }
            },
            /**
             * @function
             * @name JoyLeftClick
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles the left click events for drawing actions, including press, hold, and release actions.
             *
             * @param {Object} event - The event object containing details about the click action.
             * @param {string} event.type - The type of the event, which can be 'press', 'hold', or 'release'.
             * @param {Object} event.mode - The mode object associated with the event.
             * @param {string} event.mode.id - The identifier for the mode, which determines the action taken on release.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'JoyLeftClick': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    if (event.mode.id === 'draw') {
                        event.mode.deleteVertex();
                    }
                }
            },
            /**
             * @function
             * @name JoyRightClick
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles right-click events for drawing modes, processing different event types such as press, hold, and release.
             *
             * @param {Object} event - The event object containing details about the right-click action.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.mode - The current mode of the application, which includes methods for handling events.
             * @param {Object} event.lngLat - The longitude and latitude of the click location.
             * @returns {boolean} Returns false if the event does not have a valid lngLat or if the event type is not handled.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'JoyRightClick': function (event) {
                if (event.type === 'press') {
                    if (event.mode.id === 'draw') {
                        if (!event.lngLat) return false;
                        return event.mode.handleDown(event);
                    }
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    if (!event.lngLat) return false;
    
                    if (event.mode.id === 'draw') {
                        event.mode.handleUp(event); 
                        event.mode.handleClick(event);
                    } else {
                        event.mode.handleClick(event);
                    }
                }
            },
            /**
             * @function
             * @name BumpLeft
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles the bump left action based on the event type and gamepad state.
             *
             * @param {Object} event - The event object containing information about the action.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.gamepad - The gamepad object associated with the event.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joysticks.
             * @param {Object} event.gamepad.pressed - An object representing the buttons pressed on the gamepad.
             * @param {function} event.gamepad.setSpeed - A function to set the speed of the gamepad.
             * @param {number} event.value - The value to be used for setting the speed.
             * @returns {boolean|undefined} Returns false if the right bump is pressed without joysticks, otherwise returns the result of setSpeed.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'BumpLeft': function (event) {
                if (event.type === 'press') {
                    if (!event.gamepad.hasJoysticks) {
                        if (event.gamepad.pressed['BumpRight']) return false
                    } else {
                        return event.gamepad.setSpeed(event.value, true); // Pan speed down
                    }
                } else if (event.type === 'hold') {
                    if (!event.gamepad.hasJoysticks) {
    
                    }
                } else if (event.type === 'release') {
                    
                }
            },
            /**
             * @function
             * @name BumpRight
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles the bump right action based on the event type and gamepad state.
             *
             * @param {Object} event - The event object containing information about the action.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.gamepad - The gamepad object associated with the event.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joysticks.
             * @param {Object} event.gamepad.pressed - The current pressed buttons on the gamepad.
             * @param {function} event.gamepad.setSpeed - Function to set the speed of the gamepad.
             * @param {number} event.value - The value to set the speed to.
             * @returns {boolean} Returns false if the left bump is pressed and no joysticks are present, otherwise returns the result of setting the speed.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'BumpRight': function (event) {
                if (event.type === 'press') {
                    if (!event.gamepad.hasJoysticks) {
                        if (event.gamepad.pressed['BumpLeft']) return false
                    } else {
                        return event.gamepad.setSpeed(event.value, false); // Pan speed down
                    }
                } else if (event.type === 'hold') {
                    
                } else if (event.type === 'release') {
                    
                }
            },
            /**
             * @function
             * @name TrigLeft
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles different types of events related to gamepad input, specifically press, hold, and release actions.
             *
             * @param {Object} event - The event object containing information about the gamepad input.
             * @param {string} event.type - The type of event, which can be 'press', 'hold', or 'release'.
             * @param {number} event.value - The value associated with the event, used when the event type is 'hold'.
             * @param {Object} event.gamepad - The gamepad object that provides methods for interaction.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'TrigLeft': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    event.gamepad.setZoom(event.value, true);
                } else if (event.type === 'release') {
                    
                }
            },
            /**
             * @function
             * @name TrigRight
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles different types of events related to gamepad interactions, including press, hold, and release actions.
             *
             * @param {Object} event - The event object containing details about the interaction.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {number} event.value - The value associated with the event, used when the event type is 'hold'.
             * @param {Object} event.gamepad - The gamepad object that provides methods for interaction.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'TrigRight': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    event.gamepad.setZoom(event.value, false);
                } else if (event.type === 'release') {
                    
                }
            },
            /**
             * @function
             * @name DpadUp
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles the D-pad up input events for gamepad controls, managing different actions based on the event type.
             *
             * @param {Object} event - The event object containing details about the input event.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.gamepad - The gamepad object associated with the event.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joysticks.
             * @param {Object} event.gamepad.pressed - An object representing the buttons currently pressed on the gamepad.
             * @param {function} event.gamepad.setPitch - Function to set the pitch based on the event value.
             * @param {function} event.gamepad.setCenter - Function to set the center based on the event value and camera options.
             * @param {Object} event.geoflo - The context object for accessing gamepad buttons.
             * @param {Object} event.geoflo.getButtons - Function to retrieve button states.
             * @param {Object} event.value - The value associated with the event.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'DpadUp': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    if (!event.gamepad.hasJoysticks) {
                        if (event.gamepad.pressed['BumpLeft'] && event.gamepad.pressed['BumpRight']) {
                            event.gamepad.setPitch(event.value, true); // Pitch map
                        } else {
                            event.gamepad.setCenter(event.value, event.gamepad.options.camera.free) // Pan map
                        }
                    }
                } else if (event.type === 'release') {
                    if (event.gamepad.hasJoysticks) {
                        event.geoflo.getButtons('Polygon').button.click();
                    }
                }
            },
            /**
             * @function
             * @name DpadDown
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles the D-pad down input event for gamepad controls, managing different actions based on the event type.
             *
             * @param {Object} event - The event object containing information about the input event.
             * @param {string} event.type - The type of the event (e.g., 'press', 'hold', 'release').
             * @param {Object} event.gamepad - The gamepad object that contains the state of the gamepad.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joystick controls.
             * @param {Object} event.gamepad.pressed - An object representing the buttons currently pressed on the gamepad.
             * @param {Function} event.gamepad.setPitch - Function to set the pitch based on the event value.
             * @param {Function} event.gamepad.setCenter - Function to set the center based on the event value and camera options.
             * @param {Object} event.geoflo - The context object for the gamepad.
             * @param {Object} event.geoflo.getButtons - Function to retrieve button states.
             * @param {Object} event.geoflo.getButtons('Circle') - The button object for the 'Circle' button.
             * @param {Function} event.geoflo.getButtons('Circle').button.click - Function to simulate a button click.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'DpadDown': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    if (!event.gamepad.hasJoysticks) {
                        if (event.gamepad.pressed['BumpLeft'] && event.gamepad.pressed['BumpRight']) {
                            event.gamepad.setPitch(event.value, false); // Pitch map
                        } else {
                            event.gamepad.setCenter(event.value, event.gamepad.options.camera.free) // Pan map
                        }
                    }
                } else if (event.type === 'release') {
                    if (event.gamepad.hasJoysticks) {
                        event.geoflo.getButtons('Circle').button.click();
                    }
                }
            },
            /**
             * @function
             * @name DpadLeft
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles the D-pad left input events for a gamepad, processing press, hold, and release actions.
             *
             * @param {Object} event - The event object containing details about the input action.
             * @param {string} event.type - The type of the event (press, hold, or release).
             * @param {Object} event.gamepad - The gamepad object associated with the event.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joysticks.
             * @param {Object} event.gamepad.pressed - An object representing the buttons currently pressed on the gamepad.
             * @param {Function} event.gamepad.setBearing - Function to set the bearing of the map.
             * @param {Function} event.gamepad.setCenter - Function to set the center of the map.
             * @param {Object} event.gamepad.options - Options related to the gamepad.
             * @param {Object} event.geoflo - The context object for the gamepad.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'DpadLeft': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    if (!event.gamepad.hasJoysticks) {
                        if (event.gamepad.pressed['BumpLeft'] && event.gamepad.pressed['BumpRight']) {
                            event.gamepad.setBearing(event.value, true); // Rotate map
                        } else {
                            event.gamepad.setCenter(event.value, event.gamepad.options.camera.free) // Pan map
                        }
                    }
                } else if (event.type === 'release') {
                    if (event.gamepad.hasJoysticks) {
                        event.geoflo.getButtons('Polyline').button.click();
                    }
                }
            },
            /**
             * @function
             * @name DpadRight
             * @memberof module:geoflo.Options.gamepad.mapping
             * @description Handles the D-pad right input events for gamepad controls, managing actions based on the type of event (press, hold, release).
             *
             * @param {Object} event - The event object containing details about the input event.
             * @param {string} event.type - The type of the event (press, hold, release).
             * @param {Object} event.gamepad - The gamepad object that contains the state of the gamepad.
             * @param {boolean} event.gamepad.hasJoysticks - Indicates if the gamepad has joystick controls.
             * @param {Object} event.gamepad.pressed - An object representing the buttons currently pressed on the gamepad.
             * @param {Function} event.gamepad.setBearing - Function to set the bearing of the map.
             * @param {Function} event.gamepad.setCenter - Function to set the center of the map.
             * @param {Object} event.gamepad.options - Options for the gamepad.
             * @param {Object} event.geoflo - The context object for the gamepad.
             * @returns {void} This function does not return a value.
             * 
             * @author Solutegrate
             * @copyright 2025
             */
            'DpadRight': function (event) {
                if (event.type === 'press') {
                    
                } else if (event.type === 'hold') {
                    if (!event.gamepad.hasJoysticks) {
                        if (event.gamepad.pressed['BumpLeft'] && event.gamepad.pressed['BumpRight']) {
                            event.gamepad.setBearing(event.value, false); // Rotate map
                        } else {
                            event.gamepad.setCenter(event.value, event.gamepad.options.camera.free) // Pan map
                        }
                    }
                } else if (event.type === 'release') {
                    if (event.gamepad.hasJoysticks) {
                        event.geoflo.getButtons('Rectangle').button.click();
                    }
                }
            }
        }
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Options);

/***/ }),

/***/ "./src/Painting.js":
/*!*************************!*\
  !*** ./src/Painting.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Painting
 * @description This module provides the painting functionality for the Geoflo application. It allows users to paint features on the map by creating a buffer around the feature and snapping to nearby features.
 * @param {Object} mode - The mode object containing the type of mode.
 * @returns {Object} Returns the Painting object.
 */
const Painting = function (mode) {
    const geoflo = this.geoflo;

    this.type = mode.type;
    this.feature = false;
    this.currentCoords = [];

	/**
	 * @function
     * @memberof module:geoflo.Painting
	 * @name activate
	 * @description Activates the painting functionality by enabling painting mode and clearing the source data.
	 * @returns {void}
	 */
    this.activate = function () {
        this.deactivate();
        this.enabled = true;
        geoflo.options['painting'].enable = true;
        geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([]));
    }

	/**
	 * @function
     * @memberof module:geoflo.Painting
	 * @name deactivate
	 * @description This function deactivates the current feature by setting the 'enabled' property to false, disabling the painting tool, enabling drag pan on the map, and deleting the feature.
	 * @returns {void}
	 */
    this.deactivate = function () {
        this.enabled = false;
        geoflo.options['painting'].enable = false;
        geoflo.map.dragPan.enable();
        delete this.feature;
    }

	/**
	 * @function
     * @memberof module:geoflo.Painting getFeature
	 * @name getFeature
	 * @description This function retrieves the current painted feature.
	 * @returns {any} The painted feature.
	 */
    this.getFeature = function () {
        return this.feature;
    }

	/**
	 * @function
     * @memberof module:geoflo.Painting
	 * @name setFeature
	 * @description This function creates a feature based on the given type and coordinates. It updates the currentCoords array, sets the feature, and triggers a 'painting.start' event.
	 * @param {Array} coords - The coordinates to set the feature at.
	 * @returns {Object} The created feature.
	 */
    this.setFeature = function (coords) {
        if (!this.type || !coords) return false;
        if (!geoflo.mouseIsDown) return geoflo.hotFeature;
        
        var type = this.type;
        var feature = setFeature(type, coords);

        if (!this.feature) {
            this.currentCoords = [];
            geoflo.startPoint = coords;
            geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([feature]));
            geoflo.fire('painting.start', { type: type, coords: coords, feature: feature });
        }

        this.currentCoords.push(coords);
        this.feature = feature;
        return this.feature;
    }

	/**
	 * @function
     * @memberof module:geoflo.Painting
	 * @name updateFeature
	 * @description This function updates the feature based on the provided coordinates. It handles different types of features like Rectangle, Circle, and others.
	 * @param {Array} coords - The coordinates to update the feature with.
	 * @returns {Object} The updated feature object.
	 */
    this.updateFeature = function (coords) {
        if (!this.enabled) return geoflo.hotFeature;
        if (!this.feature) return this.setFeature(coords);

        var feature = this.feature;
        var type = this.type;

        this.currentCoords.push(coords);

        if (type === 'Rectangle') {
            updateCoordinate(feature, "0.1", coords[0], geoflo.mouseIsDown[1]);
            updateCoordinate(feature, "0.2", coords[0], coords[1]);
            updateCoordinate(feature, "0.3", geoflo.mouseIsDown[0], coords[1]);
            updateCoordinate(feature, "0.4", geoflo.mouseIsDown[0], geoflo.mouseIsDown[1] );
        } else if (type === 'Circle') {
            var center = feature.properties.center;
            if (!center || !center.length) return feature;

            const distanceInKm = turf.distance(turf.point(center), turf.point(coords), { units : 'kilometers'});
            const circleFeature = turf.circle(center, distanceInKm);

            feature.geometry.coordinates = circleFeature.geometry.coordinates;
            geoflo.Utilities.setProperty(feature, 'radiusInKm', distanceInKm);
        } else {
            feature.geometry.coordinates.push(coords);
        }

        geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([this.feature]));
        geoflo.fire('painting.update', { type: type, coords: coords, feature: feature });
        return feature;
    }

	/**
	 * @function
     * @memberof module:geoflo.Painting
	 * @name handleUp
	 * @description This function updates the feature based on the 'mouse up' event. It retrieves the current feature, updates the hot source, clones the updated feature, and sets the last click coordinates.
	 * @param {Event} event - The event triggering the function.
	 * @returns {Promise<Object>} The updated feature object.
	 */
	
    this.handleUp = async function (event) {
        if (!this.feature) return false;

        var feature;

        if (geoflo.Exploring.enabled) this.feature = await geoflo.Exploring.getMatch(this.currentCoords, { set: true, start: geoflo.startPoint });

        feature = mode.updateHotSource(this.feature);
        feature = geoflo.Utilities.cloneDeep(feature);

        geoflo.lastClick = { coords: feature.geometry.coordinates[feature.geometry.coordinates.length - 1] };
        this.currentCoords = [];
        this.feature = feature;
        return feature;
    }



    if (geoflo.options['painting'].enable) this.activate();



    function setFeature (type, coords) {
        var feature;

        if (type === 'Rectangle') {
            feature = turf.polygon([[
                geoflo.mouseIsDown,
                coords,
                coords,
                geoflo.mouseIsDown
            ]]);
        } else if (type === 'Circle') {
            feature = turf.polygon([[
                geoflo.mouseIsDown,
                coords,
                coords,
                geoflo.mouseIsDown
            ]]);

            geoflo.Utilities.setProperty(feature, 'center', geoflo.mouseIsDown);
        } else {
            feature = turf.lineString([geoflo.mouseIsDown, coords]);
        }

        geoflo.Utilities.setProperty(feature, 'type', type);
        geoflo.Utilities.setProperty(feature, 'painting', 1);
        return feature;
    }

    function updateCoordinate (f, t, e, n) {
        var o = t.split(".")
            , r = parseInt(o[0], 10)
            , i = parseInt(o[1], 10);
        void 0 === f.geometry.coordinates[r] && (f.geometry.coordinates[r] = []),
        f.geometry.coordinates[r][i] = [e, n]
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Painting);

/***/ }),

/***/ "./src/Pinning.js":
/*!************************!*\
  !*** ./src/Pinning.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Pinning
 * @description This module provides the pinning functionality for the Geoflo application. It allows users to pin features to the map by creating a buffer around the feature and snapping to nearby features.
 * @param {Object} mode - The mode object containing the type of mode.
 * @returns {Object} Returns the Pinning object.
 */
const Pinning = function (mode) {
    const geoflo = this.geoflo;

    this.type = mode.type;
    this.updatedFeatures = [];

	/**
	 * @function
     * @memberof module:geoflo.Pinning
	 * @name activate
	 * @description Activates the feature by setting the enabled flag to true and enabling pinning in the options.
	 * @params {void} None
	 * @returns {void}
	 */
    this.activate = function () {
        this.updatedFeatures = [];
        this.enabled = true;
        geoflo.options['pinning'].enable = true;
    }

	/**
	 * @function
     * @memberof module:geoflo.Pinning
	 * @name deactivate
	 * @description This function deactivates the pinning feature by setting enabled to false, disabling pinning in options, clearing buffer, pinableFeatures, and pinningFeatures, and resetting updatedFeatures.
	 */
    this.deactivate = function () {
        this.enabled = false;
        geoflo.options['pinning'].enable = false;
        this.resetFeatures();
        delete this.buffer;
        delete geoflo.pinableFeatures;
        delete geoflo.pinningFeatures;
        this.updatedFeatures = [];
    }

	/**
	 * @function
     * @memberof module:geoflo.Pinning
	 * @name getFeatures
	 * @description Retrieves the features from the pinnedFeatures array in the context object.
	 * @returns {Array} An array of features extracted from the pinnedFeatures array.
	 */
    this.getFeatures = function () {
        var features = geoflo.pinnedFeatures && geoflo.pinnedFeatures.length ? geoflo.pinnedFeatures.map(function (feature) { return feature.feature }) : [];
        return features;
    }

	/**
	 * @function
     * @memberof module:geoflo.Pinning
	 * @name setBuffer
	 * @description This function creates a buffer around the provided coordinates based on the pinning buffer option.
	 * @param {Array<number>} coords - The coordinates [longitude, latitude] to create the buffer around.
	 * @returns {Object|boolean} Returns the buffer object containing the feature, radius, and coordinates if successful, otherwise false.
	 */
    this.setBuffer = function (coords) {
        delete this.buffer;

        if (!this.enabled) return false;
        if (!coords || !geoflo.options.pinning.buffer) return false;

        var buffer = turf.buffer(turf.point(coords), geoflo.options.pinning.buffer);
        var radius = turf.polygon(buffer.geometry.coordinates);

        this.buffer = {
            feature: buffer,
            radius: radius,
            coords: coords
        }

        return this.buffer;
    }

	/**
	 * @function
     * @memberof module:geoflo.Pinning
	 * @name setFeatures
	 * @description Sets the pinable features based on the provided coordinates and fires an event.
	 * @param {Object} coords - The coordinates to determine nearby features.
	 * @returns {Array} - An array of pinable features.
	 */
    this.setFeatures = function (coords) {
        geoflo.pinableFeatures = [];
        if (!this.enabled || !coords) return false;
        geoflo.pinableFeatures = this.getNearByFeatures(coords);
        geoflo.fire('pinning.add', { features: geoflo.pinableFeatures, buffer: this.buffer });
        return geoflo.pinableFeatures;
    }

	/**
	 * @function
     * @memberof module:geoflo.Pinning
	 * @name resetFeatures
	 * @description Resets the updated features by adding them to the canvas context.
	 * @returns {boolean} Returns false if there are no updated features to reset.
	 */
    this.resetFeatures = function () {
        if (!this.updatedFeatures.length) return false;
        geoflo.addFeatures(this.updatedFeatures, true);
    }

	/**
	 * @function
     * @memberof module:geoflo.Pinning
	 * @name updateFeatures
	 * @description This function updates the features if the pinning functionality is enabled. It updates the pinable features, pinned features, and triggers events accordingly.
	 * @returns {boolean} Returns false if the pinning functionality is not enabled, otherwise returns the updated pinning features.
	 */
    this.updateFeatures = function () {
        if (!this.enabled) return false;
        if (!geoflo.pinableFeatures || !geoflo.pinableFeatures.length) return delete geoflo.pinningFeatures, false;
        updateFeatures.call(this, geoflo.pinableFeatures);
        geoflo.Features.updateFeatures(geoflo.pinableFeatures, { type: 'pinning', coords: geoflo.snappedVertex, addUnits: true });
        geoflo.pinnedFeatures = geoflo.Utilities.cloneDeep(geoflo.pinableFeatures);
        geoflo.fire('pinning.update', { feature: geoflo.hotFeature, vertex: turf.point(geoflo.snappedVertex), features: geoflo.pinnedFeatures });
        return geoflo.pinningFeatures;
    }

	/**
	 * @function
     * @memberof module:geoflo.Pinning
	 * @name getNearByFeatures
	 * @description This function calculates the radius based on the map zoom level and retrieves nearby features within that radius.
	 * @param {Array<number>} coords - The coordinates [longitude, latitude] to find nearby features.
	 * @returns {Array<Object>} An array of nearby features with their IDs, types, indices, and feature objects.
	 */
    this.getNearByFeatures = function (coords) {
        if (!this.enabled || !coords) return false;

        var hotFeature = geoflo.hotFeature;
        var calculatedRadius = geoflo.options.snapping.distance * Math.pow(2, Math.max(1, 19 - geoflo.map.getZoom()));
        var radiusInKm = calculatedRadius / 100000;
        var buffer = this.setBuffer(coords);
        var features = geoflo.getRenderedDrawnFeatures({lng: coords[0], lat: coords[1]}, radiusInKm);
        var nearby = [];

        features.forEach(function (feature) {
            turf.coordEach(feature, function (coord, index) {
                var isNearby = false;
    
                if (buffer.radius && turf.booleanWithin(turf.point(coord), buffer.radius)) isNearby = true;
                if (!isNearby && buffer.coords && geoflo.Utilities.isPointEqual(coord, buffer.coords)) isNearby = true;
                if (!isNearby) return;
                if (hotFeature && hotFeature.id === feature.id) return;
                    
                nearby.push({
                    id: feature.id || feature.properties.id,
                    type: feature.properties.type,
                    index: index,
                    feature: feature
                })
            });
        });

        return nearby;
    }
    
    if (geoflo.options['pinning'].enable) this.activate();


    function updateFeatures(features) {
        if (!features || !features.length) return false;

        features.forEach(function (feature) {
            var pinned = this.updatedFeatures.find(function (f) { return f.id === feature.id });
            if (pinned) return;
            this.updatedFeatures.push(geoflo.Utilities.cloneDeep(feature.feature));
        }, this);
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Pinning);

/***/ }),

/***/ "./src/Routing.js":
/*!************************!*\
  !*** ./src/Routing.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Routing
 * @description This module provides the routing functionality for the Geoflo application. It allows users to calculate routes between two points on the map using a PathFinder object.
 * @param {Object} mode - The mode object containing the type of mode.
 * @returns {Object} Returns the Routing object.
 */
const Routing = function (mode) {
    const geoflo = this.geoflo;

    this.type = mode.type;
    this.graphData = {};
    this.features = geoflo.Features.getColdFeatures();

	/**
	 * @function
     * @memberof module:geoflo.Routing
	 * @name activate
	 * @description Activates the functionality by setting the 'enabled' property to true and enabling routing in the options.
	 * @params {void} None
	 * @returns {void}
	 */
    this.activate = function () {
        this.enabled = true;
        geoflo.options['routing'].enable = true;
    };

	/**
	 * @function
     * @memberof module:geoflo.Routing
	 * @name deactivate
	 * @description This function deactivates the routing feature by setting the enabled flag to false, disabling routing in the options, and clearing the route data on the map.
	 * @returns {void}
	 */
    this.deactivate = function () {
        this.enabled = false;
        geoflo.options['routing'].enable = false;
        geoflo.map.getSource(geoflo.statics.constants.sources['ROUTE']).setData(turf.featureCollection([]));
    };

	/**
	 * @function
     * @memberof module:geoflo.Routing
	 * @name getRoute
	 * @description This function calculates a route between two points on a map using a PathFinder object. It checks if the routing feature is enabled and if the map is not currently moving. It then creates a feature collection from the existing features, initializes a PathFinder object, and finds a path between the two points. The path is validated and then added to the map with a 'routing.add' event.
	 * @param {Object} fromPoint - The starting point for the route.
	 * @param {Object} toPoint - The destination point for the route.
	 * @returns {Array|boolean} The calculated route path as an array of points, or false if the route could not be calculated.
	 */
    this.getRoute = function (fromPoint, toPoint) {
        if (!this.enabled || geoflo.mapMoving) return false;
        var features = turf.featureCollection(this.getFeatures());
        var pathfinder = new PathFinder(features, geoflo.options.routing);
        var path = pathfinder.findPath ? pathfinder.findPath(fromPoint, toPoint) : false;
        path = validatePath(fromPoint, toPoint, path);
        geoflo.fire('routing.add', { from: fromPoint, to: toPoint, path: path });
        return path;
    };

	/**
	 * @function
     * @memberof module:geoflo.Routing
	 * @name getMatch
	 * @description Retrieves a match for the given coordinates using the Exploring service. Sets the match as a starting point for routing.
	 * @param {Object} coords - The coordinates for which to find a match.
	 * @returns {Promise<Object>} The matched feature with routing property set to true.
	 */
    this.getMatch = async function (coords) {
        var feature = await geoflo.Exploring.getMatch(coords, { set: true, start: geoflo.startPoint });
        feature.properties.routing = true;
        return feature;
    }

	/**
	 * @function
     * @memberof module:geoflo.Routing
	 * @name getClosest
	 * @description Calculates the closest point on a route based on the last click and the closest point to it.
	 * @returns {Object|boolean} Returns a GeoJSON LineString feature with routing property set to true if successful, otherwise false.
	 */
    this.getClosest = function () {
        if (!geoflo.closestPoint || !geoflo.lastClick) return false;
        var route = this.getRoute(geoflo.lastClick, geoflo.closestPoint);
        if (!route || !route.path) return false;
        var feature = turf.lineString(route.path);
        feature.properties.routing = true;
        return feature;
    };

	/**
	 * @function
     * @memberof module:geoflo.Routing
	 * @name getFeatures
	 * @description Retrieves features of type 'LineString' from the mesh index.
	 * @returns {Array} An array of features of type 'LineString'.
	 */
    this.getFeatures = function () {
        var mesh = geoflo.meshIndex.getFeatures();
        var features = [mesh, this.features].flat();
        return features.filter(function(feature) { return feature.geometry.type === 'LineString' });
    };

    
    if (geoflo.options['routing'].enable) this.activate();


    function PathFinder(features, options) {
        options = options || {};
        
        if (!features.compactedVertices) { features = preprocess(features, options); }

        this._graph = features;
        this._keyFn = options.keyFn || function(c) { return c.join(','); };
        this._precision = options.precision || 1e-5;
        this._options = options;
    
        if (Object.keys(this._graph.compactedVertices).filter(function(k) { return k !== 'edgeData'; }).length === 0) {
            return null;
        }

        this.findPath = function(a, b) {
            var start = this._keyFn(roundCoord(a.coords, this._precision)),
                finish = this._keyFn(roundCoord(b.coords, this._precision));
    
            if (!this._graph.vertices[start] || !this._graph.vertices[finish]) {
                return null;
            }
    
            var phantomStart = this._createPhantom(start);
            var phantomEnd = this._createPhantom(finish);
    
            var path = findPath(this._graph.compactedVertices, start, finish);
    
            if (path) {
                var weight = path[0];
                path = path[1];
                return {
                    fullPath: path,
                    path: path.reduce(function buildPath(cs, v, i, vs) {
                        if (i > 0) {
                            cs = cs.concat(this._graph.compactedCoordinates[vs[i - 1]][v]);
                        }
    
                        return cs;
                    }.bind(this), []).concat([this._graph.sourceVertices[finish]]),
                    weight: weight,
                    edgeDatas: this._graph.compactedEdges 
                        ? path.reduce(function buildEdgeData(eds, v, i, vs) {
                            if (i > 0) {
                                eds.push({
                                    reducedEdge: this._graph.compactedEdges[vs[i - 1]][v]
                                });
                            }
    
                            return eds;
                        }.bind(this), [])
                        : undefined
                };
            } else {
                return null;
            }
    
            this._removePhantom(phantomStart);
            this._removePhantom(phantomEnd);
        }

        this.serialize = function() {
            return this._graph;
        }

        this._createPhantom = function(n) {
            if (this._graph.compactedVertices[n]) return null;
    
            var phantom = compactNode(n, this._graph.vertices, this._graph.compactedVertices, this._graph.sourceVertices, this._graph.edgeData, true, this._options);
            this._graph.compactedVertices[n] = phantom.edges;
            this._graph.compactedCoordinates[n] = phantom.coordinates;
    
            if (this._graph.compactedEdges) {
                this._graph.compactedEdges[n] = phantom.reducedEdges;
            }
    
            Object.keys(phantom.incomingEdges).forEach(function(neighbor) {
                this._graph.compactedVertices[neighbor][n] = phantom.incomingEdges[neighbor];
                this._graph.compactedCoordinates[neighbor][n] = [this._graph.sourceVertices[neighbor]].concat(phantom.incomingCoordinates[neighbor].slice(0, -1));
                if (this._graph.compactedEdges) {
                    this._graph.compactedEdges[neighbor][n] = phantom.reducedEdges[neighbor];
                }
            }.bind(this))
    
            return n;
        }

        this._removePhantom = function(n) {
            if (!n) return;
    
            Object.keys(this._graph.compactedVertices[n]).forEach(function(neighbor) {
                delete this._graph.compactedVertices[neighbor][n];
            }.bind(this));
            Object.keys(this._graph.compactedCoordinates[n]).forEach(function(neighbor) {
                delete this._graph.compactedCoordinates[neighbor][n];
            }.bind(this));
            if (this._graph.compactedEdges) {
                Object.keys(this._graph.compactedEdges[n]).forEach(function(neighbor) {
                    delete this._graph.compactedEdges[neighbor][n];
                }.bind(this));
            }
    
            delete this._graph.compactedVertices[n];
            delete this._graph.compactedCoordinates[n];
    
            if (this._graph.compactedEdges) {
                delete this._graph.compactedEdges[n];
            }
        }
    };

    function ShortestPath () {
        var INFINITY = 1 / 0;
        this.vertices = {};
    
        this.addVertex = function (name, edges) {
            this.vertices[name] = edges;
        };
    
        this.setVertices = function (graph) {
            this.vertices = graph;
        };
    
        this.shortestPath = function (start, finish) {
            var nodes = new PriorityQueue(),
                distances = {},
                previous = {},
                path = [],
                smallest, vertex, neighbor, alt;
        
            for (vertex in this.vertices) {
                if (vertex === start) {
                    distances[vertex] = 0;
                    nodes.enqueue(0, vertex);
                } else {
                    distances[vertex] = INFINITY;
                    nodes.enqueue(INFINITY, vertex);
                }
        
                previous[vertex] = null;
            }
        
            while (!nodes.isEmpty()) {
                smallest = nodes.dequeue();
        
                if (smallest === finish) {
                    path = [];
            
                    while (previous[smallest]) {
                        path.push(smallest);
                        smallest = previous[smallest];
                    }
            
                    break;
                }
        
                if (!smallest || distances[smallest] === INFINITY) {
                    continue;
                }
        
                for (neighbor in this.vertices[smallest]) {
                    alt = distances[smallest] + this.vertices[smallest][neighbor];
        
                    if (alt < distances[neighbor]) {
                        distances[neighbor] = alt;
                        previous[neighbor] = smallest;
            
                        nodes.enqueue(alt, neighbor);
                    }
                }
            }
        
            return path;
        };
    };
    
    function PriorityQueue() {
        this._nodes = [];
    
        this.enqueue = function (priority, key) {
            this._nodes.push({key: key, priority: priority});
            this.sort();
        };
    
        this.dequeue = function () {
            return this._nodes.shift().key;
        };
    
        this.sort = function () {
            this._nodes.sort((a, b) => {
                return a.priority - b.priority;
            });
        };
    
        this.isEmpty = function () {
            return !this._nodes.length;
        };
    };

    function TinyQueue(data, compare) {
        if ( data === void 0 ) data = [];
        if ( compare === void 0 ) compare = function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        };
    
        this.data = data;
        this.length = this.data.length;
        this.compare = compare;
    
        if (this.length > 0) {
            for (var i = (this.length >> 1) - 1; i >= 0; i--) { this._down(i); }
        }
    
        this.push = function push (item) {
            this.data.push(item);
            this.length++;
            this._up(this.length - 1);
        };
        
        this.pop = function pop () {
            if (this.length === 0) { return undefined; }
        
            var top = this.data[0];
            var bottom = this.data.pop();
            this.length--;
        
            if (this.length > 0) {
                this.data[0] = bottom;
                this._down(0);
            }
        
            return top;
        };
        
        this.peek = function peek () {
            return this.data[0];
        };
        
        this._up = function _up (pos) {
            var ref = this;
                var data = ref.data;
                var compare = ref.compare;
            var item = data[pos];
        
            while (pos > 0) {
                var parent = (pos - 1) >> 1;
                var current = data[parent];
                if (compare(item, current) >= 0) { break; }
                data[pos] = current;
                pos = parent;
            }
        
            data[pos] = item;
        };
        
        this._down = function _down (pos) {
            var ref = this;
                var data = ref.data;
                var compare = ref.compare;
            var halfLength = this.length >> 1;
            var item = data[pos];
        
            while (pos < halfLength) {
                var left = (pos << 1) + 1;
                var best = data[left];
                var right = left + 1;
        
                if (right < this.length && compare(data[right], best) < 0) {
                    left = right;
                    best = data[right];
                }
                if (compare(best, item) >= 0) { break; }
        
                data[pos] = best;
                pos = left;
            }
        
            data[pos] = item;
        };
    };

    function findNextEnd(prev, v, vertices, ends, vertexCoords, edgeData, trackIncoming, options) {
        var weight = vertices[prev][v],
            reverseWeight = vertices[v][prev],
            coordinates = [],
            path = [],
            reducedEdge = options.edgeDataSeed;
            
        if (options.edgeDataReduceFn) {
            reducedEdge = options.edgeDataReduceFn(reducedEdge, edgeData[v][prev]);
        }
    
        while (!ends[v]) {
            var edges = vertices[v];
    
            if (!edges) { break; }
    
            var next = Object.keys(edges).filter(function notPrevious(k) { return k !== prev; })[0];
            weight += edges[next];
    
            if (trackIncoming) {
                reverseWeight += vertices[next][v];
    
                if (path.indexOf(v) >= 0) {
                    ends[v] = vertices[v];
                    break;
                }
                path.push(v);
            }
    
            if (options.edgeDataReduceFn) {
                reducedEdge = options.edgeDataReduceFn(reducedEdge, edgeData[v][next]);
            }
    
            coordinates.push(vertexCoords[v]);
            prev = v;
            v = next;
        }
    
        return {
            vertex: v,
            weight: weight,
            reverseWeight: reverseWeight,
            coordinates: coordinates,
            reducedEdge: reducedEdge
        };
    };
    
    function compactNode(k, vertices, ends, vertexCoords, edgeData, trackIncoming, options) {
        options = options || {};
        var neighbors = vertices[k];
        return Object.keys(neighbors).reduce(function compactEdge(result, j) {
            var neighbor = findNextEnd(k, j, vertices, ends, vertexCoords, edgeData, trackIncoming, options);
            var weight = neighbor.weight;
            var reverseWeight = neighbor.reverseWeight;
            if (neighbor.vertex !== k) {
                if (!result.edges[neighbor.vertex] || result.edges[neighbor.vertex] > weight) {
                    result.edges[neighbor.vertex] = weight;
                    result.coordinates[neighbor.vertex] = [vertexCoords[k]].concat(neighbor.coordinates);
                    result.reducedEdges[neighbor.vertex] = neighbor.reducedEdge;
                }
                if (trackIncoming && 
                    !isNaN(reverseWeight) && (!result.incomingEdges[neighbor.vertex] || result.incomingEdges[neighbor.vertex] > reverseWeight)) {
                    result.incomingEdges[neighbor.vertex] = reverseWeight;
                    var coordinates = [vertexCoords[k]].concat(neighbor.coordinates);
                    coordinates.reverse();
                    result.incomingCoordinates[neighbor.vertex] = coordinates;
                }
            }
            return result;
        }, {edges: {}, incomingEdges: {}, coordinates: {}, incomingCoordinates: {}, reducedEdges: {}});
    };
    
    function compactGraph(vertices, vertexCoords, edgeData, options) {
        options = options || {};
        var progress = options.progress;
        var ends = Object.keys(vertices).reduce(function findEnds(es, k, i, vs) {
            var vertex = vertices[k];
            var edges = Object.keys(vertex);
            var numberEdges = edges.length;
            var remove;
    
            if(options.compact === false)  {
                remove = false;
            } else if (numberEdges === 1) {
                var other = vertices[edges[0]];
                remove = !other[k];
            } else if (numberEdges === 2) {
                remove = edges.filter(function(n) {
                    return vertices[n][k];
                }).length === numberEdges;
            } else {
                remove = false;
            }
            
            if (!remove) {
                es[k] = vertex;
            }
    
            if (i % 1000 === 0 && progress) {
                progress('compact:ends', i, vs.length);
            }
    
            return es;
        }, {});
    
        return Object.keys(ends).reduce(function compactEnd(result, k, i, es) {
            var compacted = compactNode(k, vertices, ends, vertexCoords, edgeData, false, options);
            result.graph[k] = compacted.edges;
            result.coordinates[k] = compacted.coordinates;
    
            if (options.edgeDataReduceFn) {
                result.reducedEdges[k] = compacted.reducedEdges;
            }
    
            if (i % 1000 === 0 && progress) {
                progress('compact:nodes', i, es.length);
            }
    
            return result;
        }, {graph: {}, coordinates: {}, reducedEdges: {}});
    };
    
    function findPath(graph, start, end) {
        var costs = {};
        costs[start] = 0;
        var initialState = [0, [start], start];
        var queue = new TinyQueue([initialState], function(a, b) { return a[0] - b[0]; });
        var explored = {};
    
        while (queue.length) {
            var state = queue.pop();
            var cost = state[0];
            var node = state[2];
            if (node === end) {
                return state.slice(0, 2);
            }
    
            var neighbours = graph[node];
            Object.keys(neighbours).forEach(function(n) {
                var newCost = cost + neighbours[n];
                if (!(n in costs) || newCost < costs[n]) {
                    costs[n] = newCost;
                    var newState = [newCost, state[1].concat([n]), n];
                    queue.push(newState);
                }
            });
        }
    
        return null;
    };
    
    function preprocess(graph, options) {
        options = options || {};

        var topo;

        var weightFn = options.weightFn || function defaultWeightFn(a, b) {
            return turf.distance(turf.point(a), turf.point(b));
        }
    
        if (graph.type === 'FeatureCollection') {
            // Graph is GeoJSON data, create a topology from it
            topo = topology(graph, options);
        } else if (graph.edges) {
            // Graph is a preprocessed topology
            topo = graph;
        }
    
        var graph = topo.edges.reduce(function buildGraph(g, edge, i, es) {
            var a = edge[0],
                b = edge[1],
                props = edge[2],
                w = weightFn(topo.vertices[a], topo.vertices[b], props),
                makeEdgeList = function makeEdgeList(node) {
                    if (!g.vertices[node]) {
                        g.vertices[node] = {};
                        if (options.edgeDataReduceFn) {
                            g.edgeData[node] = {};
                        }
                    }
                },
                concatEdge = function concatEdge(startNode, endNode, weight) {
                    var v = g.vertices[startNode];
                    v[endNode] = weight;
                    if (options.edgeDataReduceFn) {
                        g.edgeData[startNode][endNode] = options.edgeDataReduceFn(options.edgeDataSeed, props);
                    }
                };
    
            if (w) {
                makeEdgeList(a);
                makeEdgeList(b);
                if (w instanceof Object) {
                    if (w.forward) {
                        concatEdge(a, b, w.forward);
                    }
                    if (w.backward) {
                        concatEdge(b, a, w.backward);
                    }
                } else {
                    concatEdge(a, b, w);
                    concatEdge(b, a, w);
                }
            }
    
            if (i % 1000 === 0 && options.progress) {
                options.progress('edgeweights', i,es.length);
            }
    
            return g;
        }, {edgeData: {}, vertices: {}});
    
        var compact = compactGraph(graph.vertices, topo.vertices, graph.edgeData, options);
    
        return {
            vertices: graph.vertices,
            edgeData: graph.edgeData,
            sourceVertices: topo.vertices,
            compactedVertices: compact.graph,
            compactedCoordinates: compact.coordinates,
            compactedEdges: options.edgeDataReduceFn ? compact.reducedEdges : null
        };
    };
    
    function roundCoord(c, precision) {
        return [
            Math.round(c[0] / precision) * precision,
            Math.round(c[1] / precision) * precision,
        ];
    };
    
    function geoJsonReduce(geojson, fn, seed) {
        if (geojson.type === 'FeatureCollection') {
            return geojson.features.reduce(function reduceFeatures(a, f) {
                return geoJsonReduce(f, fn, a);
            }, seed);
        } else {
            return fn(seed, geojson);
        }
    };
    
    function geoJsonFilterFeatures(geojson, fn) {
        var features = [];
        if (geojson.type === 'FeatureCollection') {
            features = features.concat(geojson.features.filter(fn));
        }
    
        return {
            type: 'FeatureCollection',
            features: features
        };
    };
    
    function isLineString(f) {
        return f.geometry.type === 'LineString';
    };
    
    function topology(geojson, options) {
        options = options || {};
        var keyFn = options.keyFn || function defaultKeyFn(c) {
                return c.join(',');
            },
            precision = options.precision || 1e-5;
    
        var lineStrings = geoJsonFilterFeatures(geojson, isLineString);
        var explodedLineStrings = turf.explode(lineStrings);
        var vertices = explodedLineStrings.features.reduce(function buildTopologyVertices(cs, f, i, fs) {
                var rc = roundCoord(f.geometry.coordinates, precision);
                cs[keyFn(rc)] = f.geometry.coordinates;
    
                if (i % 1000 === 0 && options.progress) {
                    options.progress('topo:vertices', i, fs.length);
                }
    
                return cs;
            }, {}),
            edges = geoJsonReduce(lineStrings, function buildTopologyEdges(es, f, i, fs) {
                f.geometry.coordinates.forEach(function buildLineStringEdges(c, i, cs) {
                    if (i > 0) {
                        var k1 = keyFn(roundCoord(cs[i - 1], precision)),
                            k2 = keyFn(roundCoord(c, precision));
                        es.push([k1, k2, f.properties]);
                    }
                });
    
                if (i % 1000 === 0 && options.progress) {
                    options.progress('topo:edges', i, fs.length);
                }
    
                return es;
            }, []);
        return {
            vertices: vertices,
            edges: edges
        };
    };

    function validatePath(fromPoint, toPoint, path) {
        if (toPoint && toPoint.type === 'linepoint') return false;
        //if (precision > 0.0005) return false;
        if (!path || !path.path || !path.path.length || path.path.length < 2) return false;
        return path;

        precision = Number((Number(precision) + 0.000002).toFixed(7));
        var pathfinder = new PathFinder(features, { precision: precision });
        var newPath = pathfinder.findPath(fromPoint, toPoint);
        return validatePath(fromPoint, toPoint, features, newPath);
    };
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Routing);

/***/ }),

/***/ "./src/Select.js":
/*!***********************!*\
  !*** ./src/Select.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Select
 * @description This module provides the select functionality for the Geoflo application. It allows users to select features on the map by clicking on them.
 * @returns {Object} Returns the Select object.
 */
const Select = function () {
    const geoflo = this.geoflo;

    var lastKnownSelectIds = [];
    var removedFeatures = [];
    var nearFeatures = [];
    var clickCoords;
    var multipleSelect;
    var selectedId;

    this.id = 'select';

    /**
	 * @function
     * @memberof module:geoflo.Select
	 * @name activate
	 * @description This function activates the select feature functionality by enabling drag pan, setting buttons, and setting the active button to 'select'. It also triggers a 'select.activate' event with the provided options.
	 * @param {Object} options - The options object for activation.
	 * @param {string} [options.id] - The ID of the feature to select.
	 * @param {Object} [options.feature] - The feature object to select.
	 * @returns {boolean} Returns false if already activated.
	 */
    this.activate = function (options={}) {
        if (this.activated) return false;
        if (geoflo.currentMode.id !== this.id) return options.mode = this.id, geoflo.setMode(options);

        this.activated = true;
        geoflo.map.dragPan.enable();
        geoflo.setButtons();
        geoflo.setActiveButton('select');
        geoflo.fire('select.activate', { activated: true, options: options })
        if (this.gamepad) {}
        geoflo.map.getSource(geoflo.statics.constants.sources.SELECT).setData(turf.featureCollection([]));
        setTimeout(function(e) { e.selectFeature(options.id ? options.id : options.feature ? options.feature.id : false) }, 5, this)
    };

	/**
	 * @function
     * @memberof module:geoflo.Select
	 * @name deactivate
	 * @description This function deactivates the current feature by setting the 'activated' flag to false and triggering necessary actions.
	 * @returns {boolean} Returns false if the feature is not activated.
	 */
    this.deactivate = function () {
        if (!this.activated) return false;

        this.activated = false;
        this.deselectCurrentFeature();
        
        geoflo.setButtons();
        geoflo.fire('select.deactivate', { activated: true });
    };

	/**
	 * @function
     * @memberof module:geoflo.Select
	 * @name canHandle
	 * @description This function determines if the given mode name is equal to the SELECT mode.
	 * @param {string} modeName - The mode name to be checked.
	 * @returns {boolean} Returns true if the mode name is SELECT, false otherwise.
	 */
    this.canHandle = function (modeName) {
        return geoflo.statics.constants.modes.SELECT === modeName;
    };

	/**
	 * @function
     * @memberof module:geoflo.Select
	 * @name selectFeature
	 * @description Selects a feature by its ID, adds it to the selected features list, and optionally adds a popup.
	 * @param {string} id - The ID of the feature to be selected.
	 * @returns {Array} - An array of removed features if wantingToEdit is false, otherwise returns the removed feature.
	 */
    this.selectFeature = function (id, options={}) {
        const popup = geoflo.options.select.popup;
        
        geoflo.map.getSource(geoflo.statics.constants.sources.SELECT).setData(turf.featureCollection([]));
        
        if (!id) return false;
        if (lastKnownSelectIds.indexOf(id) === -1) lastKnownSelectIds.push(id);
        //if (geoflo.hasSelection()) geoflo.forEachSelectedFeature((feature) => { });

        removedFeatures = geoflo.Features.removeFeatures(id, true);
        geoflo.addFeaturesToSelected(removedFeatures, options);
        popup ? this.addPopup(removedFeatures) : false;

        geoflo.fire('feature.select', { ids: geoflo.getSelectedFeatureIds(), features: geoflo.getSelectedFeatures() });
        if (!geoflo.wantingToEdit) return removedFeatures;
        if (removedFeatures.length == 1 && id === removedFeatures[0].id) editFeature(removedFeatures[0]);
        return removedFeatures;
    };

	/**
	 * @function
     * @memberof module:geoflo.Select
	 * @name deselectCurrentFeature
	 * @description Deselects the current feature by removing its selection.
	 */
    this.deselectCurrentFeature = function () {
        geoflo.removeSelection();
        geoflo.fire('feature.deselect', { ids: geoflo.getSelectedFeatureIds(), features: geoflo.getSelectedFeatures() });
    };

	/**
	 * @function
     * @memberof module:geoflo.Select
	 * @name addPopup
	 * @description This function creates a popup element with the specified features and adds it to the map at the click coordinates.
	 * @param {Object} features - The features to be displayed in the popup.
	 * @param {string} features.title - The title of the popup.
	 * @param {string} features.description - The description of the popup.
	 * @param {number} features.latitude - The latitude coordinate for the popup location.
	 * @param {number} features.longitude - The longitude coordinate for the popup location.
	 */
    this.addPopup = function (features) {
        this.popupElement = buildPopup(features);

        this.popup = new mapboxgl.Popup({ closeOnClick: false })
            .setLngLat(clickCoords)
            .setDOMContent(this.popupElement)
            .addTo(geoflo.map)
            .setOffset(12);

        this.popup._container.style['margin-bottom'] = '10px'
    };

	/**
	 * @function
     * @memberof module:geoflo.Select
	 * @name removePopup
	 * @description Removes the popup element from the DOM if it exists.
	 * @return {boolean} Returns true if the popup element was successfully removed, otherwise false.
	 */
    this.removePopup = function () {
        return this.popup && this.popup.remove ? this.popup.remove() : false;
    };

	/**
	 * @function
     * @memberof module:geoflo.Select
	 * @name handleMove
	 * @description Handles the mouse move event.
	 * @param {Event} event - The event object representing the mouse move event.
	 */
    this.handleMove = function (event) {
        //geoflo.setMapClass('pointer');
    };

	/**
	 * @function
     * @memberof module:geoflo.Select
	 * @name handleClick
	 * @description Handles the click event on the map and selects features based on the event.
	 * @param {Object} event - The event object containing information about the click event.
	 * @returns {boolean} Returns false if geoflo.noSelect is true, otherwise selects features based on the event.
	 */
    this.handleClick = function (event) {
        var features = geoflo.getRenderedDrawnFeatures(event.lngLat);

        clickCoords = [event.lngLat.lng, event.lngLat.lat];
        multipleSelect = event.originalEvent && event.originalEvent.shiftKey && geoflo.options.select.multiple;

        if (features.length > 0) {
            if (!geoflo.Layers.getSelection(features, clickCoords)) return;
            selectFeature.call(this, features);
        } else if (!multipleSelect) {
            lastKnownSelectIds = [];
            nearFeatures = [];
            clickCoords = false;
            selectedId = false;
            this.deselectCurrentFeature();
        }
    };

	/**
	 * @function
     * @memberof module:geoflo.Select
	 * @name handleDrag
	 * @description Handles the drag event triggered by a user interaction. It sets the map class to 'grabbing' to indicate dragging.
	 * @param {Event} event - The event object representing the drag event.
	 */
    this.handleDrag = function (event) {
        //geoflo.setMapClass('grabbing');
    }


    function buildPopup (features) {
        const element = document.createElement('div');
        element.classList.add('popup-table-holder');

        const table = buildTable(features);

        element.appendChild(table);

        if (nearFeatures.length > 1) {
            var button = document.createElement('div');
            button.classList.add('popup-table-button');
            button.innerHTML = `<button> Next </button>`;
            button.addEventListener('click', selectFeature.bind(this));
            element.appendChild(button);
        }

        return element;
        
        /* const button = document.createElement('div');
        button.innerHTML = `<button class="btn btn-success btn-simple text-white" > Assign</button>`;
        element.appendChild(button);
        button.addEventListener('click', (e) => { console.log('Button clicked' + name); }); */
    };

    function buildTable (features) {
        var table = document.createElement('table');
        var properties = ['id', 'type'];

        table.style.width = '100%';
        table.style.height = '100%';
        table.setAttribute('border', '1');
        table.classList.add('popup-table');

        var tableBody = document.createElement('tbody');

        features.forEach(function(feature, index) {
            var type = feature.properties.type;

            properties.forEach(function(prop) {
                tableBody.appendChild(buildRow(prop, feature.properties[prop]));
            })

            tableBody.appendChild(buildRow('geometry', feature.geometry.type));

            if (feature.geometry.type === 'LineString') {
                geoflo.Features.addUnits(feature, 'feet');
                tableBody.appendChild(buildRow('unit', feature.geometry.unit));
                tableBody.appendChild(buildRow('units', feature.geometry.units));
            } else if (type === 'Text') {
                tableBody.appendChild(buildRow('content', feature.properties.text));
            } else if (feature.geometry.type === 'Polygon') {
                geoflo.Features.addUnits(feature, 'acres');
                tableBody.appendChild(buildRow('unit', feature.geometry.unit));
                tableBody.appendChild(buildRow('units', feature.geometry.units));
            }
        })

        table.appendChild(tableBody);
        return table;
    };

    function buildRow (header, data) {
        var tr = document.createElement('tr');
        tr.classList.add('popup-table-row');

        if (header) {
            var th = document.createElement('th');
            th.classList.add('popup-table-header');
            th.appendChild(document.createTextNode(header));
            tr.appendChild(th);
        }
        
        var td = document.createElement('td');
        td.classList.add('popup-table-data');
        td.classList.add(header);
        td.appendChild(document.createTextNode(data));
        tr.appendChild(td);

        return tr;
    }

    function selectFeature (features) {
        multipleSelect = geoflo.options.select.multiple;
        nearFeatures = features;
        lastKnownSelectIds = lastKnownSelectIds === undefined ? [] : lastKnownSelectIds;

        if (features.length >= lastKnownSelectIds.length) {
            lastKnownSelectIds.splice(0, features.length - lastKnownSelectIds.length + 1);
        }

        var feat = features[0];
        selectedId = feat.id || feat.properties['id'];

        if (features.length > 1) {
            features.forEach((feature) => {
                const id = feature.id || feature.properties['id'];
                if (lastKnownSelectIds.indexOf(id) === -1) {
                    selectedId = id;
                    feat = feature;
                }
            });
        }

        if (!multipleSelect) geoflo.currentMode.deselectCurrentFeature();
        geoflo.currentMode.selectFeature(selectedId);
    }

    function editFeature (feature) {
        geoflo.wantingToEdit = false;
        geoflo.setMode('edit', feature.properties.type, feature);
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Select);

/***/ }),

/***/ "./src/Snapping.js":
/*!*************************!*\
  !*** ./src/Snapping.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Snapping
 * @description This module provides the snapping functionality for the Geoflo application. It allows users to snap features to the map by creating a buffer around the feature and snapping to nearby features.
 * @param {Object} mode - The mode object containing the type of mode.
 * @returns {Object} Returns the Snapping object.
 */
const Snapping = function (mode) {
    const geoflo = this.geoflo;
    this.type = mode.type;

	/**
	 * @function
     * @memberof module:geoflo.Snapping
	 * @name activate
	 * @description This function enables the object and sets the snapping option to true.
	 */
    this.activate = function () {
        this.enabled = true;
        geoflo.options['snapping'].enable = true;
    }

	/**
	 * @function
     * @memberof module:geoflo.Snapping
	 * @name deactivate
	 * @description This function sets the 'enabled' property to false, disables snapping, and updates the mesh data.
	 * @returns {void}
	 */
    this.deactivate = function () {
        this.enabled = false;
        geoflo.options['snapping'].enable = false;
        geoflo.updateMeshData([], true);
    }


	/**
	 * @function
     * @memberof module:geoflo.Snapping
	 * @name getClosest
	 * @description Finds the closest point to the given coordinates within a specified radius or pixel distance.
	 * @param {Array<number>} coords - The coordinates [longitude, latitude] to find the closest point to.
	 * @param {Array<Object>} features - An array of features to search for the closest point within.
	 * @returns {Object} An object containing the closest point and its coordinates.
	 */
    this.getClosest = function (coords, features) {
        var calculatedRadius = geoflo.options.snapping.distance * Math.pow(2, Math.max(1, 19 - geoflo.map.getZoom()));
        var radiusInKm = calculatedRadius / 100000;
        var pixelDistance = geoflo.options.snapping.pixels ? geoflo.options.snapping.pixels * metersPerPixel(coords[1], geoflo.map.getZoom()) : false;
        
        features = features ? geoflo.getRenderedSnapFeatures({ lng: coords[0], lat: coords[1] }, radiusInKm) : [geoflo.hotFeature];

        var closestPoint = findClosestPoint(features, coords, radiusInKm, pixelDistance);

        var coords = !closestPoint ? false :
            pixelDistance ? closestPoint.coords :
            closestPoint.type === 'vertex' && closestPoint.dist <= radiusInKm ? closestPoint.coords :
            false;
        
        return {
            point: closestPoint,
            coords: coords
        };
    }

	/**
	 * @function
     * @memberof module:geoflo.Snapping
	 * @name setClosest
	 * @description This function calculates the closest feature to the given coordinates within a specified radius and snapping parameters. It determines if the closest feature is a point or a vertex and returns the snapped feature accordingly.
	 * @param {Array<number>} coords - The coordinates [longitude, latitude] to find the closest feature to.
	 * @param {boolean} isPoint - Indicates if the feature is a point.
	 * @param {boolean} isVertex - Indicates if the feature is a vertex.
	 * @returns {Object} The snapped feature based on the calculated closest point or line.
	 */
    this.setClosest = function (coords, isPoint, isVertex) {
        var snapFeature = null;
        var calculatedRadius = geoflo.options.snapping.distance * Math.pow(2, Math.max(1, 19 - geoflo.map.getZoom()));
        var radiusInKm = calculatedRadius / 100000;
        var pixelDistance = geoflo.options.snapping.pixels ? geoflo.options.snapping.pixels * metersPerPixel(coords[1], geoflo.map.getZoom()) : false;
        var filter = geoflo.pinableFeatures && geoflo.pinableFeatures.length ? ['case', ['any', ...geoflo.pinableFeatures.map(e => ["==", ["get", "id"], e.id || e.properties.id])], false, true] : false;
        var nearFeatures = geoflo.getRenderedFeatures({ lng: coords[0], lat: coords[1] }, radiusInKm, filter);
        var closestPoint = nearFeatures && nearFeatures.length ? findClosestPoint(nearFeatures, coords, radiusInKm, pixelDistance) : false;
        var lastClickDistance, lastClickArray, lastClickEqual;

        geoflo.closestPoint = closestPoint;

        if ((!nearFeatures && !isPoint) || (!closestPoint && !isPoint)) return this.updateFeature(coords);
        if (!closestPoint || !closestPoint.coords) return snapFeature;

        if (isVertex || !geoflo.lastClick) {
            snapFeature = turf.point(closestPoint.coords);
        } else {
            lastClickArray = Array.isArray(geoflo.lastClick.coords) && Array.isArray(geoflo.lastClick.coords[0]);
            if (lastClickArray) geoflo.lastClick.coords = geoflo.lastClick.coords[0];

            lastClickDistance = turf.distance(turf.point(coords), turf.point(geoflo.lastClick.coords));
            lastClickEqual = geoflo.Utilities.isPointEqual(geoflo.lastClick.coords, closestPoint.coords);

            if (lastClickEqual && lastClickDistance > geoflo.options.snapping.tolerance) return this.updateFeature(coords);

            snapFeature = turf.lineString([geoflo.lastClick.coords, closestPoint.coords]);
        }

        geoflo.fire('snapping.add', { closest: closestPoint, snapped: snapFeature });
        return snapFeature;
    }


	/**
	 * @function
     * @memberof module:geoflo.Snapping
	 * @name setFeature
	 * @description This function sets a feature on the map using the provided feature and coordinates. It handles different scenarios such as creating a point, line, or polygon feature based on the input parameters.
	 * @param {Object} feature - The feature to be set on the map.
	 * @param {Array} coords - The coordinates for the feature.
	 * @returns {Object} The feature that was set on the map.
	 */
    this.setFeature = function (feature, coords) {
        if (geoflo.touchClick) return null;

        feature = feature || geoflo.snapFeature;
        
        if (!feature && coords) return setFeature(turf.point(coords));
        if (!feature) return geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([])), null;

        var snapCoords = feature.geometry.coordinates;
        var lastClick = coords || geoflo.lastClick.coords;
        var firstClick = geoflo.firstClick.coords;
        var isPolygon = this.type === 'Polygon' || feature.properties.type === 'Polygon';
        var isPolyline = feature.geometry.type === "LineString";

        if (!isPolyline || snapCoords.length < 2) {
            feature = setFeature(isPolygon ? turf.lineString([firstClick, lastClick]) : turf.point(lastClick));
        } else if (geoflo.hotFeature) {
            var hotCoords = geoflo.hotFeature.geometry.coordinates;
            if (isPolygon) snapCoords.pop();
            hotCoords.splice.apply(hotCoords, [-1, 1].concat(geoflo.Utilities.consumableArray(snapCoords)));
        } else {
            geoflo.hotFeature = turf.lineString(snapCoords);
        }

        geoflo.Utilities.setProperty(geoflo.hotFeature, 'type', this.type);

        feature = setFeature(isPolygon ? turf.lineString([firstClick, lastClick]) : turf.point(lastClick));
        geoflo.snapFeature = feature;
        return geoflo.snapFeature;
    }

	/**
	 * @function
     * @memberof module:geoflo.Snapping
	 * @name setVertex
	 * @description This function determines the vertex based on snapping and routing settings. It sets the closest feature when snapping is enabled and calculates the route if routing is enabled. It updates the map sources accordingly and triggers events related to vertex dragging and snapping.
	 * @param {Object} geoflo - The context object containing various settings and data.
	 * @returns {boolean} Returns false if snapping is disabled or no snapped vertex is available.
	 */
    this.setVertex = function () {
        var snapToFeature = geoflo.Snapping.enabled;
        if (geoflo.bypassSnapping) snapToFeature = false;

        var calculateRoute = geoflo.Routing.enabled;
        if (geoflo.bypassRouting) calculateRoute = false;

        if (!snapToFeature || !geoflo.snappedVertex) return false;

        geoflo.snapFeature = this.setClosest(geoflo.snappedVertex, true, true);

        if (calculateRoute) geoflo.snapFeature = geoflo.Routing.getClosest() || geoflo.snapFeature;
        if (!geoflo.snapFeature) return geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([]));

        geoflo.Utilities.setProperty(geoflo.snapFeature, 'type', geoflo.currentMode.type);
        geoflo.map.getSource(geoflo.statics.constants.sources[calculateRoute ? 'ROUTE' : 'SNAP']).setData(turf.featureCollection([geoflo.snapFeature]));

        geoflo.hotFeature.geometry.coordinates[geoflo.dragIndex] = geoflo.snapFeature.geometry.coordinates;
        geoflo.map.getSource(geoflo.statics.constants.sources.HOT).setData(turf.featureCollection([geoflo.hotFeature]));
        geoflo.fire('vertex.dragsnap', { feature: geoflo.hotFeature, vertex: turf.point(geoflo.snappedVertex) });
    }


	/**
	 * @function
     * @memberof module:geoflo.Snapping
	 * @name addFeature
	 * @description This function adds a feature to the map by setting the data of the specified source with the provided feature. It also updates the properties of the feature if properties are provided.
	 * @param {Object} feature - The feature to be added to the map.
	 * @param {Object} [properties={}] - Additional properties to be assigned to the feature.
	 * @param {boolean} [dontAdd] - Flag to prevent adding the feature if set to true.
	 * @returns {boolean} Returns false if the feature is not provided or if dontAdd flag is set.
	 */
    this.addFeature = function (feature, properties={}, dontAdd) {
        geoflo.map.getSource(geoflo.statics.constants.sources['SNAP']).setData(turf.featureCollection([]));
        geoflo.map.getSource(geoflo.statics.constants.sources['ROUTE']).setData(turf.featureCollection([]));
        if (!feature || dontAdd) return false;
        if (properties) feature.properties = geoflo.Utilities.assignDeep(geoflo.Utilities.cloneDeep(properties), feature.properties);
        geoflo.snapFeature = feature;
        geoflo.map.getSource(geoflo.statics.constants.sources[feature.properties.routing ? 'ROUTE' : 'SNAP']).setData(turf.featureCollection([geoflo.snapFeature]));
    }

	/**
	 * @function
     * @memberof module:geoflo.Snapping
	 * @name updateFeature
	 * @description This function updates a feature based on the event coordinates provided. It determines the type of feature, calculates the necessary coordinates, creates a line feature with hint properties, and converts units if needed.
	 * @param {Array} evtCoords - The event coordinates to update the feature.
	 * @returns {Object} The updated feature based on the event coordinates.
	 */
    this.updateFeature = function (evtCoords) {
        geoflo.closestPoint = null;
        if (!geoflo.lastClick) return null;
        if (!geoflo.firstClick || geoflo.mouseIsDown) return null;
    
        var type = geoflo.Features.getType(geoflo.hotFeature) || geoflo.currentMode.type;
        var coords = geoflo.hotFeature ? geoflo.Utilities.getLastIndexCoords(geoflo.hotFeature) : geoflo.lastClick.coords;
        var vertex = turf.point(evtCoords);
        var hintCoords = type && type === "Polygon" && geoflo.hotFeature ? [coords, evtCoords, geoflo.firstClick.coords] : [coords, evtCoords];
        var feature = turf.lineString(hintCoords);

        feature.properties.type = type;
        feature.properties.hint = true;
        
        var unit = 'feet';
        var units = geoflo.Features.convertUnits(geoflo.hotFeature, 0, unit);
        units += geoflo.Features.convertUnits(feature, 0, unit);
        vertex = updateVertex(vertex, { units: units, unit: unit });

        return feature;
    }




    if (geoflo.options['snapping'].enable) this.activate();




    function cheapRuler (lat, units) {
        function cheapruler(lat, units) {
            return new CheapRuler(lat,units);
        }
        
        cheapruler.fromTile = function(y, z, units) {
            var n = Math.PI * (1 - 2 * (y + 0.5) / Math.pow(2, z));
            var lat = Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))) * 180 / Math.PI;
            return new CheapRuler(lat,units);
        };
        
        cheapruler.units = {
            kilometers: 1,
            miles: 1000 / 1609.344,
            nauticalmiles: 1000 / 1852,
            meters: 1000,
            metres: 1000,
            yards: 1000 / 0.9144,
            feet: 1000 / 0.3048,
            inches: 1000 / 0.0254
        };
        
        function CheapRuler(lat, units) {
            var factors = {
                kilometers: 1,
                miles: 1000 / 1609.344,
                nauticalmiles: 1000 / 1852,
                meters: 1000,
                metres: 1000,
                yards: 1000 / 0.9144,
                feet: 1000 / 0.3048,
                inches: 1000 / 0.0254
            }
        
            if (lat === undefined)
                throw new Error('No latitude given.');
            if (units && !factors[units])
                throw new Error('Unknown unit ' + units + '. Use one of: ' + Object.keys(factors));
        
            var m = units ? factors[units] : 1;
        
            var cos = Math.cos(lat * Math.PI / 180);
            var cos2 = 2 * cos * cos - 1;
            var cos3 = 2 * cos * cos2 - cos;
            var cos4 = 2 * cos * cos3 - cos2;
            var cos5 = 2 * cos * cos4 - cos3;
        
            this.kx = m * (111.41513 * cos - 0.09455 * cos3 + 0.00012 * cos5);
            this.ky = m * (111.13209 - 0.56605 * cos2 + 0.0012 * cos4);
        }
        
        CheapRuler.prototype = {
            equals: function (a, b) {
                return a[0] === b[0] && a[1] === b[1];
            },
      
            interpolate: function (a, b, t) {
                var dx = b[0] - a[0];
                var dy = b[1] - a[1];
                return [a[0] + dx * t, a[1] + dy * t];
            },
      
            distance: function(a, b) {
                var dx = (a[0] - b[0]) * this.kx;
                var dy = (a[1] - b[1]) * this.ky;
                return Math.sqrt(dx * dx + dy * dy);
            },
        
            bearing: function(a, b) {
                var dx = (b[0] - a[0]) * this.kx;
                var dy = (b[1] - a[1]) * this.ky;
                if (!dx && !dy)
                    return 0;
                var bearing = Math.atan2(-dy, dx) * 180 / Math.PI + 90;
                if (bearing > 180)
                    bearing -= 360;
                return bearing;
            },
        
            destination: function(p, dist, bearing) {
                var a = (90 - bearing) * Math.PI / 180;
                return this.offset(p, Math.cos(a) * dist, Math.sin(a) * dist);
            },
        
            offset: function(p, dx, dy) {
                return [p[0] + dx / this.kx, p[1] + dy / this.ky];
            },
        
            lineDistance: function(points) {
                var total = 0;
                for (var i = 0; i < points.length - 1; i++) {
                    total += this.distance(points[i], points[i + 1]);
                }
                return total;
            },
        
            area: function(polygon) {
                var sum = 0;
        
                for (var i = 0; i < polygon.length; i++) {
                    var ring = polygon[i];
        
                    for (var j = 0, len = ring.length, k = len - 1; j < len; k = j++) {
                        sum += (ring[j][0] - ring[k][0]) * (ring[j][1] + ring[k][1]) * (i ? -1 : 1);
                    }
                }
        
                return (Math.abs(sum) / 2) * this.kx * this.ky;
            },
        
            along: function(line, dist) {
                var sum = 0;
        
                if (dist <= 0)
                    return line[0];
        
                for (var i = 0; i < line.length - 1; i++) {
                    var p0 = line[i];
                    var p1 = line[i + 1];
                    var d = this.distance(p0, p1);
                    sum += d;
                    if (sum > dist)
                        return this.interpolate(p0, p1, (dist - (sum - d)) / d);
                }
        
                return line[line.length - 1];
            },
        
            pointOnLine: function(line, p) {
                var minDist = Infinity;
                var minX, minY, minI, minT;
        
                for (var i = 0; i < line.length - 1; i++) {
        
                    var x = line[i][0];
                    var y = line[i][1];
                    var dx = (line[i + 1][0] - x) * this.kx;
                    var dy = (line[i + 1][1] - y) * this.ky;
        
                    if (dx !== 0 || dy !== 0) {
        
                        var t = ((p[0] - x) * this.kx * dx + (p[1] - y) * this.ky * dy) / (dx * dx + dy * dy);
        
                        if (t > 1) {
                            x = line[i + 1][0];
                            y = line[i + 1][1];
        
                        } else if (t > 0) {
                            x += (dx / this.kx) * t;
                            y += (dy / this.ky) * t;
                        }
                    }
        
                    dx = (p[0] - x) * this.kx;
                    dy = (p[1] - y) * this.ky;
        
                    var sqDist = dx * dx + dy * dy;
                    if (sqDist < minDist) {
                        minDist = sqDist;
                        minX = x;
                        minY = y;
                        minI = i;
                        minT = t;
                    }
                }
        
                return {
                    point: [minX, minY],
                    index: minI,
                    t: minT
                };
            },
        
            lineSlice: function(start, stop, line) {
                var p1 = this.pointOnLine(line, start);
                var p2 = this.pointOnLine(line, stop);
        
                if (p1.index > p2.index || (p1.index === p2.index && p1.t > p2.t)) {
                    var tmp = p1;
                    p1 = p2;
                    p2 = tmp;
                }
        
                var slice = [p1.point];
        
                var l = p1.index + 1;
                var r = p2.index;
        
                if (!this.equals(line[l], slice[0]) && l <= r)
                    slice.push(line[l]);
        
                for (var i = l + 1; i <= r; i++) {
                    slice.push(line[i]);
                }
        
                if (!this.equals(line[r], p2.point))
                    slice.push(p2.point);
        
                return slice;
            },
        
            lineSliceAlong: function(start, stop, line) {
                var sum = 0;
                var slice = [];
        
                for (var i = 0; i < line.length - 1; i++) {
                    var p0 = line[i];
                    var p1 = line[i + 1];
                    var d = this.distance(p0, p1);
        
                    sum += d;
        
                    if (sum > start && slice.length === 0) {
                        slice.push(this.interpolate(p0, p1, (start - (sum - d)) / d));
                    }
        
                    if (sum >= stop) {
                        slice.push(this.interpolate(p0, p1, (stop - (sum - d)) / d));
                        return slice;
                    }
        
                    if (sum > start)
                        slice.push(p1);
                }
        
                return slice;
            },
        
            bufferPoint: function(p, buffer) {
                var v = buffer / this.ky;
                var h = buffer / this.kx;
                return [p[0] - h, p[1] - v, p[0] + h, p[1] + v];
            },
        
            bufferBBox: function(bbox, buffer) {
                var v = buffer / this.ky;
                var h = buffer / this.kx;
                return [bbox[0] - h, bbox[1] - v, bbox[2] + h, bbox[3] + v];
            },
        
            insideBBox: function(p, bbox) {
                return p[0] >= bbox[0] && p[0] <= bbox[2] && p[1] >= bbox[1] && p[1] <= bbox[3];
            }
        }
      
        return cheapruler(lat, units);
    }

    function findClosestPoint (uniqueFeatures, evtCoords, radiusInKm, pixelDistance) {
        const coords = calculatePointsOnLine(uniqueFeatures, evtCoords);
  
        let closestVertex = null;
        let closestLinepoint = null;
        let borders;
        let id = geoflo.id || 'id';
  
        coords.forEach((pointType) => {
            const dist = pointType.dist;
  
            if (dist !== null) {
                if (pointType.type === "vertex") {
                    if (closestVertex === null) {
                        closestVertex = pointType;
                    } else if (pixelDistance !== undefined) {
                        if (dist * 1000 < pixelDistance) {
                            if (closestVertex && closestVertex.lineEdge) {
                                closestVertex = pointType;
                            }
                        }
                    } else if (dist <= closestVertex.dist) {
                        if (dist === closestVertex.dist) {
                            if (closestVertex.lineEdge) {
                                closestVertex = pointType;
                            }
                        } else {
                            closestVertex = pointType;
                        }
                    }
                } else if (dist < radiusInKm) {
                    if (closestLinepoint !== null && dist === closestLinepoint.dist && closestLinepoint[id] !== pointType[id]) {
                        if (closestLinepoint.type === "linepoint") {
                            if ((pointType.distance1 <= closestLinepoint.distance1 && pointType.distance2 <= closestLinepoint.distance2) ||
                                (pointType.distance2 <= closestLinepoint.distance1 && pointType.distance1 <= closestLinepoint.distance2)) {
                                console.log("switch closest points");
                                closestLinepoint = pointType;
                            }
                        }
                    }
  
                    if (closestLinepoint === null || dist < closestLinepoint.dist) {
                        closestLinepoint = pointType;
  
                        if (pointType.border1 && pointType.border2) {
                            borders = {
                                border1: pointType.border1,
                                border2: pointType.border2,
                                distance1: pointType.distance1,
                                distance2: pointType.distance2
                            };
                        } else {
                            borders = null;
                        }
                    }
                }
            }
        });
  
        if (closestVertex !== null) {
            if (closestLinepoint !== null) {
                if (closestVertex.dist < radiusInKm) {
                    return Object.assign({ borders: null }, closestVertex);
                } else {
                    return Object.assign({ borders: borders }, closestLinepoint);
                }
            } else {
                return Object.assign({ borders: null }, closestVertex);
            }
        } else if (closestLinepoint !== null) {
            return Object.assign({ borders: borders }, closestLinepoint);
        } else {
            return null;
        }
    }

    function closestPoints (ruler, coordinates, evtCoords) {
        const result = [];
        const pointOnLine = ruler.pointOnLine(coordinates, evtCoords);
        const pointCoords = pointOnLine.point;
        const pointIndex = pointOnLine.index;
        const linePoint = { type: "linepoint", coords: pointCoords };
        const p1 = coordinates[pointIndex];
        const p2 = coordinates[pointIndex + 1];
        const distance1 = ruler.distance(p1, evtCoords);
        const distance2 = ruler.distance(p2, evtCoords);

        let lineEdge = false;
        let vertex = null;
    
        if (distance1 < distance2) {
            lineEdge = pointIndex === 0;
            vertex = p1;
        } else {
            lineEdge = pointIndex + 1 === coordinates.length - 1;
            vertex = p2;
        }
    
        linePoint.border1 = p1;
        linePoint.distance1 = distance1;
        linePoint.border2 = p2;
        linePoint.distance2 = distance2;
    
        result.push(linePoint);
        result.push({ type: "vertex", coords: vertex, lineEdge: lineEdge });
        return result;
    }

    function calculatePointsOnLine (uniqueFeatures, evtCoords) {
        const coords = [];
        const knownIds = {};
        const ruler = cheapRuler(evtCoords[1]);
    
        uniqueFeatures.forEach((feature) => {
            const id = feature.id || feature.properties.id;
            var closest = [];
    
            if (knownIds[id] === undefined) {
                knownIds[id] = true;
                const type = feature.geometry.type;
    
                if (type === "LineString") {
                    if (feature.geometry.coordinates) {
                        closest = closestPoints(ruler, feature.geometry.coordinates, evtCoords);
  
                        closest.forEach((pointType) => {
                            pointType.id = id;
                            pointType.dist = ruler.distance(pointType.coords, evtCoords);
                            coords.push(pointType);
                        });
                    } else {
                        console.log("no coordinates: ", feature);
                    }
                } else if (type === "Point") {
                    const pointType = { id: id, type: "vertex", coords: feature.geometry.coordinates, lineEdge: true };
                    pointType.dist = ruler.distance(pointType.coords, evtCoords);
                    coords.push(pointType);
                } else if (type === "Polygon") {
                    if (turf.booleanWithin(turf.point(evtCoords), feature)) return;
                    
                    feature.geometry.coordinates.forEach((featureCoords, index) => {
                        closest = closestPoints(ruler, featureCoords, evtCoords);
  
                        closest.forEach((pointType) => {
                            pointType.id = id;
                            pointType.polygonCoordsArray = index;
                            pointType.dist = ruler.distance(pointType.coords, evtCoords);
                            coords.push(pointType);
                        });
                    });
                }
            }
        });
    
        return coords;
    }

    function addVertex (startPoint, endPoint, length, data) {
        var startData = data[startPoint];
    
        if (!startData) {
            startData = {};
            data[startPoint] = startData;
        }
    
        if (!startData[endPoint]) {
            startData[endPoint] = length;
        }
    }

    function addVertexPointTwoWay (startCoord, endCoords, length, data) {
        var startPoint = startCoord.join("#");
        var endPoint = endCoords.join("#");
        addVertex(startPoint, endPoint, length, data);
        addVertex(endPoint, startPoint, length, data);
    }
    
    function metersPerPixel (latitude, zoomLevel) {
        return ((geoflo.statics.constants.CIRCUM * Math.cos((latitude * (Math.PI / 180)))) / Math.pow(2, zoomLevel + 8));
    }
    
    function setFeature (feature) {
        if (!feature) return geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([])), geoflo.snapFeature;
        geoflo.Utilities.setProperty(feature, 'type', geoflo.currentMode.type);
        geoflo.map.getSource(geoflo.statics.constants.sources.SNAP).setData(turf.featureCollection([feature]));
        return feature;
    }

    function updateVertex (vertex, options={}) {
        var features = geoflo.map.getSource(geoflo.statics.constants.sources.HOTTEXT)._data.features;
        if (features.length && features[features.length - 1].properties.mouseLine) features.pop();

        vertex.properties.units = options.units;
        vertex.properties.unit = options.unit;
        vertex.properties.text = `${options.units} ${options.unit}`;
        vertex.properties.transform = 'uppercase';
        vertex.properties.anchor = 'top-left';
        vertex.properties.mouseLine = true;
    
        features.push(vertex);
        geoflo.map.getSource(geoflo.statics.constants.sources.HOTTEXT).setData(turf.featureCollection(features));
        return vertex;
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Snapping);

/***/ }),

/***/ "./src/Statics.js":
/*!************************!*\
  !*** ./src/Statics.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const Dev = 'solutegrate';
const Id = 'geoflo';

const Statics = {
    developer: Dev,
    id: Id,
    logo: {
        full: `https://${Id}.s3.amazonaws.com/logos/logo_full_white.png`,
        icon: `https://${Id}.s3.amazonaws.com/logos/logo_icon_white.svg`,
        fullClass: Id + '-logo',
        iconClass: Id + '-icon'
    },
    controls: [
        // TOP //
        [{
            type: 'utils',
            enable: true,
            position: 'top-center',
            group: 'action',
            divider: true,
            show: true,
            buttons: {
                repeat: true,
                zoom: true,
                refresh: true,
                locate: true
            }
        },
        {
            type: 'modes',
            enable: true,
            group: 'control',
            divider: true,
            show: true,
            buttons: {
                select: true,
                edit: true,
                save: true
            }
        },
        {
            type: 'options',
            enable: true,
            group: 'action',
            divider: false,
            show: true,
            buttons: {
                import: true,
                export: true,
                clear: true,
                undo: true,
                redo: true,
                cancel: true
            }
        }],

        // BOTTOM //
        [{
            type: 'types',
            enable: true,
            position: 'top-center',
            group: 'control',
            divider: true,
            show: true,
            buttons: {
                polyline: true,
                polygon: true,
                rectangle: true,
                circle: true,
                text: true
            }
        },
        {
            type: 'actions',
            enable: true,
            group: 'control',
            divider: false,
            show: true,
            buttons: {
                snapping: true,
                pinning: true,
                routing: true,
                exploring: true,
                painting: true
            }
        }]
    ],
    constants: {
        classes: {
            PREDEFINED_CONTROL_BASE: "mapboxgl-ctrl",
            PREDEFINED_CONTROL_GROUP: "mapboxgl-ctrl-group",
            CONTROL_PREFIX: "mapboxgl-ctrl-",
            ACTION_BUTTON: Id + "-action-btn",
            CONTROL_BUTTON: "mapbox-gl-draw_ctrl-draw-btn",
            CONTROL_BUTTON_LINE: "mapbox-gl-draw_line",
            CONTROL_BUTTON_POLYGON: "mapbox-gl-draw_polygon",
            CONTROL_BUTTON_RECTANGLE: "mapbox-gl-draw_rectangle",
            CONTROL_BUTTON_POINT: "mapbox-gl-draw_point",
            CONTROL_BUTTON_TEXT: "mapbox-gl-draw_text",
            CONTROL_BUTTON_ICON: "mapbox-gl-draw_icon",
            CONTROL_BUTTON_CLEAR: Id + "-delete-data",
            CONTROL_BUTTON_DELETE_SNAP: Id + "-delete-snap-data",
            CONTROL_BUTTON_LOCATE: Id + "-locate",
            CONTROL_BUTTON_ZOOM_IN_FEATURES: Id + "-zoom-in-features",
            CONTROL_BUTTON_HIDE_SELECTED: Id + "-hide-selected",
            CONTROL_BUTTON_ADD_FEATURE_TO_GRID: Id + "-add-feature-to-grid",
            CONTROL_BUTTON_CREATE_POLYGON: Id + "-create-polygon",
            CONTROL_BUTTON_COMBINE_FEATURES: "mapbox-gl-draw_combine",
            CONTROL_BUTTON_UNCOMBINE_FEATURES: "mapbox-gl-draw_uncombine",
            CONTROL_BUTTON_GROUP_FEATURES: Id + "-group-features",
            CONTROL_BUTTON_UNGROUP_FEATURES: Id + "-ungroup-features",
            CONTROL_BUTTON_DOWNLOAD_WAYS: Id + "-download-ways",
            CONTROL_BUTTON_DOWNLOAD_BUILDINGS: Id + "-download-buildings",
            CONTROL_BUTTON_REFRESH: Id + "-refresh",
            CONTROL_BUTTON_EDIT: Id + "-edit",
            CONTROL_BUTTON_CUT: Id + "-cut",
            CONTROL_BUTTON_SELECT: Id + "-select",
            CONTROL_BUTTON_DOWNLOAD_DATA: Id + "-download-data",
            CONTROL_BUTTON_EXPORT: Id + "-export",
            CONTROL_BUTTON_SAVE_AS_GIST: Id + "-save-as-gist",
            CONTROL_BUTTON_SAVE_AS_GEOJSON: Id + "-save-as-geojson",
            CONTROL_BUTTON_SAVE_AS_KML: Id + "-save-as-kml",
            CONTROL_BUTTON_EXPAND_EDITOR: Id + "-expand-editor",
            CONTROL_BUTTON_IMPORT: Id + "-import",
            CONTROL_BUTTON_FINSIH: Id + "-finish",
            CONTROL_BUTTON_CANCEL: Id + "-cancel",
            CONTROL_BUTTON_UNDO: Id + "-undo",
            CONTROL_BUTTON_REDO: Id + "-redo",
            CONTROL_BUTTON_SNAPPING: Id + "-snapping",
            CONTROL_BUTTON_PINNING: Id + "-pinning",
            CONTROL_BUTTON_ROUTING: Id + "-routing",
            CONTROL_BUTTON_EXPLORING: Id + "-exploring",
            CONTROL_BUTTON_PAINTING: Id + "-painting",
            CONTROL_BUTTON_REPEAT: Id + "-repeat",
            CONTROL_GROUP: Id + "-ctrl-group",
            DROPDOWN_GROUP: Id + "-dropdown-group",
            DIVIDER: Id + "-divider",
            ACTION_GROUP: Id + "-action-group",
            ATTRIBUTION: "mapboxgl-ctrl-attrib",
            ACTIVE_BUTTON: "active",
            BOX_SELECT: "mapbox-gl-draw_boxselect",
        },
        sources: {
            SELECT: Id + "-select",
            SNAP: Id + "-snap",
            ROUTE: Id + "-route",
            HOT: Id + "-hot",
            COLD: Id + "-cold",
            MESH: Id + "-mesh",
            VERTEX: Id + "-vertex",
            HOTTEXT: Id + "-text",
            COLDTEXT: Id + "-coldtext",
            GAMEPAD: Id + "-gamepad"
        },
        layers: {
            MESH: Id + "-mesh"
        },
        cursors: {
            ADD: "add",
            MOVE: "move",
            DRAG: "drag",
            POINTER: "pointer",
            NONE: "none",
        },
        types: {
            POLYGON: "polygon",
            LINE: "line_string",
            POINT: "point",
        },
        geojsonTypes: {
            FEATURE: "Feature",
            POLYGON: "Polygon",
            LINE_STRING: "LineString",
            POINT: "Point",
            FEATURE_COLLECTION: "FeatureCollection",
            MULTI_PREFIX: "Multi",
            MULTI_POINT: "MultiPoint",
            MULTI_LINE_STRING: "MultiLineString",
            MULTI_POLYGON: "MultiPolygon",
        },
        modes: {
            DRAW: "draw",
            CUT: "cut",
            SELECT: "select",
            DELETE: "delete",
            EDIT: "edit"
        },
        events: {
            CREATE: "draw.create",
            DELETE: "draw.delete",
            UPDATE: "draw.update",
            SELECTION_CHANGE: "draw.selectionchange",
            MODE_CHANGE: "draw.modechange",
            ACTIONABLE: "draw.actionable",
            RENDER: "draw.render",
            COMBINE_FEATURES: "draw.combine",
            UNCOMBINE_FEATURES: "draw.uncombine",
        },
        updateActions: {
            MOVE: "move",
            CHANGE_COORDINATES: "change_coordinates",
        },
        meta: {
            FEATURE: "feature",
            MIDPOINT: "midpoint",
            VERTEX: "vertex",
        },
        activeStates: {
            ACTIVE: "true",
            INACTIVE: "false",
        },
        LAT_MIN: -90,
        LAT_RENDERED_MIN: -85,
        LAT_MAX: 90,
        LAT_RENDERED_MAX: 85,
        LNG_MIN: -270,
        LNG_MAX: 270,
        MIN_SEGMENT_LENGTH: 0.000001,
        MIN_DISTANCE: 0.00001, // 0.000001
        CIRCUM: 40075017
    }
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Statics);

/***/ }),

/***/ "./src/Styles.js":
/*!***********************!*\
  !*** ./src/Styles.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Styles
 * @description This module provides the styling functionality for the Geoflo application. It allows users to change the map style by selecting from a list of predefined styles.
 * @param {Object} options - The options object containing the styles and selected style.
 * @returns {Object} Returns the Styles object.
 */
const Styles = function (options={}) {
    const geoflo = this.geoflo;
    this.options = options;
    
    /**
	 * @function
     * @memberof module:geoflo.Styles
     * @name init
     * @description Initializes the Styles object by extending the options object with the provided options, setting the styles, defaultStyle, and event listeners.
     * @param {Object} options - The options object containing the styles and selected style.
     * @returns {Object} Returns the Styles object.
     */
    this.init = function (options={}) {
        geoflo.Utilities.extend(this.options, options);

        this.styles = this.options.styles || [
            { title: "Standard", uri: "mapbox://styles/solutegrate/clxdoec8x006901qj7wjf8uxo" },
            { title: "Satellite", uri: "mapbox://styles/mapbox/satellite-streets-v11" },
            { title: "Standard", uri: "mapbox://styles/mapbox/standard" },
            { title: "Dark", uri: "mapbox://styles/mapbox/dark-v11" },
            { title: "Light", uri: "mapbox://styles/mapbox/light-v11" },
            { title: "Outdoors", uri: "mapbox://styles/mapbox/outdoors-v11" }
        ];
    
        this.selected = this.options.selected || "Standard";
        this.onDocumentClick = this.onDocumentClick.bind(this);
        this.events = this.options.eventListeners;
        return this;
    }

    /**
	 * @function
     * @memberof module:geoflo.Styles
     * @name select
     * @description Selects the style with the provided name by setting the map style to the style's uri.
     * @param {String} name - The name of the style to select.
     * @returns {void}
     */
    this.select = function (name) {
        if (!this.mapStyleContainer || !this.mapStyleContainer.checkVisibility()) {
            var style = this.styles.find(style => style.title === name);
            if (style) this.map.setStyle(style.uri), this.selected = name;
            if (this.events && this.events.onChange && this.events.onChange({ style: style }, style))
            return;
        }

        const elms = this.mapStyleContainer.getElementsByClassName(name);
        if (elms.length > 0) elms[0].click();
    }

    /**
	 * @function
     * @memberof module:geoflo.Styles
     * @name hide
     * @description Hides the style control container.
     * @returns {void}
     */
    this.hide = function () {
        if (this.controlContainer) this.controlContainer.style.display = "none";
    }

    /**
     * @function
     * @memberof module:geoflo.Styles
     * @name show
     * @description Shows the style control container.
     * @returns {void}
     */
    this.show = function () {
        if (this.controlContainer) this.controlContainer.style.display = "block";
    }

    /**
	 * @function
     * @memberof module:geoflo.Styles
     * @name getDefaultPosition
     * @description Returns the default position for the style control container.
     * @returns {String} The default position for the style control container.
     */
    this.getDefaultPosition = function () {
        const defaultPosition = "top-right";
        return defaultPosition;
    }

    /**
	 * @function
     * @memberof module:geoflo.Styles
     * @name onAdd
     * @description Adds the style control container to the map.
     * @param {Object} map - The map object to add the style control container to.
     * @returns {Object} The style control container.
     * @throws {Error} Throws an error if the map object is not provided.
     */
    this.onAdd = function (map) {
        this.map = map;
        this.controlContainer = document.createElement("div");
        this.controlContainer.classList.add("mapboxgl-ctrl");
        this.controlContainer.classList.add("mapboxgl-ctrl-group");
        this.mapStyleContainer = document.createElement("div");
        this.styleButton = document.createElement("button");
        this.styleButton.type = "button";
        this.mapStyleContainer.classList.add("mapboxgl-style-list");

        for (const style of this.styles) {
            const styleElement = document.createElement("button");

            styleElement.type = "button";
            styleElement.classList.add(style.title.replace(/[^a-z0-9-]/gi, '_'));
            styleElement.dataset.uri = JSON.stringify(style.uri);

            styleElement.addEventListener("click", event => {
                const srcElement = event.target || event.srcElement;
                this.closeModal();
                if (srcElement.classList.contains("active")) return;
                if (this.events && this.events.onOpen && this.events.onOpen(event)) return;
                const style = JSON.parse(srcElement.dataset.uri);
                this.map.setStyle(style);
                const elms = this.mapStyleContainer.getElementsByClassName("active");
                while (elms[0]) elms[0].classList.remove("active");
                srcElement.classList.add("active");
                if (this.events && this.events.onChange && this.events.onChange(event, style)) return;
            });

            if (style.title === this.selected) {
                styleElement.classList.add("active");
            }

            this.mapStyleContainer.appendChild(styleElement);
        }

        this.styleButton.classList.add("mapboxgl-ctrl-icon");
        this.styleButton.classList.add("mapboxgl-style-switcher");

        this.styleButton.addEventListener("click", event => {
            if (this.events && this.events.onSelect && this.events.onSelect(event)) return;
            this.openModal();
        });

        document.addEventListener("click", this.onDocumentClick);

        this.controlContainer.appendChild(this.styleButton);
        this.controlContainer.appendChild(this.mapStyleContainer);
        
        this.closeModal();
        return this.controlContainer;
    }

    /**
	 * @function
     * @memberof module:geoflo.Styles
     * @name onRemove
     * @description Removes the style control container from the map.
     * @returns {void}
     * @throws {Error} Throws an error if the control container, control container parent node, map, or style button is not provided.
     * @throws {Error} Throws an error if the style button event listener is not removed.
     * @throws {Error} Throws an error if the document event listener is not removed.
     */
    this.onRemove = function () {
        if (!this.controlContainer || !this.controlContainer.parentNode || !this.map || !this.styleButton) {
            return;
        }
        this.styleButton.removeEventListener("click", this.onDocumentClick);
        this.controlContainer.parentNode.removeChild(this.controlContainer);
        document.removeEventListener("click", this.onDocumentClick);
        this.map = undefined;
    }

    /**
	 * @function
     * @memberof module:geoflo.Styles
     * @name closeModal
     * @description Closes the style control container.
     * @returns {void}
     */
    this.closeModal = function () {
        if (this.mapStyleContainer && this.styleButton) {
            this.mapStyleContainer.style.display = "none";
            this.styleButton.style.display = "block";
        }
    }

    /**
     * @function
     * @memberof module:geoflo.Styles
     * @name openModal
     * @description Opens the style control container.
     * @returns {void}
     */
    this.openModal = function () {
        if (this.mapStyleContainer && this.styleButton) {
            this.mapStyleContainer.style.display = "block";
            this.styleButton.style.display = "none";
        }
    }

    this.onDocumentClick = function (event) {
        if (this.controlContainer && !this.controlContainer.contains(event.target)) this.closeModal();
    }

    this.init();
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Styles);

/***/ }),

/***/ "./src/Utilities.js":
/*!**************************!*\
  !*** ./src/Utilities.js ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * @mixin
 * @memberof module:geoflo
 * @name Utilities
 * @description This module provides utility functions for the Geoflo application.
 * @returns {Object} Returns the Utilities object.
 */
const Utilities = function () {
    const geoflo = this.geoflo;

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name pointInCoordinates
	 * @description This function takes a line string and a point's coordinates as input and returns an array of indices where the point is found in the line string's coordinates.
	 * @param {Object} lineString - The line string object containing geometry coordinates.
	 * @param {Array} pointCoords - The coordinates of the point to search for in the line string.
	 * @returns {Array} An array containing the indices of the point in the line string's coordinates.
	 */
    this.pointInCoordinates = function (lineString, pointCoords) {
        var result = [];

        lineString.geometry.coordinates.forEach(function(coords, index) {
            if (index !== 0 && index !== lineString.geometry.coordinates.length - 1) {
                if (coords[0] === pointCoords[0] && coords[1] === pointCoords[1]) {
                    result.push(index);
                }
            }
        });

        return result;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name sameBorders
	 * @description This function compares two sets of borders to determine if they are the same.
	 * @param {Object} fromBorders - The first set of borders to compare.
	 * @param {Object} toBorders - The second set of borders to compare.
	 * @returns {boolean} Returns true if the borders are the same, false otherwise.
	 */
    this.sameBorders = function (fromBorders, toBorders) {
        if (fromBorders && toBorders) {
            return fromBorders.border1[0] === toBorders.border1[0] && fromBorders.border1[1] === toBorders.border1[1] && fromBorders.border2[0] === toBorders.border2[0] && fromBorders.border2[1] === toBorders.border2[1] || fromBorders.border1[0] === toBorders.border2[0] && fromBorders.border1[1] === toBorders.border2[1] && fromBorders.border2[0] === toBorders.border1[0] && fromBorders.border2[1] === toBorders.border1[1];
        } else {
            return false;
        }
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name getRandomColor
	 * @description This function generates a random color by randomly selecting hexadecimal values for each digit of the color code.
	 * @returns {string} A random color in hexadecimal format.
	 */
    this.getRandomColor = function () {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name createRandomStroke
	 * @description Generates a random stroke color for a shape.
	 * @returns {Object} An object containing the randomly generated stroke color.
	 */
    this.createRandomStroke = function () {
        return {
            stroke: this.getRandomColor()
        };
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name createLineAndSaveLength
	 * @description This function takes an array of line coordinates and properties, creates a line string with random stroke properties, calculates the length of the line, and saves it in the properties.
	 * @param {Array} lineCoords - Array of coordinates for the line string.
	 * @param {Object} props - Properties object for the line string.
	 * @returns {Object} - The created line string with saved length in properties.
	 */
    this.createLineAndSaveLength = function (lineCoords, props) {
        var copyProps = Object.assign({}, props, this.createRandomStroke());
        var line = turf.lineString(lineCoords, copyProps);
        copyProps.length = turf.lineDistance(line);
        return line;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name lineSplit
	 * @description Splits a line string based on the provided point indexes and returns an array of split line strings.
	 * @param {Object} lineString - The line string object to split.
	 * @param {Array} pointIndexes - An array of indexes where the line string should be split.
	 * @returns {Array} - An array of split line strings.
	 */
    this.lineSplit = function (lineString, pointIndexes) {
        var props = lineString.properties;
        var lineCoords = [].concat(_toConsumableArray(lineString.geometry.coordinates));
        var result = [];
        var delta = 0;

        pointIndexes.forEach(function(pointIndex) {
            pointIndex -= delta;
            if (pointIndex < lineCoords.length - 1) {
                var secondPart = lineCoords.splice(pointIndex, lineCoords.length - pointIndex);
                
                if (lineCoords.length > 0) {
                    lineCoords.push(secondPart[0]);
                    result.push(this.createLineAndSaveLength(lineCoords, props));
                }

                lineCoords = secondPart;
                delta += pointIndex;
            }
        }, this);

        if (lineCoords.length > 0) {
            result.push(this.createLineAndSaveLength(lineCoords, props));
        }

        return result;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name splitLines
	 * @description This function takes two line strings and splits them at their intersection points.
	 * @param {Object} lineString1 - The first line string object.
	 * @param {Object} lineString2 - The second line string object.
	 * @returns {Array|null} - An array containing the split line strings or null if no intersection points are found.
	 */
    this.splitLines = function (lineString1, lineString2) {
        var line1CutPoints = [];
        var line2CutPoints = [];

        lineString1.geometry.coordinates.forEach(function(coords, index) {
            var points = this.pointInCoordinates(lineString2, coords);
            if (points.length > 0) {
                line2CutPoints.push.apply(line2CutPoints, _toConsumableArray(points));
                line1CutPoints.push(index);
            }
        }, this);

        if (line1CutPoints.length === 0 && line2CutPoints.length === 0) {
            return null;
        } else {
            var result = [];
            result.push.apply(result, _toConsumableArray(this.lineSplit(lineString1, line1CutPoints)));
            result.push.apply(result, _toConsumableArray(this.lineSplit(lineString2, line2CutPoints)));
            return result;
        }
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name createSimpleMesh
	 * @description Creates a simple mesh by processing a list of features containing line strings.
	 * @param {Array} features - An array of line string features to be processed.
	 * @returns {Array} - An array of processed line segments forming the mesh.
	 */
    this.createSimpleMesh = function (features) {
        var result = [];

        features.forEach(function(lineString) {
            var props = lineString.properties;
            var coords = lineString.geometry.coordinates;
            var firstPoint = coords[0];
            var secondPoint = null;

            for (var index = 1; index < coords.length; index++) {
                secondPoint = coords[index];
                result.push(this.createLineAndSaveLength([firstPoint, secondPoint], props));
                firstPoint = secondPoint;
            }
        }, this);

        return result;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name createMesh
	 * @description This function takes an array of line string features and splits them at intersection points to create a mesh.
	 * @param {Array} features - An array of line string features to create the mesh from.
	 * @returns {Array} - An array representing the mesh created by splitting the line strings at intersection points.
	 */
    this.createMesh = function (features) {
        var mesh = [];

        features.forEach(function(lineString1) {
            var line1CutPoints = lineString1.properties.cutPoints;

            if (!line1CutPoints) {
                line1CutPoints = [];
                lineString1.properties.cutPoints = line1CutPoints;
            }

            features.forEach(function(lineString2) {
                if (lineString1 !== lineString2) {
                    var line2CutPoints = lineString2.properties.cutPoints;

                    if (!line2CutPoints) {
                        line2CutPoints = [];
                        lineString2.properties.cutPoints = line2CutPoints;
                    }

                    lineString1.geometry.coordinates.forEach(function(coords, index) {
                        var points = this.pointInCoordinates(lineString2, coords);

                        if (points.length > 0) {
                            points.forEach(function(cutPoint) {
                                if (line2CutPoints.indexOf(cutPoint) === -1) {
                                    line2CutPoints.push(cutPoint);
                                }
                            });

                            if (index !== 0 && index !== lineString1.geometry.coordinates.length - 1) {
                                if (line1CutPoints.indexOf(index) === -1) {
                                    line1CutPoints.push(index);
                                }
                            }
                        }
                    }, this);
                }
            }, this);
        }, this);

        features.forEach(function(lineString) {
            lineString.properties.cutPoints.sort(function(a, b) { return a - b; });
            mesh.push.apply(mesh, _toConsumableArray(this.lineSplit(lineString, lineString.properties.cutPoints)));
        }, this);

        return mesh;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name setProperty
	 * @description This function sets a property value for a given feature. If the feature does not have properties, it creates a new properties object. If the property name includes a dot (.), it creates nested objects to set the value.
	 * @param {Object} feature - The feature object to set the property for.
	 * @param {string} name - The name of the property to set.
	 * @param {any} value - The value to set for the property.
	 */
    this.setProperty = function (feature, name, value) {
        if (!feature) return false;
        
        var props = feature.properties;
        
        if (!props) {
            props = {};
            feature.properties = props;
        }

        if (name.includes('.')) {
            name = name.split('.');
            if (!props[name[0]]) props[name[0]] = {};
            props[name[0]][name[1]] = value;
        } else {
            props[name] = value;
        }
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name setProperties
	 * @description Updates the properties of a given feature object with new properties.
	 * @param {Object} feature - The feature object whose properties will be updated.
	 * @param {Object} newProps - The new properties to be merged with the existing properties of the feature.
	 */
    this.setProperties = function (feature, newProps) {
        feature.properties = Object.assign(feature.properties || {}, newProps);
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name findClosestFeatures
	 * @description This function takes an indexData object, a point object, and a radius value as parameters. It then retrieves the feature IDs within the specified radius from the point index in the indexData object. It ensures unique features are included in the result and returns an array of closest features.
	 * @param {Object} indexData - The index data object containing pointIndex, pointFeatureMap, and featureById.
	 * @param {Object} point - The point object with lng (longitude) and lat (latitude) properties.
	 * @param {number} radius - The radius within which to search for features.
	 * @returns {Array} An array of closest features to the given point within the specified radius.
	 */
    this.findClosestFeatures = function (indexData, point, radius) {
        var featureIdsWithin = indexData.pointIndex.within(point.lng, point.lat, radius);
        var assertUniqueFeatures = {};
        var featureResult = [];

        featureIdsWithin.forEach(function(pointId) {
            var featureId = indexData.pointFeatureMap[pointId];
            if (!assertUniqueFeatures[featureId]) {
                featureResult.push(indexData.featureById[featureId]);
                assertUniqueFeatures[featureId] = true;
            }
        });
        
        return featureResult;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isPointEqual
	 * @description Checks if two points are equal based on their coordinates.
	 * @param {Array} coords1 - The coordinates of the first point [x, y].
	 * @param {Array} coords2 - The coordinates of the second point [x, y].
	 * @returns {boolean} Returns true if the points have the same coordinates, false otherwise.
	 */
    this.isPointEqual = function (coords1, coords2) {
        return coords1[0] === coords2[0] && coords1[1] === coords2[1];
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isPoint
	 * @description This function takes a feature object and determines if it represents a Point geometry.
	 * @param {Object} f - The feature object to be checked.
	 * @returns {boolean} Returns true if the feature is a Point geometry, false otherwise.
	 */
    this.isPoint = function (f) {
        return !f ? false : f.geometry.type === 'Point';
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isPolygon
	 * @description This function determines if a feature represents a polygon by comparing its first and last coordinates.
	 * @param {Object} feature - The feature object to be checked.
	 * @returns {boolean} Returns true if the feature is a polygon, false otherwise.
	 */
    this.isPolygon = function (feature) {
        var coords = feature.geometry.coordinates;
        var firstCoords = coords[0];
        var lastCoords = coords[coords.length - 1];
        return this.isPointEqual(firstCoords, lastCoords);
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isLineString
	 * @description This function takes a GeoJSON feature object and determines if it represents a LineString geometry.
	 * @param {Object} f - The GeoJSON feature object to be checked.
	 * @returns {boolean} Returns true if the feature is a LineString, false otherwise.
	 */
    this.isLineString = function (f) {
        return !f ? false : f.geometry.type === 'LineString';
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isValidLineString
	 * @description Checks if the input feature is a valid LineString by verifying its geometry coordinates.
	 * @param {Object} f - The input feature to be validated.
	 * @returns {boolean} Returns true if the input feature is a valid LineString, false otherwise.
	 */
    this.isValidLineString = function (f) {
        if (!this.isLineString(f)) return false;
        var coords = f.geometry.coordinates;
        if (coords.length < 2) return false;
        return true;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isLastIndex
	 * @description This function determines if the provided index is the last index in the coordinates array of a feature.
	 * @param {number} i - The index to check.
	 * @param {object} f - The feature object containing the coordinates array.
	 * @returns {boolean} Returns true if the index is the last index, false otherwise.
	 */
    this.isLastIndex = function (i, f) {
        return !f ? false :
        this.isLineString(f) ? i == f.geometry.coordinates.length - 1 :
        this.isPolygon(f) ? i == f.geometry.coordinates[0].length - 1 :
        i == 0 ? true :
        false;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name getLastIndexCoords
	 * @description This function returns the last coordinates of a given geometry object.
	 * @param {Object} f - The geometry object to extract the last coordinates from.
	 * @returns {Array} The last coordinates of the geometry object.
	 */
    this.getLastIndexCoords = function (f) {
        return this.isLineString(f) ? f.geometry.coordinates[f.geometry.coordinates.length - 1] :
        this.isPolygon(f) ? f.geometry.coordinates[0][f.geometry.coordinates.length - 1] :
        f.geometry.coordinates;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isEmptyLineString
	 * @description This function determines if the provided feature is a LineString with only two identical points, making it an empty LineString.
	 * @param {Object} feature - The feature object to be checked.
	 * @returns {boolean} Returns true if the feature is an empty LineString, otherwise false.
	 */
    this.isEmptyLineString = function (feature) {
        if (feature.geometry.type === "LineString") {
            var coords = feature.geometry.coordinates;

            if (coords.length === 2) {
                var firstCoords = coords[0];
                var lastCoords = coords[coords.length - 1];
                return this.isPointEqual(firstCoords, lastCoords);
            }
        }

        return false;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isPointAtVertex
	 * @description This function determines if a point is at the first or last vertex of a geometry by comparing it with the first and last coordinates.
	 * @param {Array} geometryCoords - The array of coordinates representing the geometry.
	 * @param {Array} pointCoords - The coordinates of the point to check.
	 * @returns {boolean} Returns true if the point is at the first or last vertex, false otherwise.
	 */
    this.isPointAtVertex = function (geometryCoords, pointCoords) {
        var firstPoint = geometryCoords[0];
        var lastPoint = geometryCoords[geometryCoords.length - 1];
        return this.isPointEqual(firstPoint, pointCoords) || this.isPointEqual(lastPoint, pointCoords);
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isPointNotTooClose
	 * @description This function calculates the distance between two points and checks if it exceeds a minimum distance threshold.
	 * @param {Array<number>} coords1 - The coordinates of the first point [x, y].
	 * @param {Array<number>} coords2 - The coordinates of the second point [x, y].
	 * @returns {boolean} Returns true if the distance between the points is greater than or equal to the minimum distance threshold, false otherwise.
	 */
    this.isPointNotTooClose = function (coords1, coords2) {
        var line = turf.lineString([coords1, coords2]);
        var length = turf.lineDistance(line);

        if (length >= statics.constants.MIN_DISTANCE) {
            return !(coords1[0] === coords2[0] && coords1[1] === coords2[1]);
        } else {
            return false;
        }
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name isOverlapping
	 * @description This function takes two features and determines if they overlap by comparing their bounding boxes.
	 * @param {Object} feature1 - The first feature object with geometry.coordinates.
	 * @param {Object} feature2 - The second feature object with geometry.coordinates.
	 * @returns {boolean} Returns true if the features overlap, false otherwise.
	 */
    this.isOverlapping = function (feature1, feature2) {
        var coords1 = feature1.geometry.coordinates;
        var coords2 = feature2.geometry.coordinates;

        if (coords1.length === 2 && coords2.length === 2) {
            var bbox1 = this.createBbox(coords1);
            var bbox2 = this.createBbox(coords2);
            if (bbox1.east < bbox2.west || bbox1.west > bbox2.east) {
                return false;
            } else if (bbox1.north < bbox2.south || bbox1.south > bbox2.north) {
                return false;
            }
            return true;
        } else {
            throw new Error("wrong number of coordinates, expected 2");
        }
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name createLineWithLength
	 * @description This function takes an array of coordinates and creates a line string using Turf.js. It then calculates the length of the line and sets it as a property of the line.
	 * @param {Array} coords - An array of coordinates [ [x1, y1], [x2, y2], ... ].
	 * @returns {Object} - A Turf.js line string with the calculated length property.
	 */
    this.createLineWithLength = function (coords) {
        var line = turf.lineString(coords);
        var length = turf.lineDistance(line);
        this.setProperties(line, { length: length });
        return line;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name reducePrecision
	 * @description This function reduces the precision of the coordinates to 7 decimal places.
	 * @param {Array} coords - An array containing the coordinates to be processed.
	 * @returns {Array} The coordinates with reduced precision to 7 decimal places.
	 */
    this.reducePrecision = function (coords) {
        coords[0] = Number(Number(coords[0]).toFixed(7));
        coords[1] = Number(Number(coords[1]).toFixed(7));
        return coords;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name createBbox
	 * @description This function takes an array of two coordinates and constructs a bounding box object with west, east, south, and north properties.
	 * @param {Array} coords - An array of two coordinates in the format [[lon1, lat1], [lon2, lat2]].
	 * @returns {Object} Returns a bounding box object with west, east, south, and north properties.
	 */
    this.createBbox = function (coords) {
        var bbox1 = {};
        if (coords[0][0] < coords[1][0]) {
            bbox1.west = coords[0][0];
            bbox1.east = coords[1][0];
        } else {
            bbox1.west = coords[1][0];
            bbox1.east = coords[0][0];
        }
        if (coords[0][1] < coords[1][1]) {
            bbox1.south = coords[0][1];
            bbox1.north = coords[1][1];
        } else {
            bbox1.south = coords[1][1];
            bbox1.north = coords[0][1];
        }
        return bbox1;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name stringToDOM
	 * @description Converts a string to a DOM object using DOMParser.
	 * @param {string} str - The input string to be converted to a DOM object.
	 * @returns {Document} - The DOM object created from the input string.
	 */
    this.stringToDOM = function (str) {
        var parser = new DOMParser();
        return parser.parseFromString(str, "text/xml");
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name processFiles
	 * @description This function reads each file in the input array, extracts the file name and extension, and then reads the file content using FileReader. The content is passed to the handler function along with the file name and extension.
	 * @param {File[]} files - An array of File objects to be processed.
	 * @param {function} handler - A function that will be called for each file with the file content, name, and extension as parameters.
	 */
    this.processFiles = function (files, handler) {
        files.forEach(function(file) {
            var name = file.name;
            var ext = name.substring(name.lastIndexOf('.') + 1, name.length).toLowerCase();
            var fileReader = new FileReader();

            fileReader.onloadend = function() {
                if (fileReader.readyState === FileReader.DONE) {
                    try {
                        handler(fileReader.result, name, ext);
                    } catch (e) {
                        console.log(e);
                        console.error("Invalid JSON data");
                    }
                }
            }
            
            fileReader.readAsText(file);
        });
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name combineSameTypeFeatures
	 * @description This function takes an array of line features and combines them by connecting them based on their coordinates. It checks the endpoints of each line feature and connects them accordingly to form a continuous line.
	 * @param {Array} features - An array of line features to be combined.
	 * @returns {Array} - An array of coordinates representing the combined line features.
	 */
    this.combineSameTypeFeatures = function (features) {
        var coords = [];

        features.forEach(function(lineString) {
            if (coords.length === 0) {
                coords.push.apply(coords, _toConsumableArray(lineString.geometry.coordinates));
            } else {
                var firstPoint = coords[0];
                var lastPoint = coords[coords.length - 1];
                var currentFirstPoint = lineString.geometry.coordinates[0];
                var currentLastPoint = lineString.geometry.coordinates[lineString.geometry.coordinates.length - 1];

                if (this.isPointEqual(lastPoint, currentFirstPoint)) {
                    coords.push.apply(coords, _toConsumableArray(lineString.geometry.coordinates.slice(1, lineString.geometry.coordinates.length)));
                } else if (this.isPointEqual(lastPoint, currentLastPoint)) {
                    coords.push.apply(coords, _toConsumableArray(lineString.geometry.coordinates.slice(0, lineString.geometry.coordinates.length - 1).reverse()));
                } else if (this.isPointEqual(firstPoint, currentLastPoint)) {
                    coords.splice.apply(coords, [0, 0].concat(_toConsumableArray(lineString.geometry.coordinates.slice(0, lineString.geometry.coordinates.length - 1))));
                } else if (this.isPointEqual(firstPoint, currentFirstPoint)) {
                    coords.splice.apply(coords, [0, 1].concat(_toConsumableArray(lineString.geometry.coordinates.reverse())));
                } else {
                    var distanceToFirstPoint = turf.distance(lastPoint, currentFirstPoint);
                    var distanceToLastPoint = turf.distance(lastPoint, currentLastPoint);

                    if (distanceToFirstPoint < distanceToLastPoint) {
                        coords.push.apply(coords, _toConsumableArray(lineString.geometry.coordinates));
                    } else {
                        coords.push.apply(coords, _toConsumableArray([].concat(_toConsumableArray(lineString.geometry.coordinates)).reverse()));
                    }
                }
            }
        }, this);

        return coords;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name degrees2meters
	 * @description This function takes an array of latitude and longitude in degrees and converts it to meters using the Mercator projection formula.
	 * @param {Array<number>} px - An array containing latitude and longitude in degrees [longitude, latitude].
	 * @returns {Array<number>} An array containing the converted x and y coordinates in meters.
	 */
    this.degrees2meters = function (px) {
        const x = px[0] * 20037508.34 / 180;
        let y = Math.log(Math.tan((90 + px[1]) * Math.PI / 360)) / (Math.PI / 180);
        y = y * 20037508.34 / 180;
        return [x, y]
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name meters2degrees
	 * @description This function takes a pixel value and converts it to longitude and latitude in degrees.
	 * @param {Array} px - The pixel value to be converted, in the format [x, y].
	 * @returns {Array} An array containing the longitude and latitude in degrees, [lon, lat].
	 */
    this.meters2degrees = function (px) {
        const lon = px[0] * 180 / 20037508.34;
        const lat = Math.atan(Math.exp(px[1] * Math.PI / 20037508.34)) * 360 / Math.PI - 90;
        return [lon, lat]
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name extend
	 * @description Extends the properties of the first object with the properties of the subsequent objects.
	 * @param {Object} target - The object to be extended.
	 * @param {...Object} sources - The objects whose properties will be added to the target object.
	 * @return {Object} The extended object.
	 */
    this.extend = function () {
        for(var i=1; i<arguments.length; i++)
            for(var key in arguments[i])
                if(arguments[i].hasOwnProperty(key))
                    arguments[0][key] = arguments[i][key];
        return arguments[0];
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name clone
	 * @description This function recursively clones the input object or array, preserving the structure and types of the elements.
	 * @param {Object|Array|Date|RegExp|Function|Symbol} thing - The object or array to be cloned.
	 * @param {Object} opts - Optional settings for cloning functions and symbols.
	 * @returns {Object|Array|Date|RegExp|Function|Symbol} - A deep clone of the input object or array.
	 */
    this.clone = function(thing, opts) {
        var newObject = {};

        if (thing instanceof Array) {
            return thing.map(function (i) { return this.clone(i, opts); }, this);
        } else if (thing instanceof Date) {
            return new Date(thing);
        } else if (thing instanceof RegExp) {
            return new RegExp(thing);
        } else if (thing instanceof Function) {
            return opts && opts.newFns ?
            new Function('return ' + thing.toString())() :
            thing;
        } else if (thing instanceof Object) {
            Object.keys(thing).forEach(function (key) { newObject[key] = this.clone(thing[key], opts); }, this);
            return newObject;
        } else if ([ undefined, null ].indexOf(thing) > -1) {
            return thing;
        } else {
            if (thing.constructor.name === 'Symbol') {
                return Symbol(thing.toString().replace(/^Symbol\(/, '').slice(0, -1));
            }

            return thing.__proto__.constructor(thing);
        }
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name cloneDeep
	 * @description Recursively clones a value, including objects and arrays, preserving the original structure deeply.
	 * @param {any} value - The value to be cloned.
	 * @param {Function} instance - A function that can be used to clone custom instances.
	 * @returns {any} - The deeply cloned value.
	 */
    this.cloneDeep = function(value, instance) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var toString = Object.prototype.toString;
    
        function _cloneDeep(val, instanceClone) {
            switch (kindOf(val)) {
            case 'object':
                return cloneObjectDeep(val, instanceClone);
            case 'array':
                return cloneArrayDeep(val, instanceClone);
            default:
                {
                    return clone(val);
                }
            }
        }
    
        function cloneObjectDeep(obj, instanceClone) {
            if (isObject(obj)) {
                var res = {};
                forOwn(obj, function(obj, key) {
                    this[key] = _cloneDeep(obj, instanceClone);
                }, res);
                return res;
            } else if (instanceClone) {
                return instanceClone(obj);
            } else {
                return obj;
            }
        }
    
        function cloneArrayDeep(arr, instanceClone) {
            var len = arr.length
            , res = [];
            var i = -1;
            while (++i < len) {
                res[i] = _cloneDeep(arr[i], instanceClone);
            }
            return res;
        }
    
        function isObject(val) {
            return val != null && typeof val === 'object' && Array.isArray(val) === false;
        }
    
        function isObjectObject(o) {
            return isObject(o) === true && Object.prototype.toString.call(o) === '[object Object]';
        }
    
        function isPlainObject(o) {
            var ctor, prot;
    
            if (isObjectObject(o) === false)
                return false;
    
            // If has modified constructor
            ctor = o.constructor;
            if (typeof ctor !== 'function')
                return false;
    
            // If has modified prototype
            prot = ctor.prototype;
            if (isObjectObject(prot) === false)
                return false;
    
            // If constructor does not have an Object-specific method
            if (prot.hasOwnProperty('isPrototypeOf') === false) {
                return false;
            }
    
            // Most likely a plain Object
            return true;
        }
    
        function forIn(obj, fn, thisArg) {
            for (var key in obj) {
                if (fn.call(thisArg, obj[key], key, obj) === false) {
                    break;
                }
            }
        }
    
        function forOwn(obj, fn, thisArg) {
            forIn(obj, function(val, key) {
                if (hasOwn.call(obj, key)) {
                    return fn.call(thisArg, obj[key], key, obj);
                }
            });
        }
    
        function kindOf(val) {
            // primitivies
            if (typeof val === 'undefined') {
                return 'undefined';
            }
            if (val === null) {
                return 'null';
            }
            if (val === true || val === false || val instanceof Boolean) {
                return 'boolean';
            }
            if (typeof val === 'string' || val instanceof String) {
                return 'string';
            }
            if (typeof val === 'number' || val instanceof Number) {
                return 'number';
            }
    
            // functions
            if (typeof val === 'function' || val instanceof Function) {
                return 'function';
            }
    
            // array
            if (typeof Array.isArray !== 'undefined' && Array.isArray(val)) {
                return 'array';
            }
    
            // check for instances of RegExp and Date before calling `toString`
            if (val instanceof RegExp) {
                return 'regexp';
            }
            if (val instanceof Date) {
                return 'date';
            }
    
            // other objects
            var type = toString.call(val);
    
            if (type === '[object RegExp]') {
                return 'regexp';
            }
            if (type === '[object Date]') {
                return 'date';
            }
            if (type === '[object Arguments]') {
                return 'arguments';
            }
            if (type === '[object Error]') {
                return 'error';
            }
    
            // buffer
            if (isBuffer(val)) {
                return 'buffer';
            }
    
            // es6: Map, WeakMap, Set, WeakSet
            if (type === '[object Set]') {
                return 'set';
            }
            if (type === '[object WeakSet]') {
                return 'weakset';
            }
            if (type === '[object Map]') {
                return 'map';
            }
            if (type === '[object WeakMap]') {
                return 'weakmap';
            }
            if (type === '[object Symbol]') {
                return 'symbol';
            }
    
            // typed arrays
            if (type === '[object Int8Array]') {
                return 'int8array';
            }
            if (type === '[object Uint8Array]') {
                return 'uint8array';
            }
            if (type === '[object Uint8ClampedArray]') {
                return 'uint8clampedarray';
            }
            if (type === '[object Int16Array]') {
                return 'int16array';
            }
            if (type === '[object Uint16Array]') {
                return 'uint16array';
            }
            if (type === '[object Int32Array]') {
                return 'int32array';
            }
            if (type === '[object Uint32Array]') {
                return 'uint32array';
            }
            if (type === '[object Float32Array]') {
                return 'float32array';
            }
            if (type === '[object Float64Array]') {
                return 'float64array';
            }
    
            // must be a plain object
            return 'object';
        }
    
        function isBuffer(obj) {
            return obj != null && (_isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
        }
    
        function _isBuffer(obj) {
            return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
        }
    
        function isSlowBuffer(obj) {
            return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
        }
    
        function isExtendable(val) {
            return typeof val !== 'undefined' && val !== null && (typeof val === 'object' || typeof val === 'function');
        }
    
        function mixin(target, objects) {
            if (!isExtendable(target)) {
                throw new TypeError('mixin-object expects the first argument to be an object.');
            }
            var len = arguments.length
            , i = 0;
            while (++i < len) {
                var obj = arguments[i];
                if (isExtendable(obj)) {
                    forIn(obj, copy, target);
                }
            }
            return target;
        }
    
        function clone(val) {
            var type = kindOf(val);
    
            if (clone.hasOwnProperty(type)) {
                return clone[type](val);
            }
            return val;
        }
    
        clone.array = function cloneArray(arr) {
            return arr.slice();
        }
    
        clone.date = function cloneDate(date) {
            return new Date(+date);
        }
    
        clone.object = function cloneObject(obj) {
            if (isExtendable(obj)) {
                return mixin({}, obj);
            } else {
                return obj;
            }
        }
    
        clone.regexp = function cloneRegExp(re) {
            var flags = '';
            flags += re.multiline ? 'm' : '';
            flags += re.global ? 'g' : '';
            flags += re.ignorecase ? 'i' : '';
            return new RegExp(re.source,flags);
        }
    
        return _cloneDeep(value, instance);
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name assignDeep
	 * @description Recursively assigns properties of source object to target object deeply.
	 * @param {Object} target - The target object to which properties will be assigned.
	 * @param {Object} source - The source object whose properties will be assigned to the target.
	 * @param {Object} options - Optional parameters for the assignment process.
	 * @param {boolean} [options.isMutatingOk=false] - Flag to allow mutating the target object.
	 * @param {boolean} [options.isStrictlySafe=false] - Flag to enforce strict safety checks during assignment.
	 * @returns {Object} The target object with assigned properties from the source object.
	 */
    this.assignDeep = function (target, source, {isMutatingOk = false, isStrictlySafe = false} = {}) {
        target = isMutatingOk ? target : this.cloneDeep(target);

        for (const [key, val] of Object.entries(source)) {
            if (val !== null && typeof val === `object`) {
                if (target[key] === undefined) target[key] = {};    
                target[key] = this.assignDeep(target[key], val, {isMutatingOk: true});
            } else {
                target[key] = val;
            }
        }

        return target;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name compareDeep
	 * @description Recursively compares two objects deeply to check if they are equal.
	 * @param {Object} x - The first object to compare.
	 * @param {Object} y - The second object to compare.
	 * @returns {boolean} Returns true if the objects are deeply equal, false otherwise.
	 */
    this.compareDeep = function() {
        var i, l, leftChain, rightChain;
      
        function compare2Objects (x, y) {
          var p;
      
          // remember that NaN === NaN returns false
          // and isNaN(undefined) returns true
          if (isNaN(x) && isNaN(y) && typeof x === 'number' && typeof y === 'number') {
               return true;
          }
      
          // Compare primitives and functions.     
          // Check if both arguments link to the same object.
          // Especially useful on the step where we compare prototypes
          if (x === y) {
              return true;
          }
      
          // Works in case when functions are created in constructor.
          // Comparing dates is a common scenario. Another built-ins?
          // We can even handle functions passed across iframes
          if ((typeof x === 'function' && typeof y === 'function') ||
             (x instanceof Date && y instanceof Date) ||
             (x instanceof RegExp && y instanceof RegExp) ||
             (x instanceof String && y instanceof String) ||
             (x instanceof Number && y instanceof Number)) {
              return x.toString() === y.toString();
          }
      
          // At last checking prototypes as good as we can
          if (!(x instanceof Object && y instanceof Object)) {
              return false;
          }
      
          if (x.isPrototypeOf(y) || y.isPrototypeOf(x)) {
              return false;
          }
      
          if (x.constructor !== y.constructor) {
              return false;
          }
      
          if (x.prototype !== y.prototype) {
              return false;
          }
      
          // Check for infinitive linking loops
          if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) {
               return false;
          }
      
          // Quick checking of one object being a subset of another.
          // todo: cache the structure of arguments[0] for performance
          for (p in y) {
              if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                  return false;
              }
              else if (typeof y[p] !== typeof x[p]) {
                  return false;
              }
          }
      
          for (p in x) {
              if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {
                  return false;
              }
              else if (typeof y[p] !== typeof x[p]) {
                  return false;
              }
      
              switch (typeof (x[p])) {
                  case 'object':
                  case 'function':
      
                      leftChain.push(x);
                      rightChain.push(y);
      
                      if (!compare2Objects (x[p], y[p])) {
                          return false;
                      }
      
                      leftChain.pop();
                      rightChain.pop();
                      break;
      
                  default:
                      if (x[p] !== y[p]) {
                          return false;
                      }
                      break;
              }
          }
      
          return true;
        }
      
        if (arguments.length < 1) return true;
      
        for (i = 1, l = arguments.length; i < l; i++) {
      
            leftChain = []; //Todo: this can be cached
            rightChain = [];
      
            if (!compare2Objects(arguments[0], arguments[i])) return false;
        }
      
        return true;
    }

	/**
	 * @function
     * @memberof module:geoflo.Utilities
	 * @name consumableArray
	 * @description Creates a consumable copy of an array or array-like object.
	 * @param {Array|Array-like} arr - The input array or array-like object to be copied.
	 * @returns {Array} A consumable copy of the input array or array-like object.
	 */
    this.consumableArray = function (arr) {
        if (Array.isArray(arr)) {
            for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
                arr2[i] = arr[i];
            }
            return arr2;
        } else {
            return Array.from(arr);
        }
    }
}

function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
            arr2[i] = arr[i];
        }
        return arr2;
    } else {
        return Array.from(arr);
    }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Utilities);

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be isolated against other modules in the chunk.
(() => {
/*!******************!*\
  !*** ./index.js ***!
  \******************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ geoflo)
/* harmony export */ });
/* harmony import */ var _src_Statics_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/Statics.js */ "./src/Statics.js");
/* harmony import */ var _src_Options_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/Options.js */ "./src/Options.js");
/* harmony import */ var _src_Utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/Utilities.js */ "./src/Utilities.js");
/* harmony import */ var _src_Styles_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/Styles.js */ "./src/Styles.js");
/* harmony import */ var _src_Layers_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/Layers.js */ "./src/Layers.js");
/* harmony import */ var _src_Features_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/Features.js */ "./src/Features.js");
/* harmony import */ var _src_Mesh_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./src/Mesh.js */ "./src/Mesh.js");
/* harmony import */ var _src_Events_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./src/Events.js */ "./src/Events.js");
/* harmony import */ var _src_Select_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./src/Select.js */ "./src/Select.js");
/* harmony import */ var _src_Draw_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./src/Draw.js */ "./src/Draw.js");
/* harmony import */ var _src_Locate_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./src/Locate.js */ "./src/Locate.js");
/* harmony import */ var _src_Snapping_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./src/Snapping.js */ "./src/Snapping.js");
/* harmony import */ var _src_Pinning_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./src/Pinning.js */ "./src/Pinning.js");
/* harmony import */ var _src_Routing_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./src/Routing.js */ "./src/Routing.js");
/* harmony import */ var _src_Exploring_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./src/Exploring.js */ "./src/Exploring.js");
/* harmony import */ var _src_Painting_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./src/Painting.js */ "./src/Painting.js");
/* harmony import */ var _src_Control_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./src/Control.js */ "./src/Control.js");
/* harmony import */ var _src_Gamepad_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./src/Gamepad.js */ "./src/Gamepad.js");



















/**
 * @module geoflo
 * @name geoflo
 * @description Represents the GeoFlo object that manages all modules.
 * @returns {Object} The GeoFlo object with various methods for managing the entire app.
 */
const GeoFlo = function () {
    const geoflo = this;
    
    this.statics = _src_Statics_js__WEBPACK_IMPORTED_MODULE_0__["default"];
    this.options = _src_Options_js__WEBPACK_IMPORTED_MODULE_1__["default"];
    this.dev = this.statics.developer;
    this.id = this.statics.id;

    this.modes = [];
    this.plugins = {};
    this.gamepads = {};
    this.enabled = false;
    this.mobile = isMobile();

    var selectedFeatures = [];
    var hiddenFeatures = [];

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name initialize
	 * @description Initializes the object and optionally assigns it to the global window object.
	 * @returns {Object} The initialized object.
	 */
    this.initialize = function () {
        if (this.initialized) return this;
        window[this.id] = this;
        this.initialized = true;
        return this;
    }
    
	/**
	 * @function
     * @memberOf module:geoflo
	 * @name init
	 * @description Initializes the map component with the provided options and a callback function when ready.
	 * @param {Object} [options={}] - The options object for configuring the map component.
	 * @param {Function} onReady - The callback function to be executed when the map is ready.
	 * @returns {Object} Returns the map component instance.
	 */
    this.init = async function (accessToken, options={}, onReady) {
        var onReadyReturn;

        this.Utilities = new _src_Utilities_js__WEBPACK_IMPORTED_MODULE_2__["default"]();

        if (!accessToken) throw new Error('No Mapbox Access Token Provided!');
        if (this.isReady) return this.setOptions(options);

        const id = options.container || this.options.map.container;
        if (!id) throw new Error('Element id is required in the DOM for the map!');

        await loadStylesheet("https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.css");
        await loadScript("https://api.mapbox.com/mapbox-gl-js/v3.4.0/mapbox-gl.js");
        await loadScript("https://unpkg.com/@turf/turf@7/turf.min.js");
        await loadScript("https://api.tiles.mapbox.com/mapbox.js/plugins/leaflet-omnivore/v0.3.1/leaflet-omnivore.min.js");
        await loadScript("https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js");
        await loadScript("https://api.mapbox.com/search-js/v1.0.0-beta.18/core.js");

        this.styles = this.options.map.styles;
        this.setOptions(options);
        
        var container = await ready(id);
        var style = this.styles.find(style => style.title === this.options.map.style).uri;

        this.isReady = container ? true : false;
        if (!this.isReady) throw new Error('Element id is required in the DOM for the map!');

        container.classList.add(this.statics.id);

        buildMapbox.call(this);

        turf.distanceToDegrees = function distanceToDegrees(distanceInKm) { return distanceInKm / 111.32; }

        this.mapbox = new mapboxgl.Map({
            accessToken: accessToken,
            container: container,
            style: style,
            center: this.options.map.center,
            zoom: this.options.map.zoom,
            hash: true,
            projection: 'mercator',
            extent: this.options.map.extent
        });

        this.viewport = document.createElement('div');
        this.viewportHeightOffset = 110;
        this.viewportWidthOffset = 20;
        this.viewportLeft = '10px';
        this.viewportBottom = '5%';
        this.noSelect = options.noSelect || false;
        this.mapbox.on('load', this.onLoad.bind(this));

        await loaded(this);
        await this.redraw();

        this.setViewport();
        //this.setExtent(false, true);
        this.setOpacity(this.options.map.opacity);

        this.fire('sdk.ready', { enabled: this.enabled, map: this.map, ready: this.isLoaded });

        if (onReady && typeof onReady === 'function') {
            if (onReady.constructor.name === 'AsyncFunction') {
                onReadyReturn = await onReady.call(this, this);
            } else {
                onReadyReturn = onReady.call(this, this);
            }
        }

        if (onReadyReturn) {
            if (!onReadyReturn.disable) {
                this.enable();
            }
        } else {
            this.enable();
        }
        return this;
    }

    /**
	 * @function
     * @memberOf module:geoflo
	 * @name load
	 * @description This function loads the MapboxGL SDK with the given MapboxGL map object and sets up necessary components for interaction. Loads the User, Layers, and Features components, and initializes event listeners. Calls the onReady callback if provided.
	 * @param {Object} map - The MapboxGL map object to be used by the SDK.
	 * @returns {Object} - Returns the SDK instance after loading and initialization.
	 */
    this.load = function (map) {
        if (this.isLoaded || !this.isReady) return this;

        this.map = map;

        this.locate = new _src_Locate_js__WEBPACK_IMPORTED_MODULE_10__["default"]();

        this.navigation = new mapboxgl.NavigationControl({ visualizePitch: true, showZoom: true, showCompass: true });
        this.navigation.hide = function () { this._container.style.display = 'none' }.bind(this.navigation);
        this.navigation.show = function () { this._container.style.display = 'block' }.bind(this.navigation);
        this.map.addControl(this.navigation, 'top-right');

        if (!this.mobile) {
            this.fullscreen = new mapboxgl.FullscreenControl({ container: document.querySelector('body') });
            this.fullscreen.hide = function () { this._controlContainer.style.display = 'none' }.bind(this.fullscreen);
            this.fullscreen.show = function () { this._controlContainer.style.display = 'block' }.bind(this.fullscreen);
            this.map.addControl(this.fullscreen, 'top-right');
        }
    
        this.styles = new _src_Styles_js__WEBPACK_IMPORTED_MODULE_3__["default"](this, { styles: this.styles, selected: this.options.map.style });
        this.Layers = new _src_Layers_js__WEBPACK_IMPORTED_MODULE_4__["default"](this);
        this.Features = new _src_Features_js__WEBPACK_IMPORTED_MODULE_5__["default"](this);

        this.map.addControl(this.styles);
        
        this.Events = (0,_src_Events_js__WEBPACK_IMPORTED_MODULE_7__["default"])(this);
        this.Events.removeEventListeners();
        this.Events.addEventListeners();

        this.isLoaded = true;
        return this;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name enable
	 * @description This function enables the map interaction mode based on the provided type and options. It sets the mode to 'select' or 'draw' depending on the type parameter, initializes options, controls, modes, and triggers events.
	 * @param {string} type - The type of interaction mode to enable ('select' or 'draw').
	 * @param {Object} options - Additional options for the interaction mode (default: {}).
	 * @returns {Object} - The current instance of the map with the enabled interaction mode.
	 */
    this.enable = function (type, options={}) {
        if (this.enabled) return this;
        
        this.mode = !type || type === 'select' ? 'select' : 'draw';
        this.type = type;

        this.setOptions(options);
        this.setControls();

        this.Select = new _src_Select_js__WEBPACK_IMPORTED_MODULE_8__["default"](this);
        this.Draw = new _src_Draw_js__WEBPACK_IMPORTED_MODULE_9__["default"](this);

        this.modes = [ this.Select, this.Draw ];
        this.enabled = true;

        this.setMode({ mode: this.mode, type: this.type});
        this.fire('map.enable', { enabled: this.enabled, mode: this.mode, type: this.type });
        return this;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name disable
	 * @description This function disables the map by clearing modes, setting enabled to false, resetting mode to null, resetting options to default, firing a 'map.disable' event, enabling double click zoom, removing event listeners, layers, and controls.
	 * @returns {Object} Returns the current instance of the map object.
	 */
    this.disable = function () {
        if (!this.enabled) return this;

        this.modes = [];
        this.enabled = false;
        this.mode = null;
        this.options = _src_Options_js__WEBPACK_IMPORTED_MODULE_1__["default"];
        this.doubleClickZoom.enable(this.map);
        this.Layers.removeEventListeners();
        this.Events.removeEventListeners();
        this.Layers.removeLayers();
        this.removeControls();
        this.fire('map.disable', { enabled: this.enabled, mode: this.mode });
        return this;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name redraw
	 * @description Redraws the map by refreshing layers, updating event listeners, and disabling double click zoom.
	 * @returns {Promise<boolean>} Returns a promise that resolves to true if the map is successfully redrawn, false otherwise.
	 */
    this.redraw = async function () {
        if (!this.Events) return false;
        await this.Layers.refresh();
        console.log(this.Layers.getSources())
        this.Events.removeEventListeners();
        this.Events.addEventListeners();
        this.Features.updateSource();
        this.doubleClickZoom.disable(this.map);
        this.setViewport();
        this.map.style.glyphManager.urls[""] = `mapbox://fonts/${this.dev}/{fontstack}/{range}.pbf`
        this.fire('map.redraw', { enabled: this.enabled, mode: this.mode })
        if (this.onReady) await this.onReady(this), delete this.onReady;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name refresh
	 * @description Refreshes the content by redrawing it asynchronously.
	 * @returns {Promise<boolean>} Returns a Promise that resolves to a boolean value.
	 */
    this.refresh = async function () {
        if (this.noRefresh) return false;
        await this.redraw();
        this.fire('map.refresh', { enabled: this.enabled, mode: this.mode })
    }




	/**
	 * @function
     * @memberOf module:geoflo
	 * @name once
	 * @description Registers a callback function to be executed only once for a specific GeoFlo event type.
	 * @param {string} type - The type of event to listen for.
	 * @param {function} callback - The callback function to be executed when the event occurs.
	 * @returns {boolean} Returns true if the callback is successfully registered to be executed once, otherwise false.
	 */
    this.once = function (type, callback) {
        return this.map && type ? this.map.once(this.id + ':' + type, callback) : false;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name on
	 * @description Registers a callback function to be executed for a specific GeoFlo event type.
	 * @param {string} type - The type of event to listen for.
	 * @param {function} callback - The callback function to be executed when the event occurs.
	 * @returns {boolean} Returns true if the event listener was successfully attached, false otherwise.
	 */
    this.on = function (type, callback) {
        if (!callback.name) throw new Error('Function must have a name!')
        return this.map && type ? this.map.on(this.id + ':' + type, callback) : false;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name off
	 * @description Removes an event listener from the map based on the provided GeoFlo event type and callback. Callback function must have a name.
	 * @param {string} type - The type of event to remove the listener from.
	 * @param {function} callback - The callback function to be removed as the event listener.
	 * @returns {boolean} Returns true if the event listener was successfully removed, false otherwise.
	 */
    this.off = function (type, callback) {
        if (!callback.name) throw new Error('Function must have a name!')
        return this.map && type ? this.map.off(this.id + ':' + type, callback) : false;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name fire
	 * @description Fires an event with the specified GeoFlo type and detail. Detail is an Object type.
	 * @param {string} type - The type of the event to fire.
	 * @param {any} detail - Additional details to include with the event.
	 * @returns {boolean} Returns true if the event was successfully fired, false otherwise.
	 */
    this.fire = function (type, detail) {
        return this.map && type ? this.map.fire(this.id + ':' + type, { detail: detail }) : false;
    }




	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setOptions
	 * @description Sets the options for the object by merging the provided options with the existing ones.
	 * @param {Object} options - The options to be merged with the existing options.
	 * @returns {Object} The updated options object after merging.
	 */
    this.setOptions = function(options={}) {
        this.options = this.Utilities.assignDeep(this.options || {}, options);
        return this.options;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setMode
	 * @description This function allows the user to set the mode of the map editor with various options.
	 * @param {Object} options - The options object for setting the mode.
	 * @param {string} [options.mode='select'] - The mode to set (default: select).
	 * @param {string} [options.type='LineString'] - The type of the mode (default: LineString).
	 * @param {Object} [options.feature] - The feature to edit in the mode.
	 * @returns {Object} The current mode after setting it based on the options.
	 */
    this.setMode = function (options={}) {
        if (!options.mode) options.mode = this.statics.constants.modes.SELECT;
        if (!options.type) options.type = 'Polyline';

        var classesToRemove = [];
        var selectedMode = null;
        var editMode = options.mode === this.statics.constants.modes.EDIT;

        if (this.currentMode && options.mode === this.mode && options.type === this.currentMode.type) return this.currentMode;
        
        if (editMode) {
            if (options.feature) {
                options.feature = geoflo.Utilities.cloneDeep(options.feature);
                options.mode = this.statics.constants.modes.DRAW;
                options.type = options.type || options.feature.properties.type;

                this.editing = geoflo.Utilities.cloneDeep(options.feature);
                this.removeSelection();
            } else {
                //this.wantingToEdit = true;
                if (this.currentMode) this.currentMode.deactivate(options);
                return this.setMode();
            }
        }

        if (this.currentMode && this.currentMode.activated) this.currentMode.deactivate(options);

        this.container.classList.forEach(function(className) {
            if (className.indexOf("mouse-") !== -1) {
                classesToRemove.push(className);
            }
        });

        if (classesToRemove.length > 0) {
            var _map$container$classL;
            (_map$container$classL = this.container.classList).remove.apply(_map$container$classL, classesToRemove);
        }

        this.setMapClass('pointer');

        this.modes.forEach(function(m) { if (m.canHandle && m.canHandle(options.mode)) { selectedMode = m; } });

        if (selectedMode) {
            this.fire('mode.change', {
                old: this.mode,
                new: options.mode,
                mode: selectedMode,
                type: options.type
            })

            this.currentMode = selectedMode;
            this.mode = options.mode;
            selectedMode.activate(options);
        }

        this.Snapping = new _src_Snapping_js__WEBPACK_IMPORTED_MODULE_11__["default"](this.currentMode);
        this.Pinning = new _src_Pinning_js__WEBPACK_IMPORTED_MODULE_12__["default"](this.currentMode);
        this.Routing = new _src_Routing_js__WEBPACK_IMPORTED_MODULE_13__["default"](this.currentMode);
        this.Exploring = new _src_Exploring_js__WEBPACK_IMPORTED_MODULE_14__["default"](this.currentMode);
        this.Painting = new _src_Painting_js__WEBPACK_IMPORTED_MODULE_15__["default"](this.currentMode);
        this.Layers.moveLayers();
        return this.currentMode;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setControls
	 * @description Initializes and sets the controls for the map. Adds the fullscreen and navigation controls, and initializes the custom controls.
	 * @params {none} - No parameters needed for this function.
	 * @returns {Array} - An array of initialized controls for the map.
	 */
    this.setControls = function (controls=[]) {
        if (this.controls && this.controls.length) {
            this.controls.forEach(function(control) { control.enable() });
            return this.controls;
        }

        if (!this.options.controls) return false;

        this.controls = [];
        controls = controls.length ? controls : this.statics.controls;
        controls.forEach(function(control) { this.controls.push(new _src_Control_js__WEBPACK_IMPORTED_MODULE_16__["default"](control)) }, this);
        return this.controls;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setIcon
	 * @description This function determines the appropriate icon to display based on the user's following status and navigation compass icon.
     * @deprecated
	 * @param {Event} event - The event for which the icon is being set.
	 * @returns {void}
	 */
    this.setIcon = function (event) {
        var icon = this.navigation ? this.navigation._compassIcon : false;
        var following = this.Locate && this.Locate.following;

        if (following) {

        } else if (icon) {
            //control.style.transform = icon.style.transform;
        }
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setCenterMarker
	 * @description This function sets a marker at the center of the map. It allows customization of the marker icon and behavior.
	 * @param {Object} options - Options object for customizing the center marker.
	 * @param {boolean} [options.remove] - If true, removes the center marker.
	 * @param {boolean} [options.transform] - If true, applies transformation to the center marker.
	 * @param {boolean} [options.gamepad] - If true, applies gamepad settings to the center marker.
	 * @param {boolean} [options.dontAdd] - If true, does not add the center marker.
	 * @param {boolean} [options.noRemove] - If true, prevents the center marker from being removed.
	 * @return {Object|boolean} Returns the center marker object if successfully added or updated, or false if not applicable.
	 */
    this.setCenterMarker = function (options={}) {
        return;
        if (!this.mobile || this.noCenterMarker) return false;
        
        var following = this.Locate && this.Locate.following;
        var icon = this.statics.logo.icon;
        var el;

        if (options.remove) {
            if (this.centerMarker && !this.centerMarker.noRemove) return this.centerMarker.remove(), delete this.centerMarker;
            return false;
        }
       
        if (this.centerMarker) {
            this.centerMarker.setLngLat(this.map.getCenter()).addTo(this.map);
            if (options.transform || options.gamepad) this.centerMarker.setPitchAlignment('map');
            return this.centerMarker;
        } else if (options.dontAdd) {
            return false;
        }

        if (!this.centerMarkerIcon) {
            el = document.createElement('div');
            el.className = this.id + '-center-marker';
            setIcon(el, icon);
        }
        
        this.centerMarkerIcon = el;
        this.centerMarker = new mapboxgl.Marker(this.centerMarkerIcon);
        this.centerMarker.setLngLat(this.map.getCenter()).addTo(this.map).setOffset([0,0]);
        this.centerMarker.noRemove = options.noRemove;

        if (following) this.centerMarker.setOffset([0,-20]);

        function setIcon(marker, icon) {
            marker.style.backgroundImage = `url("${icon}")`;
        }

        return this.centerMarker;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setButtons
	 * @description This function resets the active buttons and activates the Select button.
	 * @return {boolean} Returns true if the Select button is successfully set, false otherwise.
	 */
    this.setButtons = function () {
        return this.getButtons('select') ? this.getButtons('select').add() : false;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setActiveButton
	 * @description Sets the active button with the specified id in the controls array.
	 * @param {string} id - The id of the button to set as active.
	 * @returns {boolean} Returns false if the controls array is empty or undefined.
	 */
    this.setActiveButton = function (id) {
        if (!this.controls || !this.controls.length) return false;
        this.controls.forEach(function(control) { control.setActiveButton(id.toLowerCase()) })
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setTheme
	 * @description Sets the theme colors for the control.
	 * @param {Object} colors - An object containing the theme colors.
	 * @returns {void}
	 */
    this.setTheme = function (colors) {
        this.Control ? this.Control.setTheme(colors) : false;
    }
	
    /**
     * @function
     * @name setLayers
     * @memberof module:geoflo
     * @description Sets custom layers and optionally resets features based on the provided options.
     *
     * @param {Array} layers - An array of layers to be set.
     * @param {Object} options - An object containing options for setting layers.
     * @param {boolean} options.reset - Indicates whether to reset features before setting layers.
     * @returns {Promise} A promise that resolves when the custom layers have been set.
     * 
     * @author Solutegrate
     * @copyright 2025
     */
    this.setLayers = async function (layers=[], options={}) {
        if (options.reset) this.removeFeatures(layers, options);
        return await this.Layers.setCustomLayers(layers, options);
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setSelectedFeatures
	 * @description This function updates the selected features on the map with the provided array of features.
	 * @param {Array} features - An array of features to set as selected.
	 * @returns {boolean} Returns false if the features array is empty.
	 */
    this.setSelectedFeatures = function (features=[]) {
        if (!features.length) {
            selectedFeatures = [];
        } else {
            selectedFeatures.splice(0, selectedFeatures.length, ...features);
        }

        this.map.getSource(this.statics.constants.sources.SELECT).setData(turf.featureCollection(this.getSelectedFeatures()));
        this.map.getSource(this.statics.constants.sources.VERTEX).setData(turf.featureCollection(this.getSelectedFeatures()));

        this.fire('select.load', {
            features: turf.featureCollection(this.getSelectedFeatures()),
            source: this.map.getSource(this.statics.constants.sources.SELECT)
        })
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setMeshFeatures
	 * @description Updates the mesh data with the provided features and returns the updated mesh. Adds a mesh index if it does not exist.
	 * @param {Array} features - An array of features to update the mesh with.
	 * @returns {Object} The updated mesh after setting the features.
	 */
    this.setMeshFeatures = function (features=[]) {
        if (!features.length) return false;
        this.updateMeshData(features, true);
        return this.meshIndex.getFeatures();
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name setMapClass
	 * @description Sets a specific mouse class on the map container element based on the provided name. Removes any existing classes starting with "mouse-" before adding the new class.
	 * @param {string} name - The name of the class to be added (without the "mouse-" prefix).
	 * @returns {boolean} Returns false if the name is empty, otherwise adds the class and returns undefined.
	 */
    this.setMapClass = function (name) {
        this.container.classList.forEach(function(className) {
            if (className.indexOf("mouse-") !== -1) this.container.classList.remove(className)
        }, this);

        if (!name) return false;
        this.container.classList.add("mouse-" + name);
    }

    /**
	 * @function
     * @memberof module:geoflo.Map
	 * @name setViewport
	 * @description This function sets the style of the viewport based on the options provided. It resizes the map, calculates the height and width of the container, adjusts the height and width of the viewport, extends the viewport style, sets padding, and returns the updated viewport element.
	 * @param {Object} options - The options object containing style properties for the viewport.
	 * @param {string} [options.position='absolute'] - The position property for the viewport.
	 * @param {string} [options.margin='auto'] - The margin property for the viewport.
	 * @param {string} [options.top=''] - The top property for the viewport.
	 * @param {string} [options.left=this.viewportLeft] - The left property for the viewport.
	 * @param {string} [options.bottom=this.viewportBottom] - The bottom property for the viewport.
	 * @returns {Element} The updated viewport element.
	 */
    this.setViewport = function (options) {
        var style = options || {
            position: 'absolute',
            margin: 'auto',
            top: '',
            left: this.viewportLeft,
            bottom: this.viewportBottom
        };

        var height = this.container.getBoundingClientRect().height;
        var width = this.container.getBoundingClientRect().width;

        style.height = `${Number.parseInt(height) - this.viewportHeightOffset}px`;
        style.width = `${Number.parseInt(width) - this.viewportWidthOffset}px`;

        this.Utilities.extend(this.viewport.style, style);
        this.setPadding();
        this.map.resize();
        return this.viewport;
    }

	/**
	 * @function
     * @memberof module:geoflo.Map
	 * @name setPadding
	 * @description Calculates the padding values for the container by comparing its position with the viewport.
	 * @returns {Object} The padding object containing left, right, top, and bottom padding values.
	 * @params {void}
	 */
    this.setPadding = function () {
        var left = (this.container.getBoundingClientRect().left) - (this.viewport.getBoundingClientRect().left);
        var right = (this.container.getBoundingClientRect().right) - (this.viewport.getBoundingClientRect().right);
        var top = (this.container.getBoundingClientRect().top) - (this.viewport.getBoundingClientRect().top);
        var bottom = (this.container.getBoundingClientRect().bottom) - (this.viewport.getBoundingClientRect().bottom);
        var noPadding = this.container.getBoundingClientRect().width < 20;

        this.padding = {
            left: noPadding ? 0 : Math.abs(left),
            right: noPadding ? 0 : Math.abs(right),
            top: noPadding ? 0 : Math.abs(top),
            bottom: noPadding ? 0 : Math.abs(bottom)
        };

        this.map.setPadding(this.padding);    
        return this.padding;
    }

    /**
	 * @function
     * @memberof module:geoflo.Map
	 * @name setStyle
	 * @description Sets the style of the map and returns the updated style.
	 * @param {Object} style - The style object to be applied to the map.
	 * @returns {Object} The updated style object of the map.
	 */
    this.setStyle = function (style, options) {
        if (!style) { return false };
        this.map.setStyle(style, options);
        return this.map.getStyle();
    }

    /**
	 * @description Sets the extent of the map based on the provided features or a given extent. If no features are provided, it uses the rendered drawn features. If extent is specified, it sets the map extent to the extent polygon. If center is not specified and isPoint is true, it centers the map at the centroid of the extent. If center is false, it fits the map to the bounding box of the features. If center is true, it centers the map at the centroid of the bounding box.
	 * @function
     * @memberof module:geoflo.Map
	 * @name setExtent
	 * @param {Array} features - Array of features to set the extent based on.
	 * @param {Array} extent - Extent polygon to set the map extent to.
	 * @param {Object} options - Additional options for setting the extent (center, isPoint).
	 * @returns {Object} - The map object after setting the extent.
	 */
    this.setExtent = function (features, extent, options={}) {
        this.settingExtent = true;

        var noFeatures = !features || !features.length;
        var center = options.center;
        !center && options.isPoint ? center = true : false;

        this.setViewport();
        
        if (extent) {
            this.preventDefault = true;
            features = !this.options.map.extent ? [] : [turf.polygon(this.options.map.extent)];
        } else if (noFeatures) {
            features = this.getDrawnFeatures();
        }

        var jumpTo = {
            bearing: options.bearing || this.options.map.bearing || this.map.getBearing(),
            center: this.options.map.center || this.map.getCenter(),
            zoom: options.zoom || this.options.map.zoom || this.map.getZoom(),
            pitch: options.pitch || this.options.map.pitch || this.map.getPitch()
        }

        if (!features) return this.map.jumpTo(jumpTo);
        if (!features.length) return;

        var bbox = turf.bbox(turf.featureCollection(features))

        if (center) {
            var polygon = turf.bboxPolygon(bbox);
            var centroid = turf.centroid(polygon);
            jumpTo.center = { lat: centroid.geometry.coordinates[1], lng: centroid.geometry.coordinates[0] };
            jumpTo.zoom = options.zoom || this.map.getZoom();
            jumpTo.pitch = options.pitch || this.map.getPitch();
            jumpTo.bearing = options.bearing || this.map.getBearing();
            this.map.jumpTo(jumpTo);
        } else if (bbox) {
            var settings = {
                padding: this.map.getPadding(),
                linear: true
            }

            if (options.bearing) settings.bearing = options.bearing;
            if (options.pitch) settings.pitch = options.pitch;
            if (options.maxZoom) settings.maxZoom = options.maxZoom;
            
            this.map.fitBounds(bbox, settings);
        }

        this.fire('features.zoom', { features: features, center: this.map.getCenter(), bbox: bbox });
        this.settingExtent = false;
        return this.map;
    }

    /**
     * @memberof module:geoflo
	 * @function
	 * @name setOpacity
	 * @description This function takes a numeric value and sets the opacity of specified layers on the map to that value.
	 *
	 * @param {number} value - The opacity value to set for the layers.
	 */
    this.setOpacity = function (value) {
        var opacity = this.opacity = Number(value || 1);
        var layers = this.map.getStyle().layers;

        layers.map((layer) => {
            if (!layer.id.includes('geoflo') || layer.type === 'background') {
                if (layer.metadata && layer.metadata.custom) return;
                
                if (layer.type === 'symbol')  {
                    this.map.setPaintProperty(layer.id, `icon-opacity`, opacity);
                    this.map.setPaintProperty(layer.id, `text-opacity`, opacity);
                } else {
                    this.map.setPaintProperty(layer.id, `${layer.type}-opacity`, opacity);
                }
            }
        })
    }

    this.setColors = async function (colors={}) {
        this.options.colors = Object.assign(this.options.colors, colors);
        this.setTheme(this.options.colors);
        await this.Layers.refresh();
        this.Features.updateSource();
        return this.getColors();
    }




	/**
	 * @function
     * @memberOf module:geoflo
	 * @name hasControls
	 * @description This function checks if the object has controls by verifying the existence and length of the controls array.
	 * @returns {boolean} Returns true if the object has controls, false otherwise.
	 */
    this.hasControls = function () {
        return this.controls && this.controls.length;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name hasSelection
	 * @description This function determines whether there is a selection of features.
	 * @returns {boolean} Returns true if there is a selection of features, otherwise false.
	 */
    this.hasSelection = function () {
        return this.getSelectedFeatures().length > 0;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name hasSingleSelection
	 * @description This function checks if there is only one selected feature.
	 * @returns {boolean} Returns true if there is a single selection, false otherwise.
	 */
    this.hasSingleSelection = function () {
        return this.getSelectedFeatures().length === 1;
    }




	/**
	 * @function
     * @memberOf module:geoflo
	 * @name activateSnapping
	 * @description This function activates snapping by getting the snapping buttons, activating them, and triggering the snapping activation event. Fires a custom event 'snapping.activate' with the enabled status and the snapping object.
	 * @returns {Object} The activated Snapping object.
	 */
    this.activateSnapping = function () {
        var buttons = this.getButtons('snapping');
        if (!buttons) return;
        buttons.activate();
        this.Snapping.activate();
        this.fire('snapping.activate', { enabled: true, mesh: this.meshIndex, snapping: this.Snapping })
        return this.Snapping;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name activatePinning
	 * @description This function activates pinning by getting the pinning buttons, activating them, enabling snapping, activating pinning, and firing an event. Fires a custom event 'pinning.activate' with the enabled status and the pinning object.
	 * @returns {Object} The activated pinning object.
	 */
    this.activatePinning = function () {
        var buttons = this.getButtons('pinning');
        if (!buttons) return;
        buttons.activate();
        //this.deactivateRouting();
        this.activateSnapping();
        this.Pinning.activate();
        this.fire('pinning.activate', { enabled: true, pinning: this.Pinning });
        return this.Pinning;
    }

	/**
     * @function
     * @memberOf module:geoflo
	 * @description This function activates the routing feature by getting the routing buttons, activating them, enabling snapping, deactivating painting, and activating the routing itself. Fires a custom event 'routing.activate' with the enabled status and the routing object.
	 * @name activateRouting
	 * @returns {Object} The activated Routing object.
	 */
    this.activateRouting = function () {
        var buttons = this.getButtons('routing');
        if (!buttons) return;
        buttons.activate();
        this.activateSnapping();
        this.deactivatePainting();
        this.Routing.activate();
        this.fire('routing.activate', { enabled: true, routing: this.Routing })
        return this.Routing;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name activateExploring
	 * @description This function activates the exploring mode by activating the exploring buttons, functionalities, and events. Fires a custom event 'exploring.activate' with the enabled status and the exploring object.
	 * @returns {Object} The activated exploring object.
	 */
    this.activateExploring = function () {
        var buttons = this.getButtons('exploring');
        if (!buttons) return;
        buttons.activate();
        this.deactivatePainting();
        this.Exploring.activate();
        this.fire('exploring.activate', { enabled: true, exploring: this.Exploring });
        return this.Exploring;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name activatePainting
	 * @description Activates the painting functionality by setting the draw mode, activating the painting buttons, deactivating routing and exploring, and firing an event. Fires a custom event 'painting.activate' with the enabled status and the painting object.
	 * @returns {Object} The activated Painting object.
	 */
    this.activatePainting = function () {
        var buttons = this.getButtons('painting');
        if (!buttons) return;
        buttons.activate();
        this.deactivateRouting();
        this.deactivateExploring();
        this.Painting.activate(this.drawMode);
        this.fire('painting.activate', { enabled: true, painting: this.Painting });
        return this.Painting;
    }




	/**
	 * @function
     * @memberOf module:geoflo
	 * @name deactivateSnapping
	 * @description This function deactivates the snapping feature by performing various actions. Deletes mesh data, deactivates the snapping buttons, deactivates the Snapping object, and fires a 'snapping.deactivate' event.
	 * @returns {boolean} Returns false after deactivating the snapping feature.
	 */
    this.deactivateSnapping = function () {
        var buttons = this.getButtons('snapping');
        if (!buttons) return;
        buttons.deactivate();
        this.deleteMeshData();
        this.Snapping.deactivate();
        this.fire('snapping.deactivate', { enable: false })
        return false;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name deactivatePinning
	 * @description This function deactivates the pinning feature by deactivating the pinning buttons, the Pinning object, and firing a 'pinning.deactivate' event.
	 * @returns {boolean} Returns false after deactivating pinning.
	 */
    this.deactivatePinning = function () {
        var buttons = this.getButtons('pinning');
        if (!buttons) return;
        buttons.deactivate();
        this.Pinning.deactivate();
        this.fire('pinning.deactivate', { enable: false });
        return false;
    }

	/**
	 * @description Deactivates the routing functionality by deactivating the routing buttons and the Routing module. Triggers a custom event 'routing.deactivate' with enable set to false.
	 * @function
     * @memberOf module:geoflo
	 * @name deactivateRouting
	 * @returns {boolean} Returns false after deactivating the routing functionality.
	 */
    this.deactivateRouting = function () {
        var buttons = this.getButtons('routing');
        if (!buttons) return;
        buttons.deactivate();
        this.Routing.deactivate();
        this.fire('routing.deactivate', { enable: false })
        return false;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name deactivateExploring
	 * @description This function deactivates the exploring mode by deactivating buttons, deleting mesh data, deactivating the exploring mode, and firing an event. Fires a custom event 'exploring.deactivate' with the enable status set to false.
	 * @returns {boolean} Returns false after deactivating the exploring mode.
	 */
    this.deactivateExploring = function () {
        var buttons = this.getButtons('exploring');
        if (!buttons) return;
        buttons.deactivate();
        this.deleteMeshData();
        this.Exploring.deactivate();
        this.fire('exploring.deactivate', { enable: false });
        return false;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name deactivatePainting
	 * @description This function deactivates the painting mode by deactivating the buttons, the painting tool, and firing an event. Fires a custom event 'painting.deactivate' with the enable status set to false.
	 * @returns {boolean} Returns false.
	 */
    this.deactivatePainting = function () {
        var buttons = this.getButtons('painting');
        if (!buttons) return;
        if (this.mobile && !this.currentMode.finished && this.currentMode.id === 'draw' && this.currentMode.type && this.currentMode.type === 'Rectangle') return;
        buttons.deactivate();
        this.Painting.deactivate();
        this.fire('painting.deactivate', { enable: false });
        return false;
    }

    


	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getMap
	 * @description Retrieves the map property from the Map object.
	 * @returns {Object} The map property of the Map object.
	 */
    this.getMap = function () {
        return this.map;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getModes
	 * @description Retrieves the modes based on the provided mode parameter. If a mode is specified, it returns the mode that can handle the input mode. If no mode is specified, it returns all available modes.
	 * @param {string} mode - The mode to be checked against available modes.
	 * @returns {Array|Object} - An array of all available modes if no mode is specified, or the mode object that can handle the input mode.
	 */
    this.getModes = function (mode) {
        return mode ? this.modes.find(function(m) { if (m.canHandle && m.canHandle(mode)) { return m; } }) : this.modes;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getMode
	 * @description Retrieves the current mode of the object. Either 'GeoFlo.Select' or 'GeoFlo.Draw'.
	 * @return {object} The current mode of the object.
	 */
    this.getMode = function () {
        return this.currentMode;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getColors
	 * @description This function retrieves the colors from the options object.
	 * @returns {Array} The colors array from the options object.
	 */
    this.getColors = function () {
        return this.options.colors;
    }

	/**
	 * @description Retrieves the buttons associated with a specific control or all buttons from the controls.
	 * @function
     * @memberOf module:geoflo
	 * @name getButtons
	 * @param {string} id - The ID of the button to retrieve. If not provided, retrieves all buttons.
	 * @returns {object|boolean} - Returns an object containing the buttons if found, or false if controls are not available.
	 */
    this.getButtons = function (id) {
        if (!this.hasControls()) return false;

        var buttons;

        this.controls.forEach(function (c) {
            var options = c.getButtonOptions();

            if (id) {
                if (!buttons && options[id]) buttons = options[id];
            } else {
                if (!buttons) buttons = {};

                Object.entries(options).forEach(function(entry) {
                    var key = entry[0];
                    var val = entry[1];
                    buttons[key] = val;
                })
            }
            
        })

        return buttons;
    }




	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getFeatures
	 * @description This function retrieves both the drawn and selected features and returns them as a single array.
	 * @return {Array} An array containing both the drawn and selected features.
	 */
    this.getFeatures = function () {
        return [this.getDrawnFeatures(), this.getSelectedFeatures()].flat();
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getDrawnFeatures
	 * @description Retrieves the drawn features from the Features object.
	 * @returns {Array} An array of drawn features.
	 */
    this.getDrawnFeatures = function () {
        return this.Features.getColdFeatures();
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getRenderedFeatures
	 * @description Retrieves rendered features within a specified radius around a given longitude and latitude, based on a filter.
	 * @param {Array<number>} lngLat - An array containing the longitude and latitude coordinates.
	 * @param {number} radiusInKm - The radius in kilometers within which to search for features.
	 * @param {object} filter - An optional filter object to apply when retrieving features.
	 * @returns {Array<object>} An array of rendered features that match the criteria.
	 */
    this.getRenderedFeatures = function (lngLat, radiusInKm, filter) {
        var features = [this.getRenderedDrawnFeatures(lngLat, radiusInKm, filter), this.getRenderedSnapFeatures(lngLat, radiusInKm, filter)].flat();
        return features;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getRenderedDrawnFeatures
	 * @description This function queries the map for rendered drawn features based on the provided parameters.
	 * @param {Object} lngLat - The longitude and latitude coordinates.
	 * @param {number} radiusInKm - The radius in kilometers for the search.
	 * @param {Object} filter - Optional filter object to apply to the query.
	 * @returns {Array} An array of features within the specified radius around the given coordinates.
	 */
    this.getRenderedDrawnFeatures = function (lngLat, radiusInKm, filter) {
        var bbox;
        var id = this.id;

        var prelayers = [
            id + "-line-cold",
            id + "-fill-cold",
            id + "-circle-cold",
            id + "-icon-cold"
        ];

        var layers = [];

        prelayers.forEach(function(layer) {
            if (this.map.getLayer(layer)) layers.push(layer);
        }, this)

        this.Layers.getLayers().forEach(function(layer) {
            if (layer.id.includes(id)) return;
            if (this.map.getLayer(layer.id)) layers.push(layer.id);
        }, this)

        var options = { layers: layers };

        if (radiusInKm) {
            var radius = turf.distanceToDegrees(radiusInKm);
            bbox = [this.map.project([lngLat.lng - radius, lngLat.lat - radius]), this.map.project([lngLat.lng + radius, lngLat.lat + radius])];
        } else {
            var point = lngLat ? this.map.project([lngLat.lng, lngLat.lat]) : null;
            bbox = point ? [[point.x - 5, point.y - 5], [point.x + 5, point.y + 5]] : null
        }

        filter ? options.filter = filter : false;
        
        var features = this.map.queryRenderedFeatures(bbox, options);
        var ids = features.map(function(feature) { return feature.parent || feature.properties.parent || feature.id || feature.properties.id; });

        return features && features.length ? this.Features.getFeaturesById(ids) : [];;
    }
    
	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getRenderedSnapFeatures
	 * @description Retrieves rendered mesh index features within a specified radius around a given point on the map.
	 * @param {Object} lngLat - The longitude and latitude coordinates of the center point.
	 * @param {number} radiusInKm - The radius in kilometers within which to search for features.
	 * @param {Object} filter - Optional filter to apply to the query.
	 * @returns {Array} An array of features that fall within the specified radius around the given point.
	 */
    this.getRenderedSnapFeatures = function (lngLat, radiusInKm, filter) {
        if (!this.meshIndex) return [];

        var radius = turf.distanceToDegrees(radiusInKm);
        var bbox = [this.map.project([lngLat.lng - radius, lngLat.lat - radius]), this.map.project([lngLat.lng + radius, lngLat.lat + radius])];
        var options = { layers: [] };

        geoflo.Layers.getLayers().forEach(function(layer) {
            if (!layer.id.includes('MESH')) return;
            if (layer.type === 'fill') return;
            options.layers.push(layer.id);
        })

        filter ? options.filter = filter : false;

        var features = this.map.queryRenderedFeatures(bbox, options);
        return features && features.length ? this.meshIndex.getFeaturesFromIndex(features) : [];
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getFeatureById
	 * @description Retrieves a feature by its ID from the Features object.
	 * @param {string} id - The ID of the feature to retrieve.
	 * @returns {boolean|object} Returns the feature object if found, otherwise false.
	 */
    this.getFeatureById = function (id) {
        if (!id) return false;
        return this.Features.getFeatureById(id);
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getFeaturesByLayer
	 * @description This function queries the map for features within a specified radius around a given location from a specific source layer.
	 * @param {string} source - The source layer to query features from.
	 * @param {LngLat} lngLat - The longitude and latitude coordinates of the center point for the query.
	 * @param {number} radiusInKm - The radius in kilometers within which to search for features.
	 * @param {Object} filter - Optional filter object to apply to the query.
	 * @returns {Array} An array of features that match the query criteria.
	 */
    this.getFeaturesByLayer = function (source, lngLat, radiusInKm, filter) {
        var layers = [];
        var bbox;

        this.Layers.getLayers().forEach(function(layer) {
            if (!layer.id.includes(source)) return;
            layers.push(layer.id);
        })

        var options = { layers: layers };

        if (radiusInKm) {
            var radius = turf.distanceToDegrees(radiusInKm);
            bbox = [this.map.project([lngLat.lng - radius, lngLat.lat - radius]), this.map.project([lngLat.lng + radius, lngLat.lat + radius])];
        } else {
            var point = lngLat ? this.map.project([lngLat.lng, lngLat.lat]) : null;
            bbox = point ? [[point.x - 5, point.y - 5], [point.x + 5, point.y + 5]] : null
        }

        filter ? options.filter = filter : false;

        var features = this.map.queryRenderedFeatures(bbox, options);
        var ids = features.map(function(feature) { return feature.parent || feature.properties.parent || feature.id || feature.properties.id; });

        return features && features.length ? this.Features.getFeaturesById(ids) : [];;
    }




	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getSelectedFeatures
	 * @description Retrieves the selected features stored in the selectedFeatures array.
	 * @returns {Array} An array containing the selected features.
	 */
    this.getSelectedFeatures = function () {
        return selectedFeatures;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getSelectedFeatureIds
	 * @description Retrieves the IDs of selected features.
	 * @returns {Array} An array of feature IDs.
	 */
    this.getSelectedFeatureIds = function () {
        return this.getSelectedFeatures().map((feature) => { return feature.parent || feature.properties.parent || feature.id || feature.properties.id; });
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getSelectedFeaturesBbox
	 * @description Retrieves the bounding box of the selected features.
	 * @returns {Array<number>} The bounding box coordinates [minX, minY, maxX, maxY].
	 */
    this.getSelectedFeaturesBbox = function () {
        if (!this.hasSelection()) return null;
        return turf.bbox(turf.featureCollection(this.getSelectedFeatures()));
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getSelectedPropertyNames
	 * @description Retrieves the unique property names of selected features excluding the ID property.
	 * @returns {Array} An array of unique property names.
	 */
    this.getSelectedPropertyNames = function () {
        const id = this.id;
        const names = [];

        this.getSelectedFeatures().forEach((feature) => {
            Object.keys(feature.properties).forEach((propertyName) => {
                if (names.indexOf(propertyName) === -1 && propertyName !== id) {
                    names.push(propertyName);
                }
            });
        });

        return names;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name getSelectedPropertyValues
	 * @description Retrieves the properties of selected features excluding the property with the specified ID.
	 * @returns {Object} An object containing the properties of selected features.
	 */
    this.getSelectedPropertyValues = function  () {
        const id = this.id;
        var props = {};

        this.getSelectedFeatures().forEach(function (feature) { Object.assign(props, feature.properties); });
        if (props[id] !== undefined) { delete props[id]; }
        return props;
    }

	/**
	 * @description This function returns the common geometry type of the selected features. If all selected features have the same geometry type, it returns that type. If the selected features have different geometry types, it returns "illegal".
	 * @function
     * @memberOf module:geoflo
	 * @name getCommonGeometryType
	 * @returns {string|null} The common geometry type or null if different types are present.
	 */
    this.getCommonGeometryType = function () {
        let allFeaturesType = null;

        this.getSelectedFeatures().forEach((feature) => {
            if (allFeaturesType === null) {
                allFeaturesType = feature.geometry.type;
            } else if (feature.geometry.type !== allFeaturesType) {
                allFeaturesType = "illegal";
            }
        });

        if (allFeaturesType === "illegal") {
            return null;
        } else {
            return allFeaturesType;
        }
    }



    /**
     * @function
     * @name selectFeature
     * @memberOf module:geoflo
     * @description Selects a feature by its ID and returns the selection result.
     *
     * @param {string} id - The ID of the feature to be selected.
     * @returns {boolean|Object} Returns false if the feature is not found, otherwise returns the result of the selection.
     */
    this.selectFeature = function (id) {
        var feature = this.getFeatureById(id);
        if (!feature) return false;
        var selected = this.Features.selectFeatures([feature]);
        
        return selected;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name editFeature
	 * @description This function allows editing a feature by providing its ID or using the currently selected feature. It triggers a 'feature.edit' event and sets the mode to 'edit'.
	 * @param {string} id - The ID of the feature to edit.
	 * @param {Object} options - Additional options for editing the feature.
	 * @param {Object} options.feature - The feature object to edit.
	 * @returns {Object} The edited feature.
	 */
    this.editFeature = function (id, options={}) {
        var feature = options.feature || this.getFeatureById(id);
        
        if (!feature) {
            if (!this.hasSingleSelection()) return false;
            feature = this.getSelectedFeatures()[0];
        }

        options.id = feature.id;
        options.mode = 'edit';
        options.feature = feature;

        this.fire('feature.edit', { feature: feature, id: feature.id });
        this.setMode(options);
        return feature;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name cancelEdit
	 * @description This function cancels the current edit mode if it is in 'draw' mode and deactivates the editing feature.
	 * @param {boolean} standby - Indicates whether the cancel operation is standby.
	 * @param {object} feature - The feature to be deactivated. If not provided, the editing feature will be used.
	 * @returns {boolean} Returns false if the current mode is not 'draw', otherwise deactivates the editing feature.
	 */
    this.cancelEdit = function (standby, feature) {
        if (this.currentMode.id !== 'draw') return false;
        return this.currentMode.deactivate({ cancel: true, standby: standby, feature: feature || this.editing });
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name saveEdit
	 * @description Saves the edited feature using the currentModes saveEdit method.
	 * @return {any} The result of the saveEdit method of the current mode.
	 */
    this.saveEdit = function () {
        return this.currentMode.saveEdit();
    }





	/**
	 * @function
     * @memberOf module:geoflo
	 * @name addFeatures
	 * @description Adds features to the map and optionally zooms to them.
	 * @param {Array} features - Array of features to be added to the map.
	 * @param {boolean} noZoom - Flag to indicate whether to zoom to the added features.
	 */
    this.addFeatures = function (features, noZoom) {
        if (!features) return false;
        if (features.features) features = features.features;
        if (!Array.isArray(features)) features = [features];
        if (!features.length) return false;

        this.Features.addFeatures(features);
        !noZoom ? this.zoomToFeatures() : false;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name addFeaturesToSelected
	 * @description This function adds the provided features to the selected features list, updates the map sources, sets buttons and updates the text.
	 * @param {Array} features - The features to be added to the selected features list.
	 */
    this.addFeaturesToSelected = function (features, options={}) {
        if (!features || !features.length) return false;

        this.getSelectedFeatures().push(...features);
        this.setViewport();
        this.setButtons();
        this.map.getSource(this.statics.constants.sources.SELECT).setData(turf.featureCollection(this.getSelectedFeatures()));
        this.map.getSource(this.statics.constants.sources.VERTEX).setData(turf.featureCollection(this.getSelectedFeatures()));
        
        this.Layers.refresh({ select: true });

        this.Features.setText(features);
        this.Features.updateFeatures(features);

        if (options.zoom) this.zoomToFeatures(features, { center: options.center });

        if (options.text) {
            this.Layers.addTextLayer({
                select: true,
                ids: options.text.ids,
                field: options.text.field || 'text',
                layout: options.text.layout || {
                    'text-transform': 'uppercase',
                    'text-size': 10,
                    'text-offset': [0, 0.5]
                }
            });
        }
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name addFeaturesToMesh
	 * @description Adds features to the mesh index and updates its data.
	 * @param {Array} features - An array of features to be added to the mesh.
	 * @returns {Array} The array of features that were added to the mesh.
	 */
    this.addFeaturesToMesh = function (features=[]) {
        if (!features.length) return false;
        this.updateMeshData(features);
        return features;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name addGamepad
	 * @description Adds a gamepad to the list of available gamepads and fires an event. Fires a custom event 'gamepad.add' with the gamepad object.
	 * @param {Object} gamepad - The gamepad object to be added.
	 * @returns {boolean} Returns false if the 'Gamepad' plugin is not available.
	 */
    this.addGamepad = function (gamepad) {
        this.gamepads[gamepad.index] = new _src_Gamepad_js__WEBPACK_IMPORTED_MODULE_17__["default"](gamepad);
        this.fire('gamepad.add', { gamepad: gamepad });
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name addTooltip
	 * @description Attaches a tooltip by calling setTooltip to a specified element within a parent element.
	 * @param {Element} parent - The parent element to which the tooltip will be attached.
	 * @param {Element} element - The element to which the tooltip will be applied.
	 * @param {Object} options - The options for customizing the tooltip.
	 * @param {Element} appendTo - The element to which the tooltip will be appended.
	 */
    this.addTooltip = function (parent, element, options, appendTo) {
        if (!this.setTooltip) return false;

        this.setTooltip(element, {
            parent: parent,
            appendTo: appendTo,
            options: options
        })
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name addPlugin
	 * @description Adds a plugin to the plugins object of the current instance.
	 * @param {Object} plugin - The plugin object to be added.
	 * @param {string} plugin.id - The unique identifier of the plugin.
	 * @throws {Error} If no Plugin ID is provided.
	 */
    this.addPlugin = function (plugin) {
        if (!plugin.id) throw new Error('No Plugin ID provided')
        var id = plugin.id;
        this.plugins[id] = plugin;
    }



    

	/**
	 * @description Removes the selection of features based on the provided feature ID. If no ID is provided, all selected features are deselected.
	 * @function
     * @memberOf module:geoflo
	 * @name removeSelection
	 * @param {string} id - The ID of the feature to be deselected.
	 * @returns {number} The number of features that were deselected.
	 */
    this.removeSelection = function (id, options={}) {
        this.removePopup();
        if (!this.hasSelection()) return this.Features.setText(), this.updateFeatures();
        var features = this.Utilities.clone(this.getSelectedFeatures());
        this.Features.addFeatures(features, true, id);
        this.getSelectedFeatures().splice(0, features.length);
        this.map.getSource(this.statics.constants.sources.SELECT).setData(turf.featureCollection([]));
        this.map.getSource(this.statics.constants.sources.VERTEX).setData(turf.featureCollection([]));
        this.Features.setText();
        this.updateFeatures(features);
        this.setButtons();
        if (options.extent) this.setViewport(), this.setExtent();
        if (options.removeText) this.Layers.removeTextLayer();
        return features.length;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name removeControls
	 * @description This function is responsible for removing controls.
	 * @params {none} No parameters needed.
	 */
    this.removeControls = function () {
        if (!this.controls || !this.controls.length) return false;
        this.controls.forEach(function (control) { control.disable(); });
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name removeGamepad
	 * @description Removes a gamepad from the list of connected gamepads and triggers the onDisconnect event. Fires a custom event 'gamepad.remove' with the gamepad object.
	 * @param {Object} gamepad - The gamepad object to be removed.
	 * @returns {boolean} Returns false if the gamepad is not found in the list.
	 */
    this.removeGamepad = function (gamepad) {
        if (!this.gamepads[gamepad.index]) return false;
        this.gamepads[gamepad.index].onDisconnect(gamepad);
        delete this.gamepads[gamepad.index]
        this.fire('gamepad.remove', { gamepad: gamepad });
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name removeFeatures
	 * @description Removes specified features from the map. If no layers are provided, all features are removed. If the layers parameter is not an array, the function returns false.
	 * @param {Array} layers - An array of layers to remove features from.
	 * @param {Object} options - Additional options for removing features.
	 */
    this.removeFeatures = function (layers, options) {
        if (!layers) return this.Features.deleteFeatures();
        if (!Array.isArray(layers)) return false;
        this.Features.removeFeatures(layers, true);
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name removeFeature
	 * @description Removes a feature from the Features collection and fires an event if edit mode is not enabled. Fires a custom event 'feature.delete' with the ID and feature object.
	 * @param {string} id - The ID of the feature to be removed.
	 * @param {boolean} edit - A flag indicating whether edit mode is enabled.
	 * @returns {boolean} - Returns true if the feature was successfully removed, otherwise false.
	 */
    this.removeFeature = function (id, edit) {
        var removed = id ? this.Features.removeFeatures(id, edit) : false;
        !edit ? this.fire('feature.delete', { id: id, feature: removed }) : false;
        return removed;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name removePopup
	 * @description Removes the popup element from the DOM.
	 * @return {boolean} Returns true if the popup was successfully removed, false otherwise.
	 */
    this.removePopup = function () {
        return this.popup && this.popup.remove ? this.popup.remove() : this.currentMode.popup && this.currentMode.popup.remove ? this.currentMode.popup.remove() : false;
    }






	/**
	 * @function
     * @memberOf module:geoflo
	 * @name updateMeshData
	 * @description This function updates the mesh data on the map by adding new features to the mesh index and updating the map source with the new data. If the mesh index is not available or the reset flag is set to true, the mesh index is reset before adding new features.
	 * @param {Array} features - An array of features to be added to the mesh index.
	 * @param {boolean} reset - A flag indicating whether to reset the mesh index before adding new features.
	 * @returns {Object} The updated feature collection that was set on the map source.
	 */
    this.updateMeshData = function (features=[], reset) {
        if (!this.meshIndex || reset) this.meshIndex = new _src_Mesh_js__WEBPACK_IMPORTED_MODULE_6__["default"]([]);
        this.meshIndex.addNewFeatures(features);

        var source = this.statics.constants.sources.MESH;
        var features = turf.featureCollection(this.meshIndex.getFeatures());

        this.map.getSource(source).setData(features);
        this.fire('mesh.update', { features: features });
        return features;
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name updateSelectedProperties
	 * @description This function updates the selected properties of features based on the new properties provided while keeping specified properties.
	 * @param {Object} newProperties - The new properties to update the features with.
	 * @param {Array} propertiesToKeep - An array of property names to keep while updating the features.
	 */
    this.updateSelectedProperties = function (newProperties, propertiesToKeep) {
        this.getSelectedFeatures().forEach((feature) => {
            const savedId = feature.parent || feature.properties.parent || feature.id || feature.properties.id;
            const baseProperties = {};

            propertiesToKeep.forEach((propertyName) => {
                if (feature.properties[propertyName]) baseProperties[propertyName] = feature.properties[propertyName];
            });

            feature.properties = Object.assign(baseProperties, newProperties, { id: savedId });
        });
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name updateOrientation
	 * @description Updates the orientation of the user based on the provided options.
	 * @param {Object} options - An object containing the options for updating the orientation.
	 * @returns {string} The location of the user after updating the orientation.
	 */
    this.updateOrientation = function (options) {
        if (!this.Locate) return false;
        this.Locate.update(options);
        return this.Locate.locate;
    }

    /**
	 * @function
     * @memberOf module:geoflo
     * @name updateFeatures
     * @description Updates the features of a layer based on the provided features.
     * @param {Array} features - An array of features to update the layer with.
     * @returns {Array} The updated features of the layer.
     */
    this.updateFeatures = function (features) {
        return this.Features.updateFeatures(features);
    }

    

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name saveFeatures
	 * @description This function prepares the features of a layer for export in different formats such as KMZ, GPX, and GeoJSON. It styles the features, creates necessary metadata, and generates the export files.
	 * @param {Object} layer - The layer object containing the features to be exported.
	 * @returns {void}
	 */
    this.saveFeatures = function (layer) {
        const id = this.id;
        var fc, folderName;

        if (!layer) {
            if (this.hasSelection()) {
                folderName = 'Selected Features';
                fc = turf.featureCollection(this.getSelectedFeatures());
            } else {
                folderName = folderName = 'All Features';
                fc = turf.featureCollection(this.Features.getColdFeatures());
            }
        } else {
            if (!layer.id || !layer.name) return window.alert('Layer ID and Name are required!');
            folderName = layer.name + '-' + layer.id;
            fc = turf.featureCollection(this.Features.getFeaturesByLayer(layer));
        }

        if (!fc.features.length) return window.alert('No Features to Export!');

        var features = geoflo.Utilities.cloneDeep(fc.features);

		features = features.map(function (f) {
            f.style = {};
            f.style['stroke'] = f.properties.style && f.properties.style.primaryColor ? f.properties.style.primaryColor : this.options.colors.primaryColor;
            f.style['stroke-width'] = 3;
            f.style['fill'] = f.properties.style && f.properties.style.secondaryColor ? f.properties.style.secondaryColor : this.options.colors.secondaryColor;
            f.style['fill-opacity'] = 1;
			
            f.properties.id = f.id;
            f.properties.unit = f.geometry.unit;
            f.properties.units = f.geometry.units;

            delete f.properties.style;
            delete f.geometry.unit;
            delete f.geometry.units;

			return f;
		}, this);

        fc = turf.featureCollection(features);

        var d = new Date();
        var name = id + "_export - " + (d.getMonth() + 1) + "." + d.getDate() + "." + d.getFullYear() + "_" + d.getHours() + d.getMinutes();

        const extensions = ['kmz', 'gpx', 'geojson'];
        const zip = new window.JSZip();
        const description = {
			Id: this.id,
            Version: this.version,
			Features: fc.features.length
		}

        extensions.forEach(function (t) {
            const folder = zip.folder(folderName + ' ' + t.toUpperCase());

			switch (t) {
				case 'kmz':
                    var table = document.createElement('table');
                    var tableBody = document.createElement('tbody');
                    table.appendChild(tableBody);

					Object.entries(description).forEach(function (entry) {
						var h = entry[0];
						var d = entry[1];

                        var row = document.createElement('tr');
                        var header = document.createElement('th');
                        var data = document.createElement('td');

                        header.textContent = h + ': ';
                        data.textContent = d;

                        row.appendChild(header);
                        row.appendChild(data);

						tableBody.appendChild(row);
					});

					var kml = omnivore.toKML(fc, {
						name: 'id',
                        simplestyle: true,
						description: description.Id,
						documentName: folderName,
						documentDescription: table.innerHTML
					});

					var blob = new Blob([kml], { type: "application/vnd.google-earth.kml+xml" });
					folder.file(folderName.toLowerCase() + ".kml", blob);
					break;
				case 'gpx':
					features.forEach(function (f) {
						var title = f.id;
						var feature = turf.featureCollection([f]);
						var gpx = omnivore.toGPX(feature, {
							creator: description.Id,
							featureTitle: function (p) { return p.id; }
						})

						folder.file(folderName.toLowerCase() + '_' + title + ".gpx", gpx);
					})
					break;
				case 'geojson':
					var geojson = fc;
					var blob = new Blob([JSON.stringify(geojson)], { type: "application/geojson" });
					folder.file(folderName.toLowerCase() + ".geojson", blob);
					break;
			}
		})

        zip.generateAsync({ type: "blob" }).then(function (content) {
            var blob = new Blob([content], { type: "application/zip;charset=utf-8" });

            window.geoflo.fire('features.export', { features: features, blob: blob, date: d, name: name });

            var tempLink = document.createElement("a");
            tempLink.setAttribute('href', URL.createObjectURL(blob));
            tempLink.setAttribute('download', name + ".zip");
            tempLink.click();
            URL.revokeObjectURL(tempLink.href);
        });
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name loadFeatures
	 * @description This function creates an input element of type file, allows multiple file selection, and triggers a file selection event. It then processes the selected files by calling the Utilities.processFiles function.
	 * @params {Event} event - The event object triggered by file selection.
	 * @returns {void}
	 */
    this.loadFeatures = function () {
        const input = document.createElement('input');
        input.type = 'file';
        input.setAttribute('multiple', 'multiple');
        input.addEventListener('change', handleSelection, false);
        input.click();

        function handleSelection(event) {
            const files = [];

            for (let x = 0; x < event.target.files.length; x++) {
                files.push(event.target.files[x]);
            }

            geoflo.Utilities.processFiles(files, processFiles);
        }

        function processFiles (file, name, ext) {
            var features = [];
        
            if (ext === 'geojson' || ext === 'json') {
                features = JSON.parse(file);
            } else if (omnivore[ext]) {
                omnivore[ext].parse(file, null, { addData: function (feats) { features = feats; } });
            } else {
                return alert("File type not supported: " + ext);
            }

            if (features.features) features = features.features;
            if (!Array.isArray(features)) features = [features];

            features.forEach(function (feature) {
                feature.properties.import = true;
                feature.source = feature.source || feature.properties.source || geoflo.statics.constants.sources.COLD;
            })
            
            geoflo.fire('features.import', { features: features, file: file, ext: ext, name: name })
            geoflo.addFeatures(features);
        }
    }


	/**
	 * @function
     * @memberOf module:geoflo
	 * @name moveMapAlongLine
	 * @description This function animates the movement of the map along a specified line. The camera follows the route, ensuring synchronized movement.
	 * @param {Array} line - The line representing the route on the map.
	 * @returns {void}
	 */
    this.moveMapAlongLine = function (line) {
        if (!line) return;

        const animationDuration = 80000;
        const cameraAltitude = 4000;
        // get the overall distance of each route so we can interpolate along them
        const routeDistance = turf.lineDistance(line);
        const cameraRouteDistance = turf.lineDistance(line);

        let start;

        console.log(line, routeDistance, cameraRouteDistance)

        function frame(time) {
            if (!start) start = time;
            // phase determines how far through the animation we are
            const phase = (time - start) / animationDuration;

            // phase is normalized between 0 and 1
            // when the animation is finished, reset start to loop the animation
            if (phase > 1) {
                // wait 1.5 seconds before looping
                setTimeout(() => {
                    start = 0.0;
                }, 1500);
            }

            // use the phase to get a point that is the appropriate distance along the route
            // this approach syncs the camera and route positions ensuring they move
            // at roughly equal rates even if they don't contain the same number of points
            const alongRoute = turf.along( turf.lineString(line), routeDistance * phase ).geometry.coordinates;
            const alongCamera = turf.along( turf.lineString(line), cameraRouteDistance * phase ).geometry.coordinates;
            const camera = geoflo.map.getFreeCameraOptions();

            // set the position and altitude of the camera
            camera.position = mapboxgl.MercatorCoordinate.fromLngLat({ lng: alongCamera[0], lat: alongCamera[1] }, cameraAltitude );

            // tell the camera to look at a point along the route
            camera.lookAtPoint({
                lng: alongRoute[0],
                lat: alongRoute[1]
            });

            geoflo.map.setFreeCameraOptions(camera);

            window.requestAnimationFrame(frame);
        }

        window.requestAnimationFrame(frame);
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name refreshMeshData
	 * @description This function refreshes the mesh data by triggering a 'snapping.refresh' event with the current mesh features.
	 * @params {void} - No parameters needed for this function.
	 */
    this.refreshMeshData = function () {
        if (!this.meshIndex) return;
        if (this.mapMoving) return;
        //this.deleteMeshData();
        //this.addFeaturesToMesh(this.getDrawnFeatures())
        this.fire('snapping.refresh', { features: this.meshIndex.getFeatures() })
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name deleteMeshData
	 * @description Deletes the mesh data by updating it with an empty array and triggering a 'snapping.delete' event with the features from the mesh index.
	 * @params {Array} features - The features to update the mesh data with.
	 * @params {Boolean} triggerEvent - A flag to indicate whether to trigger the 'snapping.delete' event.
	 */
    this.deleteMeshData = function () {
        this.updateMeshData([], true);
        this.fire('snapping.delete', { features: this.meshIndex.getFeatures() })
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name deleteUserData
	 * @description This function allows the user to delete selected features or all features based on confirmation prompts. It updates the map data and resets various properties.
	 * @params {void} - No parameters required.
	 * @returns {void} - No return value.
	 */
    this.deleteUserData = function () {
        var id

        if (this.hasSingleSelection()) {
            if (window.confirm('Delete Selected Feature?')) {
                var feature = this.getSelectedFeatures()[0];
                id = feature.parent || feature.properties.parent || feature.id || feature.properties.id;
                this.removeSelection(id);
                this.Features.removeFeatures(id, true);
                this.meshIndex ? this.meshIndex.removeFeature(id) : false;
                this.fire('feature.delete', { features: this.Features.getColdFeatures(), id: id, feature: feature })
            } else {
                return;
            }
        } else {
            if (window.confirm('Delete All Features?')) {
                this.Features.deleteFeatures();
                this.fire('features.delete', { features: this.Features.getColdFeatures() })
            } else {
                return;
            }
        }
        
        this.hotFeature = null;
        this.snapFeature = null;
        this.lastClick = null;
        this.firstClick = null;
        this.drawStarted = null;

        this.map.getSource(this.statics.constants.sources.SNAP).setData(turf.featureCollection([]));
        this.map.getSource(this.statics.constants.sources.HOT).setData(turf.featureCollection([]));
        this.map.getSource(this.statics.constants.sources.HOTTEXT).setData(turf.featureCollection([]));

        if (this.editMode) {
            this.editMode = false;
            this.setMode();
        }
    }

    this.doubleClickZoom = {
        enable(map) {
            setTimeout(() => {
                if (!map || !map.doubleClickZoom) return;
                map.doubleClickZoom.enable();
            }, 0);
        },
        disable(map) {
            setTimeout(() => {
                if (!map || !map.doubleClickZoom) return;
                map.doubleClickZoom.disable();
            }, 0);
        }
    };


    

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name hideSelectedFeatures
	 * @description This function hides the selected features on the map by moving them to a hidden features array and updating the map sources.
	 * @params {Array} hiddenFeatures - Array to store the hidden features.
	 * @params {Array} selectedFeatures - Array of selected features on the map.
	 * @returns {void}
	 */
    this.hideSelectedFeatures = function () {
        if (hiddenFeatures.length > 0) {
            this.getSelectedFeatures().push(...hiddenFeatures);
            hiddenFeatures.splice(0, hiddenFeatures.length);
        } else if (this.hasSelection()) {
            hiddenFeatures.push(...this.getSelectedFeatures().splice(0, this.getSelectedFeatures().length));
        }

        this.map.getSource(this.statics.constants.sources.SELECT).setData(turf.featureCollection(this.getSelectedFeatures()));
        this.map.getSource(this.statics.constants.sources.VERTEX).setData(turf.featureCollection(this.getSelectedFeatures()));
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name combineSelectedFeatures
	 * @description Combines selected features based on their geometry type.
	 * @params {void}
	 * @returns {void}
	 */
    this.combineSelectedFeatures = function () {
        if (this.mode === this.statics.constants.modes.SELECT) {
            if (this.hasSelection()) {
                var allFeaturesType = this.getCommonGeometryType();

                if (allFeaturesType === "Polygon") {
                    var polygons = [];

                    this.forEachSelectedFeature(function(polygon) {
                        polygons.push.apply(polygons, consumableArray(polygon.geometry.coordinates));
                    });

                    if (polygons.length > 0) {
                        this.Features.addFeatures([turf.polygon(polygons, this.getSelectedPropertyValues())]);
                        this.removeSelection();
                    }
                } else if (allFeaturesType === "LineString") {
                    var coords = geoflo.Utilities.combineSameTypeFeatures(this.getSelectedFeatures());

                    if (coords.length > 0) {
                        this.Features.addFeatures([turf.lineString(coords, this.getSelectedPropertyValues())]);
                        this.removeSelection();
                    }
                } else {
                    console.error("Only objects of the same type can be combined, " + "i.e. lines with lines and polygons with polygons");
                }
            }
        } else {
            console.error("Combine can only be executed in selection mode");
        }
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name moveSelectedFeatures
	 * @description This function checks if moving is enabled and if there are selected features of LineString type. If so, it offsets the selected LineString features by the specified distance in the provided direction.
	 * @param {number} direction - The direction in which to move the selected features (1 for forward, -1 for backward).
	 * @returns {boolean} Returns false if moving is not enabled or there are no selected LineString features.
	 */
    this.moveSelectedFeatures = function (direction) {
        if (!this.options.moving || !this.options.moving.enable) { return false }
        var distance = this.options.moving.distance;

        if (this.mode === this.statics.constants.modes.SELECT) {
            if (this.hasSelection()) {
                var allFeaturesType = this.getCommonGeometryType();

                if (allFeaturesType === "LineString") {
                    var newSelectedFeatures = [];
                    this.forEachSelectedFeature(function(feature) { newSelectedFeatures.push(turf.lineOffset(feature, distance * direction)); });
                    this.setSelectedFeatures(newSelectedFeatures);
                }
            }
        }
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name moveFeature
	 * @description This function calculates the new coordinates of a feature based on the direction and distance provided. NOT WORKING YET.
	 * @param {Object} feature - The feature object to be moved.
	 * @param {number} direction - The direction in which the feature should be moved (1 for forward, -1 for backward).
	 * @returns {Array} An array of new coordinates for the feature after moving.
	 */
    this.moveFeature = function (feature, direction) {
        return;
        if (!this.options.moving || !this.options.moving.enable) return false
        
        var distance = this.options.moving.distance;
        var result = [];
        var lastDestinationPoint = null;
        var coordinates = feature.geometry.coordinates;

        for (var index = 0; index < coordinates.length; index++) {
            var moveBearing = 0;
            var startPoint = null;
            var middlePoint = coordinates[index];

            if (index === 0) {
                var endPoint = coordinates[index + 1];
                var secondBearing = turf.bearing(middlePoint, endPoint);
                moveBearing = secondBearing - 90;
                
                if (moveBearing < -180) {
                    moveBearing += 180;
                }
            } else if (index === coordinates.length - 1) {
                startPoint = coordinates[index - 1];
                var firstBearing = turf.bearing(middlePoint, startPoint);
                moveBearing = firstBearing - 90;

                if (moveBearing < -180) {
                    moveBearing += 180;
                }
            } else {
                startPoint = coordinates[index - 1];
                var _endPoint = coordinates[index + 1];

                var _firstBearing = turf.bearing(middlePoint, startPoint);
                var _secondBearing = turf.bearing(middlePoint, _endPoint);

                var angle = 0;

                if (_firstBearing < 0 && _secondBearing < 0 || _firstBearing > 0 && _secondBearing > 0) {
                    angle = Math.abs(Math.abs(_firstBearing) - Math.abs(_secondBearing));
                    moveBearing = _firstBearing < 0 ? _firstBearing - angle / 2 : _firstBearing + angle / 2;
                } else {
                    angle = Math.abs(Math.abs(_firstBearing) + Math.abs(_secondBearing));
                    moveBearing = _firstBearing < 0 ? _firstBearing - angle / 2 : (angle / 2 - _firstBearing) * -1;
                }
            }

            var destinationPoint = turf.destination(middlePoint, direction * distance, moveBearing);

            if (lastDestinationPoint && startPoint) {
                var crossingLine = turf.lineString([lastDestinationPoint.geometry.coordinates, destinationPoint.geometry.coordinates]);
                var intersectFc = turf.lineIntersect(turf.lineString([startPoint, middlePoint]), crossingLine);

                if (intersectFc.features.length > 0) {
                    destinationPoint = turf.destination(middlePoint, direction * -distance, moveBearing);
                }
            }

            result.push(destinationPoint.geometry.coordinates);
            lastDestinationPoint = destinationPoint;
        }

        return result;
    }

    

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name forEachSelectedFeature
	 * @description Iterates over each selected feature and applies a handler function to it.
	 * @param {Function} handler - The function to be applied to each selected feature.
	 * @returns {void}
	 */
    this.forEachSelectedFeature = function (handler) {
        this.getSelectedFeatures().forEach(handler);
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name zoomToFeatures
	 * @description This function zooms to the provided features on the map. If no features are provided, it zooms to the selected features, cold features, or the map extent if no other features are available.
	 * @param {Array} features - The features to zoom to on the map.
	 * @param {Object} options - Additional options for zooming (default: {}).
	 * @returns {boolean} Returns false if no features are available to zoom to.
	 */
    this.zoomToFeatures = function (features, options={}) {
        features = features || (this.hasSelection() ? this.getSelectedFeatures() : this.getDrawnFeatures());
        this.setExtent(features, false, options);
    }

	/**
	 * @function
     * @memberOf module:geoflo
	 * @name createPolygon
	 * @description Creates a polygon from selected LineString features and adds it to the map.
	 * @params {Array} selectedFeatures - An array of selected features to be combined into a polygon.
	 * @params {Object} selectedPropertyValues - Property values of the selected features.
	 * @returns {void}
	 */
    this.createPolygon = function () {
        if (this.mode === this.statics.constants.modes.SELECT) {
            if (this.hasSelection()) {
                var allFeaturesType = this.getCommonGeometryType();

                if (allFeaturesType === "LineString") {
                    var coords = geoflo.Utilities.combineSameTypeFeatures(this.getSelectedFeatures());

                    if (coords.length > 0) {
                        if (!geoflo.Utilities.isPointEqual(coords[0], coords[coords.length - 1])) {
                            coords.push(coords[0]);
                        }

                        this.addFeaturesToSelected([turf.polygon([coords], this.getSelectedPropertyValues())]);
                        this.removeSelection();
                    }
                } else {
                    console.error("Only objects of type LineString can be combined into a polygon");
                }
            }
        } else {
            console.error("Create polygon can only be executed in selection mode");
        }
    }


    /**
     * @function
     * @name onLoad
     * @memberOf module:geoflo
     * @description Handles the loading of a MapboxGL map object, setting up the container and event listeners, and configuring map options.
     *
     * @param {Object} event - The event object triggered on load.
     * @param {Object} event.target - The target object that triggered the event, expected to be a MapboxGL map instance.
     * @returns {Promise} A promise that resolves when the map has finished loading.
     */
    this.onLoad = function (event) {
        if (!event.target || !event.target.getContainer) throw new Error('MapboxGL map object is required!');

        this.container = event.target._container;
        this.viewport ? this.container.insertBefore(this.viewport, this.container.firstChild) : false;

        event.target.off('style.load', this.onStyleLoad.bind(this));
        event.target.on('style.load', this.onStyleLoad.bind(this));

        if (this.options.map.maxPitch) event.target.setMaxPitch(this.options.map.maxPitch);
        if (this.options.map.maxZoom) event.target.setMaxZoom(this.options.map.maxZoom);
        if (this.options.map.minPitch) event.target.setMinPitch(this.options.map.minPitch);
        if (this.options.map.minZoom) event.target.setMinZoom(this.options.map.minZoom);

        return this.load(event.target);
    }

    /**
     * @function
     * @name onStyleLoad
     * @memberOf module:geoflo
     * @description Handles the style load event and triggers a redraw after a delay.
     *
     * @param {Event} event - The event object associated with the style load.
     * @returns {void} This function does not return a value.
     */
    this.onStyleLoad = function (event) {
        setTimeout(function() { geoflo.redraw(); }, 500)
    }

    /**
     * @function
     * @name onMapMove
     * @memberOf module:geoflo
     * @description Handles the event triggered when the map is moved.
     *
     * @param {Object} event - The event object containing information about the map movement.
     * @returns {void} This function does not return a value.
     */
    this.onMapMove = function (event) {

    }

    this.initialize();
};

const geoflo = new GeoFlo();

_src_Utilities_js__WEBPACK_IMPORTED_MODULE_2__["default"].prototype.geoflo = geoflo;
_src_Features_js__WEBPACK_IMPORTED_MODULE_5__["default"].prototype.geoflo = geoflo;
_src_Layers_js__WEBPACK_IMPORTED_MODULE_4__["default"].prototype.geoflo = geoflo;
_src_Control_js__WEBPACK_IMPORTED_MODULE_16__["default"].prototype.geoflo = geoflo;
_src_Locate_js__WEBPACK_IMPORTED_MODULE_10__["default"].prototype.geoflo = geoflo;
_src_Mesh_js__WEBPACK_IMPORTED_MODULE_6__["default"].prototype.geoflo = geoflo;
_src_Draw_js__WEBPACK_IMPORTED_MODULE_9__["default"].prototype.geoflo = geoflo;
_src_Select_js__WEBPACK_IMPORTED_MODULE_8__["default"].prototype.geoflo = geoflo;
_src_Gamepad_js__WEBPACK_IMPORTED_MODULE_17__["default"].prototype.geoflo = geoflo;
_src_Styles_js__WEBPACK_IMPORTED_MODULE_3__["default"].prototype.geoflo = geoflo;
_src_Snapping_js__WEBPACK_IMPORTED_MODULE_11__["default"].prototype.geoflo = geoflo;
_src_Pinning_js__WEBPACK_IMPORTED_MODULE_12__["default"].prototype.geoflo = geoflo;
_src_Routing_js__WEBPACK_IMPORTED_MODULE_13__["default"].prototype.geoflo = geoflo;
_src_Exploring_js__WEBPACK_IMPORTED_MODULE_14__["default"].prototype.geoflo = geoflo;
_src_Painting_js__WEBPACK_IMPORTED_MODULE_15__["default"].prototype.geoflo = geoflo;


async function loadScript(url) {
    try {
        const response = await fetch(url);

        if (response.ok) {
            const scriptText = await response.text();
            const script = document.createElement('script');
            script.textContent = scriptText;
            document.head.appendChild(script);
        } else {
            console.error(`Failed to load script from ${url}. Status: ${response.status}`);
        }
    } catch (error) {
        console.error(`Error loading script: ${error.message}`);
    }
}

async function loadStylesheet(url) {
    try {
        const response = await fetch(url);

        if (response.ok) {
            const scriptText = await response.text();
            const script = document.createElement('style');
            script.textContent = scriptText;
            document.head.prepend(script);
        } else {
            console.error(`Failed to load script from ${url}. Status: ${response.status}`);
        }
    } catch (error) {
        console.error(`Error loading stylesheet: ${error.message}`);
    }
}


function isMobile() {
    const e = /(iphone|ipod|ipad|android|iemobile|blackberry|bada)/.test(window.navigator.userAgent.toLowerCase());
    return e || (navigator.userAgent.includes("Mac") && "ontouchend"in document)
}

async function ready (id) {
    var count = 0;

    return new Promise(async function (resolve, reject) {
        var ready = setInterval(function() {
            var element = document.getElementById(id);
            
            if (count === 10000) {
                clearInterval(ready);
                return reject(false);
            }

            if (!element) return count++;

            clearInterval(ready);
            return resolve(element);
        }, 1);
    })
}

async function loaded (geoflo) {
    return new Promise(async function (resolve, reject) {
        var ready = setInterval(function() {
            if (!geoflo.isLoaded) return false;
            clearInterval(ready);
            return resolve(geoflo.isLoaded);
        }, 1);
    })
}

function buildMapbox () {
    const DOM = {
        create: function create (tagName, className, container) {
            const el = window.document.createElement(tagName);
            if (className !== undefined) el.className = className;
            if (container) container.appendChild(el);
            return el;
        }
    }

    // Override to add a Top-Center
    mapboxgl.Map.prototype._setupContainer = function () {
        const container = this._container;
        container.classList.add('mapboxgl-map');

        const missingCSSCanary = this._missingCSSCanary = DOM.create('div', 'mapboxgl-canary', container);
        missingCSSCanary.style.visibility = 'hidden';
        this._detectMissingCSS();

        const canvasContainer = this._canvasContainer = DOM.create('div', 'mapboxgl-canvas-container', container);
        if (this._interactive) {
            canvasContainer.classList.add('mapboxgl-interactive');
        }

        this._canvas = DOM.create('canvas', 'mapboxgl-canvas', canvasContainer);
        // $FlowFixMe[method-unbinding]
        this._canvas.addEventListener('webglcontextlost', this._contextLost, false);
        // $FlowFixMe[method-unbinding]
        this._canvas.addEventListener('webglcontextrestored', this._contextRestored, false);
        this._canvas.setAttribute('tabindex', '0');
        this._canvas.setAttribute('aria-label', this._getUIString('Map.Title'));
        this._canvas.setAttribute('role', 'region');

        this._updateContainerDimensions();
        this._resizeCanvas(this._containerWidth, this._containerHeight);

        const controlContainer = this._controlContainer = DOM.create('div', 'mapboxgl-control-container', container);
        const positions = this._controlPositions = {};

        ['top-left', 'top-right', 'top-center', 'bottom-left', 'bottom-right'].forEach((positionName) => {
            positions[positionName] = DOM.create('div', `mapboxgl-ctrl-${positionName}`, controlContainer);
        });

        // $FlowFixMe[method-unbinding]
        this._container.addEventListener('scroll', this._onMapScroll, false);
    }
}


})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EseURBQXlELGNBQWM7QUFDdkU7QUFDQSxpQkFBaUI7QUFDakIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFD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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLElBQUk7Ozs7Ozs7Ozs7Ozs7O0FDanJDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDBCQUEwQjtBQUMxQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7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LFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsU0FBUztBQUN2QixjQUFjLFNBQVM7QUFDdkIsY0FBYyxTQUFTO0FBQ3ZCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0Qjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsMkRBQTJEO0FBQ3pFLGNBQWMsc0VBQXNFO0FBQ3BGLGNBQWMsdURBQXVEO0FBQ3JFLGNBQWMseURBQXlEO0FBQ3ZFLGNBQWMsK0RBQStEO0FBQzdFLGNBQWM7QUFDZDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCLE1BQU07QUFDM0I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtB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R0FBRztBQUM1Qix5QkFBeUIsR0FBRztBQUM1QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUVBQWUsT0FBTzs7Ozs7Ozs7Ozs7Ozs7QUMvTnRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQSxjQUFjLGlGQUFpRjtBQUMvRixjQUFjLHlFQUF5RTtBQUN2RixjQUFjLDJEQUEyRDtBQUN6RSxjQUFjLHVEQUF1RDtBQUNyRSxjQUFjLHlEQUF5RDtBQUN2RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSxjQUFjO0FBQzVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsaUVBQWUsTUFBTTs7Ozs7Ozs7Ozs7Ozs7QUNsTnJCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0NBQWdDLHVCQUF1QjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUzs7QUFFVDtBQUNBLGtFQUFrRSxlQUFlO0FBQ2pGO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLFlBQVksT0FBTztBQUNuQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsWUFBWSxPQUFPO0FBQ25CLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLGVBQWU7QUFDM0IsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZ0JBQWdCO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxPQUFPO0FBQ25CLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsY0FBYyxlQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksV0FBVztBQUN2QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwQ0FBMEM7QUFDdEQsWUFBWSxRQUFRO0FBQ3BCLGNBQWMsMENBQTBDO0FBQ3hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDRDQUE0Qyw2QkFBNkI7QUFDekUsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVix3REFBd0QsZ0RBQWdEO0FBQ3hHO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQixZQUFZLFVBQVU7QUFDdEIsY0FBYyxLQUFLO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ04sd0RBQU87QUFDUCxzREFBTTtBQUNOLHlEQUFRO0FBQ1Isd0RBQU87QUFDUCx3REFBTztBQUNQLDBEQUFTO0FBQ1QseURBQVE7OztBQUdSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHdEQUF3RCxJQUFJLFlBQVksZ0JBQWdCO0FBQ3hGO0FBQ0EsTUFBTTtBQUNOLCtDQUErQyxjQUFjO0FBQzdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysd0RBQXdELElBQUksWUFBWSxnQkFBZ0I7QUFDeEY7QUFDQSxNQUFNO0FBQ04sbURBQW1ELGNBQWM7QUFDakU7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHlFQUF5RSxhQUFhO0FBQ3RGLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac29sdXRlZ3JhdGUvZ2VvZmxvLXNkay8uL3NyYy9Db250cm9sLmpzIiwid2VicGFjazovL0Bzb2x1dGVncmF0ZS9nZW9mbG8tc2RrLy4vc3JjL0RyYXcuanMiLCJ3ZWJwYWNrOi8vQHNvbHV0ZWdyYXRlL2dlb2Zsby1zZGsvLi9zcmMvRXZlbnRzLmpzIiwid2VicGFjazovL0Bzb2x1dGVncmF0ZS9nZW9mbG8tc2RrLy4vc3JjL0V4cGxvcmluZy5qcyIsIndlYnBhY2s6Ly9Ac29sdXRlZ3JhdGUvZ2VvZmxvLXNkay8uL3NyYy9GZWF0dXJlcy5qcyIsIndlYnBhY2s6Ly9Ac29sdXRlZ3JhdGUvZ2VvZmxvLXNkay8uL3NyYy9HYW1lcGFkLmpzIiwid2VicGFjazovL0Bzb2x1dGVncmF0ZS9nZW9mbG8tc2RrLy4vc3JjL0xheWVycy5qcyIsIndlYnBhY2s6Ly9Ac29sdXRlZ3JhdGUvZ2VvZmxvLXNkay8uL3NyYy9Mb2NhdGUuanMiLCJ3ZWJwYWNrOi8vQHNvbHV0ZWdyYXRlL2dlb2Zsby1zZGsvLi9zcmMvTWVzaC5qcyIsIndlYnBhY2s6Ly9Ac29sdXRlZ3JhdGUvZ2VvZmxvLXNkay8uL3NyYy9PcHRpb25zLmpzIiwid2VicGFjazovL0Bzb2x1dGVncmF0ZS9nZW9mbG8tc2RrLy4vc3JjL1BhaW50aW5nLmpzIiwid2VicGFjazovL0Bzb2x1dGVncmF0ZS9nZW9mbG8tc2RrLy4vc3JjL1Bpbm5pbmcuanMiLCJ3ZWJwYWNrOi8vQHNvbHV0ZWdyYXRlL2dlb2Zsby1zZGsvLi9zcmMvUm91dGluZy5qcyIsIndlYnBhY2s6Ly9Ac29sdXRlZ3JhdGUvZ2VvZmxvLXNkay8uL3NyYy9TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vQHNvbHV0ZWdyYXRlL2dlb2Zsby1zZGsvLi9zcmMvU25hcHBpbmcuanMiLCJ3ZWJwYWNrOi8vQHNvbHV0ZWdyYXRlL2dlb2Zsby1zZGsvLi9zcmMvU3RhdGljcy5qcyIsIndlYnBhY2s6Ly9Ac29sdXRlZ3JhdGUvZ2VvZmxvLXNkay8uL3NyYy9TdHlsZXMuanMiLCJ3ZWJwYWNrOi8vQHNvbHV0ZWdyYXRlL2dlb2Zsby1zZGsvLi9zcmMvVXRpbGl0aWVzLmpzIiwid2VicGFjazovL0Bzb2x1dGVncmF0ZS9nZW9mbG8tc2RrL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0Bzb2x1dGVncmF0ZS9nZW9mbG8tc2RrL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly9Ac29sdXRlZ3JhdGUvZ2VvZmxvLXNkay93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL0Bzb2x1dGVncmF0ZS9nZW9mbG8tc2RrL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vQHNvbHV0ZWdyYXRlL2dlb2Zsby1zZGsvLi9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtaXhpblxuICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG9cbiAqIEBuYW1lIENvbnRyb2xcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1vZHVsZSBpcyByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgYW5kIG1hbmFnaW5nIHRoZSBjb250cm9sIGJ1dHRvbnMgaW4gdGhlIEdlb2ZsbyBhcHBsaWNhdGlvbi5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbnRyb2xzIC0gQW4gYXJyYXkgb2YgY29udHJvbCBvYmplY3RzIHRvIGJlIGFkZGVkIHRvIHRoZSBtYXAuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHRoZSBjb250cm9sIGJ1dHRvbnMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBDb250cm9sIG9iamVjdC5cbiAqL1xuXG5jb25zdCBDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2xzLCBvcHRpb25zPXt9KSB7XG4gICAgY29uc3QgZ2VvZmxvID0gdGhpcy5nZW9mbG87XG5cbiAgICB0aGlzLmNvbnRyb2xzID0gY29udHJvbHM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHZhciByZ2JhID0gZnVuY3Rpb24gKGhleCwgYWxwaGEpIHtcbiAgICAgICAgaGV4ID0gaGV4LnRyaW0oKTtcblxuXG4gICAgICAgIGlmIChoZXguaW5jbHVkZXMoJ3JnYmEnKSkge1xuICAgICAgICAgICAgaGV4ID0gdGhpcy5oZXgoaGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGV4IHx8IFs0LCA3XS5pbmRleE9mKGhleC5sZW5ndGgpID09PSAtMSkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICAgICAgICBoZXggPSBoZXguc3Vic3RyKDEpO1xuXG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgICAgICAgIGhleCA9IGhleC5zcGxpdCgnJykubWFwKGZ1bmN0aW9uIChlbCkgeyByZXR1cm4gZWwgKyBlbCArICcnOyB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByID0gcGFyc2VJbnQoaGV4LnNsaWNlKDAsIDIpLCAxNiksXG4gICAgICAgICAgICBnID0gcGFyc2VJbnQoaGV4LnNsaWNlKDIsIDQpLCAxNiksXG4gICAgICAgICAgICBiID0gcGFyc2VJbnQoaGV4LnNsaWNlKDQsIDYpLCAxNik7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gYWxwaGEgIT09IHVuZGVmaW5lZCA/IFwicmdiYShcIiArIHIgKyBcIiBcIiArIGcgKyBcIiBcIiArIGIgKyBcIiAvIFwiICsgYWxwaGEgKyBcIiUpXCIgOiBcInJnYihcIiArIHIgKyBcIiBcIiArIGcgKyBcIiBcIiArIGIgKyBcIilcIjtcbiAgICB9XG5cbiAgICB2YXIgaGV4ID0gZnVuY3Rpb24gKHJnYmEpIHtcbiAgICAgICAgdmFyIGEsXG4gICAgICAgICAgICByZ2IgPSByZ2JhLnJlcGxhY2UoL1xccy9nLCAnJykubWF0Y2goL15yZ2JhP1xcKChcXGQrKSwoXFxkKyksKFxcZCspLD8oW14sXFxzKV0rKT8vaSksXG4gICAgICAgICAgICBhbHBoYSA9IChyZ2IgJiYgcmdiWzRdIHx8IFwiXCIpLnRyaW0oKSxcbiAgICAgICAgICAgIGhleCA9IHJnYiA/IChyZ2JbMV0gfCAxIDw8IDgpLnRvU3RyaW5nKDE2KS5zbGljZSgxKSArIChyZ2JbMl0gfCAxIDw8IDgpLnRvU3RyaW5nKDE2KS5zbGljZSgxKSArIChyZ2JbM10gfCAxIDw8IDgpLnRvU3RyaW5nKDE2KS5zbGljZSgxKSA6IHJnYmE7XG5cbiAgICAgICAgaWYgKGFscGhhICE9PSBcIlwiKSB7XG4gICAgICAgICAgICBhID0gYWxwaGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGEgPSAoKGEgKiAyNTUpIHwgMSA8PCA4KS50b1N0cmluZygxNikuc2xpY2UoMSlcbiAgICAgICAgaGV4ID0gaGV4ICsgYTtcbiAgICAgICAgcmV0dXJuIGhleDtcbiAgICB9XG5cblxuXG4gICAgLyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkNvbnRyb2xcblx0ICogQG5hbWUgZW5hYmxlXG4gICAgICogQGRlc2NyaXB0aW9uIEVuYWJsZXMgdGhlIGNvbnRyb2wgYnV0dG9ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY29udHJvbCAtIFRoZSBjb250cm9sIG9iamVjdCB0byBlbmFibGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udHJvbCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5lbmFibGUgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uIHx8ICd0b3AtY2VudGVyJztcbiAgICAgICAgZ2VvZmxvLm1hcC5hZGRDb250cm9sKHRoaXMsIHRoaXMucG9zaXRpb24pO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Db250cm9sXG5cdCAqIEBuYW1lIGRpc2FibGVcbiAgICAgKiBAZGVzY3JpcHRpb24gRGlzYWJsZXMgdGhlIGNvbnRyb2wgYnV0dG9ucy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb250cm9sIG9iamVjdC5cbiAgICAgKi9cbiAgICB0aGlzLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdlb2Zsby5tYXAucmVtb3ZlQ29udHJvbCh0aGlzKTtcbiAgICB9XG5cblxuXG4gICAgLyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkNvbnRyb2xcblx0ICogQG5hbWUgb25BZGRcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkcyB0aGUgY29udHJvbCBidXR0b25zIHRvIHRoZSBtYXAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1hcCAtIFRoZSBtYXAgb2JqZWN0IHRvIGFkZCB0aGUgY29udHJvbCBidXR0b25zIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnRyb2wgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMub25BZGQgPSBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbikgcmV0dXJuIHRoaXMuc2V0QXR0cmlidXRpb24obWFwKTtcbiAgICAgICAgdGhpcy5zZXRUaGVtZShvcHRpb25zLmNvbG9ycyB8fCBnZW9mbG8ub3B0aW9ucy5jb2xvcnMpO1xuICAgICAgICBnZW9mbG8uZmlyZSgnY29udHJvbC5hZGQnLCB7IGNvbnRyb2w6IHRoaXMsIGVsZW1lbnQ6IHRoaXMuZWxlbWVudCB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uQ29udHJvbFxuXHQgKiBAbmFtZSBvblJlbW92ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHRoZSBjb250cm9sIGJ1dHRvbnMgZnJvbSB0aGUgbWFwLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnRyb2wgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMub25SZW1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ2NvbnRyb2wucmVtb3ZlJywgeyBlbGVtZW50OiB0aGlzLmVsZW1lbnQsIGNvbnRyb2w6IHRoaXMgfSk7XG4gICAgfVxuXG5cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Db250cm9sXG5cdCAqIEBuYW1lIHNldEF0dHJpYnV0aW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIGF0dHJpYnV0aW9uIGZvciB0aGUgY29udHJvbCBidXR0b25zLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnRyb2wgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMuc2V0QXR0cmlidXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhdHRyID0gQXR0cihnZW9mbG8sIHRoaXMuY29udHJvbCwgb3B0aW9ucyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgYXR0cilcblxuICAgICAgICB0aGlzLnNldFRoZW1lKG9wdGlvbnMuY29sb3JzIHx8IGdlb2Zsby5vcHRpb25zLmNvbG9ycyk7XG4gICAgICAgIGdlb2Zsby5maXJlKCdjb250cm9sLmFkZCcsIHsgY29udHJvbDogdGhpcywgZWxlbWVudDogdGhpcy5lbGVtZW50IH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50O1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Db250cm9sXG5cdCAqIEBuYW1lIHNldE1vZGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgbW9kZSBmb3IgdGhlIGNvbnRyb2wgYnV0dG9ucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9kZSAtIFRoZSBtb2RlIHRvIHNldCB0aGUgY29udHJvbCBidXR0b25zIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbnRyb2wgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMuc2V0TW9kZSA9IGZ1bmN0aW9uIChtb2RlKSB7XG4gICAgICAgIGdlb2Zsby5zZXRBY3RpdmVCdXR0b24oIW1vZGUgPyAnc2VsZWN0JyA6IG1vZGUgPT09ICdkcmF3JyA/IG1vZGUgOiBtb2RlKVxuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Db250cm9sXG5cdCAqIEBuYW1lIHNldFRoZW1lXG4gICAgICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIHRoZW1lIGZvciB0aGUgY29udHJvbCBidXR0b25zLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb2xvcnMgLSBUaGUgY29sb3JzIHRvIHNldCB0aGUgdGhlbWUgdG8uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udHJvbCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5zZXRUaGVtZSA9IGZ1bmN0aW9uKGNvbG9ycykge1xuICAgICAgICBpZiAoIWNvbG9ycykgeyByZXR1cm4gY29uc29sZS5lcnJvcignQ29udHJvbCBjb2xvcnMgbm90IHByb3ZpZGVkIScpIH07XG5cbiAgICAgICAgY29sb3JzLnByaW1hcnlDb2xvciA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS0nICsgZ2VvZmxvLmlkICsgJy1wcmltYXJ5LWNvbG9yJywgcmdiYShjb2xvcnMucHJpbWFyeUNvbG9yKSkgOiBmYWxzZTtcbiAgICAgICAgY29sb3JzLnByaW1hcnlCYWNrZ3JvdW5kID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLScgKyBnZW9mbG8uaWQgKyAnLXByaW1hcnktYmFja2dyb3VuZCcsIHJnYmEoY29sb3JzLnByaW1hcnlCYWNrZ3JvdW5kKSkgOiBmYWxzZTtcbiAgICAgICAgY29sb3JzLnByaW1hcnlUZXh0ID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLScgKyBnZW9mbG8uaWQgKyAnLXByaW1hcnktdGV4dCcsIHJnYmEoY29sb3JzLnByaW1hcnlUZXh0KSkgOiBmYWxzZTtcbiAgICAgICAgY29sb3JzLnByaW1hcnlCb3JkZXIgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tJyArIGdlb2Zsby5pZCArICctcHJpbWFyeS1ib3JkZXInLCByZ2JhKGNvbG9ycy5wcmltYXJ5Qm9yZGVyKSkgOiBmYWxzZTtcblxuICAgICAgICBjb2xvcnMuc2Vjb25kYXJ5Q29sb3IgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoJy0tJyArIGdlb2Zsby5pZCArICctc2Vjb25kYXJ5LWNvbG9yJywgcmdiYShjb2xvcnMuc2Vjb25kYXJ5Q29sb3IpKSA6IGZhbHNlO1xuICAgICAgICBjb2xvcnMuc2Vjb25kYXJ5QmFja2dyb3VuZCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS0nICsgZ2VvZmxvLmlkICsgJy1zZWNvbmRhcnktYmFja2dyb3VuZCcsIHJnYmEoY29sb3JzLnNlY29uZGFyeUJhY2tncm91bmQpKSA6IGZhbHNlO1xuICAgICAgICBjb2xvcnMuc2Vjb25kYXJ5VGV4dCA/IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS0nICsgZ2VvZmxvLmlkICsgJy1zZWNvbmRhcnktdGV4dCcsIHJnYmEoY29sb3JzLnNlY29uZGFyeVRleHQpKSA6IGZhbHNlO1xuICAgICAgICBjb2xvcnMuc2Vjb25kYXJ5Qm9yZGVyID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KCctLScgKyBnZW9mbG8uaWQgKyAnLXNlY29uZGFyeS1ib3JkZXInLCByZ2JhKGNvbG9ycy5zZWNvbmRhcnlCb3JkZXIpKSA6IGZhbHNlO1xuXG4gICAgICAgIGdlb2Zsby5maXJlKCd0aGVtZS5jaGFuZ2UnLCB7IGNvbG9yczogY29sb3JzIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRUaGVtZSgpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Db250cm9sXG5cdCAqIEBuYW1lIHNldENvbnRyb2xcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgY29udHJvbCBidXR0b25zLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGNvbnRyb2xzIC0gVGhlIGNvbnRyb2wgYnV0dG9ucyB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udHJvbCBvYmplY3QuXG4gICAgICovXG4gICAgdGhpcy5zZXRDb250cm9sID0gZnVuY3Rpb24gKGNvbnRyb2xzKSB7XG4gICAgICAgIGlmICghY29udHJvbHMpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgYnV0dG9ucztcblxuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTmFtZSA9IGdlb2Zsby5pZCArICctY29udHJvbC13cmFwJztcblxuICAgICAgICB0aGlzLmNvbnRyb2wgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5jb250cm9sLmNsYXNzTmFtZSA9IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLlBSRURFRklORURfQ09OVFJPTF9CQVNFICsgJyAnICsgZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuUFJFREVGSU5FRF9DT05UUk9MX0dST1VQO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmNvbnRyb2wpO1xuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRyb2xzKSkge1xuICAgICAgICAgICAgYnV0dG9ucyA9IEJ1dHRvbnModGhpcy5jb250cm9sLCBjb250cm9scyk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMsIGJ1dHRvbnMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVuYWJsZShidXR0b25zLnBvc2l0aW9uKTtcbiAgICB9XG5cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Db250cm9sXG5cdCAqIEBuYW1lIGdldFRoZW1lXG4gICAgICogQGRlc2NyaXB0aW9uIEdldHMgdGhlIHRoZW1lIGZvciB0aGUgY29udHJvbCBidXR0b25zLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHRoZW1lIGZvciB0aGUgY29udHJvbCBidXR0b25zLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0VGhlbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGdlb2Zsby5vcHRpb25zLmNvbG9ycztcbiAgICB9XG5cbiAgICAvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uQ29udHJvbFxuXHQgKiBAbmFtZSBnZXRCdXR0b25zXG4gICAgICogQGRlc2NyaXB0aW9uIEdldHMgdGhlIGNvbnRyb2wgYnV0dG9ucy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb250cm9sIGJ1dHRvbnMuXG4gICAgICovXG4gICAgdGhpcy5nZXRCdXR0b25zID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnV0dG9ucztcbiAgICB9XG5cbiAgICAvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uQ29udHJvbFxuXHQgKiBAbmFtZSBnZXRDb250cm9sXG4gICAgICogQGRlc2NyaXB0aW9uIEdldHMgdGhlIGNvbnRyb2wgYnV0dG9ucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIGNvbnRyb2wgYnV0dG9uIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb250cm9sIGJ1dHRvbi5cbiAgICAgKi9cbiAgICB0aGlzLmdldENvbnRyb2wgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIG5vZGVzID0gdGhpcy5jb250cm9sLmNoaWxkTm9kZXM7XG4gICAgICAgIGlmICghbm9kZXMubGVuZ3RoKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgICAgaWYgKGlkKSBub2Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG4pIHsgaWYgKG4uY2xhc3NMaXN0LmNvbnRhaW5zKGlkKSkgY29udHJvbCA9IG4gfSk7XG4gICAgICAgIHJldHVybiBjb250cm9sO1xuICAgIH1cblxuXG4gICAgLyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkNvbnRyb2xcblx0ICogQG5hbWUgc2hvd0NvbnRyb2xcbiAgICAgKiBAZGVzY3JpcHRpb24gU2hvd3MgdGhlIGNvbnRyb2wgYnV0dG9ucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIGNvbnRyb2wgYnV0dG9uIHRvIHNob3cuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udHJvbCBidXR0b24uXG4gICAgICovXG4gICAgdGhpcy5zaG93Q29udHJvbCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgY29udHJvbCA9IHRoaXMuZ2V0Q29udHJvbChpZCk7XG4gICAgICAgIGlmICghY29udHJvbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgY29udHJvbC5zdHlsZS5kaXNwbGF5ID0gdGhpcy5wb3NpdGlvbi5pbmNsdWRlcygnY2VudGVyJykgPyAgJ2ZsZXgnIDogJ2Jsb2NrJztcbiAgICAgICAgcmV0dXJuIGNvbnRyb2w7XG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkNvbnRyb2xcblx0ICogQG5hbWUgaGlkZUNvbnRyb2xcbiAgICAgKiBAZGVzY3JpcHRpb24gSGlkZXMgdGhlIGNvbnRyb2wgYnV0dG9ucy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIGNvbnRyb2wgYnV0dG9uIHRvIGhpZGUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29udHJvbCBidXR0b24uXG4gICAgICovXG4gICAgdGhpcy5oaWRlQ29udHJvbCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgY29udHJvbCA9IHRoaXMuZ2V0Q29udHJvbChpZCk7XG4gICAgICAgIGlmICghY29udHJvbCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGNvbnRyb2wuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgcmV0dXJuIGNvbnRyb2w7XG4gICAgfVxuXG5cbiAgICB0aGlzLnNldENvbnRyb2woY29udHJvbHMpO1xuXG4gICAgZnVuY3Rpb24gQnV0dG9ucyAoZWxlbWVudCwgY29udHJvbHMpIHtcbiAgICAgICAgaWYgKCFjb250cm9scyB8fCAhZWxlbWVudCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgICAgICB2YXIgY2xhc3NUeXBlcyA9IFsnbW9kZScsICdmZWF0dXJlJywgJ21vdXNlJ107XG4gICAgICAgIHZhciBidXR0b25FbGVtZW50cyA9IHt9O1xuICAgICAgICB2YXIgYnV0dG9uT3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgYWN0aXZlQnV0dG9uID0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRDb250cm9sO1xuICAgICAgICB2YXIgcG9zaXRpb247XG4gICAgICAgIFxuICAgIFxuICAgICAgICB2YXIgY3VycmVudE1hcENsYXNzZXMgPSB7XG4gICAgICAgICAgICBtb2RlOiBudWxsLFxuICAgICAgICAgICAgZmVhdHVyZTogbnVsbCxcbiAgICAgICAgICAgIG1vdXNlOiBudWxsXG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHZhciBuZXh0TWFwQ2xhc3NlcyA9IHtcbiAgICAgICAgICAgIG1vZGU6IG51bGwsXG4gICAgICAgICAgICBmZWF0dXJlOiBudWxsLFxuICAgICAgICAgICAgbW91c2U6IG51bGxcbiAgICAgICAgfTtcbiAgICBcbiAgICBcbiAgICBcbiAgICAgICAgY29uc3QgbW91c2VsZWF2ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKCFnZW9mbG8uY3VycmVudE1vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVPZmZNYXAgPyBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlT2ZmTWFwKGV2ZW50KSA6IGZhbHNlO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGNvbnN0IG1vdXNlb3ZlciA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgaWYgKCFnZW9mbG8uY3VycmVudE1vZGUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVPbk1hcCA/IGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVPbk1hcChldmVudCkgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBjb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sKSB7XG4gICAgICAgICAgICBpZiAoIWdldENvbnRyb2xPcHRpb25zKGNvbnRyb2wpKSBjb250cm9sLnNob3cgPSBmYWxzZTtcbiAgICAgICAgICAgIHNldFBvc2l0aW9uKGNvbnRyb2wpO1xuICAgICAgICAgICAgY3JlYXRlQnV0dG9ucyhlbGVtZW50LCBjb250cm9sKTtcbiAgICAgICAgfSlcbiAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNldEFjdGl2ZUJ1dHRvbjogc2V0QWN0aXZlQnV0dG9uLFxuICAgICAgICAgICAgcXVldWVNYXBDbGFzc2VzOiBxdWV1ZU1hcENsYXNzZXMsXG4gICAgICAgICAgICB1cGRhdGVNYXBDbGFzc2VzOiB1cGRhdGVNYXBDbGFzc2VzLFxuICAgICAgICAgICAgcmVtb3ZlQnV0dG9uczogcmVtb3ZlQnV0dG9ucyxcbiAgICAgICAgICAgIGdldEJ1dHRvbk9wdGlvbnM6IGdldEJ1dHRvbk9wdGlvbnMsXG4gICAgICAgICAgICBnZXRCdXR0b25FbGVtZW50czogZ2V0QnV0dG9uRWxlbWVudHMsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIHF1ZXVlTWFwQ2xhc3NlcyhvcHRpb25zKSB7XG4gICAgICAgICAgICBuZXh0TWFwQ2xhc3NlcyA9IGdlb2Zsby5VdGlsaXRpZXMuZXh0ZW5kKG5leHRNYXBDbGFzc2VzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVNYXBDbGFzc2VzKCkge1xuICAgICAgICAgICAgaWYgKCFnZW9mbG8uY29udGFpbmVyKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICBcbiAgICAgICAgICAgIHZhciBjbGFzc2VzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgICAgIHZhciBjbGFzc2VzVG9BZGQgPSBbXTtcbiAgICBcbiAgICAgICAgICAgIGNsYXNzVHlwZXMuZm9yRWFjaChmdW5jdGlvbih0eXBlKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRNYXBDbGFzc2VzW3R5cGVdID09PSBjdXJyZW50TWFwQ2xhc3Nlc1t0eXBlXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgIFxuICAgICAgICAgICAgICAgIGNsYXNzZXNUb1JlbW92ZS5wdXNoKHR5cGUgKyAnLScgKyBjdXJyZW50TWFwQ2xhc3Nlc1t0eXBlXSk7XG4gICAgICAgICAgICAgICAgaWYgKG5leHRNYXBDbGFzc2VzW3R5cGVdICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzZXNUb0FkZC5wdXNoKHR5cGUgKyAnLScgKyBuZXh0TWFwQ2xhc3Nlc1t0eXBlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICBpZiAoY2xhc3Nlc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgX2dlb2ZsbyRjb250YWluZXIkY2xhc3NMO1xuICAgIFxuICAgICAgICAgICAgICAgIChfZ2VvZmxvJGNvbnRhaW5lciRjbGFzc0wgPSBnZW9mbG8uY29udGFpbmVyLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9nZW9mbG8kY29udGFpbmVyJGNsYXNzTCwgY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGlmIChjbGFzc2VzVG9BZGQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBfZ2VvZmxvJGNvbnRhaW5lciRjbGFzc0wyO1xuICAgIFxuICAgICAgICAgICAgICAgIChfZ2VvZmxvJGNvbnRhaW5lciRjbGFzc0wyID0gZ2VvZmxvLmNvbnRhaW5lci5jbGFzc0xpc3QpLmFkZC5hcHBseShfZ2VvZmxvJGNvbnRhaW5lciRjbGFzc0wyLCBjbGFzc2VzVG9BZGQpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgY3VycmVudE1hcENsYXNzZXMgPSBnZW9mbG8uVXRpbGl0aWVzLmV4dGVuZChjdXJyZW50TWFwQ2xhc3NlcywgbmV4dE1hcENsYXNzZXMpO1xuICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVRpdGxlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiAnJyArIG9wdGlvbnMudGl0bGUgKyAob3B0aW9ucy5rZXkgPyAnICgnICsgb3B0aW9ucy5rZXkgKyAnKScgOiBcIlwiKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVCdXR0b25zIChlbGVtZW50LCBjb250cm9sKSB7XG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdmFyIGdyb3VwID0gKGNvbnRyb2wuZ3JvdXAgPyBjb250cm9sLmdyb3VwLnRvVXBwZXJDYXNlKCkgOiBjb250cm9sLmF0dHJpYnV0aW9uID8gJ0FUVFInIDogJ05PTkUnKSArICdfR1JPVVAnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGJ1dHRvbnMpO1xuICAgIFxuICAgICAgICAgICAgYnV0dG9ucy5jbGFzc05hbWUgPSAnJyArIGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzW2dyb3VwXSArICcgJyArIGNvbnRyb2wudHlwZTtcbiAgICAgICAgICAgIGJ1dHRvbnMuc3R5bGUuZGlzcGxheSA9IGNvbnRyb2wuc2hvdyA/IHBvc2l0aW9uLmluY2x1ZGVzKCdjZW50ZXInKSA/ICAnZmxleCcgOiAnYmxvY2snIDogJ25vbmUnO1xuICAgIFxuICAgICAgICAgICAgY29udHJvbC5zaG93ICYmIGNvbnRyb2wuZGl2aWRlciA/IGVsZW1lbnQuYXBwZW5kQ2hpbGQoY3JlYXRlRGl2aWRlcigpKSA6IGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgYnV0dG9ucy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBtb3VzZW92ZXIpO1xuICAgICAgICAgICAgYnV0dG9ucy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgbW91c2VsZWF2ZSk7XG4gICAgXG4gICAgICAgICAgICBhZGRCdXR0b25zKGNvbnRyb2wsIGJ1dHRvbnMpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbnM7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlQmFzZUJ1dHRvbihpZCwgb3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50Q29udHJvbCB8fCAhY3VycmVudENvbnRyb2wuYnV0dG9uc1tpZF0pIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbiA9IG9wdGlvbnMucG9zaXRpb247XG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gb3B0aW9ucy5idXR0b24gfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgXG4gICAgICAgICAgICBvcHRpb25zLmtleSA9IGdlb2Zsby5vcHRpb25zLmtleXMgJiYgZ2VvZmxvLm9wdGlvbnMua2V5c1tpZF0gPyBnZW9mbG8ub3B0aW9ucy5rZXlzW2lkXSA6IG9wdGlvbnMua2V5O1xuICAgIFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMudGl0bGUpIHsgYnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBjcmVhdGVUaXRsZShvcHRpb25zKSk7IH1cbiAgICAgICAgICAgIG9wdGlvbnMuY29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgXG4gICAgICAgICAgICBvcHRpb25zW1wiaWRcIl0gPSBpZDtcbiAgICAgICAgICAgIG9wdGlvbnNbXCJidXR0b25cIl0gPSBidXR0b247XG4gICAgXG4gICAgICAgICAgICBvcHRpb25zLmFkZCA9IGZ1bmN0aW9uIChvcHRzPXt9KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgICAgICAgICB0aGlzLm9uQWRkID8gdGhpcy5vbkFkZChvcHRzKSA6IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBvcHRpb25zLnJlbW92ZSA9IGZ1bmN0aW9uIChvcHRzPXt9KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLm9uUmVtb3ZlID8gdGhpcy5vblJlbW92ZShvcHRzKSA6IHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBvcHRpb25zLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUob3B0aW9ucy5pbmFjdGl2ZUNsYXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5jbGFzc0xpc3QuYWRkKG9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLmNsYXNzTGlzdC5hZGQoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQUNUSVZFX0JVVFRPTik7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgb3B0aW9ucy5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKG9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkFDVElWRV9CVVRUT04pO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKG9wdGlvbnMuaW5hY3RpdmVDbGFzcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5hY3RpdmF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIG9wdGlvbnMuZG9udFNob3cgPyBidXR0b24uc3R5bGUuZGlzcGxheSA9ICdub25lJyA6IGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgYnV0dG9uRWxlbWVudHNbaWRdID0gYnV0dG9uO1xuICAgICAgICAgICAgYnV0dG9uT3B0aW9uc1tpZF0gPSBvcHRpb25zO1xuICAgIFxuICAgICAgICAgICAgaWYgKHBvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbi5pbmNsdWRlcygncmlnaHQnKSA/ICdsZWZ0JyA6XG4gICAgICAgICAgICAgICAgcG9zaXRpb24uaW5jbHVkZXMoJ2xlZnQnKSA/ICdyaWdodCcgOlxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLmluY2x1ZGVzKCdib3R0b20nKSA/ICd0b3AnIDpcbiAgICAgICAgICAgICAgICBwb3NpdGlvbi5pbmNsdWRlcygndG9wJykgPyAnYm90dG9tJyA6XG4gICAgICAgICAgICAgICAgJ2Fic29sdXRlJztcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIG9wdGlvbnMuY29udGFpbmVyLnRvb2x0aXBQb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgZ2VvZmxvLmFkZFRvb2x0aXAob3B0aW9ucy5jb250YWluZXIsIGJ1dHRvbiwgY3JlYXRlVGl0bGUob3B0aW9ucykpO1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVDb250cm9sQnV0dG9uKGlkKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgXG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gY3JlYXRlQmFzZUJ1dHRvbihpZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIWJ1dHRvbikgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OICsgJyAnICsgb3B0aW9ucy5jbGFzc05hbWU7XG4gICAgXG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5vbkNsaWNrKSByZXR1cm4gb3B0aW9ucy5vbkNsaWNrKGUudGFyZ2V0LCBvcHRpb25zKTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGFjdGl2ZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICBkZWFjdGl2YXRlQnV0dG9ucygpO1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uRGVhY3RpdmF0ZSA/IG9wdGlvbnMub25EZWFjdGl2YXRlKG9wdGlvbnMpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9uQWN0aXZhdGUob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0QWN0aXZlQnV0dG9uKGlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICBcbiAgICAgICAgICAgIHJldHVybiBidXR0b247XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gY3JlYXRlT3B0aW9uQnV0dG9uKGlkKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgXG4gICAgICAgICAgICB2YXIgYnV0dG9uID0gY3JlYXRlQmFzZUJ1dHRvbihpZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoIWJ1dHRvbikgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9ICcnICsgZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT047XG4gICAgXG4gICAgICAgICAgICBpZiAoZ2VvZmxvLm9wdGlvbnNbb3B0aW9ucy5uYW1lXSAmJiBnZW9mbG8ub3B0aW9uc1tvcHRpb25zLm5hbWVdLmVuYWJsZSkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKG9wdGlvbnMuYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkFDVElWRV9CVVRUT04pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZChvcHRpb25zLmluYWN0aXZlQ2xhc3MpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICghZ2VvZmxvLm9wdGlvbnNbb3B0aW9ucy5uYW1lXSkgeyBnZW9mbG8ub3B0aW9uc1tvcHRpb25zLm5hbWVdID0ge307IH1cbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoZ2VvZmxvLm9wdGlvbnNbb3B0aW9ucy5uYW1lXS5lbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMub25EZWFjdGl2YXRlKSBvcHRpb25zLm9uRGVhY3RpdmF0ZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uQWN0aXZhdGUob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgdHJ1ZSk7XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIGNyZWF0ZUFjdGlvbkJ1dHRvbihpZCkge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIFxuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGNyZWF0ZUJhc2VCdXR0b24oaWQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKCFidXR0b24pIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5BQ1RJT05fQlVUVE9OICsgJyAnICsgb3B0aW9ucy5jbGFzc05hbWU7XG4gICAgXG4gICAgICAgICAgICBpZiAoaWQgPT09ICdsb2NhdGUnICYmIGdlb2Zsby5sb2NhdGUpIGlmIChnZW9mbG8ubG9jYXRlLmNvbnRyb2wpIGdlb2Zsby5sb2NhdGUuY29udHJvbC5fY29udGFpbmVyLnJlbW92ZSgpO1xuICAgIFxuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMub25BY3RpdmF0ZShvcHRpb25zKTtcbiAgICAgICAgICAgIH0sIHRydWUpO1xuICAgIFxuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVEaXZpZGVyKCkge1xuICAgICAgICAgICAgdmFyIGRpdmlkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGRpdmlkZXIuY2xhc3NOYW1lID0gJycgKyBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5ESVZJREVSO1xuICAgICAgICAgICAgcmV0dXJuIGRpdmlkZXI7XG4gICAgICAgIH1cbiAgICBcbiAgICBcbiAgICAgICAgZnVuY3Rpb24gc2V0UG9zaXRpb24gKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICghcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbnRyb2wucG9zaXRpb24pIHRocm93IG5ldyBFcnJvcignVGhlIGZpcnN0IGNvbnRyb2wgbmVlZHMgdG8gaGF2ZSBhIHBvc2l0aW9uJylcbiAgICAgICAgICAgICAgICBwb3NpdGlvbiA9IGNvbnRyb2wucG9zaXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICBcbiAgICAgICAgZnVuY3Rpb24gZGVhY3RpdmF0ZUJ1dHRvbnMoKSB7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZUJ1dHRvbikgcmV0dXJuO1xuICAgICAgICAgICAgYWN0aXZlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQUNUSVZFX0JVVFRPTik7XG4gICAgICAgICAgICBhY3RpdmVCdXR0b24gPSBudWxsO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIHNldEFjdGl2ZUJ1dHRvbihpZCkge1xuICAgICAgICAgICAgZGVhY3RpdmF0ZUJ1dHRvbnMoKTtcbiAgICBcbiAgICAgICAgICAgIHZhciBidXR0b24gPSAhaWQgJiYgZ2VvZmxvLmVkaXRNb2RlID8gYnV0dG9uRWxlbWVudHNbJ2VkaXQnXSA6ICFpZCA/IGJ1dHRvbkVsZW1lbnRzWydzZWxlY3QnXSA6IGlkID09PSAnZWRpdCcgPyBidXR0b25FbGVtZW50c1snc2VsZWN0J10gOiBidXR0b25FbGVtZW50c1tpZF07XG4gICAgICAgICAgICBpZiAoIWJ1dHRvbikgcmV0dXJuO1xuICAgIFxuICAgICAgICAgICAgaWYgKGJ1dHRvbiAmJiBpZCAhPT0gJ3RyYXNoJykge1xuICAgICAgICAgICAgICAgIGlmIChidXR0b24udGl0bGUuaW5jbHVkZXMoJ0RyYXcgJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbi50aXRsZS5pbmNsdWRlcyhnZW9mbG8uY3VycmVudE1vZGUudHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkFDVElWRV9CVVRUT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlQnV0dG9uID0gYnV0dG9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQUNUSVZFX0JVVFRPTik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIGFkZEJ1dHRvbnMoY29udHJvbCwgYnV0dG9ucykge1xuICAgICAgICAgICAgY3VycmVudENvbnRyb2wgPSBjb250cm9sO1xuICAgIFxuICAgICAgICAgICAgaWYgKGNvbnRyb2wudHlwZSA9PT0gJ21vZGVzJykge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUNvbnRyb2xCdXR0b24oXCJzZWxlY3RcIiwge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT05fU0VMRUNULFxuICAgICAgICAgICAgICAgICAgICBrZXk6IFwic1wiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1NlbGVjdCBGZWF0dXJlcycsXG4gICAgICAgICAgICAgICAgICAgIG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGdlb2Zsby5lZGl0TW9kZSB8fCBnZW9mbG8uZHJhd01vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmdldEJ1dHRvbnMoJ2VkaXQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uZ2V0QnV0dG9ucygnc2F2ZScpLmFkZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9mbG8uaGFzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uZ2V0QnV0dG9ucygnc2F2ZScpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdlZGl0JykuYWRkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdzYXZlJykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmdldEJ1dHRvbnMoJ2VkaXQnKS5yZW1vdmUoKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uZ2V0QnV0dG9ucygndW5kbycpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdjYW5jZWwnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uZ2V0QnV0dG9ucygncmVkbycpLnJlbW92ZSgpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdpbXBvcnQnKS5hZGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uZ2V0QnV0dG9ucygnZXhwb3J0JykuYWRkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmdldEJ1dHRvbnMoJ2NsZWFyJykuYWRkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aXZhdGU6IGZ1bmN0aW9uIG9uQWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8ubm9TZWxlY3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5zZXRNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWFjdGl2YXRlOiBmdW5jdGlvbiBvbkRlYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8ubm9TZWxlY3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY3JlYXRlQ29udHJvbEJ1dHRvbihcImVkaXRcIiwge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT05fRURJVCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcIkVudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRWRpdCBGZWF0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgZG9udFNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQWRkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uZ2V0QnV0dG9ucygnc2VsZWN0JykucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkFDVElWRV9CVVRUT04pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5idXR0b24uc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnV0dG9uLnN0eWxlWydiYWNrZ3JvdW5kLWNvbG9yJ10gPSBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuc2Vjb25kYXJ5QmFja2dyb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25BY3RpdmF0ZTogZnVuY3Rpb24gb25BY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5lZGl0RmVhdHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmdldEJ1dHRvbnMoJ3NhdmUnKS5hZGQoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWFjdGl2YXRlOiBmdW5jdGlvbiBvbkRlYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdzYXZlJykgPyBmYWxzZSA6IGNyZWF0ZVNlbGVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIGNyZWF0ZUNvbnRyb2xCdXR0b24oXCJzYXZlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX0ZJTlNJSCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcIkVudGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnU2F2ZSBFZGl0JyxcbiAgICAgICAgICAgICAgICAgICAgZG9udFNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQWRkOiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmdldEJ1dHRvbnMoJ3NlbGVjdCcpLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmdldEJ1dHRvbnMoJ2VkaXQnKS5yZW1vdmUoKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdpbXBvcnQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdleHBvcnQnKS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdjbGVhcicpLnJlbW92ZSgpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmdldEJ1dHRvbnMoJ3VuZG8nKS5hZGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdjYW5jZWwnKS5hZGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdyZWRvJykuYWRkKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1dHRvbi5zdHlsZVsnYmFja2dyb3VuZC1jb2xvciddID0gZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnNlY29uZGFyeUNvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkFjdGl2YXRlOiBmdW5jdGlvbiBvbkFjdGl2YXRlKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5vcHRpb25zLnJlcGVhdERyYXcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdyZXBlYXQnKS5kZWFjdGl2YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlQ2xpY2soeyBmaW5pc2g6IHRydWUgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250cm9sLnR5cGUgPT09ICdvcHRpb25zJykge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUFjdGlvbkJ1dHRvbihcImltcG9ydFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9JTVBPUlQsXG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJ1XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnSW1wb3J0IEZlYXR1cmVzJyxcbiAgICAgICAgICAgICAgICAgICAgb25BY3RpdmF0ZTogZnVuY3Rpb24gb25BY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW9mbG8ubG9hZEZlYXR1cmVzKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgY3JlYXRlQWN0aW9uQnV0dG9uKFwiZXhwb3J0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX0VYUE9SVCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcImRcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdFeHBvcnQgRmVhdHVyZXMnLFxuICAgICAgICAgICAgICAgICAgICBvbkFjdGl2YXRlOiBmdW5jdGlvbiBvbkFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5zYXZlRmVhdHVyZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgIFxuICAgICAgICAgICAgICAgIGNyZWF0ZUFjdGlvbkJ1dHRvbihcImNsZWFyXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX0NMRUFSLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IFwiRGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRGVsZXRlIFNlbGVjdGVkIG9yIEFsbCBGZWF0dXJlcycsXG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aXZhdGU6IGZ1bmN0aW9uIG9uQWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uZGVsZXRlVXNlckRhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5nZXRCdXR0b25zKCdzZWxlY3QnKS5hZGQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY3JlYXRlQWN0aW9uQnV0dG9uKFwidW5kb1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9VTkRPLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IFwidVwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1VuZG8gRWRpdCcsXG4gICAgICAgICAgICAgICAgICAgIGRvbnRTaG93OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvbkFjdGl2YXRlOiBmdW5jdGlvbiBvbkFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVVbmRvKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBjcmVhdGVBY3Rpb25CdXR0b24oXCJyZWRvXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX1JFRE8sXG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJyXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnUmVkbyBFZGl0JyxcbiAgICAgICAgICAgICAgICAgICAgZG9udFNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aXZhdGU6IGZ1bmN0aW9uIG9uQWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZVJlZG8oKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgY3JlYXRlQWN0aW9uQnV0dG9uKFwiY2FuY2VsXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX0NBTkNFTCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcIkVzY2FwZVwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0NhbmNlbCBFZGl0JyxcbiAgICAgICAgICAgICAgICAgICAgZG9udFNob3c6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aXZhdGU6IGZ1bmN0aW9uIG9uQWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8ub3B0aW9ucy5yZXBlYXREcmF3ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uZ2V0QnV0dG9ucygncmVwZWF0JykuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5jYW5jZWxFZGl0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udHJvbC50eXBlID09PSAnYWN0aW9ucycpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVPcHRpb25CdXR0b24oXCJzbmFwcGluZ1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJzbmFwcGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0VuYWJsZS9EaXNhYmxlIFNuYXBwaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ2xhc3M6IGdlb2Zsby5pZCArICctc25hcHBpbmctZW5hYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgIGluYWN0aXZlQ2xhc3M6IGdlb2Zsby5pZCArICctc25hcHBpbmctZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICBvbkFjdGl2YXRlOiBmdW5jdGlvbiBvbkFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5hY3RpdmF0ZVNuYXBwaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGVhY3RpdmF0ZTogZnVuY3Rpb24gb25EZWFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5kZWFjdGl2YXRlU25hcHBpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBjcmVhdGVPcHRpb25CdXR0b24oXCJwaW5uaW5nXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcInBpbm5pbmdcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdFbmFibGUvRGlzYWJsZSBQaW5uaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ2xhc3M6IGdlb2Zsby5pZCArICctcGlubmluZy1lbmFibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgaW5hY3RpdmVDbGFzczogZ2VvZmxvLmlkICsgJy1waW5uaW5nLWRpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgb25BY3RpdmF0ZTogZnVuY3Rpb24gb25BY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW9mbG8uYWN0aXZhdGVQaW5uaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGVhY3RpdmF0ZTogZnVuY3Rpb24gb25EZWFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5kZWFjdGl2YXRlUGlubmluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGNyZWF0ZU9wdGlvbkJ1dHRvbihcInJvdXRpbmdcIiwge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicm91dGluZ1wiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0VuYWJsZS9EaXNhYmxlIFJvdXRpbmcnLFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmVDbGFzczogZ2VvZmxvLmlkICsgJy1yb3V0aW5nLWVuYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZUNsYXNzOiBnZW9mbG8uaWQgKyAnLXJvdXRpbmctZGlzYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICBvbkFjdGl2YXRlOiBmdW5jdGlvbiBvbkFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5hY3RpdmF0ZVJvdXRpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWFjdGl2YXRlOiBmdW5jdGlvbiBvbkRlYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLmRlYWN0aXZhdGVSb3V0aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBjcmVhdGVPcHRpb25CdXR0b24oXCJleHBsb3JpbmdcIiwge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiZXhwbG9yaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBgRW5hYmxlL0Rpc2FibGUgRXhwbG9yaW5nYCxcbiAgICAgICAgICAgICAgICAgICAgYWN0aXZlQ2xhc3M6IGdlb2Zsby5pZCArICctZXhwbG9yaW5nLWVuYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZUNsYXNzOiBnZW9mbG8uaWQgKyAnLWV4cGxvcmluZy1kaXNhYmxlZCcsXG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aXZhdGU6IGZ1bmN0aW9uIG9uQWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLmFjdGl2YXRlRXhwbG9yaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGVhY3RpdmF0ZTogZnVuY3Rpb24gb25EZWFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5kZWFjdGl2YXRlRXhwbG9yaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgY3JlYXRlT3B0aW9uQnV0dG9uKFwicGFpbnRpbmdcIiwge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwicGFpbnRpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdFbmFibGUvRGlzYWJsZSBQYWludGluZycsXG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUNsYXNzOiBnZW9mbG8uaWQgKyAnLXBhaW50aW5nLWVuYWJsZWQnLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZUNsYXNzOiBnZW9mbG8uaWQgKyAnLXBhaW50aW5nLWRpc2FibGVkJyxcbiAgICAgICAgICAgICAgICAgICAgb25BY3RpdmF0ZTogZnVuY3Rpb24gb25BY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW9mbG8uYWN0aXZhdGVQYWludGluZygpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBvbkRlYWN0aXZhdGU6IGZ1bmN0aW9uIG9uRGVhY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW9mbG8uZGVhY3RpdmF0ZVBhaW50aW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29udHJvbC50eXBlID09PSAndHlwZXMnKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlQ29udHJvbEJ1dHRvbihcInBvbHlsaW5lXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX0xJTkUsXG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJsXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRHJhdyBQb2x5bGluZScsXG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aXZhdGU6IGZ1bmN0aW9uIG9uQWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLnNldE1vZGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5tb2Rlcy5EUkFXLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiUG9seWxpbmVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGVhY3RpdmF0ZTogZnVuY3Rpb24gb25EZWFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5zZXRNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgY3JlYXRlQ29udHJvbEJ1dHRvbihcInBvbHlnb25cIiwge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXI6IGJ1dHRvbnMsXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT05fUE9MWUdPTixcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcInBcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdEcmF3IFBvbHlnb24nLFxuICAgICAgICAgICAgICAgICAgICBvbkFjdGl2YXRlOiBmdW5jdGlvbiBvbkFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5zZXRNb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMubW9kZXMuRFJBVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlBvbHlnb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGVhY3RpdmF0ZTogZnVuY3Rpb24gb25EZWFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5zZXRNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgY3JlYXRlQ29udHJvbEJ1dHRvbihcInJlY3RhbmdsZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9SRUNUQU5HTEUsXG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJyXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnRHJhdyBSZWN0YW5nbGUnLFxuICAgICAgICAgICAgICAgICAgICBvbkFjdGl2YXRlOiBmdW5jdGlvbiBvbkFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5zZXRNb2RlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RlOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMubW9kZXMuRFJBVyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlJlY3RhbmdsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWFjdGl2YXRlOiBmdW5jdGlvbiBvbkRlYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLnNldE1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBjcmVhdGVDb250cm9sQnV0dG9uKFwiY2lyY2xlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX1BPSU5ULFxuICAgICAgICAgICAgICAgICAgICBrZXk6IFwib1wiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0RyYXcgQ2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgb25BY3RpdmF0ZTogZnVuY3Rpb24gb25BY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW9mbG8uc2V0TW9kZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLm1vZGVzLkRSQVcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJDaXJjbGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRGVhY3RpdmF0ZTogZnVuY3Rpb24gb25EZWFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5zZXRNb2RlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgICAgICBjcmVhdGVDb250cm9sQnV0dG9uKFwidGV4dFwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9URVhULFxuICAgICAgICAgICAgICAgICAgICBrZXk6IFwidFwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0RyYXcgVGV4dCcsXG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aXZhdGU6IGZ1bmN0aW9uIG9uQWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLnNldE1vZGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5tb2Rlcy5EUkFXLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiVGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWFjdGl2YXRlOiBmdW5jdGlvbiBvbkRlYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLnNldE1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBjcmVhdGVDb250cm9sQnV0dG9uKFwiaWNvblwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9JQ09OLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IFwiaVwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ0RyYXcgSWNvbicsXG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aXZhdGU6IGFzeW5jIGZ1bmN0aW9uIG9uQWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLnNldE1vZGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZGU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5tb2Rlcy5EUkFXLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiSWNvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25EZWFjdGl2YXRlOiBmdW5jdGlvbiBvbkRlYWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuZGVhY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLnNldE1vZGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb250cm9sLnR5cGUgPT09ICd1dGlscycpIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVDb250cm9sQnV0dG9uKFwicmVwZWF0XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX1JFUEVBVCxcbiAgICAgICAgICAgICAgICAgICAga2V5OiBcImBcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6ICdSZXBlYXQgU2VsZWN0ZWQgTW9kZScsXG4gICAgICAgICAgICAgICAgICAgIG9uQ2xpY2s6IGZ1bmN0aW9uICh0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5vcHRpb25zLnJlcGVhdERyYXcgPSAhZ2VvZmxvLm9wdGlvbnMucmVwZWF0RHJhdztcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5vcHRpb25zLnJlcGVhdERyYXcgPyBvcHRpb25zLmFjdGl2YXRlKCkgOiBvcHRpb25zLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgY3JlYXRlQWN0aW9uQnV0dG9uKFwiem9vbVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYnV0dG9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9aT09NX0lOX0ZFQVRVUkVTLFxuICAgICAgICAgICAgICAgICAgICBrZXk6IFwieFwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogJ1pvb20gdG8gRXh0ZW50JyxcbiAgICAgICAgICAgICAgICAgICAgb25BY3RpdmF0ZTogZnVuY3Rpb24gb25BY3RpdmF0ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW9mbG8uem9vbVRvRmVhdHVyZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBjcmVhdGVBY3Rpb25CdXR0b24oXCJyZWZyZXNoXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiBidXR0b25zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX1JFRlJFU0gsXG4gICAgICAgICAgICAgICAgICAgIGtleTogXCJxXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiAnUmVmcmVzaCcsXG4gICAgICAgICAgICAgICAgICAgIG9uQWN0aXZhdGU6IGZ1bmN0aW9uIG9uQWN0aXZhdGUoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLyogY3JlYXRlQWN0aW9uQnV0dG9uKFwiZGVsZXRlLXNuYXBcIiwge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYWN0aW9uMkdyb3VwLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT05fREVMRVRFX1NOQVAsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdEZWxldGUgU25hcCBMYXllciBGZWF0dXJlcycsXG4gICAgICAgICAgICAgICAgb25BY3Rpb246IGZ1bmN0aW9uIG9uQWN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLmRlbGV0ZU1lc2hEYXRhKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7ICovXG4gICAgXG4gICAgICAgICAgICAvKiBjcmVhdGVDb250cm9sQnV0dG9uKFwiY3V0XCIsIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGNvbnRyb2xHcm91cCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX0NVVCxcbiAgICAgICAgICAgICAgICBrZXk6IFwiYVwiLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnQ3V0IEZlYXR1cmVzJyxcbiAgICAgICAgICAgICAgICBvbkFjdGl2YXRlOiBmdW5jdGlvbiBvbkFjdGl2YXRlKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLnNldE1vZGUoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLm1vZGVzLkNVVCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7ICovXG4gICAgXG4gICAgICAgICAgICAvKiBjcmVhdGVBY3Rpb25CdXR0b24oXCJjb21iaW5lXCIsIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IGFjdGlvbjJHcm91cCxcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5jbGFzc2VzLkNPTlRST0xfQlVUVE9OX0NPTUJJTkVfRkVBVFVSRVMsXG4gICAgICAgICAgICAgICAgdGl0bGU6ICdDb21iaW5lIEZlYXR1cmVzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICcrJyxcbiAgICAgICAgICAgICAgICBvbkFjdGlvbjogZnVuY3Rpb24gb25BY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW9mbG8uY29tYmluZUZlYXR1cmVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7ICovXG4gICAgXG4gICAgICAgICAgICAvKiBjcmVhdGVBY3Rpb25CdXR0b24oXCJncm91cC1lbGVtZW50c1wiLCB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBhY3Rpb24yR3JvdXAsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9HUk9VUF9GRUFUVVJFUyxcbiAgICAgICAgICAgICAgICBrZXk6IFwiZ1wiLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnR3JvdXAgU2ltaWxhciBGZWF0dXJlcycsXG4gICAgICAgICAgICAgICAgb25BY3Rpb246IGZ1bmN0aW9uIG9uQWN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLmdyb3VwRmVhdHVyZXMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIGNyZWF0ZUFjdGlvbkJ1dHRvbihcInVuZ3JvdXAtZWxlbWVudHNcIiwge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYWN0aW9uMkdyb3VwLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT05fVU5HUk9VUF9GRUFUVVJFUyxcbiAgICAgICAgICAgICAgICBrZXk6IFwiR1wiLFxuICAgICAgICAgICAgICAgIHRpdGxlOiAnVW5ncm91cCBTaW1pbGFyIEZlYXR1cmVzJyxcbiAgICAgICAgICAgICAgICBvbkFjdGlvbjogZnVuY3Rpb24gb25BY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZW9mbG8udW5ncm91cEZlYXR1cmVzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7ICovXG4gICAgXG4gICAgICAgICAgICAvKiBjcmVhdGVBY3Rpb25CdXR0b24oXCJjcmVhdGUtcG9seWdvblwiLCB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyOiBhY3Rpb24yR3JvdXAsXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuY2xhc3Nlcy5DT05UUk9MX0JVVFRPTl9DUkVBVEVfUE9MWUdPTixcbiAgICAgICAgICAgICAgICBrZXk6ICdwJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0NyZWF0ZSBQb2x5Z29uIGZyb20gU2VsZWN0ZWQgRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgb25BY3Rpb246IGZ1bmN0aW9uIG9uQWN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLmNyZWF0ZVBvbHlnb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTsgKi9cbiAgICBcbiAgICAgICAgICAgIC8qIGNyZWF0ZUFjdGlvbkJ1dHRvbihcImhpZGUtc2VsZWN0ZWRcIiwge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcjogYWN0aW9uMkdyb3VwLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmNsYXNzZXMuQ09OVFJPTF9CVVRUT05fSElERV9TRUxFQ1RFRCxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0hpZGUgU2VsZWN0ZWQgRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgb25BY3Rpb246IGZ1bmN0aW9uIG9uQWN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2VvZmxvLmhpZGVGZWF0dXJlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pOyAqL1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcmVtb3ZlQnV0dG9ucygpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGJ1dHRvbkVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uKGJ1dHRvbklkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGJ1dHRvbkVsZW1lbnRzW2J1dHRvbklkXTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGRlbGV0ZSBidXR0b25FbGVtZW50c1tidXR0b25JZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIGJ1dHRvbk9wdGlvbnNbYnV0dG9uSWRdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICBcbiAgICBcbiAgICAgICAgZnVuY3Rpb24gZ2V0Q29udHJvbE9wdGlvbnMgKGNvbnRyb2wpIHtcbiAgICAgICAgICAgIGlmICghY29udHJvbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgdmFyIGNvbnRyb2xzID0gZ2VvZmxvLm9wdGlvbnMuY29udHJvbHMgJiYgdHlwZW9mIGdlb2Zsby5vcHRpb25zLmNvbnRyb2xzID09PSAnb2JqZWN0JztcbiAgICAgICAgICAgIHZhciBkb250U2hvdyA9IGNvbnRyb2xzID8gIWdlb2Zsby5vcHRpb25zLmNvbnRyb2xzW2NvbnRyb2wudHlwZV0gOiBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuICBkb250U2hvdyB8fCBjb250cm9sLmRvbnRTaG93IHx8ICFnZW9mbG8ub3B0aW9ucy5jb250cm9scyA/IGZhbHNlIDogdHJ1ZTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBnZXRCdXR0b25PcHRpb25zKCkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1dHRvbk9wdGlvbnM7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gZ2V0QnV0dG9uRWxlbWVudHMoKSB7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uRWxlbWVudHM7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbnRyb2w7IiwiLyoqXG4gKiBAbWl4aW5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvXG4gKiBAbmFtZSBEcmF3XG4gKiBAZGVzY3JpcHRpb24gVGhpcyBtb2R1bGUgcHJvdmlkZXMgdGhlIGZ1bmN0aW9uYWxpdHkgZm9yIGRyYXdpbmcgZmVhdHVyZXMgb24gdGhlIG1hcC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBtZXRob2QgY2hhaW5pbmcuXG4gKiBcbiAqL1xuY29uc3QgRHJhdyA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBnZW9mbG8gPSB0aGlzLmdlb2ZsbztcblxuICAgIHRoaXMuaWQgPSAnZHJhdyc7XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkRyYXdcblx0ICogQG5hbWUgY2FuSGFuZGxlXG5cdCAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgdGhlIGdpdmVuIG1vZGVOYW1lIGlzIGVxdWFsIHRvIHRoZSBjb25zdGFudCBtb2RlIERSQVcuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBtb2RlIHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIG1vZGVOYW1lIGlzIGVxdWFsIHRvIERSQVcsIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5jYW5IYW5kbGUgPSBmdW5jdGlvbiAobW9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5tb2Rlcy5EUkFXID09PSBtb2RlTmFtZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkRyYXdcblx0ICogQG5hbWUgYWN0aXZhdGVcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gYWN0aXZhdGVzIHRoZSBkcmF3aW5nIG1vZGUgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucy4gSXQgc2V0cyB1cCB0aGUgbmVjZXNzYXJ5IHByb3BlcnRpZXMgYW5kIGV2ZW50IGxpc3RlbmVycyBmb3IgZHJhd2luZyBmZWF0dXJlcyBvbiB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciBhY3RpdmF0aW5nIHRoZSBkcmF3aW5nIG1vZGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5mZWF0dXJlXSAtIFRoZSBmZWF0dXJlIHRvIGJlIGVkaXRlZCBvciBkcmF3bi5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnR5cGVdIC0gVGhlIHR5cGUgb2YgZmVhdHVyZSB0byBiZSBkcmF3bi5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmxuZ0xhdF0gLSBUaGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBjb29yZGluYXRlcyBmb3IgZHJhd2luZy5cblx0ICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmlkXSAtIFRoZSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhlIGZlYXR1cmUuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIG1ldGhvZCBjaGFpbmluZy5cblx0ICovXG4gICAgdGhpcy5hY3RpdmF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZ2VvZmxvLmN1cnJlbnRNb2RlLmlkICE9PSB0aGlzLmlkKSByZXR1cm4gb3B0aW9ucy5tb2RlID0gdGhpcy5pZCwgZ2VvZmxvLnNldE1vZGUob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5hY3RpdmF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9oYW5kbGVIaXN0b3J5ID0gdGhpcy5oYW5kbGVIaXN0b3J5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLnVuZG8gPSBbXTtcblxuICAgICAgICBpZiAob3B0aW9ucy5mZWF0dXJlKSBvcHRpb25zLnR5cGUgPSBlZGl0TW9kZShvcHRpb25zLmZlYXR1cmUpO1xuICAgICAgICBnZW9mbG8uZHJhd01vZGUgPSAhZ2VvZmxvLmVkaXRNb2RlO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxuZ0xhdCA9IG9wdGlvbnMubG5nTGF0O1xuICAgICAgICBkZWxldGUgb3B0aW9ucy5sbmdMYXQ7XG5cbiAgICAgICAgdmFyIG5ld1R5cGUgPSB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gb3B0aW9ucy5mZWF0dXJlID8gb3B0aW9ucy5mZWF0dXJlLnByb3BlcnRpZXMgOiBvcHRpb25zO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbih7fSwgcHJvcGVydGllcyk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByb3BlcnRpZXMubW9kZTtcbiAgICAgICAgZGVsZXRlIHRoaXMucHJvcGVydGllcy5sb2NhdGlvbjtcblxuICAgICAgICBjb25zdCBpZCA9IG9wdGlvbnMuaWQgfHwgcHJvcGVydGllcy5pZCB8fCBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtdKSkuc2xpY2UoLTM2KTtcblxuICAgICAgICB0aGlzLnByb3BlcnRpZXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLnR5cGUgPSBuZXdUeXBlO1xuXG4gICAgICAgIGdlb2Zsby5zZXRCdXR0b25zKCk7XG4gICAgICAgIGdlb2Zsby5zZXRBY3RpdmVCdXR0b24obmV3VHlwZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZ2VvZmxvLlV0aWxpdGllcy5pc1BvaW50KGdlb2Zsby5ob3RGZWF0dXJlLCBuZXdUeXBlKSkgdGhpcy5pc1BvaW50ID0gdHJ1ZTtcblxuICAgICAgICBnZW9mbG8uZmlyZSgnZHJhdy5hY3RpdmF0ZScsIHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHR5cGU6IG5ld1R5cGUsXG4gICAgICAgICAgICBhY3RpdmF0ZWQ6IHRoaXMuYWN0aXZhdGVkLFxuICAgICAgICAgICAgZWRpdGluZzogZ2VvZmxvLmVkaXRNb2RlLFxuICAgICAgICAgICAgZmVhdHVyZTogZ2VvZmxvLmhvdEZlYXR1cmUgfHwgb3B0aW9ucy5mZWF0dXJlLFxuICAgICAgICAgICAgcHJvcGVydGllczogdGhpcy5wcm9wZXJ0aWVzXG4gICAgICAgIH0pXG5cbiAgICAgICAgZ2VvZmxvLm9uKCdzb3VyY2UuaG90JywgdGhpcy5faGFuZGxlSGlzdG9yeSk7XG4gICAgICAgIGlmIChsbmdMYXQpIHRoaXMuaGFuZGxlTW92ZSh7IGxuZ0xhdDogbG5nTGF0IH0pO1xuICAgICAgICBnZW9mbG8ub3B0aW9ucy5wYWludGluZy5lbmFibGUgfHwgKGdlb2Zsby5tb2JpbGUgJiYgbmV3VHlwZSA9PT0gJ1JlY3RhbmdsZScpID8gZ2VvZmxvLmFjdGl2YXRlUGFpbnRpbmcoKSA6IGZhbHNlO1xuXG4gICAgICAgIGdlb2Zsby5yZWZyZXNoTWVzaERhdGEoKTtcbiAgICAgICAgdGhpcy51cGRhdGVIb3RTb3VyY2UoKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBnZW9mbG8uRmVhdHVyZXMucmVtb3ZlRmVhdHVyZXMoaWQpOyB9LCAxMDApO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkRyYXdcblx0ICogQG5hbWUgZGVhY3RpdmF0ZVxuXHQgKiBAZGVzY3JpcHRpb24gRGVhY3RpdmF0ZXMgdGhlIGRyYXcgZmVhdHVyZSBieSBjYW5jZWxpbmcgdGhlIGN1cnJlbnQgZWRpdCwgY2xlYW5pbmcgdXAgdGhlIGRyYXcsIHNldHRpbmcgYnV0dG9ucywgYW5kIGhhbmRsaW5nIGV2ZW50cy5cblx0ICogQHBhcmFtIHtib29sZWFufSBjYW5jZWwgLSBGbGFnIHRvIGRldGVybWluZSBpZiB0aGUgZWRpdCBzaG91bGQgYmUgY2FuY2VsZWQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhbmRieSAtIEZsYWcgdG8gaW5kaWNhdGUgaWYgdGhlIGZlYXR1cmUgaXMgaW4gc3RhbmRieSBtb2RlLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZSAtIFRoZSBmZWF0dXJlIHRvIGJlIGRlYWN0aXZhdGVkLlxuXHQgKi9cbiAgICB0aGlzLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAob3B0aW9ucz17fSkge1xuICAgICAgICBpZiAoIXRoaXMuYWN0aXZhdGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGUgfHwgdGhpcy50eXBlO1xuICAgICAgICBpZiAob3B0aW9ucy5jYW5jZWwpIHRoaXMuY2FuY2VsRWRpdChvcHRpb25zLnN0YW5kYnksIG9wdGlvbnMuZmVhdHVyZSk7XG4gICAgICAgIGNsZWFudXBEcmF3KHRoaXMpO1xuICAgICAgICBnZW9mbG8uc2V0QnV0dG9ucygpO1xuICAgICAgICBnZW9mbG8ub2ZmKCdzb3VyY2UuaG90JywgdGhpcy5faGFuZGxlSGlzdG9yeSk7XG4gICAgICAgIGdlb2Zsby5maXJlKCdkcmF3LmRlYWN0aXZhdGUnLCB7IGFjdGl2YXRlZDogdGhpcy5hY3RpdmF0ZWQgfSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNFTEVDVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7IH0sIDMwMCk7XG4gICAgICAgICFnZW9mbG8ub3B0aW9ucy5yZXBlYXREcmF3ID8gZ2VvZmxvLnNldE1vZGUoKSA6IGdlb2Zsby5zZXRNb2RlKHsgbW9kZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLm1vZGVzLkRSQVcsIHR5cGU6IHR5cGUgfSk7XG4gICAgfVxuXG5cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSB1cGRhdGVIb3RTb3VyY2Vcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdXBkYXRlcyB0aGUgaG90IHNvdXJjZSBmZWF0dXJlIHdpdGggbmV3IHByb3BlcnRpZXMgYW5kIGFzc2lnbnMgaXQgdG8gdGhlIGdlb2Zsby5ob3RGZWF0dXJlLiBJdCB0aGVuIHVwZGF0ZXMgdGhlIGRhdGEgb2YgdGhlIFZFUlRFWCBhbmQgSE9UIHNvdXJjZXMgb24gdGhlIG1hcCB3aXRoIHRoZSB1cGRhdGVkIGZlYXR1cmUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlIC0gVGhlIGZlYXR1cmUgb2JqZWN0IHRvIGJlIHVwZGF0ZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIC0gVGhlIG5ldyBwcm9wZXJ0aWVzIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBmZWF0dXJlLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdXBkYXRlZCBob3Qgc291cmNlIGZlYXR1cmUuXG5cdCAqL1xuICAgIHRoaXMudXBkYXRlSG90U291cmNlID0gZnVuY3Rpb24gKGZlYXR1cmUsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUpIGdlb2Zsby5ob3RGZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgaWYgKCFnZW9mbG8uaG90RmVhdHVyZSB8fCBnZW9mbG8ub3ZlcnBhc3NEb3dubG9hZGluZykgcmV0dXJuO1xuICAgICAgICBnZW9mbG8uaG90RmVhdHVyZS5wcm9wZXJ0aWVzID0gZ2VvZmxvLlV0aWxpdGllcy5hc3NpZ25EZWVwKGdlb2Zsby5ob3RGZWF0dXJlLnByb3BlcnRpZXMsIHByb3BlcnRpZXMgfHwge30pO1xuICAgICAgICBnZW9mbG8uaG90RmVhdHVyZS5wcm9wZXJ0aWVzLnN0eWxlID0gZ2VvZmxvLmhvdEZlYXR1cmUucHJvcGVydGllcy5zdHlsZSB8fCB7fTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuVkVSVEVYKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2dlb2Zsby5ob3RGZWF0dXJlXSkpO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5IT1QpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbZ2VvZmxvLmhvdEZlYXR1cmVdKSk7XG4gICAgICAgIHJldHVybiBnZW9mbG8uaG90RmVhdHVyZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkRyYXdcblx0ICogQG5hbWUgZGVsZXRlVmVydGV4XG5cdCAqIEBkZXNjcmlwdGlvbiBEZWxldGVzIGEgdmVydGV4IGZyb20gdGhlIGN1cnJlbnQgZmVhdHVyZSBiZWluZyBlZGl0ZWQgb24gdGhlIG1hcC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSB2ZXJ0ZXggdG8gYmUgZGVsZXRlZC5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMuZGVsZXRlVmVydGV4ID0gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIGlmIChnZW9mbG8uaG90RmVhdHVyZSkge1xuICAgICAgICAgICAgY29uc3QgY29vcmRzID0gZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBpbmRleCA9IGluZGV4ICE9PSB1bmRlZmluZWQgPyBpbmRleCA6IGNvb3Jkcy5sZW5ndGggLSAxO1xuXG4gICAgICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBjb29yZHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICBnZW9mbG8ubGFzdENsaWNrID0geyBjb29yZHM6IGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV0gfTtcblxuICAgICAgICAgICAgICAgIGlmIChjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBnZW9mbG8uc25hcEZlYXR1cmUgPSB0dXJmLnBvaW50KGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb2Zsby5zbmFwRmVhdHVyZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGNvb3Jkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkhPVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtnZW9mbG8uaG90RmVhdHVyZV0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZW9mbG8uaG90RmVhdHVyZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkhPVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZ2VvZmxvLmZpcmUoJ3ZlcnRleC5kZWxldGUnLCB7IGNvb3JkczogY29vcmRzLCBpbmRleDogaW5kZXgsIGZlYXR1cmU6IGdlb2Zsby5ob3RGZWF0dXJlIH0pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChnZW9mbG8ubGFzdE1vdXNlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlTW92ZSA/IGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVNb3ZlKGdlb2Zsby5sYXN0TW91c2VFdmVudCkgOiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChnZW9mbG8uc25hcEZlYXR1cmUpIHtcbiAgICAgICAgICAgIGdlb2Zsby5zbmFwRmVhdHVyZSA9IG51bGw7XG4gICAgICAgICAgICBnZW9mbG8ubGFzdENsaWNrID0gbnVsbDtcbiAgICAgICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNOQVApLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuICAgICAgICB9XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5EcmF3XG5cdCAqIEBuYW1lIGdldEZlYXR1cmVcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyB0aGUgaG90IGZlYXR1cmUgZnJvbSB0aGUgY29udGV4dC5cblx0ICogQHJldHVybnMge2FueX0gVGhlIGhvdCBmZWF0dXJlIHN0b3JlZCBpbiB0aGUgY29udGV4dC5cblx0ICovXG4gICAgdGhpcy5nZXRGZWF0dXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZ2VvZmxvLmhvdEZlYXR1cmU7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5EcmF3XG5cdCAqIEBuYW1lIHNlbGVjdEZlYXR1cmVcblx0ICogQGRlc2NyaXB0aW9uIFNlbGVjdHMgYSBmZWF0dXJlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBJRC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIElEIG9mIHRoZSBmZWF0dXJlIHRvIGJlIHNlbGVjdGVkLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBubyBJRCBpcyBwcm92aWRlZCwgb3RoZXJ3aXNlIHJldHVybnMgdGhlIHJlc3VsdCBvZiBzZWxlY3RpbmcgdGhlIGZlYXR1cmUuXG5cdCAqL1xuICAgIHRoaXMuc2VsZWN0RmVhdHVyZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIWlkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGdlb2Zsby5zZXRNb2RlKCk7XG4gICAgICAgIHJldHVybiBnZW9mbG8uY3VycmVudE1vZGUuc2VsZWN0RmVhdHVyZShpZCk7XG4gICAgfVxuXG5cdC8qKiBcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSBzYXZlRWRpdFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBzYXZlcyB0aGUgZWRpdGVkIGZlYXR1cmUgaW4gdGhlIG1hcC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgLSBUaGUgZmVhdHVyZSB0byBiZSBzYXZlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlIGlzIHN1Y2Nlc3NmdWxseSBzYXZlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cbiAgICB0aGlzLnNhdmVFZGl0ID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIGhvdCA9IGdlb2Zsby5ob3RGZWF0dXJlO1xuICAgICAgICBpZiAoIWhvdCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciB0eXBlID0gaG90LnByb3BlcnRpZXMudHlwZSB8fCBmZWF0dXJlLnByb3BlcnRpZXMudHlwZSB8fCB0aGlzLnR5cGU7XG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlIHx8IGhvdDtcblxuICAgICAgICB0aGlzLnNhdmluZ0VkaXQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gZmluaXNoRHJhdyh0eXBlLCBmZWF0dXJlKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkRyYXdcblx0ICogQG5hbWUgY2FuY2VsRWRpdFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjYW5jZWxzIHRoZSBjdXJyZW50IGVkaXRpbmcgb3BlcmF0aW9uIGJ5IHNldHRpbmcgdGhlICdjYW5jZWxsZWQnIGZsYWcgdG8gdHJ1ZS4gSWYgdGhlICdmZWF0dXJlJyBwYXJhbWV0ZXIgaXMgbm90IHByb3ZpZGVkIG9yIGRvZXMgbm90IGhhdmUgYSAndHlwZScgcHJvcGVydHksIGl0IHNldHMgJ2dlb2Zsby5ob3RGZWF0dXJlJyB0byBudWxsIGFuZCBmaW5pc2hlcyB0aGUgZHJhdyBwcm9jZXNzLiBJdCB0aGVuIHNldHMgdGhlICdzdGFuZGJ5JyBwcm9wZXJ0eSwgdXBkYXRlcyAnZ2VvZmxvLmhvdEZlYXR1cmUnLCBmaXJlcyBhICdkcmF3LmNhbmNlbCcgZXZlbnQgd2l0aCB0aGUgZmVhdHVyZSwgYW5kIHJldHVybnMgdGhlIHJlc3VsdCBvZiAnZmluaXNoRHJhdygpJy5cblx0ICogQHBhcmFtIHtib29sZWFufSBzdGFuZGJ5IC0gVGhlIHN0YW5kYnkgdmFsdWUgdG8gc2V0LlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZSAtIFRoZSBmZWF0dXJlIGJlaW5nIGVkaXRlZC5cblx0ICogQHJldHVybnMge2FueX0gVGhlIHJlc3VsdCBvZiB0aGUgJ2ZpbmlzaERyYXcoKScgZnVuY3Rpb24uXG5cdCAqL1xuICAgIHRoaXMuY2FuY2VsRWRpdCA9IGZ1bmN0aW9uIChzdGFuZGJ5LCBmZWF0dXJlKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFmZWF0dXJlIHx8ICFmZWF0dXJlLnByb3BlcnRpZXMudHlwZSkgcmV0dXJuIGdlb2Zsby5ob3RGZWF0dXJlID0gbnVsbCwgZmluaXNoRHJhdygpO1xuICAgICAgICB0aGlzLnN0YW5kYnkgPSBzdGFuZGJ5O1xuICAgICAgICBnZW9mbG8uaG90RmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgIGdlb2Zsby5maXJlKCdkcmF3LmNhbmNlbCcsIHsgZmVhdHVyZTogZmVhdHVyZSB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmlzaERyYXcoKTtcbiAgICB9XG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5EcmF3XG5cdCAqIEBuYW1lIGhhbmRsZURvd25cblx0ICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIG1vdXNlIG9yIHRvdWNoIGRvd24gZXZlbnQgb24gdGhlIG1hcC4gVXBkYXRlcyB0aGUgbW91c2UvdG91Y2ggcG9zaXRpb24sIGFkZHMgYSB2ZXJ0ZXggaWYgYWxsb3dlZCwgYW5kIHNldHMgZmVhdHVyZXMgZm9yIHBpbm5pbmcuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmhhbmRsZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBvaW50O1xuXG4gICAgICAgIGdlb2Zsby5tb3VzZUlzRG93biA9IFtldmVudC5sbmdMYXQubG5nLCBldmVudC5sbmdMYXQubGF0XTtcblxuICAgICAgICBpZiAoZXZlbnQudG91Y2gpIHtcbiAgICAgICAgICAgIGdlb2Zsby50b3VjaERvd24gPSB0cnVlO1xuICAgICAgICAgICAgcG9pbnQgPSB0dXJmLnBvaW50KGdlb2Zsby5tb3VzZUlzRG93bik7XG4gICAgICAgICAgICBvblZlcnRleChnZXRWZXJ0ZXgocG9pbnQpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGdlb2Zsby5jYW5BZGRWZXJ0ZXgpIHtcbiAgICAgICAgICAgIHBvaW50ID0gYWRkVmVydGV4KGdlb2Zsby5jYW5BZGRWZXJ0ZXgsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBvblZlcnRleChnZXRWZXJ0ZXgocG9pbnQpLCB0cnVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlb2Zsby5QaW5uaW5nLnNldEZlYXR1cmVzKGdlb2Zsby5zbmFwcGVkVmVydGV4KTtcbiAgICAgICAgc3RhcnRJZGxlVGltZSgpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSBoYW5kbGVVcFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgaGFuZGxpbmcgdGhlIG1vdXNlIHVwIGV2ZW50IGR1cmluZyBkcmF3aW5nIGFuZCBlZGl0aW5nIG9wZXJhdGlvbnMgb24gdGhlIG1hcC4gSXQgY2hlY2tzIHZhcmlvdXMgY29uZGl0aW9ucyBhbmQgdHJpZ2dlcnMgY29ycmVzcG9uZGluZyBhY3Rpb25zIGJhc2VkIG9uIHRoZSBjb250ZXh0IGFuZCB1c2VyIGludGVyYWN0aW9ucy5cblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgbW91c2UgdXAgZXZlbnQgb2JqZWN0LlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5oYW5kbGVVcCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBnZW9mbG8ubW91c2VJc0Rvd24gPSBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLnRvdWNoRG93biA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChnZW9mbG8uUGFpbnRpbmcuZW5hYmxlZCkgcmV0dXJuIGdlb2Zsby5QYWludGluZy5oYW5kbGVVcChldmVudCk7XG4gICAgICAgIGlmIChnZW9mbG8uYWRkZWRWZXJ0ZXhPbkxpbmUgJiYgIWdlb2Zsby5kcmFnTW92aW5nKSByZXR1cm47XG4gICAgICAgIGlmIChldmVudC50b3VjaCAmJiBnZW9mbG8udG91Y2hNb3ZpbmcpIHJldHVybiBnZW9mbG8uZHJhZ01vdmluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChnZW9mbG8uVXRpbGl0aWVzLmlzUG9pbnQoZ2VvZmxvLmhvdEZlYXR1cmUpICYmIGdlb2Zsby5zbmFwcGVkVmVydGV4KSByZXR1cm4gZ2VvZmxvLmVkaXRNb2RlID8gdGhpcy5zYXZlRWRpdCgpIDogZmluaXNoRHJhdyh0aGlzLnR5cGUpO1xuXG4gICAgICAgIGlmIChnZW9mbG8uc25hcHBlZFZlcnRleCAmJiBnZW9mbG8uZHJhZ01vdmluZyAmJiAhZ2VvZmxvLm1hcE1vdmluZyAmJiB0aGlzLnR5cGUgIT09ICdSZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICBnZW9mbG8uZ2FtZXBhZERyYWcgPSBldmVudC5nYW1lcGFkO1xuXG4gICAgICAgICAgICB2YXIgaXNMYXN0SW5kZXggPSBnZW9mbG8uVXRpbGl0aWVzLmlzTGFzdEluZGV4KGdlb2Zsby5kcmFnSW5kZXgsIGdlb2Zsby5ob3RGZWF0dXJlKTtcbiAgICAgICAgICAgIGlzTGFzdEluZGV4ID0gaXNMYXN0SW5kZXggPyBpc0xhc3RJbmRleCA6IGdlb2Zsby5VdGlsaXRpZXMuaXNQb2x5Z29uKGdlb2Zsby5ob3RGZWF0dXJlKSAmJiBnZW9mbG8uZHJhZ0luZGV4ID09IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGdlb2Zsby5VdGlsaXRpZXMuZ2V0TGFzdEluZGV4Q29vcmRzKGdlb2Zsby5ob3RGZWF0dXJlKTtcblxuICAgICAgICAgICAgb25WZXJ0ZXgoZ2V0VmVydGV4KHR1cmYucG9pbnQoZ2VvZmxvLnNuYXBwZWRWZXJ0ZXgpKSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUhvdFNvdXJjZSgpO1xuICAgICAgICAgICAgaWYgKGlzTGFzdEluZGV4KSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBnZW9mbG8ubGFzdENsaWNrID0geyBjb29yZHM6IGNvb3JkcyB9IH0sIDEwMClcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZ2VvZmxvLnBpbmFibGVGZWF0dXJlcyA9IFtdO1xuICAgICAgICBnZW9mbG8ubW91c2VJc0lkbGUgPSBmYWxzZTtcbiAgICAgICAgYWRkVGV4dC5jYWxsKHRoaXMsIHRoaXMudHlwZSwgZ2VvZmxvLnNuYXBGZWF0dXJlKTtcbiAgICAgICAgZ2VvZmxvLnJlZnJlc2hNZXNoRGF0YSgpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSBoYW5kbGVDbGlja1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBwcm9jZXNzZXMgdGhlIGNsaWNrIGV2ZW50IGZvciBkcmF3aW5nIGZlYXR1cmVzIG9uIHRoZSBtYXAuIEl0IGRldGVybWluZXMgdGhlIGFjdGlvbiBiYXNlZCBvbiB0aGUgZXZlbnQgdHlwZSBhbmQgY29udGV4dCBzdGF0ZSwgc3VjaCBhcyBlZGl0aW5nIG1vZGUsIHRvdWNoIGlucHV0LCB2ZXJ0ZXggYWRkaXRpb24sIGFuZCBnYW1lcGFkIGludGVyYWN0aW9uLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGNsaWNrIGV2ZW50LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdXBkYXRlZCBldmVudCBvYmplY3Qgb3IgdGhlIHJlc3VsdCBvZiB0aGUgZHJhd2luZyBhY3Rpb24uXG5cdCAqL1xuICAgIHRoaXMuaGFuZGxlQ2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmZpbmlzaCkgcmV0dXJuIGdlb2Zsby5lZGl0TW9kZSA/IHRoaXMuc2F2ZUVkaXQoKSA6IGZpbmlzaERyYXcodGhpcy50eXBlKTtcbiAgICAgICAgaWYgKGV2ZW50LnRvdWNoICYmIGdlb2Zsby50b3VjaE1vdmluZykgcmV0dXJuIGdlb2Zsby50b3VjaE1vdmluZyA9IGZhbHNlLCBnZW9mbG8uU25hcHBpbmcuc2V0RmVhdHVyZSgpLCB0aGlzLnVwZGF0ZUhvdFNvdXJjZSgpO1xuICAgICAgICBpZiAoZXZlbnQudG91Y2gpIGdlb2Zsby50b3VjaENsaWNrID0gdHJ1ZTtcblxuICAgICAgICBpZiAoZ2VvZmxvLmFkZGVkVmVydGV4T25MaW5lKSB7XG4gICAgICAgICAgICBnZW9mbG8uU25hcHBpbmcuc2V0RmVhdHVyZSgpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVIb3RTb3VyY2UoKTtcbiAgICAgICAgICAgIG9uVmVydGV4KGdldFZlcnRleChnZW9mbG8uYWRkZWRWZXJ0ZXhPbkxpbmUpKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRHJhZyhldmVudCk7XG4gICAgICAgICAgICBnZW9mbG8uZHJhZ01vdmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgZ2VvZmxvLmdhbWVwYWREcmFnID0gZmFsc2VcbiAgICAgICAgICAgIGdlb2Zsby5tb3VzZUlzSWRsZSA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlb2Zsby5nYW1lcGFkRHJhZykgcmV0dXJuIGdlb2Zsby5nYW1lcGFkRHJhZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChnZW9mbG8uZWRpdE1vZGUgJiYgKHRoaXMudHlwZSA9PT0gJ1BvbHlnb24nIHx8IHRoaXMudHlwZSA9PT0gJ1RleHQnKSkgcmV0dXJuO1xuXG4gICAgICAgIGlmICghdGhpcy5maXJzdENsaWNrICYmICFnZW9mbG8uZHJhd1N0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGdlb2Zsby5kcmF3U3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBnZW9mbG8uZmlyZSgnZHJhdy5zdGFydCcsIHsgdHlwZTogdGhpcy50eXBlLCBlZGl0aW5nOiBnZW9mbG8uZWRpdE1vZGUsIGNvb3JkczogW2V2ZW50LmxuZ0xhdC5sbmcsIGV2ZW50LmxuZ0xhdC5sYXRdIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VvZmxvLmZpcmUoJ3ZlcnRleC5hZGQnLCB7IHR5cGU6IHRoaXMudHlwZSwgY29vcmRzOiBbZXZlbnQubG5nTGF0LmxuZywgZXZlbnQubG5nTGF0LmxhdF0gfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGFzdFBvaW50ID0gZ2VvZmxvLmNsb3Nlc3RQb2ludCB8fCB7IGNvb3JkczogW2V2ZW50LmxuZ0xhdC5sbmcsIGV2ZW50LmxuZ0xhdC5sYXRdIH07XG4gICAgICAgIHZhciBwb2ludCA9IHR1cmYucG9pbnQobGFzdFBvaW50LmNvb3Jkcyk7XG5cbiAgICAgICAgcG9pbnQucHJvcGVydGllcyA9IHRoaXMucHJvcGVydGllcztcbiAgICAgICAgcG9pbnQuc291cmNlID0gdGhpcy5zb3VyY2U7XG5cbiAgICAgICAgZ2VvZmxvLmxhc3RNb3ZlID0gbGFzdFBvaW50LmNvb3Jkcy5sZW5ndGggPiAxID8geyBsYXQ6IGxhc3RQb2ludC5jb29yZHNbbGFzdFBvaW50LmNvb3Jkcy5sZW5ndGgtMV1bMV0sIGxuZzogbGFzdFBvaW50LmNvb3Jkc1tsYXN0UG9pbnQuY29vcmRzLmxlbmd0aC0xXVswXSB9IDogZmFsc2U7ICAgICAgICBcblxuICAgICAgICBpZiAoIWdlb2Zsby5zdGFydFBvaW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy50eXBlID09PSAnUmVjdGFuZ2xlJykge1xuICAgICAgICAgICAgICAgIGdlb2Zsby5zdGFydFBvaW50ID0gbGFzdFBvaW50LmNvb3JkcztcblxuICAgICAgICAgICAgICAgIGdlb2Zsby5ob3RGZWF0dXJlID0gdHVyZi5wb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIGdlb2Zsby5zdGFydFBvaW50LFxuICAgICAgICAgICAgICAgICAgICBbZXZlbnQubG5nTGF0LmxuZywgZXZlbnQubG5nTGF0LmxhdF0sXG4gICAgICAgICAgICAgICAgICAgIFtnZW9mbG8uc3RhcnRQb2ludFswXSwgZXZlbnQubG5nTGF0LmxhdF0sXG4gICAgICAgICAgICAgICAgICAgIGdlb2Zsby5zdGFydFBvaW50XG4gICAgICAgICAgICAgICAgXV0pO1xuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBnZW9mbG8uVXRpbGl0aWVzLnNldFByb3BlcnR5KGdlb2Zsby5ob3RGZWF0dXJlLCAndHlwZScsIHRoaXMudHlwZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgZ2VvZmxvLnN0YXJ0UG9pbnQgPSBsYXN0UG9pbnQuY29vcmRzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIWdlb2Zsby5zbmFwRmVhdHVyZSAmJiBsYXN0UG9pbnQpIGdlb2Zsby5zbmFwRmVhdHVyZSA9IGxhc3RQb2ludDtcblxuICAgICAgICBpZiAobmVlZHNUb0ZpbmlzaCh0aGlzLnR5cGUsIGxhc3RQb2ludC5jb29yZHMpKSByZXR1cm4gZmluaXNoRHJhdyh0aGlzLnR5cGUsIHBvaW50KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZmlyc3RDbGljayA9IGdlb2Zsby5maXJzdENsaWNrID8gZmFsc2UgOiB7IGNvb3JkczogbGFzdFBvaW50LmNvb3JkcyB9O1xuXG4gICAgICAgIGdlb2Zsby5sYXN0Q2xpY2sgPSBsYXN0UG9pbnQ7XG4gICAgICAgIGdlb2Zsby5maXJzdENsaWNrID0gZ2VvZmxvLmZpcnN0Q2xpY2sgPyBnZW9mbG8uZmlyc3RDbGljayA6IHsgY29vcmRzOiBsYXN0UG9pbnQuY29vcmRzIH07XG4gICAgICAgIGdlb2Zsby5TbmFwcGluZy5zZXRGZWF0dXJlKCk7XG4gICAgICAgIGFkZFRleHQuY2FsbCh0aGlzLCB0aGlzLnR5cGUpO1xuICAgICAgICBnZW9mbG8uRXhwbG9yaW5nLnNldEZlYXR1cmVzKGxhc3RQb2ludC5jb29yZHMsIHsgc2V0OiB0cnVlIH0pO1xuICAgICAgICBkZWxldGUgZ2VvZmxvLnRvdWNoQ2xpY2s7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZUhvdFNvdXJjZSgpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSBoYW5kbGVNb3ZlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgdGhlIGJlaGF2aW9yIGJhc2VkIG9uIHRoZSBldmVudCB0eXBlIGFuZCBjb250ZXh0IHN0YXRlLiBJdCBoYW5kbGVzIHZhcmlvdXMgYWN0aW9ucyBzdWNoIGFzIGRyYWdnaW5nLCBwYWludGluZywgc25hcHBpbmcsIHJvdXRpbmcsIGFuZCBzbmFwcGluZyB0byBwb2ludHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbW91c2Ugb3IgdG91Y2ggZXZlbnQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGluIGNlcnRhaW4gY29uZGl0aW9ucyB0byBwcmV2ZW50IGRlZmF1bHQgYmVoYXZpb3IuXG5cdCAqL1xuICAgIHRoaXMuaGFuZGxlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQudG91Y2ggJiYgZ2VvZmxvLm1vdXNlSXNEb3duKSBnZW9mbG8udG91Y2hNb3ZpbmcgPSB0cnVlO1xuICAgICAgICBpZiAoZ2VvZmxvLm92ZXJwYXNzRG93bmxvYWRpbmcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGdlb2Zsby5tb3VzZUlzRG93biAmJiBnZW9mbG8uY2FuQWRkVmVydGV4KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChnZW9mbG8uY2FuRHJhZ01vdmUgJiYgZ2VvZmxvLnNuYXBwZWRWZXJ0ZXggJiYgZ2VvZmxvLm1vdXNlSXNEb3duKSByZXR1cm4gdGhpcy5oYW5kbGVEcmFnKGV2ZW50KTtcbiAgICAgICAgaWYgKGdlb2Zsby5tb3VzZUlzRG93biAmJiBnZW9mbG8uUGFpbnRpbmcuZW5hYmxlZCkgcmV0dXJuIHRoaXMuaGFuZGxlUGFpbnRpbmcoZXZlbnQpO1xuICAgICAgICBpZiAoZXZlbnQudG91Y2ggJiYgZ2VvZmxvLnRvdWNoTW92aW5nKSByZXR1cm4gZ2VvZmxvLnNuYXBGZWF0dXJlID0gZmFsc2U7XG5cbiAgICAgICAgdmFyIGJ1dHRvbiA9ICFldmVudC5vcmlnaW5hbEV2ZW50ID8gZmFsc2UgOiBldmVudC5vcmlnaW5hbEV2ZW50LmJ1dHRvbnMgIT09IHVuZGVmaW5lZCA/IGV2ZW50Lm9yaWdpbmFsRXZlbnQuYnV0dG9ucyA6IGV2ZW50Lm9yaWdpbmFsRXZlbnQud2hpY2g7XG4gICAgICAgIGlmIChidXR0b24gPT09IDEpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgY2FsY3VsYXRlUm91dGUgPSBnZW9mbG8uUm91dGluZy5lbmFibGVkO1xuICAgICAgICBpZiAoZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSkgY2FsY3VsYXRlUm91dGUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgc25hcFRvUG9pbnQgPSBnZW9mbG8uU25hcHBpbmcuZW5hYmxlZDtcbiAgICAgICAgaWYgKGV2ZW50Lm9yaWdpbmFsRXZlbnQgJiYgZXZlbnQub3JpZ2luYWxFdmVudC5zaGlmdEtleSkgc25hcFRvUG9pbnQgPSBmYWxzZTtcblxuICAgICAgICB2YXIgZXZ0Q29vcmRzID0gW2V2ZW50LmxuZ0xhdC5sbmcsIGV2ZW50LmxuZ0xhdC5sYXRdO1xuICAgICAgICB2YXIgaXNQb2ludCA9IGdlb2Zsby5VdGlsaXRpZXMuaXNQb2ludChnZW9mbG8uaG90RmVhdHVyZSk7XG4gICAgICAgIHZhciBlZGl0UG9seWdvbiA9IGdlb2Zsby5lZGl0TW9kZSAmJiAodGhpcy50eXBlID09PSAnUG9seWdvbicgfHwgdGhpcy50eXBlID09PSAnUmVjdGFuZ2xlJyk7XG4gICAgICAgIHZhciBwb2ludCA9IHR1cmYucG9pbnQoZXZ0Q29vcmRzKTtcbiAgICAgICAgdmFyIHNuYXBGZWF0dXJlID0gbnVsbDtcblxuICAgICAgICBpZiAoZWRpdFBvbHlnb24pIHtcbiAgICAgICAgICAgIHNuYXBGZWF0dXJlID0gcG9pbnQ7XG4gICAgICAgIH0gZWxzZSBpZiAoc25hcFRvUG9pbnQpIHtcbiAgICAgICAgICAgIHNuYXBGZWF0dXJlID0gZ2VvZmxvLlNuYXBwaW5nLnNldENsb3Nlc3QoZXZ0Q29vcmRzLCBpc1BvaW50KTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNQb2ludCkge1xuICAgICAgICAgICAgc25hcEZlYXR1cmUgPSBnZW9mbG8uU25hcHBpbmcudXBkYXRlRmVhdHVyZShldnRDb29yZHMpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzUG9pbnQpIHtcbiAgICAgICAgICAgIHNuYXBGZWF0dXJlID0gcG9pbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2FsY3VsYXRlUm91dGUpIHNuYXBGZWF0dXJlID0gZ2VvZmxvLlJvdXRpbmcuZ2V0Q2xvc2VzdCgpIHx8IHNuYXBGZWF0dXJlO1xuICAgICAgICBpZiAoIXNuYXBGZWF0dXJlKSBzbmFwRmVhdHVyZSA9IHBvaW50O1xuXG4gICAgICAgIGdlb2Zsby5TbmFwcGluZy5hZGRGZWF0dXJlKHNuYXBGZWF0dXJlLCB0aGlzLnByb3BlcnRpZXMsIGVkaXRQb2x5Z29uKTtcbiAgICAgICAgb25WZXJ0ZXgoZ2V0VmVydGV4KHBvaW50KSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXNuYXBGZWF0dXJlICYmIHRoaXMuaXNQb2ludCkgZGVsZXRlIHRoaXMuaXNQb2ludDtcbiAgICAgICAgaWYgKGVkaXRQb2x5Z29uICYmIGNhbGN1bGF0ZVJvdXRlKSBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlc1snUk9VVEUnXSkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ1JlY3RhbmdsZScpIHJldHVybiB0aGlzLmhhbmRsZVJlY3RhbmdsZShldmVudCk7XG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdJY29uJykgcmV0dXJuIHRoaXMuaGFuZGxlSWNvbihldmVudCwgZ2VvZmxvLnNuYXBGZWF0dXJlKTtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ1RleHQnKSByZXR1cm4gdGhpcy5oYW5kbGVUZXh0KGV2ZW50LCBnZW9mbG8uc25hcEZlYXR1cmUpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSBoYW5kbGVEcmFnXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciBoYW5kbGluZyB0aGUgZHJhZyBldmVudCBvZiBhIHZlcnRleCBvbiB0aGUgbWFwLiBJdCB1cGRhdGVzIHRoZSBwb3NpdGlvbiBvZiB0aGUgdmVydGV4IGJhc2VkIG9uIHRoZSB1c2VyJ3MgaW50ZXJhY3Rpb24gYW5kIHRyaWdnZXJzIHZhcmlvdXMgYWN0aW9ucyBhY2NvcmRpbmdseS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBkcmFnIGV2ZW50LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiB0aGUgZHJhZyBpbmRleCBpcyBub3QgdmFsaWQuXG5cdCAqL1xuICAgIHRoaXMuaGFuZGxlRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgdmFsaWRJbmRleCA9IGdlb2Zsby5kcmFnSW5kZXggPiAtMTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdmFsaWRJbmRleCkge1xuICAgICAgICAgICAgb2ZmVmVydGV4KCk7XG4gICAgICAgICAgICBpZiAoZ2VvZmxvLm1vdXNlSXNEb3duICYmIGdlb2Zsby5QYWludGluZy5lbmFibGVkKSB0aGlzLmhhbmRsZVBhaW50aW5nKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgICFldmVudC5nYW1lcGFkID8gZXZlbnQub3JpZ2luYWxFdmVudC5zdG9wUHJvcGFnYXRpb24oKSA6IGZhbHNlO1xuXG4gICAgICAgIGdlb2Zsby5kcmFnTW92aW5nID0gdHJ1ZTtcbiAgICAgICAgZ2VvZmxvLmxhc3REcmFnTW92ZSA9IDA7XG4gICAgICAgIGdlb2Zsby5zbmFwcGVkVmVydGV4ID0gW2V2ZW50LmxuZ0xhdC5sbmcsIGV2ZW50LmxuZ0xhdC5sYXRdO1xuICAgICAgICBnZW9mbG8uYnlwYXNzUm91dGluZyA9IHRydWU7IC8vIWV2ZW50LmdhbWVwYWQgPyBldmVudC5vcmlnaW5hbEV2ZW50LmFsdEtleSA6IGZhbHNlO1xuICAgICAgICBnZW9mbG8uYnlwYXNzU25hcHBpbmcgPSAhZXZlbnQuZ2FtZXBhZCA/IGV2ZW50Lm9yaWdpbmFsRXZlbnQuc2hpZnRLZXkgOiBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLmxhc3RJbmRleCA9IGdlb2Zsby5VdGlsaXRpZXMuaXNMYXN0SW5kZXgoZ2VvZmxvLmRyYWdJbmRleCwgZ2VvZmxvLmhvdEZlYXR1cmUpO1xuXG4gICAgICAgIHZhciB2ZXJ0ZXggPSB0dXJmLnBvaW50KGdlb2Zsby5zbmFwcGVkVmVydGV4KTtcblxuICAgICAgICBpZiAoZ2VvZmxvLmxhc3RJbmRleCkgZ2VvZmxvLmxhc3RDbGljayA9IHsgY29vcmRzOiBnZW9mbG8uc25hcHBlZFZlcnRleCB9O1xuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdDaXJjbGUnIHx8IHRoaXMudHlwZSA9PT0gJ0ljb24nIHx8IHRoaXMudHlwZSA9PT0gJ0ltYWdlJykge1xuICAgICAgICAgICAgaWYgKCFnZW9mbG8uUGFpbnRpbmcuZW5hYmxlZCkgZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBnZW9mbG8uc25hcHBlZFZlcnRleDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBpc0xhc3RJbmRleCA9IGdlb2Zsby5VdGlsaXRpZXMuaXNMYXN0SW5kZXgoZ2VvZmxvLmRyYWdJbmRleCwgZ2VvZmxvLmhvdEZlYXR1cmUpO1xuICAgICAgICAgICAgZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbZ2VvZmxvLmRyYWdJbmRleF0gPSBnZW9mbG8uc25hcHBlZFZlcnRleDtcblxuICAgICAgICAgICAgaWYgKHRoaXMudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdEluZGV4KSBnZW9mbG8uaG90RmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSA9IGdlb2Zsby5zbmFwcGVkVmVydGV4O1xuICAgICAgICAgICAgICAgIGlmIChnZW9mbG8uZHJhZ0luZGV4ID09IDApIGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2dlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCAtMV0gPSBnZW9mbG8uc25hcHBlZFZlcnRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGdlb2Zsby5VdGlsaXRpZXMuc2V0UHJvcGVydHkoZ2VvZmxvLmhvdEZlYXR1cmUsICd0eXBlJywgdGhpcy50eXBlKTtcbiAgICAgICAgZ2VvZmxvLlV0aWxpdGllcy5zZXRQcm9wZXJ0eSh2ZXJ0ZXgsICd0eXBlJywgdGhpcy50eXBlKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuUk9VVEUpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TTkFQKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuSE9UKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2dlb2Zsby5ob3RGZWF0dXJlXSkpO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5WRVJURVgpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbdmVydGV4XSkpO1xuICAgICAgICBnZW9mbG8uZmlyZSgndmVydGV4LmRyYWcnLCB7IHR5cGU6IHRoaXMudHlwZSwgY29vcmRzOiBbZXZlbnQubG5nTGF0LmxuZywgZXZlbnQubG5nTGF0LmxhdF0sIGZlYXR1cmU6IGdlb2Zsby5ob3RGZWF0dXJlLCB2ZXJ0ZXg6IHZlcnRleCB9KTtcbiAgICAgICAgZ2VvZmxvLlBpbm5pbmcudXBkYXRlRmVhdHVyZXMoKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkRyYXdcblx0ICogQG5hbWUgaGFuZGxlVG91Y2hcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gaXMgcmVzcG9uc2libGUgZm9yIGhhbmRsaW5nIHRvdWNoIGV2ZW50cyBhbmQgdHJpZ2dlcmluZyBjb3JyZXNwb25kaW5nIGFjdGlvbnMuXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHRvdWNoIGV2ZW50IG9iamVjdC5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMuaGFuZGxlVG91Y2ggPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQudG91Y2ggPSB0cnVlO1xuXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRG93bihldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVVcChldmVudCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNsaWNrKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3ZlKGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSBoYW5kbGVPZmZNYXBcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gaXMgdHJpZ2dlcmVkIHdoZW4gYW4gb2ZmLW1hcCBldmVudCBvY2N1cnMgYW5kIGNsZWFycyB0aGUgZGF0YSBvZiBhIHNwZWNpZmljIHNvdXJjZSBvbiB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgdHJpZ2dlcmluZyB0aGUgZnVuY3Rpb24uXG5cdCAqL1xuICAgIHRoaXMuaGFuZGxlT2ZmTWFwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TTkFQKSkgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU05BUCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5EcmF3XG5cdCAqIEBuYW1lIGhhbmRsZU9uTWFwXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgdGhlIGRhdGEgb2YgdGhlIFNOQVAgc291cmNlIG9uIHRoZSBtYXAgd2l0aCB0aGUgc25hcEZlYXR1cmUuXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRyaWdnZXJpbmcgdGhlIGZ1bmN0aW9uLlxuXHQgKi9cbiAgICB0aGlzLmhhbmRsZU9uTWFwID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmIChnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TTkFQKSAmJiBnZW9mbG8uc25hcEZlYXR1cmUpIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNOQVApLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbZ2VvZmxvLnNuYXBGZWF0dXJlXSkpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSBoYW5kbGVQYWludGluZ1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBpcyB0cmlnZ2VyZWQgd2hlbiBwYWludGluZyBvbiB0aGUgbWFwLiBJdCBkaXNhYmxlcyBkcmFnIHBhbiwgc2V0cyB0aGUgbWFwIGNsYXNzIHRvICdwYWludGluZycsIGFuZCB1cGRhdGVzIHRoZSBmZWF0dXJlIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IHRyaWdnZXJpbmcgdGhlIGZ1bmN0aW9uLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBtb3VzZSBpcyBub3QgZG93biBvciBubyBjb29yZGluYXRlcyBhcmUgYXZhaWxhYmxlLCBvdGhlcndpc2UgdXBkYXRlcyB0aGUgZmVhdHVyZSBjb29yZGluYXRlcy5cblx0ICovXG4gICAgdGhpcy5oYW5kbGVQYWludGluZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoIWdlb2Zsby5tb3VzZUlzRG93bikgcmV0dXJuIGZhbHNlO1xuICAgICAgICBnZW9mbG8ubWFwLmRyYWdQYW4uZGlzYWJsZSgpO1xuICAgICAgICBnZW9mbG8uc2V0TWFwQ2xhc3MoJ3BhaW50aW5nJyk7XG5cbiAgICAgICAgdmFyIHNuYXBDb29yZHMgPSBnZW9mbG8uc25hcEZlYXR1cmUgJiYgIWdlb2Zsby5QYWludGluZy5mZWF0dXJlO1xuICAgICAgICB2YXIgY29vcmRzID0gZXZlbnQubG5nTGF0ICYmIGV2ZW50LmxuZ0xhdC5sbmcgPyBbZXZlbnQubG5nTGF0LmxuZywgZXZlbnQubG5nTGF0LmxhdF0gOiBmYWxzZTtcbiAgICAgICAgaWYgKHNuYXBDb29yZHMpIGNvb3JkcyA9IGdlb2Zsby5zbmFwRmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICBpZiAoIWNvb3JkcykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gZ2VvZmxvLlBhaW50aW5nLnVwZGF0ZUZlYXR1cmUoY29vcmRzKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkRyYXdcblx0ICogQG5hbWUgaGFuZGxlUmVjdGFuZ2xlXG5cdCAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBjcmVhdGlvbiBhbmQgbWFuaXB1bGF0aW9uIG9mIGEgcmVjdGFuZ2xlIGZlYXR1cmUgb24gYSBtYXAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgdHJpZ2dlcmluZyB0aGUgZnVuY3Rpb24uXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmhhbmRsZVJlY3RhbmdsZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAoZ2VvZmxvLmVkaXRNb2RlICYmIGdlb2Zsby5ob3RGZWF0dXJlKSBnZW9mbG8uc3RhcnRQb2ludCA9IGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdO1xuICAgICAgICBpZiAoIWdlb2Zsby5zdGFydFBvaW50KSByZXR1cm47XG4gICAgICAgIGlmICghZ2VvZmxvLmRyYWdNb3ZpbmcpIGdlb2Zsby5VdGlsaXRpZXMuc2V0UHJvcGVydHkoZ2VvZmxvLmhvdEZlYXR1cmUsICd0eXBlJywgdGhpcy50eXBlKTtcbiAgICAgICAgZ2VvZmxvLmRyYWdNb3ZpbmcgPSB0cnVlO1xuXG4gICAgICAgIHZhciBjb29yZHMgPSBnZW9mbG8uc25hcEZlYXR1cmUgPyBnZW9mbG8uc25hcEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBbZXZlbnQubG5nTGF0LmxuZywgZXZlbnQubG5nTGF0LmxhdF07XG5cbiAgICAgICAgaWYgKGdlb2Zsby5kcmFnSW5kZXggPiAtMSkge1xuICAgICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBnZW9mbG8uZHJhZ0luZGV4ID09IDAgfHwgZ2VvZmxvLmRyYWdJbmRleCA9PSA0ID8gNCA6IGdlb2Zsby5kcmFnSW5kZXg7XG4gICAgICAgICAgICB2YXIgZW5kUG9pbnQgPSBzdGFydFBvaW50ID09IDEgPyAzIDogc3RhcnRQb2ludCA9PSAyID8gNCA6IHN0YXJ0UG9pbnQgPT0gMyA/IDEgOiAyO1xuICAgICAgICAgICAgdmFyIGxlZnRQb2ludCA9IGVuZFBvaW50ID09IDEgPyA0IDogZW5kUG9pbnQgPT0gMiA/IDEgOiBlbmRQb2ludCA9PSAzID8gMiA6IDNcbiAgICAgICAgICAgIHZhciByaWdodFBvaW50ID0gbGVmdFBvaW50ID09IDEgPyAzIDogbGVmdFBvaW50ID09IDIgPyA0IDogbGVmdFBvaW50ID09IDMgPyAxIDogMjtcblxuICAgICAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShnZW9mbG8uaG90RmVhdHVyZSwgXCIwLlwiICsgc3RhcnRQb2ludCwgY29vcmRzWzBdLCBjb29yZHNbMV0pO1xuICAgICAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShnZW9mbG8uaG90RmVhdHVyZSwgXCIwLlwiICsgbGVmdFBvaW50LCBjb29yZHNbMF0sIGdlb2Zsby5zdGFydFBvaW50WzFdKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvb3JkaW5hdGUoZ2VvZmxvLmhvdEZlYXR1cmUsIFwiMC5cIiArIHJpZ2h0UG9pbnQsIGdlb2Zsby5zdGFydFBvaW50WzBdLCBjb29yZHNbMV0pO1xuICAgICAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShnZW9mbG8uaG90RmVhdHVyZSwgXCIwLlwiICsgZW5kUG9pbnQsIGdlb2Zsby5zdGFydFBvaW50WzBdLCBnZW9mbG8uc3RhcnRQb2ludFsxXSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShnZW9mbG8uaG90RmVhdHVyZSwgXCIwLjFcIiwgY29vcmRzWzBdLCBnZW9mbG8uc3RhcnRQb2ludFsxXSk7XG4gICAgICAgICAgICB1cGRhdGVDb29yZGluYXRlKGdlb2Zsby5ob3RGZWF0dXJlLCBcIjAuMlwiLCBjb29yZHNbMF0sIGNvb3Jkc1sxXSk7XG4gICAgICAgICAgICB1cGRhdGVDb29yZGluYXRlKGdlb2Zsby5ob3RGZWF0dXJlLCBcIjAuM1wiLCBnZW9mbG8uc3RhcnRQb2ludFswXSwgY29vcmRzWzFdKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvb3JkaW5hdGUoZ2VvZmxvLmhvdEZlYXR1cmUsIFwiMC40XCIsIGdlb2Zsby5zdGFydFBvaW50WzBdLCBnZW9mbG8uc3RhcnRQb2ludFsxXSApO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuSE9UKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2dlb2Zsby5ob3RGZWF0dXJlXSkpO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5WRVJURVgpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbZ2VvZmxvLmhvdEZlYXR1cmVdKSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5EcmF3XG5cdCAqIEBuYW1lIGhhbmRsZVRleHRcblx0ICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGV4dCBpbnB1dCBldmVudHMgYW5kIGxvZ3MgcmVsZXZhbnQgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IHRyaWdnZXJpbmcgdGhlIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmVhdHVyZSAtIFRoZSBmZWF0dXJlIHRvIGJlIGhhbmRsZWQuXG5cdCAqL1xuICAgIHRoaXMuaGFuZGxlVGV4dCA9IGZ1bmN0aW9uIChldmVudCwgZmVhdHVyZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnaGFuZGxlVGV4dCcsIHRoaXMucHJvcGVydGllcywgZ2VvZmxvLnNuYXBGZWF0dXJlKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkRyYXdcblx0ICogQG5hbWUgaGFuZGxlSWNvblxuXHQgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgaWNvbiBiYXNlZCBvbiB0aGUgZXZlbnQgYW5kIGZlYXR1cmUgcHJvdmlkZWQuXG5cdCAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IHRyaWdnZXJpbmcgdGhlIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZSAtIFRoZSBmZWF0dXJlIG9iamVjdCB0byBiZSBoYW5kbGVkLlxuXHQgKi9cbiAgICB0aGlzLmhhbmRsZUljb24gPSBmdW5jdGlvbiAoZXZlbnQsIGZlYXR1cmUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2hhbmRsZUljb24nLCB0aGlzLnByb3BlcnRpZXMsIGdlb2Zsby5zbmFwRmVhdHVyZSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5EcmF3XG5cdCAqIEBuYW1lIGhhbmRsZUNvbnRleHRcblx0ICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGNvbnRleHQgb2YgZHJhZ2dpbmcgYW5kIG1vdmluZyBhIGZlYXR1cmUgdmVydGV4LlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCB0cmlnZ2VyaW5nIHRoZSBjb250ZXh0IGhhbmRsaW5nLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5oYW5kbGVDb250ZXh0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghZ2VvZmxvLmNhbkRyYWdNb3ZlIHx8ICFnZW9mbG8uc25hcHBlZFZlcnRleCkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgdmFyIHZhbGlkSW5kZXggPSBnZW9mbG8uZHJhZ0luZGV4ID4gLTE7XG4gICAgICAgIGlmICghdmFsaWRJbmRleCkgcmV0dXJuO1xuXG4gICAgICAgIGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLnNwbGljZShnZW9mbG8uZHJhZ0luZGV4LCAxKTtcblxuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5IT1QpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbZ2VvZmxvLmhvdEZlYXR1cmVdKSk7XG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlZFUlRFWCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtnZW9mbG8uaG90RmVhdHVyZV0pKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU05BUCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5EcmF3XG5cdCAqIEBuYW1lIGhhbmRsZUhpc3Rvcnlcblx0ICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGhpc3Rvcnkgb2YgZmVhdHVyZXMgaW4gdGhlIGN1cnJlbnQgbW9kZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IHRyaWdnZXJpbmcgdGhlIGhpc3RvcnkgdXBkYXRlLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5oYW5kbGVIaXN0b3J5ID0gZnVuY3Rpb24gaGFuZGxlSGlzdG9yeSAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGdlb2Zsby5kcmFnTW92aW5nKSByZXR1cm47XG5cbiAgICAgICAgdmFyIGhpc3RvcnkgPSBnZW9mbG8uY3VycmVudE1vZGUuaGlzdG9yeTtcbiAgICAgICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gZXZlbnQuZGV0YWlsLmRhdGEuZmVhdHVyZXM7XG4gICAgICAgIGlmICghZmVhdHVyZXMgfHwgIWZlYXR1cmVzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBmZWF0dXJlID0gZ2VvZmxvLlV0aWxpdGllcy5jbG9uZURlZXAoZmVhdHVyZXNbMF0pO1xuICAgICAgICBmZWF0dXJlLmhpc3RvcnlEYXRlID0gZGF0ZTtcbiAgICAgICAgaGlzdG9yeS5wdXNoKGZlYXR1cmUpO1xuXG4gICAgICAgIGdlb2Zsby5maXJlKCdmZWF0dXJlLmhpc3RvcnknLCB7IHR5cGU6IGdlb2Zsby5jdXJyZW50TW9kZS50eXBlLCBmZWF0dXJlOiBmZWF0dXJlLCBoaXN0b3J5OiBoaXN0b3J5IH0pO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSBoYW5kbGVVbmRvXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGlzIHJlc3BvbnNpYmxlIGZvciB1bmRvaW5nIHRoZSBsYXN0IGFjdGlvbiBwZXJmb3JtZWQgaW4gdGhlIGFwcGxpY2F0aW9uLiBJdCByZXRyaWV2ZXMgdGhlIGhpc3RvcnkgYW5kIHVuZG8gYXJyYXlzIGZyb20gdGhlIGN1cnJlbnQgbW9kZSwgcG9wcyB0aGUgbGFzdCBmZWF0dXJlIGZyb20gdGhlIGhpc3RvcnksIHNldHMgdGhlIHVuZG8gZmxhZyB0byB0cnVlIGZvciB0aGUgZmVhdHVyZSwgdXBkYXRlcyB0aGUgaG90RmVhdHVyZSwgcHVzaGVzIHRoZSBmZWF0dXJlIHRvIHRoZSB1bmRvIGFycmF5LCBhbmQgdXBkYXRlcyB0aGUgbWFwIHNvdXJjZSBkYXRhIHdpdGggdGhlIGhvdEZlYXR1cmUuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmhhbmRsZVVuZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhbGVydChcIlVOREVSIERFVkVMT1BNRU5UXCIpO1xuICAgICAgICB2YXIgaGlzdG9yeSA9IGdlb2Zsby5jdXJyZW50TW9kZS5oaXN0b3J5O1xuICAgICAgICB2YXIgdW5kbyA9IGdlb2Zsby5jdXJyZW50TW9kZS51bmRvO1xuXG4gICAgICAgIHZhciBmZWF0dXJlID0gaGlzdG9yeS5wb3AoKTtcblxuICAgICAgICBmZWF0dXJlLnVuZG8gPSB0cnVlO1xuICAgICAgICBnZW9mbG8uaG90RmVhdHVyZSA9IGZlYXR1cmU7XG5cbiAgICAgICAgdW5kby5wdXNoKGdlb2Zsby5ob3RGZWF0dXJlKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuSE9UKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2dlb2Zsby5ob3RGZWF0dXJlXSkpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRHJhd1xuXHQgKiBAbmFtZSBoYW5kbGVSZWRvXG5cdCAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSByZWRvIGZ1bmN0aW9uYWxpdHkgKGN1cnJlbnRseSB1bmRlciBkZXZlbG9wbWVudCkuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmhhbmRsZVJlZG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhbGVydChcIlVOREVSIERFVkVMT1BNRU5UXCIpO1xuICAgICAgICB2YXIgcmVkbyA9IGZhbHNlXG4gICAgfVxuXG5cblxuXG5cblxuICAgIGZ1bmN0aW9uIGVkaXRNb2RlIChmZWF0dXJlKSB7XG4gICAgICAgIHZhciB0eXBlID0gZ2VvZmxvLkZlYXR1cmVzLmdldFR5cGUoZmVhdHVyZSk7XG4gICAgICAgIGlmICghdHlwZSkgcmV0dXJuIGFsZXJ0KCdObyBGZWF0dXJlIFR5cGUgRm91bmQnKTtcblxuICAgICAgICBjb25zdCBpZCA9IGZlYXR1cmUuaWQ7XG4gICAgXG4gICAgICAgIGdlb2Zsby5jdXJyZW50TW9kZS50eXBlID0gdHlwZTtcbiAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLnNvdXJjZSA9IGZlYXR1cmUuc291cmNlO1xuICAgICAgICBnZW9mbG8uZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICBnZW9mbG8uaG90RmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgXG4gICAgICAgIGdlb2Zsby5VdGlsaXRpZXMuc2V0UHJvcGVydHkoZ2VvZmxvLmhvdEZlYXR1cmUsICd0eXBlJywgdHlwZSk7XG4gICAgICAgIGdlb2Zsby5VdGlsaXRpZXMuc2V0UHJvcGVydHkoZ2VvZmxvLmhvdEZlYXR1cmUsICdlZGl0JywgdHJ1ZSk7XG5cbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU0VMRUNUKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pKTtcbiAgICBcbiAgICAgICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgZ2VvZmxvLmhvdEZlYXR1cmUgPSB0dXJmLnBvbHlnb25Ub0xpbmUoZ2VvZmxvLmhvdEZlYXR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZSA9PT0gJ0NpcmNsZScgfHwgdHlwZSA9PT0gJ0ljb24nIHx8IHR5cGUgPT09ICdJbWFnZScpIHtcbiAgICAgICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkhPVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ1RleHQnKSB7XG4gICAgICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5IT1RURVhUKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2dlb2Zsby5ob3RGZWF0dXJlXSkpO1xuICAgICAgICAgICAgYWRkVGV4dC5jYWxsKGdlb2Zsby5jdXJyZW50TW9kZSwgdHlwZSwgZ2VvZmxvLmhvdEZlYXR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuSE9UKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2dlb2Zsby5ob3RGZWF0dXJlXSkpO1xuICAgICAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuVkVSVEVYKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2dlb2Zsby5ob3RGZWF0dXJlXSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvb3JkcyA9IGdlb2Zsby5VdGlsaXRpZXMuaXNQb2ludChnZW9mbG8uaG90RmVhdHVyZSkgPyBnZW9mbG8uaG90RmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyA6IGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2dlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICBnZW9mbG8ubGFzdENsaWNrID0geyBjb29yZHM6IGNvb3JkcyB9O1xuICAgICAgICBnZW9mbG8uZmlyc3RDbGljayA9IHsgY29vcmRzOiBjb29yZHMgfTtcbiAgICAgICAgcmV0dXJuIGdlb2Zsby5jdXJyZW50TW9kZS50eXBlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmlzaERyYXcgKHR5cGUsIHBvaW50LCB0ZXh0KSB7XG4gICAgICAgIHZhciBmZWF0dXJlO1xuICAgICAgICB2YXIgY2FuY2VsbGVkID0gZ2VvZmxvLmN1cnJlbnRNb2RlLmNhbmNlbGxlZDtcblxuICAgICAgICBpZiAoZ2VvZmxvLmVkaXRNb2RlICYmICFnZW9mbG8uY3VycmVudE1vZGUuc2F2aW5nRWRpdCAmJiAhY2FuY2VsbGVkKSByZXR1cm4gZ2VvZmxvLmN1cnJlbnRNb2RlLnNhdmVFZGl0KHBvaW50KTtcbiAgICBcbiAgICAgICAgaWYgKGNhbmNlbGxlZCB8fCAhdHlwZSkge1xuICAgICAgICAgICAgZmluaXNoVGV4dCgpO1xuXG4gICAgICAgICAgICBpZiAoZ2VvZmxvLmhvdEZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBnZW9mbG8ucmVtb3ZlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgZ2VvZmxvLnJlbW92ZUZlYXR1cmUoZ2VvZmxvLmhvdEZlYXR1cmUuaWQsIHRydWUpO1xuICAgICAgICAgICAgICAgIGdlb2Zsby5hZGRGZWF0dXJlcyhbZ2VvZmxvLmhvdEZlYXR1cmVdLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2VvZmxvLlBpbm5pbmcucmVzZXRGZWF0dXJlcygpO1xuXG4gICAgICAgICAgICBpZiAoIWdlb2Zsby5lZGl0TW9kZSkgZ2VvZmxvLmZpcmUoJ2RyYXcuY2FuY2VsJywgeyBjYW5jZWw6IHRydWUsIGZlYXR1cmU6IGdlb2Zsby5ob3RGZWF0dXJlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdUZXh0JyAmJiAhdGV4dCkge1xuICAgICAgICAgICAgcmV0dXJuIGFkZFRleHQuY2FsbChnZW9mbG8uY3VycmVudE1vZGUsIHR5cGUsIHBvaW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChnZW9mbG8uaG90RmVhdHVyZSkge1xuICAgICAgICAgICAgaWYgKGdlb2Zsby5VdGlsaXRpZXMuaXNQb2ludChnZW9mbG8uaG90RmVhdHVyZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzID0gQXJyYXkuaXNBcnJheShnZW9mbG8uaG90RmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSkgP1xuICAgICAgICAgICAgICAgIGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdIDpcbiAgICAgICAgICAgICAgICBbZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sIGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdXVxuICAgIFxuICAgICAgICAgICAgICAgIHBvaW50ID0gZ2VvZmxvLlBhaW50aW5nLmVuYWJsZWQgfHwgZ2VvZmxvLmN1cnJlbnRNb2RlLnNhdmluZ0VkaXQgPyBwb2ludCA6IHR1cmYucG9pbnQoY29vcmRzKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlID0gcG9pbnQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlb2Zsby5VdGlsaXRpZXMuaXNQb2x5Z29uKGdlb2Zsby5ob3RGZWF0dXJlLCB0eXBlKSkge1xuICAgICAgICAgICAgICAgIGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LnR5cGUgPSBcIlBvbHlnb25cIjtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnUmVjdGFuZ2xlJykge1xuICAgICAgICAgICAgICAgICAgICBnZW9mbG8uZW5kUG9pbnQgPyB1cGRhdGVDb29yZGluYXRlKGdlb2Zsby5ob3RGZWF0dXJlLCBcIjAuMlwiLCBnZW9mbG8uZW5kUG9pbnRbMF0sIGdlb2Zsby5lbmRQb2ludFsxXSkgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZW9mbG8uaG90RmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcy5wdXNoKGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBbZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvZmxvLlV0aWxpdGllcy5pc0xpbmVTdHJpbmcoZ2VvZmxvLmhvdEZlYXR1cmUsIHR5cGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgICAgICBnZW9mbG8uaG90RmVhdHVyZS5nZW9tZXRyeS50eXBlID0gdHlwZTtcbiAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMucHVzaChnZW9mbG8uaG90RmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gW2dlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdSZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGdlb2Zsby5lbmRQb2ludCA/IHVwZGF0ZUNvb3JkaW5hdGUoZ2VvZmxvLmhvdEZlYXR1cmUsIFwiMC4yXCIsIGdlb2Zsby5lbmRQb2ludFswXSwgZ2VvZmxvLmVuZFBvaW50WzFdKSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlID0gcG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoZ2VvZmxvLlBhaW50aW5nLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9sZXJhbmNlID0gZ2VvZmxvLm9wdGlvbnMucGFpbnRpbmcudG9sZXJhbmNlO1xuICAgIFxuICAgICAgICAgICAgICAgIGdlb2Zsby5ob3RGZWF0dXJlID0gdHlwZSA9PT0gJ0NpcmNsZScgPyBnZW9mbG8uaG90RmVhdHVyZSA6IHR1cmYuc2ltcGxpZnkoZ2VvZmxvLmhvdEZlYXR1cmUsIHtcbiAgICAgICAgICAgICAgICAgICAgbXV0YXRlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB0b2xlcmFuY2U6IHR5cGVvZiB0b2xlcmFuY2UgPT09ICdmdW5jdGlvbicgPyB0b2xlcmFuY2UoZ2VvZmxvLm1hcCkgOiB0b2xlcmFuY2UsXG4gICAgICAgICAgICAgICAgICAgIGhpZ2hRdWFsaXR5OiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZ2VvZmxvLnN0YXJ0UG9pbnQpIGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdID0gZ2VvZmxvLnN0YXJ0UG9pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnQpIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmZWF0dXJlID0gZ2VvZmxvLkV4cGxvcmluZy5jdXJyZW50RmVhdHVyZSB8fCBmZWF0dXJlIHx8IGdlb2Zsby5ob3RGZWF0dXJlO1xuICAgICAgICBpZiAoIWZlYXR1cmUgfHwgIWdlb2Zsby5jdXJyZW50TW9kZS5hY3RpdmF0ZWQpIHJldHVybiBnZW9mbG8uY3VycmVudE1vZGUuZGVhY3RpdmF0ZSgpO1xuXG4gICAgICAgIGZlYXR1cmUgPSBnZW9mbG8uRmVhdHVyZXMuYWRkRmVhdHVyZShmZWF0dXJlLCBnZW9mbG8uY3VycmVudE1vZGUuc291cmNlLCBnZW9mbG8uY3VycmVudE1vZGUucHJvcGVydGllcyk7XG4gICAgICAgIGdlb2Zsby5maXJlKCdkcmF3LmZpbmlzaCcsIHsgZmVhdHVyZTogZmVhdHVyZSwgcGlubmVkOiBnZW9mbG8uUGlubmluZy5nZXRGZWF0dXJlcygpLCB0eXBlOiB0eXBlLCBlZGl0aW5nOiBnZW9mbG8uZWRpdE1vZGUgfSk7XG4gICAgICAgIHJldHVybiBnZW9mbG8uY3VycmVudE1vZGUuZGVhY3RpdmF0ZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGZpbmlzaFRleHQgKGUsIHR5cGUsIGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IGdlb2Zsby50ZXh0TWFya2VyO1xuICAgICAgICBpZiAoIW1hcmtlcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBlbGVtZW50ID0gbWFya2VyLmdldEVsZW1lbnQoKTtcbiAgICAgICAgdmFyIHRleHQgPSBlbGVtZW50LnZhbHVlO1xuICAgIFxuICAgICAgICBpZiAoIXRleHQubGVuZ3RoIHx8IGdlb2Zsby5jdXJyZW50TW9kZS5jYW5jZWxsZWQpIHJldHVybiBtYXJrZXIucmVtb3ZlKCksIGdlb2Zsby50ZXh0SW5wdXQgPSBmYWxzZSwgYWRkVGV4dC5jYWxsKHRoaXMsIHR5cGUsIGZlYXR1cmUpO1xuICAgIFxuICAgICAgICB2YXIgY29vcmRzID0gW2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdsbmcnKSwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2xhdCcpXTtcbiAgICAgICAgdHlwZSA9IHR5cGUgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKTtcblxuICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUucHJvcGVydGllcy50ZXh0ID0gdGV4dDtcbiAgICAgICAgXG4gICAgICAgIHZhciBmZWF0dXJlID0ge1xuICAgICAgICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICAgICAgICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgIHRleHQ6IHRleHRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAgICAgICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAgICAgICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBjb29yZHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbWFya2VyLnJlbW92ZSgpO1xuICAgICAgICBmaW5pc2hEcmF3KHR5cGUsIGZlYXR1cmUsIHRleHQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFudXBEcmF3IChtb2RlKSB7XG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlJPVVRFKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU05BUCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkhPVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlZFUlRFWCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkhPVFRFWFQpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TRUxFQ1QpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuICAgIFxuICAgICAgICBnZW9mbG8uZGVsZXRlTWVzaERhdGEoKTtcbiAgICBcbiAgICAgICAgbW9kZS5oaXN0b3J5ID0gW107XG4gICAgICAgIG1vZGUudW5kbyA9IFtdO1xuICAgICAgICBtb2RlLnR5cGUgPSBudWxsO1xuICAgICAgICBtb2RlLmNhbmNlbGxlZCA9IGZhbHNlO1xuICAgICAgICBtb2RlLmFjdGl2YXRlZCA9IGZhbHNlO1xuICAgICAgICBtb2RlLnNhdmluZ0VkaXQgPSBmYWxzZTtcblxuICAgICAgICBnZW9mbG8uZWRpdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLmRyYXdNb2RlID0gZmFsc2U7XG5cbiAgICAgICAgZGVsZXRlIGdlb2Zsby5zdGFydFBvaW50O1xuICAgICAgICBkZWxldGUgZ2VvZmxvLmxhc3RDbGljaztcbiAgICAgICAgZGVsZXRlIGdlb2Zsby5maXJzdENsaWNrO1xuICAgICAgICBkZWxldGUgZ2VvZmxvLmVuZFBvaW50O1xuICAgICAgICBkZWxldGUgZ2VvZmxvLnNuYXBGZWF0dXJlO1xuICAgICAgICBkZWxldGUgZ2VvZmxvLmhvdEZlYXR1cmU7XG4gICAgICAgIGRlbGV0ZSBnZW9mbG8uZHJhd1N0YXJ0ZWQ7XG4gICAgICAgIGRlbGV0ZSBnZW9mbG8uZHJhZ01vdmluZztcbiAgICAgICAgZGVsZXRlIGdlb2Zsby5lZGl0aW5nO1xuICAgICAgICBkZWxldGUgZ2VvZmxvLnRleHRNYXJrZXI7XG4gICAgICAgIGRlbGV0ZSBnZW9mbG8udGV4dElucHV0O1xuICAgICAgICBkZWxldGUgZ2VvZmxvLnRvdWNoTW92aW5nO1xuICAgICAgICBkZWxldGUgZ2VvZmxvLnRvdWNoRG93bjtcbiAgICAgICAgZGVsZXRlIGdlb2Zsby5waW5uaW5nRmVhdHVyZXM7XG4gICAgICAgIGRlbGV0ZSBnZW9mbG8ucGlubmVkRmVhdHVyZXM7XG4gICAgICAgIGRlbGV0ZSBnZW9mbG8uY2FuRHJhZ01vdmU7XG4gICAgICAgIGRlbGV0ZSBnZW9mbG8uY2FuQWRkVmVydGV4O1xuICAgICAgICBkZWxldGUgZ2VvZmxvLmRyYWdJbmRleDtcbiAgICAgICAgZGVsZXRlIGdlb2Zsby5hZGRlZFZlcnRleE9uTGluZTtcbiAgICAgICAgZGVsZXRlIGdlb2Zsby5zbmFwcGVkVmVydGV4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFZlcnRleCAocG9pbnQpIHtcbiAgICAgICAgdmFyIGhvdEZlYXR1cmUgPSBnZW9mbG8uaG90RmVhdHVyZTtcbiAgICAgICAgdmFyIHZlcnRleDtcbiAgICBcbiAgICAgICAgaWYgKGdlb2Zsby5kcmFnTW92aW5nKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghaG90RmVhdHVyZSkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgICAgICB2YXIgY2xvc2VzdCA9IGdlb2Zsby5TbmFwcGluZy5nZXRDbG9zZXN0KHBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGNsb3Nlc3QuY29vcmRzO1xuICAgICAgICB2YXIgdHlwZSA9IGNsb3Nlc3QucG9pbnQgPyBjbG9zZXN0LnBvaW50LnR5cGUgOiBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgICAgICBpZiAoIWNvb3JkcyAmJiB0eXBlID09PSAnbGluZXBvaW50JyAmJiBjbG9zZXN0LnBvaW50LmJvcmRlcnMpIHtcbiAgICAgICAgICAgIHZhciBzZWdtZW50ID0gdHVyZi5saW5lU3RyaW5nKFtjbG9zZXN0LnBvaW50LmJvcmRlcjEsIGNsb3Nlc3QucG9pbnQuYm9yZGVyMl0pO1xuICAgICAgICAgICAgdmVydGV4ID0gdHVyZi5hbG9uZyhzZWdtZW50LCBjbG9zZXN0LnBvaW50LmRpc3RhbmNlMSk7XG4gICAgICAgICAgICBjb29yZHMgPSB2ZXJ0ZXguZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKCFjb29yZHMpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBwb2ludCA9IHR1cmYucG9pbnQoY29vcmRzKTsgXG5cbiAgICAgICAgdmFyIGlzTGluZVZlcnRleCA9IGdlb2Zsby5VdGlsaXRpZXMuaXNMaW5lU3RyaW5nKGhvdEZlYXR1cmUpICYmIHR5cGUgPT09ICd2ZXJ0ZXgnO1xuICAgICAgICB2YXIgbmVhcmVzdFZlcnRleCA9IGlzTGluZVZlcnRleCA/IHR1cmYubmVhcmVzdFBvaW50T25MaW5lKGhvdEZlYXR1cmUsIHBvaW50KSA6IGZhbHNlO1xuICAgICAgICAgICBcbiAgICAgICAgdmVydGV4ID0gbmVhcmVzdFZlcnRleCB8fCBwb2ludDtcbiAgICAgICAgdmVydGV4LnByb3BlcnRpZXMudHlwZSA9IHR5cGU7XG4gICAgXG4gICAgICAgIGdlb2Zsby5maXJlKCd2ZXJ0ZXguZmluZCcsIHsgdmVydGV4OiB2ZXJ0ZXgsIGZlYXR1cmU6IGdlb2Zsby5ob3RGZWF0dXJlLCBjbG9zZXN0OiBjbG9zZXN0IH0pO1xuICAgICAgICByZXR1cm4gdmVydGV4O1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBhZGRWZXJ0ZXggKHBvaW50LCBldmVudCkge1xuICAgICAgICB2YXIgZmVhdHVyZTtcbiAgICBcbiAgICAgICAgaWYgKGV2ZW50ICYmIHBvaW50KSB7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICB2YXIgbGluZSA9IHR1cmYubGluZVN0cmluZyhjb29yZHMpO1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gdHVyZi5wb2ludChjb29yZHNbMF0pXG4gICAgICAgICAgICB2YXIgc3BsaXQgPSB0dXJmLmxpbmVTbGljZShzdGFydCwgcG9pbnQsIGxpbmUpO1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gc3BsaXQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciB2ZXJ0ZXggPSBzcGxpdC5nZW9tZXRyeS5jb29yZGluYXRlc1tpbmRleF07XG4gICAgXG4gICAgICAgICAgICBwb2ludCA9IHR1cmYucG9pbnQodmVydGV4KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGluZS5nZW9tZXRyeS5jb29yZGluYXRlcy5zcGxpY2UuYXBwbHkobGluZS5nZW9tZXRyeS5jb29yZGluYXRlcywgW2luZGV4LCAwXS5jb25jYXQoW3ZlcnRleF0pKTtcbiAgICBcbiAgICAgICAgICAgIGxpbmUgPSB0dXJmLmNsZWFuQ29vcmRzKGxpbmUpO1xuICAgICAgICAgICAgZmVhdHVyZSA9IHR1cmYudHJ1bmNhdGUobGluZSwgeyBwcmVjaXNpb246IDYsIGNvb3JkaW5hdGVzOiAyLCBtdXRhdGU6IHRydWUgfSk7XG4gICAgICAgICAgICBnZW9mbG8uaG90RmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBnZW9mbG8uaG90RmVhdHVyZSA9IGdlb2Zsby5VdGlsaXRpZXMuY2xvbmVEZWVwKGdlb2Zsby5ob3RGZWF0dXJlKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb2ludCkge1xuICAgICAgICAgICAgZ2VvZmxvLmNhbkRyYWdNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGdlb2Zsby5jYW5BZGRWZXJ0ZXggPSBwb2ludDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIG9uVmVydGV4ICh2ZXJ0ZXgsIGFkZCkge1xuICAgICAgICB2YXIgaG90RmVhdHVyZSA9IGdlb2Zsby5ob3RGZWF0dXJlO1xuICAgICAgICB2YXIgZHJhZ0luZGV4ID0gbnVsbDtcbiAgICBcbiAgICAgICAgaWYgKGdlb2Zsby5kcmFnTW92aW5nKSByZXR1cm4gb2ZmVmVydGV4KCk7XG4gICAgICAgIGlmICghaG90RmVhdHVyZSB8fCAhdmVydGV4KSByZXR1cm4gb2ZmVmVydGV4KCk7XG4gICAgICAgIFxuICAgICAgICBnZW9mbG8udXBkYXRlTWVzaERhdGEoKTtcbiAgICBcbiAgICAgICAgdmFyIHR5cGUgPSB2ZXJ0ZXgucHJvcGVydGllcy50eXBlO1xuICAgICAgICB2YXIgaW5kZXggPSB2ZXJ0ZXgucHJvcGVydGllcy5pbmRleCB8fCB2ZXJ0ZXgucHJvcGVydGllcy5pbmRleCA9PSAwO1xuICAgIFxuICAgICAgICBkcmFnSW5kZXggPSBpbmRleCA/IHZlcnRleC5wcm9wZXJ0aWVzLmluZGV4IDogZ2VvZmxvLmN1cnJlbnRNb2RlLnR5cGUgPT09ICdDaXJjbGUnIHx8IGdlb2Zsby5jdXJyZW50TW9kZS50eXBlID09PSAnSWNvbicgfHwgZ2VvZmxvLmN1cnJlbnRNb2RlLnR5cGUgPT09ICdJbWFnZScgPyAwIDogZmFsc2U7XG4gICAgXG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNOQVApLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbdmVydGV4XSkpO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5WRVJURVgpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbZ2VvZmxvLmhvdEZlYXR1cmVdKSk7XG4gICAgXG4gICAgICAgIGlmICh0eXBlID09PSAnbGluZXBvaW50JykgcmV0dXJuIGFkZFZlcnRleCh2ZXJ0ZXgpO1xuICAgIFxuICAgICAgICBnZW9mbG8ubWFwLmRyYWdQYW4uZGlzYWJsZSgpO1xuICAgICAgICBnZW9mbG8uZHJhZ0luZGV4ID0gZHJhZ0luZGV4O1xuICAgICAgICBnZW9mbG8uYWRkZWRWZXJ0ZXhPbkxpbmUgPSBhZGQgPyB2ZXJ0ZXggOiBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLmNhbkFkZFZlcnRleCA9IGZhbHNlO1xuICAgICAgICBnZW9mbG8uY2FuRHJhZ01vdmUgPSB0cnVlO1xuICAgICAgICBnZW9mbG8uc25hcHBlZFZlcnRleCA9IHZlcnRleC5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgZ2VvZmxvLlBpbm5pbmcuc2V0RmVhdHVyZXMoZ2VvZmxvLnNuYXBwZWRWZXJ0ZXgpO1xuICAgICAgICBnZW9mbG8uZmlyZSgndmVydGV4Lm9uJywgeyB2ZXJ0ZXg6IHZlcnRleCwgaW5kZXg6IGRyYWdJbmRleCwgZmVhdHVyZTogZ2VvZmxvLmhvdEZlYXR1cmUgfSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIG9mZlZlcnRleCAoKSB7XG4gICAgICAgIGlmIChnZW9mbG8ubW91c2VJc0Rvd24gJiYgZ2VvZmxvLlBhaW50aW5nLmVuYWJsZWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICBpZiAoZ2VvZmxvLmhvdEZlYXR1cmUgJiYgZ2VvZmxvLnNuYXBwZWRWZXJ0ZXgpIHtcbiAgICAgICAgICAgIGdlb2Zsby5sYXN0SW5kZXggPyBnZW9mbG8ubGFzdENsaWNrID0geyBjb29yZHM6IGdlb2Zsby5zbmFwcGVkVmVydGV4IH0gOiBmYWxzZTtcbiAgICAgICAgICAgIGdlb2Zsby5maXJlKCd2ZXJ0ZXgub2ZmJywgeyB2ZXJ0ZXg6IGZhbHNlLCBpbmRleDogZ2VvZmxvLmRyYWdJbmRleCwgZmVhdHVyZTogZ2VvZmxvLmhvdEZlYXR1cmUgfSlcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBnZW9mbG8ubWFwLmRyYWdQYW4uZW5hYmxlKCk7XG4gICAgICAgIGdlb2Zsby5kcmFnTW92aW5nID0gZmFsc2U7XG4gICAgICAgIGdlb2Zsby5jYW5EcmFnTW92ZSA9IGZhbHNlO1xuICAgICAgICBnZW9mbG8uc25hcHBlZFZlcnRleCA9IG51bGw7XG4gICAgICAgIGdlb2Zsby5kcmFnSW5kZXggPSAtMTtcbiAgICAgICAgZ2VvZmxvLm1vdXNlSXNEb3duID0gZ2VvZmxvLnRvdWNoRG93biB8fCBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLnBpbmFibGVGZWF0dXJlcyA9IFtdO1xuICAgICAgICBnZW9mbG8ubGFzdEluZGV4ID0gZmFsc2U7XG4gICAgICAgIGdlb2Zsby5jYW5BZGRWZXJ0ZXggPSBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLmFkZGVkVmVydGV4T25MaW5lID0gZmFsc2VcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRUZXh0ICh0eXBlLCBmZWF0dXJlKSB7XG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlIHx8IGdlb2Zsby5ob3RGZWF0dXJlO1xuICAgICAgICBpZiAoIWZlYXR1cmUpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB0eXBlID0gdHlwZSB8fCBmZWF0dXJlLnByb3BlcnRpZXMudHlwZTtcbiAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzLnR5cGUgPSB0eXBlO1xuXG4gICAgICAgIGlmICh0eXBlICE9PSAnVGV4dCcpIHJldHVybiAvL2dlb2Zsby5GZWF0dXJlcy5zZXRUZXh0KGZlYXR1cmUpO1xuICAgICAgICBpZiAoZ2VvZmxvLnRleHRJbnB1dCkgcmV0dXJuIGZpbmlzaFRleHQoZmFsc2UsIHR5cGUsIGZlYXR1cmUpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGxuZ0xhdCA9IHsgbG5nOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLCBsYXQ6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0gfVxuICAgICAgICB2YXIgZWwgPSBnZW9mbG8udGV4dElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcblxuICAgICAgICBlbC52YWx1ZSA9IGZlYXR1cmUucHJvcGVydGllcy50ZXh0IHx8ICcnO1xuICAgICAgICBlbC5jbGFzc05hbWUgPSAndGV4dC1tYXJrZXInO1xuXG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ3RydWUnKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdhdXRvY29ycmVjdCcsICdvZmYnKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdzcGVsbGNoZWNrJywgJ2ZhbHNlJyk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCAnUHJlc3MgRW50ZXIgb3IgU2VsZWN0IEJ1dHRvbiBXaGVuIERvbmUuLi4nKTtcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0eXBlJywgdHlwZSk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnbG5nJywgbG5nTGF0LmxuZyk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgnbGF0JywgbG5nTGF0LmxhdCk7XG4gICAgICAgIFxuICAgICAgICBnZW9mbG8udGV4dE1hcmtlciA9IG5ldyBtYXBib3hnbC5NYXJrZXIoZWwpLnNldExuZ0xhdChsbmdMYXQpLmFkZFRvKGdlb2Zsby5tYXApO1xuICAgICAgICBnZW9mbG8udGV4dE1hcmtlci5zZXRPZmZzZXQoWzAsIC0yNV0pXG5cbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCBmaW5pc2hUZXh0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaW5wdXRUZXh0KTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInBhc3RlXCIsIGhhbmRsZVBhc3RlKTtcbiAgICAgICAgZWwuZm9jdXMoKTtcblxuICAgICAgICBnZW9mbG8uZmlyZSgndGV4dC5hZGQnLCB7IGZlYXR1cmU6IGZlYXR1cmUsIG1hcmtlcjogZ2VvZmxvLnRleHRNYXJrZXIsIHR5cGU6IHR5cGUgfSk7XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIGlucHV0VGV4dCAoZSkge1xuICAgICAgICAgICAgaWYgKFszMiwgMzcsIDM4LCAzOSwgNDBdLmluZGV4T2YoZS5rZXlDb2RlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZihlLmtleUNvZGUgPT09IDEzKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGZpbmlzaFRleHQoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVQYXN0ZSAoZSkge1xuICAgICAgICAgICAgdmFyIGNsaXBib2FyZERhdGEsIHBhc3RlZERhdGE7XG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgY2xpcGJvYXJkRGF0YSA9IGUuY2xpcGJvYXJkRGF0YSB8fCB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgICAgICAgICAgIHBhc3RlZERhdGEgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoJ3RleHQvcGxhaW4nKS5zbGljZSgwLCBDSEFSX0xJTUlUKTtcbiAgICAgICAgICAgIGUudGFyZ2V0LmlubmVyVGV4dCA9IHBhc3RlZERhdGE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVDb29yZGluYXRlIChmLCB0LCBlLCBuKSB7XG4gICAgICAgIHZhciBvID0gdC5zcGxpdChcIi5cIilcbiAgICAgICAgICAgICwgciA9IHBhcnNlSW50KG9bMF0sIDEwKVxuICAgICAgICAgICAgLCBpID0gcGFyc2VJbnQob1sxXSwgMTApO1xuICAgICAgICB2b2lkIDAgPT09IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbcl0gJiYgKGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbcl0gPSBbXSksXG4gICAgICAgIGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbcl1baV0gPSBbZSwgbl1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWN0YW5nbGUgKGV2ZW50LCB0eXBlKSB7XG4gICAgICAgIGlmICh0eXBlICE9PSAnUmVjdGFuZ2xlJykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgdmFyIGdlb21ldHJ5ID0gZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgICAgIHZhciBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgY29uc3QgY29vcmRUeXBlID0gZ2VvbWV0cnkudHlwZTtcbiAgICAgICAgLy9jb29yZHMgPSBjb29yZFR5cGUgPT09ICdMaW5lc3RyaW5nJyA/IGNvb3JkcyA6IGNvb3Jkc1swXTtcbiAgICBcbiAgICAgICAgaWYgKGdlb2Zsby5jdXJyZW50VmVydGV4UG9zaXRpb24gPT09IDIpIHtcbiAgICAgICAgICAgIGNvbnN0IGdldHBYWTMgPSBjYWxjdWxhdGVwWFkzKGdlb21ldHJ5LCBldmVudCwgdHlwZSk7XG4gICAgICAgICAgICBpZiAoZ2V0cFhZM1syXSkgcmV0dXJuIHVwZGF0ZUNvb3JkaW5hdGUoYDAuJHtnZW9mbG8uY3VycmVudFZlcnRleFBvc2l0aW9uICsgMX1gLCBnZXRwWFkzWzJdWzBdLCBnZXRwWFkzWzJdWzFdKTtcbiAgICAgICAgICAgIHJldHVybiBnZW9mbG8uaG90RmVhdHVyZTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICB1cGRhdGVDb29yZGluYXRlKGAwLiR7Z2VvZmxvLmN1cnJlbnRWZXJ0ZXhQb3NpdGlvbn1gLCBldmVudC5sbmdMYXQubG5nLCBldmVudC5sbmdMYXQubGF0KTtcbiAgICAgICAgZ2VvZmxvLmN1cnJlbnRWZXJ0ZXhQb3NpdGlvbisrO1xuICAgICAgICB1cGRhdGVDb29yZGluYXRlKGAwLiR7Z2VvZmxvLmN1cnJlbnRWZXJ0ZXhQb3NpdGlvbn1gLCBldmVudC5sbmdMYXQubG5nLCBldmVudC5sbmdMYXQubGF0KTtcbiAgICBcbiAgICAgICAgZnVuY3Rpb24gY2FsY3VsYXRlcFhZMyAoZ2VvbWV0cnksIGV2ZW50LCB0eXBlKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIFxuICAgICAgICAgICAgY29uc3QgcFhZMCA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHBYWTBfMzg1NyA9IGdlb2Zsby5VdGlsaXRpZXMuZGVncmVlczJtZXRlcnMocFhZMCk7XG4gICAgICAgICAgICBjb25zdCBwWFkxID0gY29vcmRzWzFdO1xuICAgICAgICAgICAgY29uc3QgcFhZMV8zODU3ID0gZ2VvZmxvLlV0aWxpdGllcy5kZWdyZWVzMm1ldGVycyhwWFkxKTtcbiAgICAgICAgICAgIGxldCBwWFkyXzM4NTcgPSBnZW9mbG8uVXRpbGl0aWVzLmRlZ3JlZXMybWV0ZXJzKFtldmVudC5sbmdMYXQubG5nLCBldmVudC5sbmdMYXQubGF0XSk7XG4gICAgICAgICAgICBjb25zdCBtb3VzZV8zODU3ID0gZ2VvZmxvLlV0aWxpdGllcy5kZWdyZWVzMm1ldGVycyhbZXZlbnQubG5nTGF0LmxuZywgZXZlbnQubG5nTGF0LmxhdF0pO1xuICAgICAgICBcbiAgICAgICAgICAgIGlmIChwWFkwXzM4NTdbMF0gPT09IHBYWTFfMzg1N1swXSkge1xuICAgICAgICAgICAgICAgIHBYWTJfMzg1NyA9IFttb3VzZV8zODU3WzBdLCBwWFkxXzM4NTdbMV1dO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwWFkwXzM4NTdbMV0gPT09IHBYWTFfMzg1N1sxXSkge1xuICAgICAgICAgICAgICAgIHBYWTJfMzg1NyA9IFtwWFkxXzM4NTdbMF0sIG1vdXNlXzM4NTdbMV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ZWN0b3IxXzM4NTcgPSAocFhZMV8zODU3WzFdIC0gcFhZMF8zODU3WzFdKSAvIChwWFkxXzM4NTdbMF0gLSBwWFkwXzM4NTdbMF0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlY3RvcjJfMzg1NyA9IC0xLjAgLyB2ZWN0b3IxXzM4NTc7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyh2ZWN0b3IyXzM4NTcpIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICBwWFkyXzM4NTdbMV0gPSB2ZWN0b3IyXzM4NTcgKiAobW91c2VfMzg1N1swXSAtIHBYWTFfMzg1N1swXSkgKyBwWFkxXzM4NTdbMV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcFhZMl8zODU3WzBdID0gcFhZMV8zODU3WzBdICsgKHBYWTJfMzg1N1sxXSAtIHBYWTFfMzg1N1sxXSkgLyB2ZWN0b3IyXzM4NTc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIGNvbnN0IHZlY3Rvcl8zODU3ID0gW3BYWTFfMzg1N1swXSAtIHBYWTBfMzg1N1swXSwgcFhZMV8zODU3WzFdIC0gcFhZMF8zODU3WzFdXTtcbiAgICAgICAgICAgIGNvbnN0IHBYWTNfMzg1NyA9IFtwWFkyXzM4NTdbMF0gLSB2ZWN0b3JfMzg1N1swXSwgcFhZMl8zODU3WzFdIC0gdmVjdG9yXzM4NTdbMV1dO1xuICAgICAgICAgICAgY29uc3QgcFhZMkcgPSBnZW9mbG8uVXRpbGl0aWVzLm1ldGVyczJkZWdyZWVzKHBYWTJfMzg1Nyk7XG4gICAgICAgICAgICBjb25zdCBwWFkzRyA9IGdlb2Zsby5VdGlsaXRpZXMubWV0ZXJzMmRlZ3JlZXMocFhZM18zODU3KTtcbiAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gW2Nvb3JkcywgcFhZMkcsIHBYWTNHXTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnRJZGxlVGltZSAoKSB7XG4gICAgICAgIHZhciByZWFkeSA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKGdlb2Zsby5tb3VzZUlzRG93bikge1xuICAgICAgICAgICAgICAgIGdlb2Zsby5sYXN0RHJhZ01vdmUgKz0gMTtcbiAgICAgICAgICAgICAgICBjaGVja0lkbGVNb3ZlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGdlb2Zsby5sYXN0RHJhZ01vdmUgPSAwO1xuICAgICAgICAgICAgICAgIGdlb2Zsby5tb3VzZUlzSWRsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVhZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAxKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gY2hlY2tJZGxlTW92ZSAoKSB7XG4gICAgICAgIGlmIChnZW9mbG8ubGFzdERyYWdNb3ZlIDwgZ2VvZmxvLm9wdGlvbnMucGlubmluZy5pZGxlKSByZXR1cm4gZ2VvZmxvLm1vdXNlSXNJZGxlID0gZmFsc2UsIGZhbHNlO1xuICAgICAgICBnZW9mbG8ubW91c2VJc0lkbGUgPSB0cnVlO1xuICAgICAgICBnZW9mbG8uU25hcHBpbmcuc2V0VmVydGV4KCk7XG4gICAgICAgIGdlb2Zsby5QaW5uaW5nLnVwZGF0ZUZlYXR1cmVzKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5lZWRzVG9GaW5pc2ggKHR5cGUsIGNvb3Jkcykge1xuICAgICAgICB2YXIgdHlwZXMgPSBbJ0NpcmNsZScsICdJY29uJywgJ1RleHQnLCAnSW1hZ2UnXTtcbiAgICAgICAgaWYgKCF0eXBlKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKHR5cGUpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdSZWN0YW5nbGUnICYmIGdlb2Zsby5zdGFydFBvaW50KSByZXR1cm4gZ2VvZmxvLmVuZFBvaW50ID0gY29vcmRzLCB0cnVlO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ1BvbHlnb24nICYmIGdlb2Zsby5zbmFwcGVkVmVydGV4ICYmIGdlb2Zsby5zdGFydFBvaW50ICYmIGdlb2Zsby5VdGlsaXRpZXMuaXNQb2ludEVxdWFsKGdlb2Zsby5zdGFydFBvaW50LCBnZW9mbG8uc25hcHBlZFZlcnRleCkpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAoZ2VvZmxvLnNuYXBwZWRWZXJ0ZXggJiYgZ2VvZmxvLlV0aWxpdGllcy5pc0xhc3RJbmRleChnZW9mbG8uZHJhZ0luZGV4LCBnZW9mbG8uaG90RmVhdHVyZSkpIHJldHVybiB0cnVlXG4gICAgICAgIGlmIChnZW9mbG8ubGFzdENsaWNrICYmIGdlb2Zsby5VdGlsaXRpZXMuaXNQb2ludEVxdWFsKGdlb2Zsby5sYXN0Q2xpY2suY29vcmRzLCBjb29yZHMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnN0cmFpbkZlYXR1cmVNb3ZlbWVudCAoZ2VvanNvbkZlYXR1cmVzLCBkZWx0YSkge1xuICAgICAgICAvLyBcImlubmVyIGVkZ2VcIiA9IGEgZmVhdHVyZSdzIGxhdGl0dWRlIGNsb3Nlc3QgdG8gdGhlIGVxdWF0b3JcbiAgICAgICAgbGV0IG5vcnRoSW5uZXJFZGdlID0gZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLkxBVF9NSU47XG4gICAgICAgIGxldCBzb3V0aElubmVyRWRnZSA9IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5MQVRfTUFYO1xuICAgICAgICAvLyBcIm91dGVyIGVkZ2VcIiA9IGEgZmVhdHVyZSdzIGxhdGl0dWRlIGZ1cnRoZXN0IGZyb20gdGhlIGVxdWF0b3JcbiAgICAgICAgbGV0IG5vcnRoT3V0ZXJFZGdlID0gZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLkxBVF9NSU47XG4gICAgICAgIGxldCBzb3V0aE91dGVyRWRnZSA9IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5MQVRfTUFYO1xuICAgIFxuICAgICAgICBsZXQgd2VzdEVkZ2UgPSBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuTE5HX01BWDtcbiAgICAgICAgbGV0IGVhc3RFZGdlID0gZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLkxOR19NSU47XG4gICAgXG4gICAgICAgIGdlb2pzb25GZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAvL2NvbnN0IGJvdW5kcyA9IGV4dGVudChmZWF0dXJlKTsgTmVlZCB0byBhZGQgVHVyZiBib3VuZHMgaGVyZVxuICAgICAgICAgICAgY29uc3QgZmVhdHVyZVNvdXRoRWRnZSA9IGJvdW5kc1sxXTtcbiAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVOb3J0aEVkZ2UgPSBib3VuZHNbM107XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlV2VzdEVkZ2UgPSBib3VuZHNbMF07XG4gICAgICAgICAgICBjb25zdCBmZWF0dXJlRWFzdEVkZ2UgPSBib3VuZHNbMl07XG4gICAgICAgICAgICBpZiAoZmVhdHVyZVNvdXRoRWRnZSA+IG5vcnRoSW5uZXJFZGdlKSBub3J0aElubmVyRWRnZSA9IGZlYXR1cmVTb3V0aEVkZ2U7XG4gICAgICAgICAgICBpZiAoZmVhdHVyZU5vcnRoRWRnZSA8IHNvdXRoSW5uZXJFZGdlKSBzb3V0aElubmVyRWRnZSA9IGZlYXR1cmVOb3J0aEVkZ2U7XG4gICAgICAgICAgICBpZiAoZmVhdHVyZU5vcnRoRWRnZSA+IG5vcnRoT3V0ZXJFZGdlKSBub3J0aE91dGVyRWRnZSA9IGZlYXR1cmVOb3J0aEVkZ2U7XG4gICAgICAgICAgICBpZiAoZmVhdHVyZVNvdXRoRWRnZSA8IHNvdXRoT3V0ZXJFZGdlKSBzb3V0aE91dGVyRWRnZSA9IGZlYXR1cmVTb3V0aEVkZ2U7XG4gICAgICAgICAgICBpZiAoZmVhdHVyZVdlc3RFZGdlIDwgd2VzdEVkZ2UpIHdlc3RFZGdlID0gZmVhdHVyZVdlc3RFZGdlO1xuICAgICAgICAgICAgaWYgKGZlYXR1cmVFYXN0RWRnZSA+IGVhc3RFZGdlKSBlYXN0RWRnZSA9IGZlYXR1cmVFYXN0RWRnZTtcbiAgICAgICAgfSk7XG4gICAgXG4gICAgXG4gICAgICAgIC8vIFRoZXNlIGNoYW5nZXMgYXJlIG5vdCBtdXR1YWxseSBleGNsdXNpdmU6IHdlIG1pZ2h0IGhpdCB0aGUgaW5uZXJcbiAgICAgICAgLy8gZWRnZSBidXQgYWxzbyBoYXZlIGhpdCB0aGUgb3V0ZXIgZWRnZSBhbmQgdGhlcmVmb3JlIG5lZWRcbiAgICAgICAgLy8gYW5vdGhlciByZWFkanVzdG1lbnRcbiAgICAgICAgY29uc3QgY29uc3RyYWluZWREZWx0YSA9IGRlbHRhO1xuICAgIFxuICAgICAgICBpZiAobm9ydGhJbm5lckVkZ2UgKyBjb25zdHJhaW5lZERlbHRhLmxhdCA+IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5MQVRfUkVOREVSRURfTUFYKSB7XG4gICAgICAgICAgICBjb25zdHJhaW5lZERlbHRhLmxhdCA9IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5MQVRfUkVOREVSRURfTUFYIC0gbm9ydGhJbm5lckVkZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vcnRoT3V0ZXJFZGdlICsgY29uc3RyYWluZWREZWx0YS5sYXQgPiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuTEFUX01BWCkge1xuICAgICAgICAgICAgY29uc3RyYWluZWREZWx0YS5sYXQgPSBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuTEFUX01BWCAtIG5vcnRoT3V0ZXJFZGdlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3V0aElubmVyRWRnZSArIGNvbnN0cmFpbmVkRGVsdGEubGF0IDwgZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLkxBVF9SRU5ERVJFRF9NSU4pIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbmVkRGVsdGEubGF0ID0gZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLkxBVF9SRU5ERVJFRF9NSU4gLSBzb3V0aElubmVyRWRnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc291dGhPdXRlckVkZ2UgKyBjb25zdHJhaW5lZERlbHRhLmxhdCA8IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5MQVRfTUlOKSB7XG4gICAgICAgICAgICBjb25zdHJhaW5lZERlbHRhLmxhdCA9IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5MQVRfTUlOIC0gc291dGhPdXRlckVkZ2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlc3RFZGdlICsgY29uc3RyYWluZWREZWx0YS5sbmcgPD0gZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLkxOR19NSU4pIHtcbiAgICAgICAgICAgIGNvbnN0cmFpbmVkRGVsdGEubG5nICs9IE1hdGguY2VpbChNYXRoLmFicyhjb25zdHJhaW5lZERlbHRhLmxuZykgLyAzNjApICogMzYwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlYXN0RWRnZSArIGNvbnN0cmFpbmVkRGVsdGEubG5nID49IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5MTkdfTUFYKSB7XG4gICAgICAgICAgICBjb25zdHJhaW5lZERlbHRhLmxuZyAtPSBNYXRoLmNlaWwoTWF0aC5hYnMoY29uc3RyYWluZWREZWx0YS5sbmcpIC8gMzYwKSAqIDM2MDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gY29uc3RyYWluZWREZWx0YTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxjdWxhdGVPcmllbnRlZEFuZ2xlUG9seWdvbiAoZmVhdHVyZSkge1xuICAgICAgICB2YXIgZ2VvbWV0cnkgPSBmZWF0dXJlLmdlb21ldHJ5O1xuICAgICAgICB2YXIgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIGNvbnN0IGNvb3JkVHlwZSA9IGdlb21ldHJ5LnR5cGU7XG4gICAgICAgIGNvb3JkcyA9IGNvb3JkVHlwZSA9PT0gJ0xpbmVzdHJpbmcnID8gY29vcmRzIDogY29vcmRzWzBdO1xuICAgIFxuICAgICAgICBjb25zdCBwWFkwID0gY29vcmRzWzBdO1xuICAgICAgICBjb25zdCBwWFkwXzM4NTcgPSBnZW9mbG8uVXRpbGl0aWVzLmRlZ3JlZXMybWV0ZXJzKHBYWTApO1xuICAgICAgICBjb25zdCBwWFkxID0gY29vcmRzWzFdO1xuICAgICAgICBjb25zdCBwWFkxXzM4NTcgPSBnZW9mbG8uVXRpbGl0aWVzLmRlZ3JlZXMybWV0ZXJzKHBYWTEpO1xuICAgICAgICBjb25zdCBhbmdsZVN0ZEdyYXVzID0gTWF0aC5hdGFuMihwWFkxXzM4NTdbMV0gLSBwWFkwXzM4NTdbMV0sIHBYWTFfMzg1N1swXSAtIHBYWTBfMzg1N1swXSkgKiAxODAgLyBNYXRoLlBJO1xuICAgIFxuICAgICAgICBsZXQgYW5nbGVTdWRHcmF1cyA9IC0xLjAgKiAoYW5nbGVTdGRHcmF1cyArIDkwKTtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBhbmdsZVN1ZEdyYXVzIDwgMCA/IGFuZ2xlU3VkR3JhdXMgKyAzNjAgOiBhbmdsZVN1ZEdyYXVzO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCgoYW5nbGUpLnRvRml4ZWQoMikpO1xuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IERyYXc7IiwiY29uc3QgZXZlbnRzID0gW1xuICAgICdtYXAuZW5hYmxlJyxcbiAgICAnbWFwLmRpc2FibGUnLFxuICAgICdtYXAucmVhZHknLFxuICAgICdtYXAucmVkcmF3JyxcbiAgICAnbWFwLnJlZnJlc2gnLFxuICAgICdtb2RlLmNoYW5nZScsXG4gICAgJ3RoZW1lLmNoYW5nZScsXG4gICAgJ3NvdXJjZXMuYWRkJyxcbiAgICAnc291cmNlLmFkZCcsXG4gICAgJ3NvdXJjZS5ob3QnLFxuICAgICdsYXllcnMuYWRkJyxcbiAgICAnbGF5ZXJzLnJlbW92ZScsXG4gICAgJ2xheWVyLmFkZCcsXG4gICAgJ2NvbnRyb2wuYWRkJyxcbiAgICAnY29udHJvbC5yZW1vdmUnLFxuICAgICdmZWF0dXJlcy56b29tJyxcbiAgICAnZmVhdHVyZXMuYWRkJyxcbiAgICAnZmVhdHVyZXMuZGVsZXRlJyxcbiAgICAnZmVhdHVyZXMudXBkYXRlJyxcbiAgICAnZmVhdHVyZXMuaW1wb3J0JyxcbiAgICAnZmVhdHVyZXMuZXhwb3J0JyxcbiAgICAnZmVhdHVyZXMub2Zmc2V0JyxcbiAgICAnZmVhdHVyZS5hZGQnLFxuICAgICdmZWF0dXJlLmRlbGV0ZScsXG4gICAgJ2ZlYXR1cmUuc2VsZWN0JyxcbiAgICAnZmVhdHVyZS5kZXNlbGVjdCcsXG4gICAgJ2ZlYXR1cmUudXBkYXRlJyxcbiAgICAnZmVhdHVyZS5oaXN0b3J5JyxcbiAgICAnc2VsZWN0LmxvYWQnLFxuICAgICdzZWxlY3QuYWRkJyxcbiAgICAnc2VsZWN0LnJlbW92ZScsXG4gICAgJ3NlbGVjdC5hY3RpdmF0ZScsXG4gICAgJ3NlbGVjdC5kZWFjdGl2YXRlJyxcbiAgICAnZHJhdy5hY3RpdmF0ZScsXG4gICAgJ2RyYXcuZGVhY3RpdmF0ZScsXG4gICAgJ2RyYXcuc3RhcnQnLFxuICAgICdkcmF3LmZpbmlzaCcsXG4gICAgJ2RyYXcuY2FuY2VsJyxcbiAgICAnbWVzaC5sb2FkJyxcbiAgICAndGV4dC5hZGQnLFxuICAgICdpY29uLmFkZCcsXG4gICAgJ3ZlcnRleC5maW5kJyxcbiAgICAndmVydGV4Lm9uJyxcbiAgICAndmVydGV4Lm9mZicsXG4gICAgJ3ZlcnRleC5hZGQnLFxuICAgICd2ZXJ0ZXguZHJhZycsXG4gICAgJ3ZlcnRleC5kcmFnc25hcCcsXG4gICAgJ3ZlcnRleC5kZWxldGUnLFxuICAgICdvdmVycGFzcy5hZGQnLFxuICAgICdzbmFwcGluZy5hY3RpdmF0ZScsXG4gICAgJ3NuYXBwaW5nLmRlYWN0aXZhdGUnLFxuICAgICdzbmFwcGluZy5hZGQnLFxuICAgICdzbmFwcGluZy5yZWZyZXNoJyxcbiAgICAnc25hcHBpbmcuZGVsZXRlJyxcbiAgICAncGlubmluZy5hY3RpdmF0ZScsXG4gICAgJ3Bpbm5pbmcuZGVhY3RpdmF0ZScsXG4gICAgJ3Bpbm5pbmcuYWRkJyxcbiAgICAncGlubmluZy51cGRhdGUnLFxuICAgICdyb3V0aW5nLmFjdGl2YXRlJyxcbiAgICAncm91dGluZy5kZWFjdGl2YXRlJyxcbiAgICAncm91dGluZy5hZGQnLFxuICAgICdwYWludGluZy5hY3RpdmF0ZScsXG4gICAgJ3BhaW50aW5nLmRlYWN0aXZhdGUnLFxuICAgICdwYWludGluZy5zdGFydCcsXG4gICAgJ3BhaW50aW5nLnVwZGF0ZScsXG4gICAgJ2dhbWVwYWQuaW5pdCcsXG4gICAgJ2dhbWVwYWQuYWRkJyxcbiAgICAnZ2FtZXBhZC5yZW1vdmUnLFxuICAgICdnYW1lcGFkLmhvbGQnLFxuICAgICdnYW1lcGFkLnByZXNzJyxcbiAgICAnZ2FtZXBhZC5yZWxlYXNlJyxcbiAgICAnZ2FtZXBhZC5jb25uZWN0JyxcbiAgICAnZ2FtZXBhZC5kaXNjb25uZWN0JyxcbiAgICAnbG9jYXRlLm9uJyxcbiAgICAnbG9jYXRlLm9mZicsXG4gICAgJ2xvY2F0ZS51cGRhdGUnXG5dXG5cbi8qKlxuICogQG1peGluXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsb1xuICogQG5hbWUgRXZlbnRzXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBtb2R1bGUgaGFuZGxlcyB2YXJpb3VzIG1hcCBhbmQgdXNlciBpbnRlcmFjdGlvbiBldmVudHMgZm9yIHRoZSBnZW9mbG8gYXBwbGljYXRpb24uXG4gKiBAcGFyYW0ge09iamVjdH0gZ2VvZmxvIC0gVGhlIGdlb2ZsbyBpbnN0YW5jZSB0byB3aGljaCB0aGUgZXZlbnRzIGFyZSBib3VuZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIG1ldGhvZHMgdG8gYWRkIGFuZCByZW1vdmUgZXZlbnQgbGlzdGVuZXJzLlxuICogQGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzIC0gQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gdGhlIG1hcCBhbmQgb3RoZXIgZWxlbWVudHMuXG4gKiBAZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgLSBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBtYXAgYW5kIG90aGVyIGVsZW1lbnRzLlxuICovXG5cbmNvbnN0IEV2ZW50cyA9IGZ1bmN0aW9uIChnZW9mbG8pIHtcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FdmVudHNcbiAgICAgKiBAbmFtZSBtYXBNb3ZlU3RhcnRcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgYG1vdmVzdGFydGAgZXZlbnQgb24gdGhlIG1hcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgbWFwIG1vdmVtZW50IGRldGFpbHMuXG4gICAgICovXG4gICAgY29uc3QgbWFwTW92ZVN0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGdlb2Zsby5tYXBNb3ZpbmcgPSBldmVudDtcbiAgICAgICAgaWYgKGdlb2Zsby5zZXR0aW5nRXh0ZW50KSByZXR1cm47XG4gICAgICAgIGlmIChnZW9mbG8ubG9jYXRlKSBnZW9mbG8ubG9jYXRlLm9uTWFwTW92ZShldmVudCk7XG4gICAgICAgIGdlb2Zsby5zZXRJY29uKGV2ZW50KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQG5hbWUgbWFwTW92aW5nXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGBtb3ZlYCBldmVudCBvbiB0aGUgbWFwLCB1cGRhdGluZyBpY29ucyBhbmQgdHJhY2tpbmcgbW92ZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBtYXAgbW92ZW1lbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb25zdCBtYXBNb3ZpbmcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZ2VvZmxvLm1hcE1vdmluZyA9IGV2ZW50O1xuICAgICAgICBpZiAoZ2VvZmxvLnNldHRpbmdFeHRlbnQpIHJldHVybjtcbiAgICAgICAgZ2VvZmxvLnNldEljb24oZXZlbnQpO1xuICAgICAgICBnZW9mbG8uc2V0Q2VudGVyTWFya2VyKCk7XG4gICAgICAgIGdlb2Zsby5sb2NhdGUgJiYgZ2VvZmxvLmxvY2F0ZS5mb2xsb3dpbmcgPyBnZW9mbG8uc2V0TWFwQ2xhc3MoJ2Rpc2FibGUnKSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FdmVudHNcbiAgICAgKiBAbmFtZSBtYXBNb3ZlRW5kXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGBtb3ZlZW5kYCBldmVudCBvbiB0aGUgbWFwLCB1cGRhdGluZyBpY29ucyBhbmQgdHJhY2tpbmcgbW92ZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBtYXAgbW92ZW1lbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb25zdCBtYXBNb3ZlRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGdlb2Zsby5tYXBNb3ZpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKGdlb2Zsby5zZXR0aW5nRXh0ZW50KSByZXR1cm47XG4gICAgICAgIGdlb2Zsby5vbk1hcE1vdmUoZXZlbnQpO1xuICAgICAgICBpZiAoZ2VvZmxvLmxvY2F0ZSkgZ2VvZmxvLmxvY2F0ZS5vbk1hcE1vdmUoZXZlbnQpO1xuICAgICAgICBnZW9mbG8uc2V0SWNvbihldmVudCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkV2ZW50c1xuICAgICAqIEBuYW1lIG1vdXNlTW92ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBgbW91c2Vtb3ZlYCBldmVudCBvbiB0aGUgbWFwLCB1cGRhdGluZyBpY29ucyBhbmQgdHJhY2tpbmcgbW92ZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBtb3VzZSBtb3ZlbWVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIGNvbnN0IG1vdXNlTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgcGFpbnRpbmcgPSBnZW9mbG8ub3B0aW9ucy5wYWludGluZyAmJiBnZW9mbG8ub3B0aW9ucy5wYWludGluZy5lbmFibGU7XG4gICAgICAgIHBhaW50aW5nID0gcGFpbnRpbmcgJiYgZ2VvZmxvLmN1cnJlbnRNb2RlICYmIGdlb2Zsby5jdXJyZW50TW9kZS5pZCA9PT0gJ2RyYXcnO1xuICAgICAgICBcbiAgICAgICAgZ2VvZmxvLmxvY2F0ZSAmJiBnZW9mbG8ubG9jYXRlLmZvbGxvd2luZyA/IGdlb2Zsby5zZXRNYXBDbGFzcygnZGlzYWJsZScpIDpcbiAgICAgICAgZ2VvZmxvLmRyYWdNb3ZpbmcgPyBnZW9mbG8uc2V0TWFwQ2xhc3MoJ2dyYWJiaW5nJykgOlxuICAgICAgICBnZW9mbG8uYWRkaW5nVmVydGV4T25MaW5lIHx8IGdlb2Zsby5jYW5BZGRWZXJ0ZXggPyBnZW9mbG8uc2V0TWFwQ2xhc3MoJ3BvaW50ZXInKSA6XG4gICAgICAgIGdlb2Zsby5jYW5EcmFnTW92ZSA/IGdlb2Zsby5zZXRNYXBDbGFzcygnZ3JhYicpIDpcbiAgICAgICAgcGFpbnRpbmc/IGdlb2Zsby5zZXRNYXBDbGFzcygncGFpbnRpbmcnKSA6XG4gICAgICAgIGdlb2Zsby5zZXRNYXBDbGFzcygncG9pbnRlcicpO1xuXG4gICAgICAgIGdlb2Zsby5sYXN0TW91c2VFdmVudCA9IGV2ZW50O1xuICAgICAgICBpZiAoIWdlb2Zsby5jdXJyZW50TW9kZSkgcmV0dXJuO1xuICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlTW92ZSA/IGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVNb3ZlKGV2ZW50KSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FdmVudHNcbiAgICAgKiBAbmFtZSBtb3VzZURvd25cbiAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgYG1vdXNlZG93bmAgZXZlbnQgb24gdGhlIG1hcCwgdXBkYXRpbmcgaWNvbnMgYW5kIHRyYWNraW5nIG1vdmVtZW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgbW91c2UgbW92ZW1lbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb25zdCBtb3VzZURvd24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHBhaW50aW5nID0gZ2VvZmxvLm9wdGlvbnMucGFpbnRpbmcgJiYgZ2VvZmxvLm9wdGlvbnMucGFpbnRpbmcuZW5hYmxlO1xuICAgICAgICBwYWludGluZyA9IHBhaW50aW5nICYmIGdlb2Zsby5jdXJyZW50TW9kZSAmJiBnZW9mbG8uY3VycmVudE1vZGUuaWQgPT09ICdkcmF3JztcbiAgICAgICAgXG4gICAgICAgIGdlb2Zsby5sb2NhdGUgJiYgZ2VvZmxvLmxvY2F0ZS5mb2xsb3dpbmcgPyBnZW9mbG8uc2V0TWFwQ2xhc3MoJ2Rpc2FibGUnKSA6XG4gICAgICAgIHBhaW50aW5nPyBnZW9mbG8uc2V0TWFwQ2xhc3MoJ3BhaW50aW5nJykgOlxuICAgICAgICBnZW9mbG8uZHJhZ01vdmluZyA/IGdlb2Zsby5zZXRNYXBDbGFzcygnZ3JhYmJpbmcnKSA6XG4gICAgICAgIGdlb2Zsby5hZGRpbmdWZXJ0ZXhPbkxpbmUgPyBnZW9mbG8uc2V0TWFwQ2xhc3MoJ2dyYWJiaW5nJykgOlxuICAgICAgICBnZW9mbG8uY2FuRHJhZ01vdmUgPyBnZW9mbG8uc2V0TWFwQ2xhc3MoJ2dyYWInKSA6XG4gICAgICAgIGdlb2Zsby5sYXN0Q2xpY2sgPyBnZW9mbG8uc2V0TWFwQ2xhc3MoJ2dyYWJiaW5nJykgOlxuICAgICAgICBnZW9mbG8uc2V0TWFwQ2xhc3MoJ3BvaW50ZXInKTtcbiAgICAgICAgXG4gICAgICAgIGdlb2Zsby5tb3VzZUlzRG93biA9IFtldmVudC5sbmdMYXQubG5nLCBldmVudC5sbmdMYXQubGF0XTtcbiAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZURvd24gPyBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlRG93bihldmVudCkgOiBmYWxzZTtcbiAgICB9OyAgICBcbiAgICBcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FdmVudHNcbiAgICAgKiBAbmFtZSBtb3VzZVVwXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGBtb3VzZXVwYCBldmVudCBvbiB0aGUgbWFwLCB1cGRhdGluZyBpY29ucyBhbmQgdHJhY2tpbmcgbW92ZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBtb3VzZSBtb3ZlbWVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIGNvbnN0IG1vdXNlVXAgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZ2VvZmxvLm1vdXNlSXNEb3duID0gZmFsc2U7XG4gICAgICAgIGdlb2Zsby5sb2NhdGUgJiYgZ2VvZmxvLmxvY2F0ZS5mb2xsb3dpbmcgPyBnZW9mbG8uc2V0TWFwQ2xhc3MoJ2Rpc2FibGUnKSA6IGdlb2Zsby5zZXRNYXBDbGFzcygncG9pbnRlcicpO1xuICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlVXAgPyBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlVXAoZXZlbnQpIDogZmFsc2U7XG4gICAgfTtcblxuICAgIFxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkV2ZW50c1xuICAgICAqIEBuYW1lIG1vdXNlQ2xpY2tcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgYGNsaWNrYCBldmVudCBvbiB0aGUgbWFwLCB1cGRhdGluZyBpY29ucyBhbmQgdHJhY2tpbmcgbW92ZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBtb3VzZSBtb3ZlbWVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIGNvbnN0IG1vdXNlQ2xpY2sgPSBhc3luYyBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUuaW5jbHVkZXMoJ3ByZWNsaWNrJykpIHJldHVybiBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlUHJlY2xpY2sgPyBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlUHJlY2xpY2soZXZlbnQpIDogZmFsc2U7XG4gICAgICAgIGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVDbGljayA/IGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVDbGljayhldmVudCkgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQG5hbWUgbW91c2VEcmFnXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGBkcmFnYCBldmVudCBvbiB0aGUgbWFwLCB1cGRhdGluZyBpY29ucyBhbmQgdHJhY2tpbmcgbW92ZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBtb3VzZSBtb3ZlbWVudCBkZXRhaWxzLlxuICAgICAqL1xuICAgIGNvbnN0IG1vdXNlRHJhZyA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBnZW9mbG8ubG9jYXRlICYmIGdlb2Zsby5sb2NhdGUuZm9sbG93aW5nID8gZ2VvZmxvLnNldE1hcENsYXNzKCdkaXNhYmxlJykgOlxuICAgICAgICBnZW9mbG8uZHJhZ01vdmluZyA/IGdlb2Zsby5zZXRNYXBDbGFzcygnZ3JhYmJpbmcnKSA6XG4gICAgICAgIGdlb2Zsby5jYW5EcmFnTW92ZSA/IGdlb2Zsby5zZXRNYXBDbGFzcygnZ3JhYicpIDpcbiAgICAgICAgZ2VvZmxvLnNldE1hcENsYXNzKCdtb3ZlJyk7XG5cbiAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZURyYWcgPyBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlRHJhZyhldmVudCkgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQG5hbWUgbW91c2VsZWF2ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBgbW91c2VsZWF2ZWAgZXZlbnQgb24gdGhlIG1hcCwgdXBkYXRpbmcgaWNvbnMgYW5kIHRyYWNraW5nIG1vdmVtZW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgbW91c2UgbW92ZW1lbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb25zdCBtb3VzZWxlYXZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVPZmZNYXAgPyBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlT2ZmTWFwKGV2ZW50KSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FdmVudHNcbiAgICAgKiBAbmFtZSBtb3VzZW92ZXJcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgYG1vdXNlb3ZlcmAgZXZlbnQgb24gdGhlIG1hcCwgdXBkYXRpbmcgaWNvbnMgYW5kIHRyYWNraW5nIG1vdmVtZW50cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgbW91c2UgbW92ZW1lbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICBjb25zdCBtb3VzZW92ZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZU9uTWFwID8gZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZU9uTWFwKGV2ZW50KSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FdmVudHNcbiAgICAgKiBAbmFtZSBrZXlwcmVzc1xuICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBga2V5cHJlc3NgIGV2ZW50IG9uIHRoZSBtYXAsIHVwZGF0aW5nIGljb25zIGFuZCB0cmFja2luZyBtb3ZlbWVudHMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGtleXByZXNzIGRldGFpbHMuXG4gICAgICovXG4gICAgY29uc3Qga2V5cHJlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGdlb2Zsby50ZXh0TWFya2VyKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBjb25zb2xlLmxvZyhcImtleWNvZGU6IFwiLCBldmVudC5rZXlDb2RlLCBcIiA9PlwiLCBldmVudC5rZXksIFwiIHwgQ29kZTpcIiwgZXZlbnQuY29kZSwgXCIgRXZlbnQ6XCIsIGV2ZW50KTtcbiAgICAgICAgY29uc3QgYnV0dG9uT3B0aW9ucyA9IGdlb2Zsby5nZXRCdXR0b25zKCk7XG5cbiAgICAgICAgbGV0IGtleUhhbmRsZWQgPSBmYWxzZTtcblxuICAgICAgICBPYmplY3Qua2V5cyhidXR0b25PcHRpb25zKS5mb3JFYWNoKChidXR0b25JZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gYnV0dG9uT3B0aW9uc1tidXR0b25JZF07XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBnZW9mbG8ub3B0aW9ucy5rZXlzW2J1dHRvbklkXTtcblxuICAgICAgICAgICAgaWYgKGtleSA9PT0gZXZlbnQua2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLmJ1dHRvbi5jbGljaygpO1xuICAgICAgICAgICAgICAgIGtleUhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IGV2ZW50LmtleUNvZGUpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uYnV0dG9uLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAga2V5SGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9wdGlvbi5rZXljb2RlICYmIG9wdGlvbi5rZXljb2RlID09PSBldmVudC5rZXlDb2RlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uLmJ1dHRvbi5jbGljaygpO1xuICAgICAgICAgICAgICAgIGtleUhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoZ2VvZmxvLm9wdGlvbnMuY29tbWFuZHMpIHtcbiAgICAgICAgICAgIGdlb2Zsby5vcHRpb25zLmNvbW1hbmRzLmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5rZXkgPT09IGV2ZW50LmtleUNvZGUgfHwgYy5rZXkgPT09IGV2ZW50LmtleSB8fCBjLmtleSA9PT0gZXZlbnQuY29kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWMuY29tbWFuZCB8fCB0eXBlb2YgYy5jb21tYW5kICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIGMuY29tbWFuZChldmVudCwgZ2VvZmxvLCBjKTtcbiAgICAgICAgICAgICAgICAgICAga2V5SGFuZGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChrZXlIYW5kbGVkKSByZXR1cm4ga2V5SGFuZGxlZDtcblxuICAgICAgICBpZiAoZXZlbnQua2V5LmluY2x1ZGVzKCdBcnJvdycpKSB7fVxuXG4gICAgICAgIGdlb2Zsby5jdXJyZW50S2V5UHJlc3MgPSBldmVudC5rZXk7XG5cbiAgICAgICAgc3dpdGNoIChldmVudC5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwiRW50ZXJcIjoge1xuICAgICAgICAgICAgICAgIGdlb2Zsby5zZXRNb2RlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiTnVtcGFkRW50ZXJcIjoge1xuICAgICAgICAgICAgICAgIGdlb2Zsby5zZXRNb2RlKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiRXNjYXBlXCI6IHtcbiAgICAgICAgICAgICAgICBnZW9mbG8uaG90RmVhdHVyZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgZ2VvZmxvLnNldE1vZGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJIb21lXCI6IHtcbiAgICAgICAgICAgICAgICBnZW9mbG8ubW92ZVNlbGVjdGVkRmVhdHVyZXMoMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiRW5kXCI6IHtcbiAgICAgICAgICAgICAgICBnZW9mbG8ubW92ZVNlbGVjdGVkRmVhdHVyZXMoLTEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIkRlbGV0ZVwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKGdlb2Zsby5tb2RlID09PSBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMubW9kZXMuU0VMRUNUKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZW9mbG8uaGFzU2VsZWN0aW9uKCkpIHsgZ2VvZmxvLnJlbW92ZVNlbGVjdGlvbigpOyB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9mbG8ubW9kZSA9PT0gZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLm1vZGVzLkRSQVcpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmRlbGV0ZVZlcnRleCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FdmVudHNcbiAgICAgKiBAbmFtZSBrZXlyZWxlYXNlXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGBrZXlyZWxlYXNlYCBldmVudCBvbiB0aGUgbWFwLCB1cGRhdGluZyBpY29ucyBhbmQgdHJhY2tpbmcgbW92ZW1lbnRzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBrZXlwcmVzcyBkZXRhaWxzLlxuICAgICAqL1xuICAgIGNvbnN0IGtleXJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJrZXlyZWxlYXNlOiBcIiwgZXZlbnQpO1xuICAgICAgICBnZW9mbG8uY3VycmVudEtleVByZXNzID0gZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkV2ZW50c1xuICAgICAqIEBuYW1lIHRvdWNoc3RhcnRcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgdG91Y2hzdGFydCBldmVudCBieSBkZWxlZ2F0aW5nIHRvIHRoZSBjdXJyZW50IG1vZGUncyBoYW5kbGVUb3VjaCBtZXRob2QgaWYgaXQgZXhpc3RzLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHRvdWNoc3RhcnQgZXZlbnQgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0IHRvdWNoc3RhcnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZVRvdWNoID8gZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZVRvdWNoKGV2ZW50KSA6IGZhbHNlO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSB0b3VjaGVuZFxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkV2ZW50c1xuICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSB0b3VjaGVuZCBldmVudCBieSBpbnZva2luZyB0aGUgaGFuZGxlVG91Y2ggbWV0aG9kIG9mIHRoZSBjdXJyZW50IG1vZGUgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgdG91Y2hlbmQgZXZlbnQgb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIHRoZSBoYW5kbGVUb3VjaCBtZXRob2QgZG9lcyBub3QgZXhpc3Q7IG90aGVyd2lzZSwgaXQgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICovXG4gICAgY29uc3QgdG91Y2hlbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZVRvdWNoID8gZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZVRvdWNoKGV2ZW50KSA6IGZhbHNlO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgdG91Y2htb3ZlXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIHRvdWNobW92ZSBldmVudCBieSBpbnZva2luZyB0aGUgaGFuZGxlVG91Y2ggbWV0aG9kIG9mIHRoZSBjdXJyZW50IG1vZGUgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgdG91Y2htb3ZlIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiB0aGUgaGFuZGxlVG91Y2ggbWV0aG9kIGRvZXMgbm90IGV4aXN0LlxuICAgICAqL1xuICAgIGNvbnN0IHRvdWNobW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlVG91Y2ggPyBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlVG91Y2goZXZlbnQpIDogZmFsc2U7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIHRvdWNoY2FuY2VsXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIHRvdWNoIGNhbmNlbCBldmVudCBieSBpbnZva2luZyB0aGUgaGFuZGxlVG91Y2ggbWV0aG9kIG9mIHRoZSBjdXJyZW50IG1vZGUgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgdG91Y2ggY2FuY2VsIGV2ZW50IG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiB0aGUgaGFuZGxlVG91Y2ggbWV0aG9kIGRvZXMgbm90IGV4aXN0OyBvdGhlcndpc2UsIGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiB0aGUgaGFuZGxlVG91Y2ggbWV0aG9kLlxuICAgICAqL1xuICAgIGNvbnN0IHRvdWNoY2FuY2VsID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVUb3VjaCA/IGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVUb3VjaChldmVudCkgOiBmYWxzZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgZ2FtZXBhZGNvbm5lY3RlZFxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkV2ZW50c1xuICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBldmVudCB3aGVuIGEgZ2FtZXBhZCBpcyBjb25uZWN0ZWQgYW5kIGFkZHMgaXQgdG8gdGhlIGdlb2ZsbyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjb25uZWN0ZWQgZ2FtZXBhZC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgKi9cbiAgICBjb25zdCBnYW1lcGFkY29ubmVjdGVkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGdlb2Zsby5hZGRHYW1lcGFkKGV2ZW50LmdhbWVwYWQgfHwgZXZlbnQuZGV0YWlsLmdhbWVwYWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBnYW1lcGFkZGlzY29ubmVjdGVkXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGV2ZW50IHdoZW4gYSBnYW1lcGFkIGlzIGRpc2Nvbm5lY3RlZCBhbmQgcmVtb3ZlcyBpdCBmcm9tIHRoZSBnZW9mbG8gc3lzdGVtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGRpc2Nvbm5lY3RlZCBnYW1lcGFkLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAqL1xuICAgIGNvbnN0IGdhbWVwYWRkaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZ2VvZmxvLnJlbW92ZUdhbWVwYWQoZXZlbnQuZ2FtZXBhZCB8fCBldmVudC5kZXRhaWwuZ2FtZXBhZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIGhhbmRsZU9yaWVudGF0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSBnZW9mbG8gb2JqZWN0IGJhc2VkIG9uIHRoZSBkZXZpY2UncyBvcmllbnRhdGlvbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIG9yaWVudGF0aW9uIGV2ZW50IGNvbnRhaW5pbmcgYWxwaGEsIGJldGEsIGFuZCBnYW1tYSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge3ZvaWR9IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICovXG4gICAgY29uc3QgaGFuZGxlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZ2VvZmxvLnVwZGF0ZU9yaWVudGF0aW9uKHtcbiAgICAgICAgICAgIGFscGhhOiBldmVudC5hbHBoYSxcbiAgICAgICAgICAgIGJldGE6IGV2ZW50LmJldGEsXG4gICAgICAgICAgICBnYW1tYTogZXZlbnQuZ2FtbWFcbiAgICAgICAgfSlcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgZHJhZ1N0YXJ0XG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGRyYWcgc3RhcnQgZXZlbnQgZm9yIGFuIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkcmFnIHN0YXJ0IGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAqL1xuICAgIGNvbnN0IGRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAvL2lmIChnZW9mbG8ubG9jYXRlICYmIGdlb2Zsby5sb2NhdGUuZm9sbG93aW5nKSByZXR1cm4gZXZlbnQub3JpZ2luYWxFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSByb3RhdGVQaXRjaFxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkV2ZW50c1xuICAgICAqIEBkZXNjcmlwdGlvbiBBZGp1c3RzIHRoZSBtYXAncyBwaXRjaCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZXZlbnQsIHNldHRpbmcgdGhlIG1hcCBjbGFzcyB0byAnZ3JhYmJpbmcnLCB1cGRhdGluZyB0aGUgaWNvbiwgYW5kIHJlcG9zaXRpb25pbmcgdGhlIGNlbnRlciBtYXJrZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGludGVyYWN0aW9uLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAqL1xuICAgIGNvbnN0IHJvdGF0ZVBpdGNoID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGdlb2Zsby5zZXRNYXBDbGFzcygnZ3JhYmJpbmcnKTtcbiAgICAgICAgZ2VvZmxvLnNldEljb24oZXZlbnQpO1xuICAgICAgICBnZW9mbG8uc2V0Q2VudGVyTWFya2VyKHsgdHJhbnNmb3JtOiB0cnVlIH0pO1xuICAgIH07XG5cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgZmlyZUV2ZW50XG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIFRyaWdnZXJzIGEgY3VzdG9tIGV2ZW50IG9uIHRoZSBnZW9mbG8gbWFwIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBldmVudCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIHdoaWNoIGluY2x1ZGVzIHRoZSBhY3Rpb24gYW5kIHRhcmdldCBpbmZvcm1hdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZGV0YWlsIC0gQWRkaXRpb25hbCBkZXRhaWxzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICogQHJldHVybnMge3ZvaWR9IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICovXG4gICAgY29uc3QgZmlyZUV2ZW50ID0gZnVuY3Rpb24gZmlyZUV2ZW50IChldmVudCkge1xuICAgICAgICBjb25zdCBuYW1lID0gZXZlbnQudHlwZS5zcGxpdCgnOicpWzFdO1xuICAgICAgICBcbiAgICAgICAgY29uc3QgZGV0YWlsID0ge1xuICAgICAgICAgICAgZGF0YTogZXZlbnQuZGV0YWlsLFxuICAgICAgICAgICAgdHlwZTogbmFtZS5zcGxpdCgnLicpWzBdLFxuICAgICAgICAgICAgYWN0aW9uOiBuYW1lLnNwbGl0KCcuJylbMV0sXG4gICAgICAgICAgICB0YXJnZXQ6IGdlb2ZsbyxcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSB7IG5hbWU6IG5hbWUsIGRldGFpbDogZGV0YWlsIH07XG4gICAgICAgIGdlb2Zsby5tYXAuZmlyZShnZW9mbG8uaWQsIGRldGFpbHMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIGNvbnRleHRNZW51XG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGNvbnRleHQgbWVudSBldmVudCBieSBpbnZva2luZyB0aGUgY3VycmVudCBtb2RlJ3MgY29udGV4dCBoYW5kbGluZyBmdW5jdGlvbiBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBjb250ZXh0IG1lbnUgZXZlbnQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgdGhlIGN1cnJlbnQgbW9kZSBkb2VzIG5vdCBoYXZlIGEgY29udGV4dCBoYW5kbGVyLlxuICAgICAqL1xuICAgIGNvbnN0IGNvbnRleHRNZW51ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVDb250ZXh0ID8gZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZUNvbnRleHQoZXZlbnQpIDogZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgc291cmNlRGF0YVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkV2ZW50c1xuICAgICAqIEBkZXNjcmlwdGlvbiBQcm9jZXNzZXMgdGhlIHNvdXJjZSBkYXRhIGZyb20gYW4gZXZlbnQgYW5kIHRyaWdnZXJzIGFuIGFjdGlvbiBiYXNlZCBvbiB0aGUgc291cmNlIElELlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIHNvdXJjZSBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5zb3VyY2VEYXRhVHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBzb3VyY2UgZGF0YS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQuc291cmNlSWQgLSBUaGUgSUQgb2YgdGhlIHNvdXJjZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuc291cmNlIC0gVGhlIHNvdXJjZSBvYmplY3QgY29udGFpbmluZyBkYXRhLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIHRoZSBzb3VyY2UgZGF0YSB0eXBlIGlzIGludmFsaWQgb3IgaWYgdGhlIHNvdXJjZSBJRCBpcyBub3QgcHJlc2VudDsgb3RoZXJ3aXNlLCBpdCB0cmlnZ2VycyBhbiBldmVudCBiYXNlZCBvbiB0aGUgc291cmNlIElELlxuICAgICAqL1xuICAgIGNvbnN0IHNvdXJjZURhdGEgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudC5zb3VyY2VEYXRhVHlwZSB8fCAhZXZlbnQuc291cmNlRGF0YVR5cGUgPT09ICdjb250ZW50JyB8fCAhZXZlbnQuc291cmNlSWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaWQgPSBldmVudC5zb3VyY2VJZDtcblxuICAgICAgICBjb25zdCBkZXRhaWwgPSB7XG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBkYXRhOiBldmVudC5zb3VyY2UuZGF0YSxcbiAgICAgICAgICAgIHR5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICB0YXJnZXQ6IGdlb2ZsbyxcbiAgICAgICAgfVxuXG4gICAgICAgIGlkID09PSBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5IT1QgPyBnZW9mbG8uZmlyZSgnc291cmNlLmhvdCcsIGRldGFpbCkgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIGFkZEV2ZW50TGlzdGVuZXJzXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXZlbnRzXG4gICAgICogQGRlc2NyaXB0aW9uIEF0dGFjaGVzIHZhcmlvdXMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBtYXAgYW5kIGNvbnRhaW5lciBmb3IgaGFuZGxpbmcgdXNlciBpbnRlcmFjdGlvbnMgYW5kIG1hcCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRFdmVudExpc3RlbmVycyAoKSB7XG4gICAgICAgIGdlb2Zsby5tYXAub24oXCJtb3Zlc3RhcnRcIiwgbWFwTW92ZVN0YXJ0KTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vbihcIm1vdmVcIiwgbWFwTW92aW5nKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vbihcIm1vdmVlbmRcIiwgbWFwTW92ZUVuZCk7XG4gICAgICAgIGdlb2Zsby5tYXAub24oXCJtb3VzZW1vdmVcIiwgbW91c2VNb3ZlKTtcblxuICAgICAgICBnZW9mbG8ubWFwLm9uKCdwcmVjbGljaycsIG1vdXNlQ2xpY2spO1xuICAgICAgICBnZW9mbG8ubWFwLm9uKCdjbGljaycsIG1vdXNlQ2xpY2spO1xuICAgICAgICBnZW9mbG8ubWFwLm9uKCd0YXAnLCBtb3VzZUNsaWNrKTtcblxuICAgICAgICBnZW9mbG8ubWFwLm9uKCdkcmFnc3RhcnQnLCBkcmFnU3RhcnQpO1xuICAgICAgICBnZW9mbG8ubWFwLm9uKCdkcmFnJywgbW91c2VEcmFnKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vbignbW91c2Vkb3duJywgbW91c2VEb3duKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vbignbW91c2V1cCcsIG1vdXNlVXApO1xuXG4gICAgICAgIGdlb2Zsby5tYXAub24oJ3JvdGF0ZXN0YXJ0Jywgcm90YXRlUGl0Y2gpO1xuICAgICAgICBnZW9mbG8ubWFwLm9uKCdwaXRjaHN0YXJ0Jywgcm90YXRlUGl0Y2gpO1xuICAgICAgICBnZW9mbG8ubWFwLm9uKCdyb3RhdGUnLCByb3RhdGVQaXRjaCk7XG4gICAgICAgIGdlb2Zsby5tYXAub24oJ3BpdGNoJywgcm90YXRlUGl0Y2gpO1xuXG4gICAgICAgIGdlb2Zsby5tYXAub24oJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0KTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vbigndG91Y2hlbmQnLCB0b3VjaGVuZCk7XG4gICAgICAgIGdlb2Zsby5tYXAub24oJ3RvdWNobW92ZScsIHRvdWNobW92ZSk7XG4gICAgICAgIGdlb2Zsby5tYXAub24oJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWwpO1xuXG4gICAgICAgIGdlb2Zsby5tYXAub24oJ2NvbnRleHRtZW51JywgY29udGV4dE1lbnUpO1xuICAgICAgICBnZW9mbG8ubWFwLm9uKCdzb3VyY2VkYXRhJywgc291cmNlRGF0YSk7XG5cbiAgICAgICAgZXZlbnRzLmZvckVhY2goZnVuY3Rpb24oZXZlbnQpIHsgZ2VvZmxvLm1hcC5vbihnZW9mbG8uaWQgKyAnOicgKyBldmVudCwgZmlyZUV2ZW50KTsgfSlcblxuICAgICAgICBnZW9mbG8uY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBrZXlwcmVzcyk7XG4gICAgICAgIGdlb2Zsby5jb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcigna2V5dXAnLCBrZXlyZWxlYXNlKTtcbiAgICAgICAgZ2VvZmxvLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBtb3VzZW92ZXIpO1xuICAgICAgICBnZW9mbG8uY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBtb3VzZWxlYXZlKTtcblxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRjb25uZWN0ZWRcIiwgZ2FtZXBhZGNvbm5lY3RlZCk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGRpc2Nvbm5lY3RlZFwiLCBnYW1lcGFkZGlzY29ubmVjdGVkKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCBoYW5kbGVPcmllbnRhdGlvbiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgcmVtb3ZlRXZlbnRMaXN0ZW5lcnNcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FdmVudHNcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyB2YXJpb3VzIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBtYXAgYW5kIGNvbnRhaW5lciB0byBwcmV2ZW50IGZ1cnRoZXIgaW50ZXJhY3Rpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3ZvaWR9IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgKCkge1xuICAgICAgICBnZW9mbG8ubWFwLm9mZihcIm1vdmVzdGFydFwiLCBtYXBNb3ZlU3RhcnQpO1xuICAgICAgICBnZW9mbG8ubWFwLm9mZihcIm1vdmVcIiwgbWFwTW92aW5nKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vZmYoXCJtb3ZlZW5kXCIsIG1hcE1vdmVFbmQpO1xuICAgICAgICBnZW9mbG8ubWFwLm9mZihcIm1vdXNlbW92ZVwiLCBtb3VzZU1vdmUpO1xuXG4gICAgICAgIGdlb2Zsby5tYXAub2ZmKCdwcmVjbGljaycsIG1vdXNlQ2xpY2spO1xuICAgICAgICBnZW9mbG8ubWFwLm9mZignY2xpY2snLCBtb3VzZUNsaWNrKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vZmYoJ3RhcCcsIG1vdXNlQ2xpY2spO1xuXG4gICAgICAgIGdlb2Zsby5tYXAub2ZmKCdkcmFnc3RhcnQnLCBkcmFnU3RhcnQpO1xuICAgICAgICBnZW9mbG8ubWFwLm9mZignZHJhZycsIG1vdXNlRHJhZyk7XG4gICAgICAgIGdlb2Zsby5tYXAub2ZmKCdtb3VzZWRvd24nLCBtb3VzZURvd24pO1xuICAgICAgICBnZW9mbG8ubWFwLm9mZignbW91c2V1cCcsIG1vdXNlVXApO1xuXG4gICAgICAgIGdlb2Zsby5tYXAub2ZmKCdyb3RhdGVzdGFydCcsIHJvdGF0ZVBpdGNoKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vZmYoJ3BpdGNoc3RhcnQnLCByb3RhdGVQaXRjaCk7XG5cbiAgICAgICAgZ2VvZmxvLm1hcC5vZmYoJ3RvdWNoc3RhcnQnLCB0b3VjaHN0YXJ0KTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vZmYoJ3RvdWNoZW5kJywgdG91Y2hlbmQpO1xuICAgICAgICBnZW9mbG8ubWFwLm9mZigndG91Y2htb3ZlJywgdG91Y2htb3ZlKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5vZmYoJ3RvdWNoY2FuY2VsJywgdG91Y2hjYW5jZWwpO1xuICAgICAgICBcbiAgICAgICAgZ2VvZmxvLm1hcC5vZmYoJ2NvbnRleHRtZW51JywgY29udGV4dE1lbnUpO1xuICAgICAgICBnZW9mbG8ubWFwLm9mZignc291cmNlZGF0YScsIHNvdXJjZURhdGEpO1xuXG4gICAgICAgIGV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGV2ZW50KSB7IGdlb2Zsby5tYXAub2ZmKGdlb2Zsby5pZCArICc6JyArIGV2ZW50LCBmaXJlRXZlbnQpOyB9KVxuXG4gICAgICAgIGdlb2Zsby5jb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGtleXByZXNzKTtcbiAgICAgICAgZ2VvZmxvLmNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBtb3VzZW92ZXIpO1xuICAgICAgICBnZW9mbG8uY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBtb3VzZWxlYXZlKTtcblxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImdhbWVwYWRjb25uZWN0ZWRcIiwgZ2FtZXBhZGNvbm5lY3RlZCk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiZ2FtZXBhZGRpc2Nvbm5lY3RlZFwiLCBnYW1lcGFkZGlzY29ubmVjdGVkKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJkZXZpY2VvcmllbnRhdGlvblwiLCBoYW5kbGVPcmllbnRhdGlvbiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcnMsXG4gICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzXG4gICAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBFdmVudHM7IiwiLyoqXG4gKiBAbWl4aW5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvXG4gKiBAbmFtZSBFeHBsb3JpbmdcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1peGluIHByb3ZpZGVzIHRoZSBleHBsb3JpbmcgZnVuY3Rpb25hbGl0eSBmb3IgdGhlIEdlb0ZsbyBhcHBsaWNhdGlvbi4gSXQgYWxsb3dzIHVzZXJzIHRvIGV4cGxvcmUgZmVhdHVyZXMgb24gdGhlIG1hcCBieSBjcmVhdGluZyBhIGJ1ZmZlciBhcm91bmQgdGhlIGZlYXR1cmUgYW5kIHNuYXBwaW5nIHRvIG5lYXJieSBmZWF0dXJlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlIC0gVGhlIG1vZGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHR5cGUgb2YgbW9kZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBFeHBsb3Jpbmcgb2JqZWN0LlxuICovXG5jb25zdCBFeHBsb3JpbmcgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgIGNvbnN0IGdlb2ZsbyA9IHRoaXMuZ2VvZmxvO1xuICAgIHRoaXMudHlwZSA9IG1vZGUudHlwZTtcblxuXHQvKipcbiAgICAgKiBBY3RpdmF0ZXMgdGhlIGV4cGxvcmluZyBmdW5jdGlvbmFsaXR5IGJ5IGVuYWJsaW5nIHRoZSAnZXhwbG9yaW5nJyBvcHRpb24uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgYWN0aXZhdGVcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FeHBsb3JpbmdcbiAgICAgKiBAZGVzY3JpcHRpb24gQWN0aXZhdGVzIGJ5IHNldHRpbmcgdGhlICdlbmFibGVkJyBwcm9wZXJ0eSB0byB0cnVlIGFuZCBlbmFibGluZyB0aGUgJ2V4cGxvcmluZycgb3B0aW9uLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHRoaXMuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGdlb2Zsby5vcHRpb25zWydleHBsb3JpbmcnXS5lbmFibGUgPSB0cnVlO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXhwbG9yaW5nXG5cdCAqIEBuYW1lIGRlYWN0aXZhdGVcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gc2V0cyB0aGUgJ2VuYWJsZWQnIGFuZCAnY3VycmVudE1hdGNoJyBwcm9wZXJ0aWVzIHRvIGZhbHNlLCBhbmQgZGlzYWJsZXMgdGhlICdleHBsb3JpbmcnIG9wdGlvbiBpbiB0aGUgY29udGV4dC5cblx0ICovXG4gICAgdGhpcy5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50TWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLm9wdGlvbnNbJ2V4cGxvcmluZyddLmVuYWJsZSA9IGZhbHNlO1xuICAgIH1cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FeHBsb3Jpbmdcblx0ICogQG5hbWUgc2V0RmVhdHVyZXNcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gc2V0cyBmZWF0dXJlcyBvbiB0aGUgbWFwIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBjb29yZGluYXRlcyBhbmQgb3B0aW9ucy4gSXQgY2FsY3VsYXRlcyB0aGUgYnVmZmVyIGJhc2VkIG9uIHRoZSBtYXAgem9vbSBsZXZlbCBhbmQgcmV0cmlldmVzIGZlYXR1cmVzIHdpdGhpbiB0aGUgYnVmZmVyIGFyZWEuIElmIHJvdXRpbmcgaXMgZW5hYmxlZCwgaXQgY2FsY3VsYXRlcyB0aGUgcm91dGUgYmV0d2VlbiB0d28gcG9pbnRzLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkcyAtIFRoZSBjb29yZGluYXRlcyB0byBzZXQgZmVhdHVyZXMgYXJvdW5kLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBzZXR0aW5nIGZlYXR1cmVzLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiB0aGUgZnVuY3Rpb24gaXMgbm90IGV4ZWN1dGVkIHN1Y2Nlc3NmdWxseS5cblx0ICovXG4gICAgdGhpcy5zZXRGZWF0dXJlcyA9IGZ1bmN0aW9uIChjb29yZHMsIG9wdGlvbnM9e30pIHtcbiAgICAgICAgaWYgKGdlb2Zsby5tYXBNb3ZpbmcgfHwgIXRoaXMuZW5hYmxlZCB8fCBnZW9mbG8uY3VycmVudE1vZGUuaWQgIT09ICdkcmF3JykgcmV0dXJuIGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFnZW9mbG8uUm91dGluZy5lbmFibGVkKSB7XG4gICAgICAgICAgICBpZiAoZ2VvZmxvLmhvdEZlYXR1cmUpIGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLnBvcCgpO1xuICAgICAgICAgICAgdmFyIGZyb21Qb2ludCA9IGdlb2Zsby5jdXJyZW50TW9kZS5maXJzdENsaWNrIHx8ICFnZW9mbG8uaG90RmVhdHVyZSA/IGdlb2Zsby5maXJzdENsaWNrLmNvb3JkcyA6IGdlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2dlb2Zsby5ob3RGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IFtmcm9tUG9pbnQsIGNvb3Jkc107XG4gICAgICAgICAgICBpZiAoZ2VvZmxvLlV0aWxpdGllcy5pc1BvaW50RXF1YWwoY29vcmRzWzBdLCBjb29yZHNbMV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRSb3V0ZShjb29yZHMsIG9wdGlvbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdlb2Zsby5tYXAuZ2V0Wm9vbSgpIDwgZ2VvZmxvLm9wdGlvbnMuZXhwbG9yaW5nLm1pblpvb20pIHJldHVybiBhbGVydChgWm9vbSBtdXN0IGJlIGxvd2VyIHRoYW4gJHtnZW9mbG8ub3B0aW9ucy5leHBsb3JpbmcubWluWm9vbX1gKTtcblxuICAgICAgICB2YXIgYnVmZmVyID0gb3B0aW9ucy5idWZmZXIgfHwgKChnZW9mbG8ub3B0aW9ucy5leHBsb3JpbmcuYnVmZmVyICogTWF0aC5wb3coMiwgTWF0aC5tYXgoMSwgMTkgLSBnZW9mbG8ubWFwLmdldFpvb20oKSkpKSAvIDEwMCk7XG4gICAgICAgIHZhciBwb2x5Z29uID0gdHVyZi5iYm94UG9seWdvbihbIGdlb2Zsby5tYXAuZ2V0Qm91bmRzKCkuZ2V0V2VzdCgpLCBnZW9mbG8ubWFwLmdldEJvdW5kcygpLmdldFNvdXRoKCksIGdlb2Zsby5tYXAuZ2V0Qm91bmRzKCkuZ2V0RWFzdCgpLCBnZW9mbG8ubWFwLmdldEJvdW5kcygpLmdldE5vcnRoKCkgXSk7XG5cbiAgICAgICAgaWYgKGNvb3JkcykgcG9seWdvbiA9IHR1cmYucG9seWdvbih0dXJmLmJ1ZmZlcih0dXJmLnBvaW50KGNvb3JkcyksIGJ1ZmZlcikuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzWydTTkFQJ10pLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlc1snUk9VVEUnXSkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzWydWRVJURVgnXSkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtwb2x5Z29uXSkpO1xuXG4gICAgICAgIHRoaXMuZ2V0RmVhdHVyZXModHVyZi5iYm94KHBvbHlnb24pKS50aGVuKGZlYXR1cmVzID0+IHsgc2V0RmVhdHVyZXMoZmVhdHVyZXMsIG9wdGlvbnMpOyB9KTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkV4cGxvcmluZ1xuXHQgKiBAbmFtZSBzZXRGZWF0dXJlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBsaW5lIGZlYXR1cmUgdXNpbmcgdGhlIGdpdmVuIGNvb3JkaW5hdGVzIGFuZCB1cGRhdGVzIHRoZSBjdXJyZW50IG1hdGNoIGJhc2VkIG9uIHRoZSBvcHRpb25zLiBJdCBhbHNvIHRyaWdnZXJzIGFuIGV2ZW50IGFuZCB1cGRhdGVzIHRoZSBzb3VyY2UgZGF0YSBvbiB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgLSBUaGUgY29vcmRpbmF0ZXMgdG8gY3JlYXRlIHRoZSBsaW5lIGZlYXR1cmUuIERlZmF1bHQgaXMgYW4gZW1wdHkgYXJyYXkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBzZXR0aW5nIHRoZSBmZWF0dXJlLCBzdWNoIGFzIHRoZSBzdGFydGluZyBwb2ludC4gRGVmYXVsdCBpcyBhbiBlbXB0eSBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB1cGRhdGVkIGZlYXR1cmUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGVzIGFuZCBvcHRpb25zLlxuXHQgKi9cbiAgICB0aGlzLnNldEZlYXR1cmUgPSBmdW5jdGlvbiAoY29vcmRzPVtdLCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICghZ2VvZmxvLmhvdEZlYXR1cmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFjb29yZHMubGVuZ3RoKSByZXR1cm4gZ2VvZmxvLmhvdEZlYXR1cmU7XG5cbiAgICAgICAgdmFyIGZlYXR1cmUgPSB0dXJmLmxpbmVTdHJpbmcoY29vcmRzKTtcbiAgICAgICAgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSA9IG9wdGlvbnMuc3RhcnQgfHwgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXTtcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWF0Y2gpIGZlYXR1cmUgPSB0dXJmLmxpbmVTdHJpbmcoZ2VvZmxvLlV0aWxpdGllcy5jb21iaW5lU2FtZVR5cGVGZWF0dXJlcyhbdGhpcy5jdXJyZW50TWF0Y2gsIGZlYXR1cmVdKSk7XG4gICAgICAgIHRoaXMuY3VycmVudE1hdGNoID0gZmVhdHVyZTtcblxuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TTkFQKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ2V4cGxvcmluZy5tYXRjaCcsIHsgcm91dGU6IHRoaXMuY3VycmVudE1hdGNoIH0pO1xuICAgICAgICByZXR1cm4gbW9kZS51cGRhdGVIb3RTb3VyY2UodGhpcy5jdXJyZW50TWF0Y2gpO1xuICAgIH1cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5FeHBsb3Jpbmdcblx0ICogQG5hbWUgZ2V0RmVhdHVyZXNcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgYm91bmRzIHVzaW5nIE92ZXJwYXNzIEFQSS5cblx0ICogQHBhcmFtIHtBcnJheX0gYm91bmRzIC0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgYm91bmRpbmcgYm94IGNvb3JkaW5hdGVzIFttaW5Mb24sIG1pbkxhdCwgbWF4TG9uLCBtYXhMYXRdLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheT59IEFuIGFycmF5IG9mIEdlb0pTT04gZmVhdHVyZXMgd2l0aGluIHRoZSBzcGVjaWZpZWQgYm91bmRzLlxuXHQgKi9cbiAgICB0aGlzLmdldEZlYXR1cmVzID0gYXN5bmMgZnVuY3Rpb24gKGJvdW5kcykge1xuICAgICAgICBpZiAoIWJvdW5kcyB8fCAhYm91bmRzLmxlbmd0aCB8fCBib3VuZHMubGVuZ3RoICE9IDQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgdGFnID0gYHdheVtcImhpZ2h3YXlcIl0oJHtib3VuZHNbMV19ICwgJHtib3VuZHNbMF19ICwgJHtib3VuZHNbM119ICwgJHtib3VuZHNbMl19KTtgO1xuXG4gICAgICAgIGlmIChnZW9mbG8ubWFwLmdldFpvb20oKSA8IDEyKSB7XG4gICAgICAgICAgICB0YWcgPSBgd2F5W1wiaGlnaHdheVwiPVwibW90b3J3YXlcIl0oJHtib3VuZHNbMV19ICwgJHtib3VuZHNbMF19ICwgJHtib3VuZHNbM119ICwgJHtib3VuZHNbMl19KTtgXG4gICAgICAgICAgICAvKiB3YXlbXCJoaWdod2F5XCI9XCJwcmltYXJ5XCJdKCR7Ym91bmRzWzFdfSAsICR7Ym91bmRzWzBdfSAsICR7Ym91bmRzWzNdfSAsICR7Ym91bmRzWzJdfSk7XG4gICAgICAgICAgICB3YXlbXCJoaWdod2F5XCI9XCJzZWNvbmRhcnlcIl0oJHtib3VuZHNbMV19ICwgJHtib3VuZHNbMF19ICwgJHtib3VuZHNbM119ICwgJHtib3VuZHNbMl19KTtgICovXG4gICAgICAgIH1cblxuICAgICAgICBnZW9mbG8ub3ZlcnBhc3NEb3dubG9hZGluZyA9IHRydWU7XG5cbiAgICAgICAgY29uc3QgcXVlcnkgPSAnW291dDpqc29uXVt0aW1lb3V0OjI1XTsoJyArIHRhZyArICcpO291dCBib2R5Oz47b3V0IHNrZWwgcXQ7JztcbiAgICAgICAgY29uc3QgZGF0YSA9IGF3YWl0IGZldGNoKFwiLy9vdmVycGFzcy1hcGkuZGUvYXBpL2ludGVycHJldGVyP2RhdGE9XCIgKyBxdWVyeSwgeyBtZXRob2Q6ICdHRVQnIH0gKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBkYXRhLmpzb24oKTtcbiAgICAgICAgY29uc3QgZ2VvanNvbiA9IGNvbnZlcnRGcm9tT3ZlcnBhc3NUb0dlb2pzb24ocmVzcG9uc2UpO1xuICAgICAgICByZXR1cm4gZ2VvanNvbiAmJiBnZW9qc29uLmZlYXR1cmVzID8gZ2VvanNvbi5mZWF0dXJlcyA6IFtdO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRXhwbG9yaW5nXG5cdCAqIEBuYW1lIGdldE1hdGNoXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIGNvb3JkaW5hdGVzIGFuZCBvcHRpb25hbCBvcHRpb25zIHRvIGZldGNoIGEgbWF0Y2hlZCByb3V0ZSBmcm9tIHRoZSBPU1JNIEFQSS5cblx0ICogQHBhcmFtIHtBcnJheX0gY29vcmRzIC0gQW4gYXJyYXkgb2YgY29vcmRpbmF0ZXMgdG8gbWF0Y2ggdGhlIHJvdXRlIGFnYWluc3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgY3VzdG9taXphdGlvbi5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZmVhdHVyZSAtIE9wdGlvbmFsIGZlYXR1cmUgdG8gbWF0Y2ggYWdhaW5zdC5cblx0ICogQHBhcmFtIHtOdW1iZXJ8RnVuY3Rpb259IG9wdGlvbnMucmFkaXVzIC0gT3B0aW9uYWwgcmFkaXVzIGZvciBtYXRjaGluZyBvciBhIGZ1bmN0aW9uIHRvIGNhbGN1bGF0ZSBpdC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMucHJvZmlsZSAtIE9wdGlvbmFsIHByb2ZpbGUgZm9yIHJvdXRpbmcgKGRlZmF1bHQ6ICdkcml2aW5nJykuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zZXQgLSBPcHRpb25hbCBmbGFnIHRvIHNldCB0aGUgZmVhdHVyZSBpZiBtYXRjaGluZyBpcyBzdWNjZXNzZnVsLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxBcnJheXxCb29sZWFuPn0gVGhlIG1hdGNoZWQgcm91dGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGZhbHNlIGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwcm92aWRlZCBvciBtYXRjaGluZyBmYWlscy5cblx0ICovXG4gICAgdGhpcy5nZXRNYXRjaCA9IGFzeW5jIGZ1bmN0aW9uIChjb29yZHM9W10sIG9wdGlvbnM9e30pIHtcbiAgICAgICAgaWYgKCFjb29yZHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIHRvbGVyYW5jZSA9IGdlb2Zsby5vcHRpb25zLmV4cGxvcmluZy50b2xlcmFuY2U7XG4gICAgICAgIHZhciBmZWF0dXJlID0gb3B0aW9ucy5mZWF0dXJlIHx8IHR1cmYuY2xlYW5Db29yZHModHVyZi5saW5lU3RyaW5nKGNvb3JkcykpO1xuICAgICAgICBmZWF0dXJlID0gdHVyZi5zaW1wbGlmeShmZWF0dXJlLCB7IG11dGF0ZTogdHJ1ZSwgdG9sZXJhbmNlOiB0eXBlb2YgdG9sZXJhbmNlID09PSAnZnVuY3Rpb24nID8gdG9sZXJhbmNlKGdlb2Zsby5tYXApIDogdG9sZXJhbmNlLCBoaWdoUXVhbGl0eTogdHJ1ZSB9KTtcblxuICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGdlb2Zsby5vdmVycGFzc0Rvd25sb2FkaW5nID0gdHJ1ZTtcblxuICAgICAgICBvcHRpb25zLnJhZGl1cyA9IG9wdGlvbnMucmFkaXVzIHx8IDUwO1xuICAgICAgICBvcHRpb25zLnByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGUgfHwgJ2RyaXZpbmcnO1xuICAgICAgICBjb29yZHMgPSBjb29yZGluYXRlcy5qb2luKCc7Jyk7XG5cbiAgICAgICAgY29uc3QgcmFkaXVzZXMgPSBjb29yZGluYXRlcy5tYXAoKCkgPT4gb3B0aW9ucy5yYWRpdXMpLmpvaW4oJzsnKTtcblxuICAgICAgICBjb25zdCBxdWVyeSA9ICdodHRwczovL3JvdXRlci5wcm9qZWN0LW9zcm0ub3JnL21hdGNoL3YxLycgKyBvcHRpb25zLnByb2ZpbGUgKyAnLycgKyBjb29yZHMgK1xuICAgICAgICAgICAgJz9vdmVydmlldz1zaW1wbGlmaWVkJyArXG4gICAgICAgICAgICAnJnJhZGl1c2VzPScgKyByYWRpdXNlcyArXG4gICAgICAgICAgICAnJmdlbmVyYXRlX2hpbnRzPWZhbHNlJyArXG4gICAgICAgICAgICAnJnNraXBfd2F5cG9pbnRzPXRydWUnICtcbiAgICAgICAgICAgICcmZ2Fwcz1pZ25vcmUnICtcbiAgICAgICAgICAgICcmYW5ub3RhdGlvbnM9bm9kZXMnICtcbiAgICAgICAgICAgICcmdGlkeT10cnVlJyArXG4gICAgICAgICAgICAnJmdlb21ldHJpZXM9Z2VvanNvbic7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBhd2FpdCBmZXRjaChxdWVyeSwgeyBtZXRob2Q6ICdHRVQnIH0gKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYXRjaC5qc29uKCk7XG5cbiAgICAgICAgZ2VvZmxvLm92ZXJwYXNzRG93bmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmNvZGUgIT09ICdPaycpIGFsZXJ0KGAke3Jlc3BvbnNlLmNvZGV9IC0gJHtyZXNwb25zZS5tZXNzYWdlfS5gKTtcbiAgICAgICAgcmV0dXJuICFvcHRpb25zLnNldCA/IHJlc3BvbnNlIDogIXJlc3BvbnNlLm1hdGNoaW5ncyB8fCAhcmVzcG9uc2UubWF0Y2hpbmdzLmxlbmd0aCA/IGZlYXR1cmUgOiB0aGlzLnNldEZlYXR1cmUocmVzcG9uc2UubWF0Y2hpbmdzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBvcHRpb25zKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkV4cGxvcmluZ1xuXHQgKiBAbmFtZSBnZXRSb3V0ZVxuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIGEgcm91dGUgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGVzIHVzaW5nIHRoZSBPU1JNIHJvdXRpbmcgc2VydmljZS5cblx0ICogQHBhcmFtIHtBcnJheX0gY29vcmRzIC0gQXJyYXkgb2YgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIHRoZSByb3V0ZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHRoZSByb3V0ZSBjYWxjdWxhdGlvbi5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMuZmVhdHVyZSAtIEZlYXR1cmUgb2JqZWN0IHRvIHVzZSBmb3IgdGhlIHJvdXRlIGNhbGN1bGF0aW9uLlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5wcm9maWxlIC0gUHJvZmlsZSB0eXBlIGZvciB0aGUgcm91dGUgY2FsY3VsYXRpb24gKGRlZmF1bHQ6ICdkcml2aW5nJykuXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5zZXQgLSBGbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdG8gc2V0IHRoZSByb3V0ZSBhcyBhIGZlYXR1cmUuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPEFycmF5fEJvb2xlYW4+fSBUaGUgcm91dGUgcmVzcG9uc2Ugb2JqZWN0IG9yIGZhbHNlIGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwcm92aWRlZCBvciB0aGUgcm91dGUgY2FsY3VsYXRpb24gZmFpbHMuXG5cdCAqL1xuICAgIHRoaXMuZ2V0Um91dGUgPSBhc3luYyBmdW5jdGlvbiAoY29vcmRzPVtdLCBvcHRpb25zPXt9KSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gb3B0aW9ucy5mZWF0dXJlID8gb3B0aW9ucy5mZWF0dXJlIDogIWNvb3Jkcy5sZW5ndGggPyBmYWxzZSA6IHR1cmYuY2xlYW5Db29yZHModHVyZi5saW5lU3RyaW5nKGNvb3JkcykpO1xuICAgICAgICBpZiAoIWZlYXR1cmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBjb29yZGluYXRlcyA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgZ2VvZmxvLm92ZXJwYXNzRG93bmxvYWRpbmcgPSB0cnVlO1xuICAgICAgICBvcHRpb25zLnByb2ZpbGUgPSBvcHRpb25zLnByb2ZpbGUgfHwgJ2RyaXZpbmcnO1xuICAgICAgICBjb29yZHMgPSBjb29yZGluYXRlcy5qb2luKCc7Jyk7XG5cbiAgICAgICAgY29uc3QgcXVlcnkgPSAnaHR0cHM6Ly9yb3V0ZXIucHJvamVjdC1vc3JtLm9yZy9yb3V0ZS92MS8nICsgb3B0aW9ucy5wcm9maWxlICsgJy8nICsgY29vcmRzICtcbiAgICAgICAgICAgICc/b3ZlcnZpZXc9c2ltcGxpZmllZCcgK1xuICAgICAgICAgICAgJyZjb250aW51ZV9zdHJhaWdodD10cnVlJyArXG4gICAgICAgICAgICAnJmFubm90YXRpb25zPW5vZGVzJyArXG4gICAgICAgICAgICAnJmdlb21ldHJpZXM9Z2VvanNvbic7XG5cbiAgICAgICAgY29uc3QgbWF0Y2ggPSBhd2FpdCBmZXRjaChxdWVyeSwgeyBtZXRob2Q6ICdHRVQnIH0gKTtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBtYXRjaC5qc29uKCk7XG5cbiAgICAgICAgZ2VvZmxvLm92ZXJwYXNzRG93bmxvYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmNvZGUgIT09ICdPaycpIGFsZXJ0KGAke3Jlc3BvbnNlLmNvZGV9IC0gJHtyZXNwb25zZS5tZXNzYWdlfS5gKTtcbiAgICAgICAgcmV0dXJuICFvcHRpb25zLnNldCA/IHJlc3BvbnNlIDogIXJlc3BvbnNlLnJvdXRlcyB8fCAhcmVzcG9uc2Uucm91dGVzLmxlbmd0aCA/IGZlYXR1cmUgOiB0aGlzLnNldEZlYXR1cmUocmVzcG9uc2Uucm91dGVzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgXG5cblxuICAgIGlmIChnZW9mbG8ub3B0aW9uc1snZXhwbG9yaW5nJ10uZW5hYmxlKSB0aGlzLmFjdGl2YXRlKCk7XG5cblxuXG4gICAgZnVuY3Rpb24gY29udmVydEZyb21PdmVycGFzc1RvR2VvanNvbihvcCkge1xuICAgICAgICBjb25zdCBlbGVtZW50c0J5SWQgPSB7fTtcblxuICAgICAgICBvcC5lbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgJHtlbGVtZW50LnR5cGV9LSR7ZWxlbWVudC5pZH1gO1xuICAgICAgICAgICAgZWxlbWVudHNCeUlkW2tleV0gPSBlbGVtZW50O1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB3YXlUb1BvaW50cyA9IGZ1bmN0aW9uICh3YXkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBbXTtcbiAgICAgICAgICAgIHdheS5ub2Rlcy5mb3JFYWNoKChub2RlSWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBgbm9kZS0ke25vZGVJZH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVFbGVtZW50ID0gZWxlbWVudHNCeUlkW2tleV07XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUucHVzaChbbm9kZUVsZW1lbnQubG9uLCBub2RlRWxlbWVudC5sYXRdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiTm9kZSBcIiwga2V5LCBcIiBtaXNzaW5nXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgbGluZVN0cmluZ3MgPSBbXTtcblxuICAgICAgICBvcC5lbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZWxlbWVudC50eXBlID09PSBcIndheVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHdheVRvUG9pbnRzKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChsaW5lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZVN0cmluZ3MucHVzaCh0dXJmLmxpbmVTdHJpbmcobGluZSwgZWxlbWVudC50YWdzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnR5cGUgPT09IFwicmVsYXRpb25cIikge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubWVtYmVycy5mb3JFYWNoKChtZW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVtYmVyVHlwZSA9IG1lbWJlci50eXBlO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVyVHlwZSA9PT0gXCJ3YXlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYHdheS0ke21lbWJlci5yZWZ9YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdheSA9IGVsZW1lbnRzQnlJZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZSA9IHdheVRvUG9pbnRzKHdheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0cmluZ3MucHVzaCh0dXJmLmxpbmVTdHJpbmcobGluZSwgZWxlbWVudC50YWdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGdlb2Zsby50dXJmLmZlYXR1cmVDb2xsZWN0aW9uKGxpbmVTdHJpbmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRGZWF0dXJlcyhmZWF0dXJlcz1bXSkge1xuICAgICAgICBnZW9mbG8ub3ZlcnBhc3NEb3dubG9hZGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAoZ2VvZmxvLm1hcE1vdmluZyB8fCAhZ2VvZmxvLkV4cGxvcmluZy5lbmFibGVkIHx8IGdlb2Zsby5jdXJyZW50TW9kZS5pZCAhPT0gJ2RyYXcnKSByZXR1cm4gZ2VvZmxvLnVwZGF0ZU1lc2hEYXRhKFtdLCB0cnVlKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuVkVSVEVYKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pKTtcbiAgICAgICAgZ2VvZmxvLlNuYXBwaW5nLmFkZEZlYXR1cmUoZ2VvZmxvLnNuYXBGZWF0dXJlKTtcbiAgICAgICAgZ2VvZmxvLnNldE1lc2hGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICAgIGdlb2Zsby5jdXJyZW50TW9kZS51cGRhdGVIb3RTb3VyY2UoKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ292ZXJwYXNzLmFkZCcsIHsgZmVhdHVyZXM6IGZlYXR1cmVzIH0pO1xuICAgICAgICBpZiAoIWdlb2Zsby5jdXJyZW50TW9kZS5maXJzdENsaWNrKSByZXR1cm4gZmVhdHVyZXM7XG4gICAgICAgIHZhciBwb2ludHMgPSB0dXJmLmV4cGxvZGUodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcykpXG4gICAgICAgIHZhciBjbG9zZXN0UG9pbnQgPSB0dXJmLm5lYXJlc3RQb2ludCh0dXJmLnBvaW50KGdlb2Zsby5jdXJyZW50TW9kZS5maXJzdENsaWNrLmNvb3JkcyksIHBvaW50cyk7XG4gICAgICAgIGdlb2Zsby5sYXN0Q2xpY2sgPSB7IGNvb3JkczogY2xvc2VzdFBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzIH07XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG59O1xuXG5leHBvcnQgZGVmYXVsdCBFeHBsb3Jpbmc7IiwiLyoqXG4gKiBAbWl4aW5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvXG4gKiBAbmFtZSBGZWF0dXJlc1xuICogQGRlc2NyaXB0aW9uIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBmZWF0dXJlcyBmdW5jdGlvbmFsaXR5IGZvciB0aGUgR2VvZmxvIGFwcGxpY2F0aW9uLiBJdCBhbGxvd3MgdXNlcnMgdG8gYWRkLCByZW1vdmUsIHVwZGF0ZSwgYW5kIHJldHJpZXZlIGZlYXR1cmVzIGZyb20gdGhlIG1hcC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIEZlYXR1cmVzIG9iamVjdC5cbiAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgbm8gbWFwIG9iamVjdCBpcyBwcm92aWRlZC5cbiAqL1xuY29uc3QgRmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZ2VvZmxvID0gdGhpcy5nZW9mbG87XG4gICAgaWYgKCFnZW9mbG8ubWFwKSB7IHRocm93IG5ldyBFcnJvcignTm8gbWFwIG9iamVjdCBwcm92aWRlZCEnKSB9XG5cbiAgICBjb25zdCBjb2xkRmVhdHVyZXMgPSBbXTtcbiAgICB0aGlzLm9mZnNldExpbmVzID0gZmFsc2U7XG5cbiAgICBcblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkZlYXR1cmVzXG5cdCAqIEBuYW1lIGdldENvbGRGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiByZXR1cm5zIGFuIGFycmF5IG9mIGNvbGQgZmVhdHVyZXMuXG5cdCAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBjb2xkIGZlYXR1cmVzLlxuXHQgKi9cbiAgICB0aGlzLmdldENvbGRGZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGNvbGRGZWF0dXJlcztcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5GZWF0dXJlc1xuXHQgKiBAbmFtZSBnZXRGZWF0dXJlQnlJZFxuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIGEgZmVhdHVyZSBieSBpdHMgSUQgZnJvbSBhIGdpdmVuIHNvdXJjZS4gSWYgdGhlIElEIGlzIGFuIGFycmF5IHdpdGggbXVsdGlwbGUgSURzLCBpdCByZXRyaWV2ZXMgbXVsdGlwbGUgZmVhdHVyZXMuIElmIHRoZSBJRCBpcyBhbiBvYmplY3QsIGl0IHRyaWVzIHRvIGV4dHJhY3QgdGhlIElEIGZyb20gdGhlIG9iamVjdCdzIHBhcmVudCwgcHJvcGVydGllcywgb3IgaWQgZmllbGRzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ8QXJyYXl9IGlkIC0gVGhlIElEIG9yIGFycmF5IG9mIElEcyBvZiB0aGUgZmVhdHVyZShzKSB0byByZXRyaWV2ZS5cblx0ICogQHJldHVybnMge09iamVjdHxBcnJheX0gVGhlIGZlYXR1cmUgb3IgYXJyYXkgb2YgZmVhdHVyZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvdmlkZWQgSUQocykuXG5cdCAqL1xuICAgIHRoaXMuZ2V0RmVhdHVyZUJ5SWQgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpICYmIGlkLmxlbmd0aCA+IDEpIHJldHVybiB0aGlzLmdldEZlYXR1cmVzQnlJZChpZCk7XG4gICAgICAgIGlmICh0eXBlb2YgaWQgPT09ICdvYmplY3QnKSBpZCA9IGlkLnBhcmVudCB8fCBpZC5wcm9wZXJ0aWVzLnBhcmVudCB8fCBpZC5pZCB8fCBpZC5wcm9wZXJ0aWVzLmlkO1xuICAgICAgICByZXR1cm4gZ2V0RmVhdHVyZUJ5SWQoaWQpO1xuICAgIH07XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkZlYXR1cmVzXG5cdCAqIEBuYW1lIGdldEZlYXR1cmVzQnlJZFxuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIGZlYXR1cmVzIGJ5IHRoZWlyIElEcy5cblx0ICogQHBhcmFtIHtBcnJheX0gaWRzIC0gQW4gYXJyYXkgb2YgZmVhdHVyZSBJRHMgdG8gcmV0cmlldmUuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gLSBBbiBhcnJheSBvZiBmZWF0dXJlcyBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBJRHMuXG5cdCAqL1xuICAgIHRoaXMuZ2V0RmVhdHVyZXNCeUlkID0gZnVuY3Rpb24gKGlkcykge1xuICAgICAgICBjb25zdCBhZGRlZElkcyA9IFtdO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZHMuZm9yRWFjaCgoaWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZlYXR1cmUgPSB0aGlzLmdldEZlYXR1cmVCeUlkKGlkKTtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlICYmICFhZGRlZElkcy5pbmNsdWRlcyhpZCkpIGFkZGVkSWRzLnB1c2goaWQpLCByZXN1bHQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5GZWF0dXJlc1xuXHQgKiBAbmFtZSBnZXRUeXBlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHR5cGUgb2YgdGhlIGlucHV0IGZlYXR1cmUuXG5cdCAqIEBwYXJhbSB7YW55fSBmZWF0dXJlIC0gVGhlIGZlYXR1cmUgd2hvc2UgdHlwZSBuZWVkcyB0byBiZSBkZXRlcm1pbmVkLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgdHlwZSBvZiB0aGUgaW5wdXQgZmVhdHVyZS5cblx0ICovXG4gICAgdGhpcy5nZXRUeXBlID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgcmV0dXJuIGdldFR5cGUoZmVhdHVyZSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5GZWF0dXJlcyBnZXRVbml0XG5cdCAqIEBuYW1lIGdldFVuaXRcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyB0aGUgdW5pdCBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBmZWF0dXJlIHR5cGUgZnJvbSB0aGUgY29udGV4dCBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZSAtIFRoZSBmZWF0dXJlIG9iamVjdCBmb3Igd2hpY2ggdGhlIHVuaXQgbmVlZHMgdG8gYmUgcmV0cmlldmVkLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfGJvb2xlYW59IFRoZSB1bml0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZmVhdHVyZSB0eXBlIGlmIGZvdW5kLCBvdGhlcndpc2UgZmFsc2UuXG5cdCAqL1xuICAgIHRoaXMuZ2V0VW5pdCA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmICghZmVhdHVyZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciB0eXBlID0gZmVhdHVyZS5wcm9wZXJ0aWVzLnR5cGU7XG4gICAgICAgIGlmICghdHlwZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGlmICghZ2VvZmxvLm9wdGlvbnMudW5pdHMgfHwgIWdlb2Zsby5vcHRpb25zLnVuaXRzW3R5cGVdKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgcmV0dXJuIGdlb2Zsby5vcHRpb25zLnVuaXRzW3R5cGVdO1xuICAgIH07XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkZlYXR1cmVzXG5cdCAqIEBuYW1lIGdldFVuaXRzXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlIC0gVGhlIGZlYXR1cmUgZm9yIHdoaWNoIHVuaXRzIG5lZWQgdG8gYmUgY2FsY3VsYXRlZC5cblx0ICogQHJldHVybnMge251bWJlcn0gLSBUaGUgY2FsY3VsYXRlZCB1bml0cyAobGVuZ3RoIG9yIGFyZWEpIG9mIHRoZSBmZWF0dXJlLlxuXHQgKi9cbiAgICB0aGlzLmdldFVuaXRzID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgdmFyIHVuaXQgPSB0aGlzLmdldFVuaXQoZmVhdHVyZSk7XG4gICAgICAgIGlmICghdW5pdCB8fCAhZmVhdHVyZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciB1bml0cyA9IDE7XG4gICAgICAgIHZhciB0eXBlID0gZmVhdHVyZS5wcm9wZXJ0aWVzLnR5cGU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiUG9seWxpbmVcIikge1xuICAgICAgICAgICAgdW5pdHMgPSB0dXJmLmxlbmd0aChmZWF0dXJlLCB7IHVuaXRzOiAnbWV0ZXJzJyB9KTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgIHVuaXRzID0gdHVyZi5hcmVhKGZlYXR1cmUpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdSZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICB1bml0cyA9IHR1cmYuYXJlYShmZWF0dXJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1bml0cztcbiAgICB9O1xuXG5cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRmVhdHVyZXNcblx0ICogQG5hbWUgc2V0RmVhdHVyZXNTdGF0ZVxuXHQgKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgc3RhdGUgb2YgbXVsdGlwbGUgZmVhdHVyZXMgaW4gYSBtYXAuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZlYXR1cmVzIC0gQW4gYXJyYXkgb2YgZmVhdHVyZXMgdG8gc2V0IHRoZSBzdGF0ZSBmb3IuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gc3RhdGUgLSBUaGUgc3RhdGUgdG8gc2V0IGZvciB0aGUgZmVhdHVyZXMuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gLSBUaGUgdXBkYXRlZCBhcnJheSBvZiBmZWF0dXJlcyB3aXRoIHRoZSBuZXcgc3RhdGUuXG5cdCAqL1xuICAgIHRoaXMuc2V0RmVhdHVyZXNTdGF0ZSA9IGZ1bmN0aW9uIChmZWF0dXJlcz1bXSwgc3RhdGUpIHtcbiAgICAgICAgaWYgKCFzdGF0ZSB8fCAhZmVhdHVyZXMubGVuZ3RoKSByZXR1cm4gW107XG4gICAgICAgIFxuICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IGZlYXR1cmUuaWQgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkO1xuICAgICAgICAgICAgaWYgKGdlb2Zsby5ob3RGZWF0dXJlICYmIGdlb2Zsby5ob3RGZWF0dXJlLmlkID09PSBpZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zZXRGZWF0dXJlU3RhdGUoaWQsIHN0YXRlKTtcbiAgICAgICAgfSwgdGhpcylcblxuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRmVhdHVyZXNcblx0ICogQG5hbWUgc2V0RmVhdHVyZVN0YXRlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHNldHMgdGhlIHN0YXRlIG9mIGEgZmVhdHVyZSBhbmQgaXRzIGNoaWxkcmVuIGluIHRoZSBtYXAgYnkgdXBkYXRpbmcgdGhlaXIgZmVhdHVyZSBzdGF0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIElEIG9mIHRoZSBwYXJlbnQgZmVhdHVyZS5cblx0ICogQHBhcmFtIHtvYmplY3R9IHN0YXRlIC0gVGhlIHN0YXRlIG9iamVjdCB0byBzZXQgZm9yIHRoZSBmZWF0dXJlcy5cblx0ICogQHJldHVybnMge2FycmF5fSAtIEFuIGFycmF5IG9mIGZlYXR1cmVzIHdob3NlIHN0YXRlIHdhcyB1cGRhdGVkLlxuXHQgKi9cbiAgICB0aGlzLnNldEZlYXR1cmVTdGF0ZSA9IGZ1bmN0aW9uIChpZCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKCFzdGF0ZSB8fCAhaWQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgZmVhdHVyZXMgPSBnZXRGZWF0dXJlc0J5UGFyZW50KGlkKTtcbiAgICAgICAgXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gZmVhdHVyZS5pZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICBnZW9mbG8ubWFwLnNldEZlYXR1cmVTdGF0ZSh7IHNvdXJjZTogZmVhdHVyZS5zb3VyY2UsIGlkOiBpZCB9LCBzdGF0ZSk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH07XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkZlYXR1cmVzXG5cdCAqIEBuYW1lIHNldFRleHRcblx0ICogQGRlc2NyaXB0aW9uIFNldHMgdGV4dCBmZWF0dXJlcyBvbiB0aGUgbWFwIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBmZWF0dXJlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVzIC0gVGhlIGZlYXR1cmVzIHRvIHNldCB0ZXh0IG9uLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBubyBmZWF0dXJlcyBhcmUgcHJvdmlkZWQgb3IgaWYgdGhlIGZlYXR1cmVzIGFycmF5IGlzIGVtcHR5LlxuXHQgKi9cbiAgICB0aGlzLnNldFRleHQgPSBmdW5jdGlvbiAoZmVhdHVyZXM9W10pIHtcbiAgICAgICAgaWYgKCFnZW9mbG8ub3B0aW9ucy5zaG93RmVhdHVyZVRleHQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgc291cmNlID0gZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuSE9UVEVYVDtcblxuICAgICAgICB0aGlzLnRleHRGZWF0dXJlcyA9IFtdO1xuXG4gICAgICAgIGlmIChmZWF0dXJlcy5mZWF0dXJlcykgZmVhdHVyZXMgPSBmZWF0dXJlcy5mZWF0dXJlcztcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGZlYXR1cmVzKSkgZmVhdHVyZXMgPSBbZmVhdHVyZXNdO1xuXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmVhdHVyZS5wcm9wZXJ0aWVzLnR5cGU7XG4gICAgICAgICAgICBpZiAoIXR5cGUpIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VHlwZSA9IHR5cGU7XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnUG9seWxpbmUnICYmIGdlb2Zsby5VdGlsaXRpZXMuaXNWYWxpZExpbmVTdHJpbmcoZmVhdHVyZSkgJiYgZ2VvZmxvLm9wdGlvbnMuc2hvd0xpbmVVbml0cykge1xuICAgICAgICAgICAgICAgIHR1cmYuc2VnbWVudEVhY2goZmVhdHVyZSwgc2V0TGluZVRleHQuYmluZCh0aGlzKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZSA9IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNFTEVDVDtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdCA9IGdlb2Zsby5VdGlsaXRpZXMuY2xvbmVEZWVwKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZlYXQucHJvcGVydGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ1RleHQnLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBmZWF0dXJlLnByb3BlcnRpZXMudGV4dCxcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IGZlYXR1cmUucHJvcGVydGllcy5zdHlsZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnRleHRGZWF0dXJlcy5wdXNoKGZlYXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKVxuICAgICAgICBcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2Uoc291cmNlKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24odGhpcy50ZXh0RmVhdHVyZXMpKTtcblxuICAgICAgICBkZWxldGUgdGhpcy50ZXh0RmVhdHVyZXM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRUeXBlO1xuICAgIH1cblxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkZlYXR1cmVzXG5cdCAqIEBuYW1lIGFkZEZlYXR1cmVcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gYWRkcyBhIGZlYXR1cmUgdG8gdGhlIG1hcCB3aXRoIHRoZSBnaXZlbiBwcm9wZXJ0aWVzLiBJdCBjbGVhbnMgdGhlIGNvb3JkaW5hdGVzLCB0cnVuY2F0ZXMgdGhlbSwgYXNzaWducyBkZWVwIHByb3BlcnRpZXMsIHNldHMgdGhlIHNvdXJjZSwgYW5kIHJlbW92ZXMgdW5uZWNlc3NhcnkgcHJvcGVydGllcyBiZWZvcmUgYWRkaW5nIHRoZSBmZWF0dXJlIHRvIHRoZSBtYXAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlIC0gVGhlIGZlYXR1cmUgb2JqZWN0IHRvIGJlIGFkZGVkIHRvIHRoZSBtYXAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gLSBBZGRpdGlvbmFsIHByb3BlcnRpZXMgdG8gYmUgYXNzaWduZWQgdG8gdGhlIGZlYXR1cmUuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmZWF0dXJlIG9iamVjdCB0aGF0IHdhcyBhZGRlZCB0byB0aGUgbWFwLlxuXHQgKi9cbiAgICB0aGlzLmFkZEZlYXR1cmUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgc291cmNlLCBwcm9wZXJ0aWVzPXt9KSB7XG4gICAgICAgIGlmICghZmVhdHVyZSB8fCAhZmVhdHVyZS5wcm9wZXJ0aWVzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBmZWF0dXJlID0gdHVyZi5jbGVhbkNvb3JkcyhmZWF0dXJlKTtcbiAgICAgICAgZmVhdHVyZSA9IHR1cmYudHJ1bmNhdGUoZmVhdHVyZSwgeyBwcmVjaXNpb246IDYsIGNvb3JkaW5hdGVzOiAzLCBtdXRhdGU6IHRydWUgfSk7XG5cbiAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzID0gZ2VvZmxvLlV0aWxpdGllcy5hc3NpZ25EZWVwKHByb3BlcnRpZXMsIGZlYXR1cmUucHJvcGVydGllcyk7XG4gICAgICAgIGZlYXR1cmUuc291cmNlID0gc291cmNlIHx8IGZlYXR1cmUuc291cmNlIHx8IGZlYXR1cmUucHJvcGVydGllcy5zb3VyY2UgfHwgZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuQ09MRDtcbiAgICAgICAgXG4gICAgICAgIGRlbGV0ZSBmZWF0dXJlLnByb3BlcnRpZXMuc291cmNlO1xuICAgICAgICBkZWxldGUgZmVhdHVyZS5wcm9wZXJ0aWVzLnBhaW50aW5nO1xuICAgICAgICBkZWxldGUgZmVhdHVyZS5wcm9wZXJ0aWVzLmVkaXQ7XG4gICAgICAgIGRlbGV0ZSBmZWF0dXJlLnByb3BlcnRpZXMubmV3O1xuICAgICAgICBkZWxldGUgZmVhdHVyZS5wcm9wZXJ0aWVzLnNlbGVjdGVkO1xuICAgICAgICBkZWxldGUgZmVhdHVyZS5wcm9wZXJ0aWVzLmhpZGRlbjtcbiAgICAgICAgZGVsZXRlIGZlYXR1cmUucHJvcGVydGllcy5vZmZzZXQ7XG4gICAgICAgIFxuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGUgPSBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGUgfHwge307XG5cbiAgICAgICAgdGhpcy5hZGRVbml0cyhmZWF0dXJlKTtcbiAgICAgICAgdGhpcy5hZGRGZWF0dXJlcyhbZmVhdHVyZV0pO1xuICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5GZWF0dXJlc1xuXHQgKiBAbmFtZSBhZGRGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSBvZiBmZWF0dXJlcyBhbmQgYWRkcyB0aGVtIHRvIHRoZSBtYXAuIEl0IGFsc28gdXBkYXRlcyB0aGUgc291cmNlIGlmIGFueSBjaGFuZ2VzIGFyZSBtYWRlLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBmZWF0dXJlcyAtIEFuIGFycmF5IG9mIGZlYXR1cmVzIHRvIGJlIGFkZGVkIHRvIHRoZSBtYXAuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gdW5zZWxlY3QgLSBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHVuc2VsZWN0IHRoZSBmZWF0dXJlcy5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgZmVhdHVyZXMgdGhhdCB3ZXJlIGFkZGVkIHRvIHRoZSBtYXAuXG5cdCAqL1xuICAgIHRoaXMuYWRkRmVhdHVyZXMgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIHVuc2VsZWN0LCBpZCkge1xuICAgICAgICB2YXIgdXBkYXRlO1xuICAgICAgICB2YXIgc291cmNlcyA9IFtdO1xuXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGZlYXR1cmUuaWQgPSBmZWF0dXJlLmlkIHx8IGZlYXR1cmUucHJvcGVydGllcy5pZCB8fCBVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFtdKSkuc2xpY2UoLTM2KTtcbiAgICAgICAgICAgIGlmIChpZCAmJiBmZWF0dXJlLmlkICE9PSBpZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBmZWF0dXJlLnNvdXJjZSA9IGZlYXR1cmUuc291cmNlIHx8IGZlYXR1cmUucHJvcGVydGllcy5zb3VyY2UgfHwgZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuQ09MRDtcbiAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5pZCA9IGZlYXR1cmUuaWQ7XG4gICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMudHlwZSA9IHRoaXMuZ2V0VHlwZShmZWF0dXJlKTtcblxuICAgICAgICAgICAgdmFyIGluZGV4ID0gY29sZEZlYXR1cmVzLmZpbmRJbmRleChmdW5jdGlvbihmKSB7IGlmIChmLmlkID09PSBmZWF0dXJlLmlkIHx8IGYucHJvcGVydGllcy5pZCA9PT0gZmVhdHVyZS5pZCkgcmV0dXJuIGY7IH0pO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmVhdHVyZVN0YXRlKGZlYXR1cmUuaWQsIHsgaGlkZGVuOiAhdW5zZWxlY3QgfSk7XG4gICAgICAgICAgICAgICAgY29sZEZlYXR1cmVzW2luZGV4XSA9IGZlYXR1cmU7XG4gICAgICAgICAgICAgICAgdXBkYXRlID0gIXVuc2VsZWN0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUgPSAhdGhpcy51cGRhdGluZ0ZlYXR1cmVzO1xuICAgICAgICAgICAgICAgIGNvbGRGZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodW5zZWxlY3QpIGRlbGV0ZSBmZWF0dXJlLnByb3BlcnRpZXMuX3NlbGVjdGVkO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZSAmJiAhc291cmNlcy5pbmNsdWRlcyhmZWF0dXJlLnNvdXJjZSkpIHNvdXJjZXMucHVzaChmZWF0dXJlLnNvdXJjZSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmICh1cGRhdGUpIHRoaXMudXBkYXRlU291cmNlKHNvdXJjZXMpO1xuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRmVhdHVyZXNcblx0ICogQG5hbWUgYWRkVW5pdHNcblx0ICogQGRlc2NyaXB0aW9uIEFkZHMgdW5pdHMgdG8gYSBmZWF0dXJlJ3MgZ2VvbWV0cnkgYmFzZWQgb24gdGhlIHNwZWNpZmllZCBjb252ZXJzaW9uIG9yIGRlZmF1bHQgdW5pdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgLSBUaGUgZmVhdHVyZSBvYmplY3QgdG8gd2hpY2ggdW5pdHMgd2lsbCBiZSBhZGRlZC5cblx0ICogQHBhcmFtIHtTdHJpbmd9IGNvbnZlcnRUbyAtIFRoZSB1bml0IHRvIHdoaWNoIHRoZSBmZWF0dXJlJ3MgdW5pdHMgd2lsbCBiZSBjb252ZXJ0ZWQuIElmIG5vdCBwcm92aWRlZCwgdGhlIGRlZmF1bHQgdW5pdCB3aWxsIGJlIHVzZWQuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBmZWF0dXJlIG9iamVjdCB3aXRoIGFkZGVkIHVuaXRzLlxuXHQgKi9cbiAgICB0aGlzLmFkZFVuaXRzID0gZnVuY3Rpb24gKGZlYXR1cmUsIGNvbnZlcnRUbykge1xuICAgICAgICB2YXIgdW5pdCA9IGNvbnZlcnRUbyB8fCB0aGlzLmdldFVuaXQoZmVhdHVyZSk7XG4gICAgICAgIGlmICghdW5pdCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciB1bml0cyA9IHRoaXMuY29udmVydFVuaXRzKGZlYXR1cmUsIG51bGwsIGNvbnZlcnRUbyk7XG5cbiAgICAgICAgZmVhdHVyZS5nZW9tZXRyeS51bml0cyA9IHVuaXRzO1xuICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LnVuaXQgPSB1bml0O1xuICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgc2VsZWN0RmVhdHVyZXNcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5GZWF0dXJlc1xuICAgICAqIEBkZXNjcmlwdGlvbiBTZWxlY3RzIGZlYXR1cmVzIGZyb20gYSBnaXZlbiBhcnJheSBhbmQgbWFya3MgdGhlbSBhcyBzZWxlY3RlZCBpZiB0aGV5IGFyZSBub3QgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGZlYXR1cmVzIC0gQW4gYXJyYXkgb2YgZmVhdHVyZSBvYmplY3RzIHRvIGJlIHNlbGVjdGVkLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxib29sZWFufSBSZXR1cm5zIGFuIGFycmF5IG9mIHNlbGVjdGVkIGZlYXR1cmVzIGlmIGFueSBmZWF0dXJlcyB3ZXJlIHNlbGVjdGVkLCBvdGhlcndpc2UgcmV0dXJucyBmYWxzZS5cbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdEZlYXR1cmVzID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgIGlmICghZmVhdHVyZXMgfHwgIWZlYXR1cmVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBzZWxlY3RlZCA9IGdlb2Zsby5nZXRTZWxlY3RlZEZlYXR1cmVzKCk7XG5cbiAgICAgICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gZmVhdHVyZS5pZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBzZWxlY3RlZC5maW5kSW5kZXgoKGYpID0+IHsgcmV0dXJuIGYuaWQgPT09IGlkIHx8IGYucHJvcGVydGllcy5pZCA9PT0gaWQgfSk7XG5cbiAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5fc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZWN0ZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uRmVhdHVyZXNcblx0ICogQG5hbWUgdXBkYXRlRmVhdHVyZXNcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdXBkYXRlcyB0aGUgY29vcmRpbmF0ZXMgb2YgZmVhdHVyZXMgaW4gYSBtYXAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGNvb3JkaW5hdGVzLiBJdCBpdGVyYXRlcyB0aHJvdWdoIHRoZSBmZWF0dXJlcyBhcnJheSwgcmV0cmlldmVzIHRoZSBvcmlnaW5hbCBmZWF0dXJlIGJ5IElELCBhbmQgdXBkYXRlcyBpdHMgZ2VvbWV0cnkgY29vcmRpbmF0ZXMgYmFzZWQgb24gdGhlIGZlYXR1cmUgdHlwZS4gSXQgdGhlbiBhZGRzIHVuaXRzIHRvIHRoZSB1cGRhdGVkIGZlYXR1cmUgYW5kIHVwZGF0ZXMgdGhlIHNvdXJjZSBvZiB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBmZWF0dXJlcyAtIEFuIGFycmF5IG9mIGZlYXR1cmVzIHRvIHVwZGF0ZS5cblx0ICogQHBhcmFtIHtBcnJheX0gY29vcmRzIC0gVGhlIG5ldyBjb29yZGluYXRlcyB0byBzZXQgZm9yIHRoZSBmZWF0dXJlcy5cblx0ICovXG4gICAgdGhpcy51cGRhdGVGZWF0dXJlcyA9IGZ1bmN0aW9uKGZlYXR1cmVzLCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGZlYXR1cmVzID0gZmVhdHVyZXMgfHwgZ2VvZmxvLmdldEZlYXR1cmVzKCk7XG5cbiAgICAgICAgdmFyIHNvdXJjZXMgPSBbXTtcbiAgICAgICAgdmFyIHNlbGVjdGVkRmVhdHVyZXMgPSBnZW9mbG8uZ2V0U2VsZWN0ZWRGZWF0dXJlcygpO1xuICAgICAgICB2YXIgY29vcmRzID0gb3B0aW9ucy5jb29yZHMgfHwgbnVsbDtcblxuICAgICAgICB0aGlzLnVwZGF0aW5nRmVhdHVyZXMgPSB0cnVlO1xuXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gZmVhdHVyZS5pZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICBpZiAoIWlkKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhciBvcmlnaW5hbEZlYXR1cmUgPSB0aGlzLmdldEZlYXR1cmVCeUlkKGlkKTtcbiAgICAgICAgICAgIGlmICghb3JpZ2luYWxGZWF0dXJlIHx8IG9yaWdpbmFsRmVhdHVyZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcy5hZGRGZWF0dXJlKGZlYXR1cmUpO1xuXG4gICAgICAgICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZEZlYXR1cmVzLmZpbmQoKGZlYXR1cmUpID0+IHsgcmV0dXJuIGZlYXR1cmUuaWQgPT09IGlkIHx8IGZlYXR1cmUucHJvcGVydGllcy5pZCA9PT0gaWQgfSk7XG5cbiAgICAgICAgICAgIGlmIChzZWxlY3RlZCAmJiAhZ2VvZmxvLm5vU2VsZWN0KSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICAgIHNlbGVjdGVkLnByb3BlcnRpZXMgPSBmZWF0dXJlLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQucHJvcGVydGllcy5fc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8qIGdlb2Zsby5MYXllcnMuZ2V0TGF5ZXIoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU0VMRUNUKS5mb3JFYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7IH0pICovXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNFTEVDVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKHNlbGVjdGVkRmVhdHVyZXMpKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIXNvdXJjZXMuaW5jbHVkZXMob3JpZ2luYWxGZWF0dXJlLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VzLnB1c2gob3JpZ2luYWxGZWF0dXJlLnNvdXJjZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnR5cGUgPT09ICdwaW5uaW5nJyAmJiBjb29yZHMpIHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50JyA/IG9yaWdpbmFsRmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyA9IGNvb3JkcyA6XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxGZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyAmJiBjb29yZHMgPyBvcmlnaW5hbEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bZmVhdHVyZS5pbmRleF0gPSBjb29yZHMgOlxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgJiYgY29vcmRzID8gb3JpZ2luYWxGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzW2ZlYXR1cmUuaW5kZXhdID0gY29vcmRzIDpcbiAgICAgICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgICAgICBvcmlnaW5hbEZlYXR1cmUucHJvcGVydGllcyA9IGZlYXR1cmUucHJvcGVydGllcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3B0aW9ucy5hZGRVbml0cyA/IHRoaXMuYWRkVW5pdHMob3JpZ2luYWxGZWF0dXJlKSA6IGZhbHNlO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICB0aGlzLnVwZGF0aW5nRmVhdHVyZXMgPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXNvdXJjZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLnVwZGF0ZVNvdXJjZShzb3VyY2VzKTtcbiAgICB9O1xuXG4gICAgXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkZlYXR1cmVzXG5cdCAqIEBuYW1lIHVwZGF0ZVNvdXJjZVxuXHQgKiBAZGVzY3JpcHRpb24gVXBkYXRlcyB0aGUgc291cmNlIG9mIHRoZSBjdXJyZW50IG9iamVjdCB3aXRoIHRoZSBwcm92aWRlZCBzb3VyY2VzLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIC0gQW4gYXJyYXkgb2Ygc291cmNlcyB0byB1cGRhdGUgdGhlIGN1cnJlbnQgb2JqZWN0IHdpdGguXG5cdCAqIEByZXR1cm5zIHthbnl9IFRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgdXBkYXRlU291cmNlIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIHNvdXJjZXMuXG5cdCAqL1xuICAgIHRoaXMudXBkYXRlU291cmNlID0gZnVuY3Rpb24gKHNvdXJjZXMpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNvdXJjZS5jYWxsKHRoaXMsIHNvdXJjZXMpO1xuICAgIH07XG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5GZWF0dXJlc1xuXHQgKiBAbmFtZSByZW1vdmVGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiByZW1vdmVzIGZlYXR1cmVzIGZyb20gdGhlIG1hcCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgSUQgb3IgYXJyYXkgb2YgSURzLiBJdCB1cGRhdGVzIHRoZSBtYXAgc291cmNlIGFmdGVyIHJlbW92aW5nIHRoZSBmZWF0dXJlcy5cblx0ICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IGlkIC0gVGhlIElEIG9yIGFycmF5IG9mIElEcyBvZiB0aGUgZmVhdHVyZXMgdG8gYmUgcmVtb3ZlZC5cblx0ICogQHBhcmFtIHtib29sZWFufSByZW1vdmUgLSBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHJlbW92ZSB0aGUgZmVhdHVyZXMgb3Igbm90LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0W119IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHJlbW92ZWQgZmVhdHVyZXMuXG5cdCAqL1xuICAgIHRoaXMucmVtb3ZlRmVhdHVyZXMgPSBmdW5jdGlvbiAoaWQsIHJlbW92ZSkge1xuICAgICAgICBjb25zdCByZW1vdmVkRmVhdHVyZXMgPSBbXTtcblxuICAgICAgICB2YXIgZmVhdHVyZTtcbiAgICAgICAgdmFyIHNvdXJjZXM7XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaWQpICYmIHJlbW92ZSkge1xuICAgICAgICAgICAgc291cmNlcyA9IGlkLm1hcChmdW5jdGlvbihsYXllcikgeyByZXR1cm4gbGF5ZXIuZGV0YWlscyA/IGxheWVyLmRldGFpbHMuaWQgOiBsYXllci5pZCA/IGxheWVyLmlkIDogbGF5ZXIgfSk7XG5cbiAgICAgICAgICAgIGNvbGRGZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzb3VyY2VzLmluY2x1ZGVzKGZlYXR1cmUuc291cmNlKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IGNvbGRGZWF0dXJlcy5maW5kSW5kZXgoKGYpID0+IHsgcmV0dXJuIGZlYXR1cmUuaWQgPT09IGYuaWQgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkID09PSBmLmlkIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKSByZW1vdmVkRmVhdHVyZXMucHVzaCguLi5jb2xkRmVhdHVyZXMuc3BsaWNlKGluZGV4LCAxKSk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNvdXJjZShzb3VyY2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSByZW1vdmUgPyBjb2xkRmVhdHVyZXMuZmluZEluZGV4KChmZWF0dXJlKSA9PiB7IHJldHVybiBmZWF0dXJlLmlkID09PSBpZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IGlkIH0pIDpcbiAgICAgICAgICAgIGNvbGRGZWF0dXJlcy5maW5kKChmZWF0dXJlKSA9PiB7IHJldHVybiBmZWF0dXJlLmlkID09PSBpZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IGlkIH0pO1xuXG4gICAgICAgICAgICBpZiAocmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVkRmVhdHVyZXMucHVzaCguLi5jb2xkRmVhdHVyZXMuc3BsaWNlKGZlYXR1cmUsIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlcyA9IHJlbW92ZWRGZWF0dXJlcy5tYXAoKGZlYXR1cmUpID0+IHsgcmV0dXJuIGZlYXR1cmUuc291cmNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNvdXJjZShzb3VyY2VzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlZEZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGZWF0dXJlU3RhdGUoaWQsIHsgaGlkZGVuOiB0cnVlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlbW92ZWRGZWF0dXJlcztcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5GZWF0dXJlc1xuXHQgKiBAbmFtZSBkZWxldGVGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gRGVsZXRlcyBhbGwgZmVhdHVyZXMgZnJvbSB0aGUgY29sZEZlYXR1cmVzIGFycmF5IGFuZCB1cGRhdGVzIHRoZSBzb3VyY2UuXG5cdCAqIEBwYXJhbXMge0FycmF5fSBjb2xkRmVhdHVyZXMgLSBUaGUgYXJyYXkgb2YgZmVhdHVyZXMgdG8gYmUgZGVsZXRlZC5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMuZGVsZXRlRmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbGRGZWF0dXJlcy5zcGxpY2UoMCwgY29sZEZlYXR1cmVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMudXBkYXRlU291cmNlKCk7XG4gICAgfTtcbiAgICBcblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5GZWF0dXJlc1xuXHQgKiBAbmFtZSBjb252ZXJ0VW5pdHNcblx0ICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIHRoZSBnaXZlbiB1bml0cyBvZiBhIGZlYXR1cmUgdG8gdGhlIHNwZWNpZmllZCB0YXJnZXQgdW5pdHMgYmFzZWQgb24gdGhlIGZlYXR1cmUgdHlwZSAoUG9seWxpbmUsIFBvbHlnb24sIG9yIFJlY3RhbmdsZSkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlIC0gVGhlIGZlYXR1cmUgb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyBsaWtlIHR5cGUuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB1bml0cyAtIFRoZSB1bml0cyB0byBiZSBjb252ZXJ0ZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjb252ZXJ0VG8gLSBUaGUgdGFyZ2V0IHVuaXRzIHRvIGNvbnZlcnQgdG8gKG9wdGlvbmFsKS5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIGNvbnZlcnRlZCB1bml0cyBpbiB0aGUgdGFyZ2V0IHVuaXQgZm9ybWF0LlxuXHQgKi9cbiAgICB0aGlzLmNvbnZlcnRVbml0cyA9IGZ1bmN0aW9uIChmZWF0dXJlLCB1bml0cywgY29udmVydFRvKSB7XG4gICAgICAgIGlmICghZmVhdHVyZSkgcmV0dXJuIDA7XG4gICAgICAgIFxuICAgICAgICB2YXIgdHlwZSA9IGZlYXR1cmUucHJvcGVydGllcy50eXBlO1xuICAgICAgICB2YXIgdW5pdCA9IGNvbnZlcnRUbyB8fCB0aGlzLmdldFVuaXQoZmVhdHVyZSk7XG5cbiAgICAgICAgdW5pdHMgPSB1bml0cyB8fCB0aGlzLmdldFVuaXRzKGZlYXR1cmUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGUgPT09IFwiUG9seWxpbmVcIikge1xuICAgICAgICAgICAgdW5pdHMgPSBNYXRoLnJvdW5kKHR1cmYuY29udmVydExlbmd0aCh1bml0cywgJ21ldGVycycsIHVuaXQpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgICAgIHVuaXRzID0gTWF0aC5yb3VuZCh0dXJmLmNvbnZlcnRBcmVhKHVuaXRzLCAnbWV0ZXJzJywgdW5pdCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdSZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICB1bml0cyA9IE1hdGgucm91bmQodHVyZi5jb252ZXJ0QXJlYSh1bml0cywgJ21ldGVycycsIHVuaXQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHVuaXRzID0gdW5pdHMgPyBOdW1iZXIodW5pdHMudG9GaXhlZCgyKSkgOiAwO1xuICAgICAgICByZXR1cm4gdW5pdHM7XG4gICAgfTtcblxuICAgIFxuXG5cbiAgICBmdW5jdGlvbiBnZXRGZWF0dXJlQnlJZChpZCkge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGNvbGRGZWF0dXJlcy5maW5kKChmZWF0dXJlKSA9PiB7IHJldHVybiBmZWF0dXJlLmlkID09PSBpZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQgPT09IGlkIH0pO1xuICAgICAgICBmZWF0dXJlID0gZmVhdHVyZSB8fCBnZW9mbG8uZ2V0U2VsZWN0ZWRGZWF0dXJlcygpLmZpbmQoKGZlYXR1cmUpID0+IHsgcmV0dXJuIGZlYXR1cmUuaWQgPT09IGlkIHx8IGZlYXR1cmUucHJvcGVydGllcy5pZCA9PT0gaWQgfSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBnZXRGZWF0dXJlc0J5UGFyZW50IChpZCkge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IHR5cGVvZiBpZCA9PT0gJ29iamVjdCcgJiYgaWQuaWQgPyBpZCA6IGdldEZlYXR1cmVCeUlkKGlkKTtcbiAgICAgICAgaWYgKCFmZWF0dXJlIHx8ICFmZWF0dXJlLnNvdXJjZSB8fCAhZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZmVhdHVyZS5zb3VyY2UpIHx8ICFnZW9mbG8ubWFwLmdldFNvdXJjZShmZWF0dXJlLnNvdXJjZSkuX2RhdGEpIHJldHVybiBbXTtcbiAgICAgICAgdmFyIGZpZWxkID0gZ2VvZmxvLm9wdGlvbnMub2Zmc2V0T3ZlcmxhcHBpbmdMaW5lcyA/ICdwYXJlbnQnIDogJ2lkJztcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZmVhdHVyZS5zb3VyY2UpLl9kYXRhLmZlYXR1cmVzLmZpbHRlcihmdW5jdGlvbihmKSB7IHJldHVybiBmW2ZpZWxkXSA9PT0gaWQgfHwgZi5wcm9wZXJ0aWVzW2ZpZWxkXSA9PT0gaWQgfSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlVGV4dEZlYXR1cmVzIChmZWF0dXJlKSB7XG4gICAgICAgIHZhciBpc0xpbmUgPSBnZW9mbG8uVXRpbGl0aWVzLmlzVmFsaWRMaW5lU3RyaW5nKGZlYXR1cmUpO1xuICAgICAgICB2YXIgc2VnbWVudHMgPSBbXTtcblxuICAgICAgICBpZiAoaXNMaW5lKSB7XG4gICAgICAgICAgICB0dXJmLnNlZ21lbnRFYWNoKGZlYXR1cmUsIGZ1bmN0aW9uIChjdXJyZW50U2VnbWVudCkge1xuICAgICAgICAgICAgICAgIHZhciBzZWdtZW50ID0gZ2VvZmxvLlV0aWxpdGllcy5jbG9uZURlZXAoY3VycmVudFNlZ21lbnQpO1xuICAgICAgICAgICAgICAgIHZhciBmb290YWdlID0gTWF0aC5yb3VuZCh0dXJmLmxlbmd0aChzZWdtZW50LCB7IHVuaXRzOiAnbWlsZXMnIH0pICogNTI4MCk7XG4gICAgICAgICAgICAgICAgdmFyIG1pbGVhZ2UgPSBOdW1iZXIodHVyZi5sZW5ndGgoc2VnbWVudCwgeyB1bml0czogJ21pbGVzJyB9KS50b0ZpeGVkKDMpKTtcbiAgICAgICAgICAgICAgICBmb290YWdlID0gTnVtYmVyKGZvb3RhZ2UudG9GaXhlZCgyKSk7XG4gICAgICAgICAgICAgICAgbWlsZWFnZSA9IE51bWJlcihtaWxlYWdlLnRvRml4ZWQoMikpO1xuXG4gICAgICAgICAgICAgICAgc2VnbWVudC5wcm9wZXJ0aWVzLmZvb3RhZ2UgPSBmb290YWdlO1xuICAgICAgICAgICAgICAgIHNlZ21lbnQucHJvcGVydGllcy5taWxlYWdlID0gbWlsZWFnZTtcbiAgICAgICAgICAgICAgICBzZWdtZW50LnByb3BlcnRpZXMudGV4dCA9IGAke21pbGVhZ2V9IG1pbGVzYDs7XG4gICAgICAgICAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHNlZ21lbnRzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVTb3VyY2UgKHNvdXJjZXM9W10pIHtcbiAgICAgICAgdmFyIHNvdXJjZUZlYXR1cmVzID0ge307XG4gICAgICAgIHZhciB1bnNvdXJjZUZlYXR1cmVzID0gW107XG4gICAgICAgIHZhciB0ZXh0U291cmNlID0gZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuQ09MRFRFWFQpO1xuICAgICAgICB2YXIgY29sZFNvdXJjZSA9IGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkNPTEQpO1xuXG4gICAgICAgIGdlb2Zsby51cGRhdGluZ1NvdXJjZSA9IHRydWU7XG5cbiAgICAgICAgdGV4dFNvdXJjZSA/IHRleHRTb3VyY2Uuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSkgOiBmYWxzZTtcbiAgICAgICAgY29sZFNvdXJjZSA/IGNvbGRTb3VyY2Uuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSkgOiBmYWxzZTtcblxuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TRUxFQ1QpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuXG4gICAgICAgIGNvbGRGZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgZmVhdHVyZS5wcm9wZXJ0aWVzLm5ldztcbiAgICAgICAgICAgIGRlbGV0ZSBmZWF0dXJlLnByb3BlcnRpZXMub2Zmc2V0O1xuXG4gICAgICAgICAgICB2YXIgc291cmNlID0gZmVhdHVyZS5zb3VyY2U7XG4gICAgICAgICAgICBpZiAoc291cmNlcy5sZW5ndGggJiYgIXNvdXJjZXMuaW5jbHVkZXMoc291cmNlKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpIHJldHVybiB1bnNvdXJjZUZlYXR1cmVzLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICBpZiAoIXNvdXJjZUZlYXR1cmVzW3NvdXJjZV0pIHNvdXJjZUZlYXR1cmVzW3NvdXJjZV0gPSBbXTtcbiAgICAgICAgICAgIHNvdXJjZUZlYXR1cmVzW3NvdXJjZV0ucHVzaChmZWF0dXJlKTtcbiAgICAgICAgfSlcblxuICAgICAgICBpZiAoIWNvbGRGZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGdlb2Zsby5MYXllcnMuZ2V0Q3VzdG9tTGF5ZXJzKCkuZm9yRWFjaCgobGF5ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyLmRldGFpbHMgfHwgIWxheWVyLmRldGFpbHMuc291cmNlKSByZXR1cm47XG4gICAgICAgICAgICAgICAgdmFyIHNvdXJjZSA9IGxheWVyLmRldGFpbHMuc291cmNlO1xuICAgICAgICAgICAgICAgIGlmICghZ2VvZmxvLm1hcC5nZXRTb3VyY2Uoc291cmNlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKHNvdXJjZSkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMoc291cmNlRmVhdHVyZXMpLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZW50cnlbMF07XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIGlmICghZ2VvZmxvLm1hcC5nZXRTb3VyY2Uoc291cmNlKSkgcmV0dXJuIHVuc291cmNlRmVhdHVyZXMucHVzaChmZWF0dXJlcyk7XG4gICAgICAgICAgICBzZXRMaW5lT2Zmc2V0KGZlYXR1cmVzLCBzb3VyY2UpO1xuICAgICAgICB9KVxuXG4gICAgICAgIHNldExpbmVPZmZzZXQodW5zb3VyY2VGZWF0dXJlcy5mbGF0KCksIGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkNPTEQpO1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHt0aGlzLnNldEZlYXR1cmVzU3RhdGUoY29sZEZlYXR1cmVzLCB7IGhpZGRlbjogZmFsc2UgfSk7IH0sIDEwMCk7XG4gICAgICAgIGdlb2Zsby5maXJlKCdmZWF0dXJlcy51cGRhdGUnLCB7IGZlYXR1cmVzOiBjb2xkRmVhdHVyZXMgfSk7XG4gICAgICAgIHNvdXJjZUZlYXR1cmVzID0gbnVsbDtcbiAgICAgICAgdW5zb3VyY2VGZWF0dXJlcyA9IG51bGw7XG4gICAgICAgIGdlb2Zsby51cGRhdGluZ1NvdXJjZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29sZEZlYXR1cmVzO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRMaW5lVGV4dCAoc2VnbWVudCkge1xuICAgICAgICBzZWdtZW50ID0gZ2VvZmxvLlV0aWxpdGllcy5jbG9uZURlZXAoc2VnbWVudCk7XG4gICAgICAgIHNlZ21lbnQucHJvcGVydGllcy50eXBlID0gdGhpcy5jdXJyZW50VHlwZTtcbiAgICAgICAgXG4gICAgICAgIHZhciB0ZXh0ID0gdHVyZi5wb2ludChzZWdtZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdKTtcbiAgICAgICAgdmFyIHVuaXRzID0gdGhpcy5nZXRVbml0cyhzZWdtZW50KTtcbiAgICAgICAgdmFyIHVuaXQgPSAnZmVldCc7XG5cbiAgICAgICAgdW5pdHMgPSB0aGlzLmNvbnZlcnRVbml0cyhzZWdtZW50LCB1bml0cywgdW5pdCk7XG5cbiAgICAgICAgdGV4dC5wcm9wZXJ0aWVzLnVuaXRzID0gdW5pdHM7XG4gICAgICAgIHRleHQucHJvcGVydGllcy51bml0ID0gdW5pdDtcbiAgICAgICAgdGV4dC5wcm9wZXJ0aWVzLnRleHQgPSBgJHt1bml0c30gJHt1bml0fWA7XG4gICAgICAgIHRleHQucHJvcGVydGllcy50cmFuc2Zvcm0gPSAndXBwZXJjYXNlJztcbiAgICAgICAgdGV4dC5wcm9wZXJ0aWVzLmFuY2hvciA9ICdib3R0b20tbGVmdCc7XG5cbiAgICAgICAgdGhpcy50ZXh0RmVhdHVyZXMucHVzaCh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0TGluZU9mZnNldCAoZmVhdHVyZXMsIHNvdXJjZSkge1xuICAgICAgICBpZiAoIWZlYXR1cmVzIHx8ICFmZWF0dXJlcy5sZW5ndGggfHwgIXNvdXJjZSB8fCAhZ2VvZmxvLm1hcC5nZXRTb3VyY2Uoc291cmNlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWdlb2Zsby5vcHRpb25zLm9mZnNldE92ZXJsYXBwaW5nTGluZXMpIHJldHVybiBnZW9mbG8ubWFwLmdldFNvdXJjZShzb3VyY2UpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcykpO1xuXG4gICAgICAgIHZhciBtZXNoID0gbmV3IGdlb2Zsby5NZXNoKGZlYXR1cmVzLCB0cnVlKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IG1lc2guZ2V0RmVhdHVyZXMoKTtcblxuICAgICAgICBvZmZzZXQuZm9yRWFjaChmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmZWF0dXJlcy5maW5kKGZ1bmN0aW9uIChmZSkgeyByZXR1cm4gZmUuaWQgPT09IGZlYXR1cmUucGFyZW50IH0pO1xuICAgICAgICAgICAgaWYgKCFmKSByZXR1cm47XG4gICAgICAgICAgICBmZWF0dXJlLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5zdHlsZSA9IGYucHJvcGVydGllcy5zdHlsZSB8fCBmZWF0dXJlLnByb3BlcnRpZXMuc3R5bGU7XG4gICAgICAgICAgICBzZXRPdmVybGFwT2Zmc2V0KG9mZnNldCwgZmVhdHVyZSlcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2Uoc291cmNlKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24ob2Zmc2V0KSk7XG4gICAgICAgIGdlb2Zsby5maXJlKCdmZWF0dXJlcy5vZmZzZXQnLCB7IGZlYXR1cmVzOiBmZWF0dXJlcywgb2Zmc2V0OiBvZmZzZXQsIHNvdXJjZTogc291cmNlIH0pO1xuXG4gICAgICAgIG1lc2ggPSBudWxsO1xuICAgICAgICBvZmZzZXQgPSBudWxsO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRPdmVybGFwT2Zmc2V0IChmZWF0dXJlcywgZmVhdHVyZSkge1xuICAgICAgICBpZiAoIWdlb2Zsby5vcHRpb25zLm9mZnNldE92ZXJsYXBwaW5nTGluZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFpc1BvbHlsaW5lKGZlYXR1cmUpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChmZWF0dXJlLnByb3BlcnRpZXMub2Zmc2V0KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IDY7XG4gICAgICAgIHZhciBvdmVybGFwcyA9IFtdO1xuXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgIGlmICghaXNQb2x5bGluZShmKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGYucGFyZW50ID09PSBmZWF0dXJlLnBhcmVudCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKGYucHJvcGVydGllcy5vZmZzZXQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIG92ZXJsYXAgPSB0dXJmLmJvb2xlYW5PdmVybGFwKGYsIGZlYXR1cmUpIHx8IHR1cmYuYm9vbGVhbldpdGhpbihmLCBmZWF0dXJlKTtcbiAgICAgICAgICAgIGlmICghb3ZlcmxhcCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgICAgICBvdmVybGFwcy5wdXNoKGYpXG4gICAgICAgIH0sIHRoaXMpXG5cbiAgICAgICAgb3ZlcmxhcHMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgZi5wcm9wZXJ0aWVzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCA9IG9mZnNldCAqIDI7XG4gICAgICAgIH0sIHRoaXMpXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHNldFdpdGhpbk9mZnNldCAoZmVhdHVyZXMpIHtcbiAgICAgICAgaWYgKCFnZW9mbG8ub3B0aW9ucy5vZmZzZXRPdmVybGFwcGluZ0xpbmVzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgY29uc3QgYWRkZXIgPSA0O1xuICAgICAgICBjb25zdCBtaWxlcyA9IDAuMDAxODkzOTQ7IC8vIDEwIEZlZXRcbiAgICAgICAgY29uc3QgZXhwbG9kZSA9IHR1cmYuZXhwbG9kZSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKSlcbiAgICAgICAgXG4gICAgICAgIGlmICghZXhwbG9kZSB8fCAhZXhwbG9kZS5mZWF0dXJlcy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICBleHBsb2RlLmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgaWYgKGZlYXR1cmUucHJvcGVydGllcy5vZmZzZXQpIHJldHVybiBmYWxzZTtcblxuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHR1cmYuYnVmZmVyKGZlYXR1cmUsIG1pbGVzLCB7dW5pdHM6ICdtaWxlcyd9KTtcbiAgICAgICAgICAgIHZhciB3aXRoaW4gPSB0dXJmLnBvaW50c1dpdGhpblBvbHlnb24oZXhwbG9kZSwgYnVmZmVyKTtcblxuICAgICAgICAgICAgaWYgKCF3aXRoaW4gfHwgIXdpdGhpbi5mZWF0dXJlcy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICAgICAgdmFyIG9mZnNldCA9IGFkZGVyO1xuXG4gICAgICAgICAgICB3aXRoaW4uZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIGlmIChmLnByb3BlcnRpZXMuaWQgPT09IGZlYXR1cmUucHJvcGVydGllcy5pZCB8fCBmLnByb3BlcnRpZXMub2Zmc2V0KSByZXR1cm47XG4gICAgICAgICAgICAgICAgZi5wcm9wZXJ0aWVzLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyBhZGRlcjtcbiAgICAgICAgICAgIH0pICAgICAgICAgICAgXG4gICAgICAgIH0pXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzUG9seWxpbmUgKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0eXBlID0gZ2VvZmxvLkxheWVycy5nZXRMYXllclR5cGUoZmVhdHVyZS5zb3VyY2UpO1xuICAgICAgICByZXR1cm4gdHVyZi5nZXRUeXBlKGZlYXR1cmUpID09PSAnTGluZVN0cmluZyc7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzUG9seWdvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoIWZlYXR1cmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHR5cGUgPSBnZW9mbG8uTGF5ZXJzLmdldExheWVyVHlwZShmZWF0dXJlLnNvdXJjZSk7XG4gICAgICAgIHJldHVybiB0dXJmLmdldFR5cGUoZmVhdHVyZSkgPT09ICdQb2x5Z29uJyB8fCBmZWF0dXJlLnByb3BlcnRpZXMudHlwZSA9PT0gJ1BvbHlnb24nIHx8IHR5cGUgPT09ICdQb2x5Z29uJztcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gaXNSZWN0YW5nbGUgKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0eXBlID0gZ2VvZmxvLkxheWVycy5nZXRMYXllclR5cGUoZmVhdHVyZS5zb3VyY2UpO1xuICAgICAgICByZXR1cm4gdHVyZi5nZXRUeXBlKGZlYXR1cmUpID09PSAnUG9seWdvbicgJiYgZmVhdHVyZS5wcm9wZXJ0aWVzLnR5cGUgPT09ICdSZWN0YW5nbGUnIHx8IHR5cGUgPT09ICdSZWN0YW5nbGUnO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpc1BvaW50IChmZWF0dXJlKSB7XG4gICAgICAgIGlmICghZmVhdHVyZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgdHlwZSA9IGdlb2Zsby5MYXllcnMuZ2V0TGF5ZXJUeXBlKGZlYXR1cmUuc291cmNlKTtcbiAgICAgICAgaWYgKHR1cmYuZ2V0VHlwZShmZWF0dXJlKSA9PT0gJ1BvaW50JyAmJiAoIWZlYXR1cmUucHJvcGVydGllcy50eXBlIHx8IGZlYXR1cmUucHJvcGVydGllcy50eXBlID09PSAnQ2lyY2xlJykpIHJldHVybiB0cnVlO1xuICAgICAgICBpZiAodHVyZi5nZXRUeXBlKGZlYXR1cmUpID09PSAnUG9pbnQnICYmICh0eXBlID09PSAnUG9pbnQnIHx8IHR5cGUgPT09ICdDaXJjbGUnKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0dXJmLmdldFR5cGUoZmVhdHVyZSkgPT09ICdQb2ludCcgJiYgKGZlYXR1cmUucHJvcGVydGllcy50eXBlICE9PSAnVGV4dCcgJiYgZmVhdHVyZS5wcm9wZXJ0aWVzLnR5cGUgIT09ICdJY29uJyAmJiBmZWF0dXJlLnByb3BlcnRpZXMudHlwZSAhPT0gJ0ltYWdlJyk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzVGV4dCAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoIWZlYXR1cmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHR5cGUgPSBnZW9mbG8uTGF5ZXJzLmdldExheWVyVHlwZShmZWF0dXJlLnNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnVGV4dCcpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdHVyZi5nZXRUeXBlKGZlYXR1cmUpID09PSAnUG9pbnQnICYmIGZlYXR1cmUucHJvcGVydGllcy50eXBlID09PSAnVGV4dCc7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzSWNvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoIWZlYXR1cmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgbGV0IHR5cGUgPSBnZW9mbG8uTGF5ZXJzLmdldExheWVyVHlwZShmZWF0dXJlLnNvdXJjZSk7XG4gICAgICAgIGlmICh0eXBlID09PSAnSWNvbicpIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gdHVyZi5nZXRUeXBlKGZlYXR1cmUpID09PSAnUG9pbnQnICYmIGZlYXR1cmUucHJvcGVydGllcy50eXBlID09PSAnSWNvbic7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGlzSW1hZ2UgKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGxldCB0eXBlID0gZ2VvZmxvLkxheWVycy5nZXRMYXllclR5cGUoZmVhdHVyZS5zb3VyY2UpO1xuICAgICAgICBpZiAodHlwZSA9PT0gJ0ltYWdlJykgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiB0dXJmLmdldFR5cGUoZmVhdHVyZSkgPT09ICdQb2ludCcgJiYgZmVhdHVyZS5wcm9wZXJ0aWVzLnR5cGUgPT09ICdJbWFnZSc7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGdldFR5cGUgKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlKSByZXR1cm4gbnVsbDtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBpc1JlY3RhbmdsZShmZWF0dXJlKSA/ICdSZWN0YW5nbGUnIDpcbiAgICAgICAgaXNQb2x5Z29uKGZlYXR1cmUpID8gJ1BvbHlnb24nIDpcbiAgICAgICAgaXNQb2x5bGluZShmZWF0dXJlKSA/ICdQb2x5bGluZScgOlxuICAgICAgICBpc1RleHQoZmVhdHVyZSkgPyAnVGV4dCcgOlxuICAgICAgICBpc0ljb24oZmVhdHVyZSkgPyAnSWNvbicgOlxuICAgICAgICBpc0ltYWdlKGZlYXR1cmUpID8gJ0ltYWdlJyA6XG4gICAgICAgIGlzUG9pbnQoZmVhdHVyZSkgPyAnQ2lyY2xlJyA6XG4gICAgICAgIG51bGw7XG4gICAgfTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEZlYXR1cmVzOyIsIi8qKlxuICogQG1peGluXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsb1xuICogQG5hbWUgR2FtZXBhZFxuICogQGRlc2NyaXB0aW9uIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBnYW1lcGFkIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBHZW9mbG8gYXBwbGljYXRpb24uIEl0IGFsbG93cyB1c2VycyB0byBpbnRlcmFjdCB3aXRoIHRoZSBtYXAgdXNpbmcgYSBnYW1lcGFkIGNvbnRyb2xsZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gZ2FtZXBhZCAtIFRoZSBnYW1lcGFkIG9iamVjdCB0byBiZSBpbml0aWFsaXplZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGdhbWVwYWQgaW5pdGlhbGl6YXRpb24uIENvbWVzIGZyb20gZ2VvRmxvLm9wdGlvbnMuZ2FtZXBhZC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjdXJyZW50IG9iamVjdCBpbnN0YW5jZS5cbiAqL1xuY29uc3QgR2FtZXBhZCA9IGZ1bmN0aW9uIChnYW1lcGFkKSB7XG4gICAgY29uc3QgZ2VvZmxvID0gdGhpcy5nZW9mbG87XG5cbiAgICBpZiAoIXN1cHBvcnRlZCgpKSB0aHJvdyBuZXcgRXJyb3IoJ0dhbWVwYWRzIGFyZSBub3Qgc3VwcG9ydGVkIG9uIHlvdXIgYnJvd3NlciEnKTtcbiAgICBcbiAgICBjb25zdCBjb250cm9sID0gdGhpcztcblxuICAgIHRoaXMub3B0aW9ucyA9IGdlb2Zsby5vcHRpb25zLmdhbWVwYWQ7XG5cbiAgICBjb25zdCBsYXlvdXQgPSB7XG4gICAgICAgIFwic2VsZWN0XCI6ICdTZWxlY3QnLFxuICAgICAgICBcInN0YXJ0XCI6ICdTdGFydCcsXG4gICAgICAgIFwicG93ZXJcIjogJ1Bvd2VyJyxcbiAgICAgICAgXCJidXR0b24wXCI6ICdCJyxcbiAgICAgICAgXCJidXR0b24xXCI6ICdBJyxcbiAgICAgICAgXCJidXR0b24yXCI6ICdZJyxcbiAgICAgICAgXCJidXR0b24zXCI6ICdYJyxcbiAgICAgICAgXCJidXR0b240XCI6ICdCdW1wTGVmdCcsXG4gICAgICAgIFwiYnV0dG9uNVwiOiAnQnVtcFJpZ2h0JyxcbiAgICAgICAgXCJidXR0b242XCI6ICdUcmlnTGVmdCcsXG4gICAgICAgIFwiYnV0dG9uN1wiOiAnVHJpZ1JpZ2h0JyxcbiAgICAgICAgXCJidXR0b244XCI6ICdTZWxlY3QnLFxuICAgICAgICBcImJ1dHRvbjlcIjogJ1N0YXJ0JyxcbiAgICAgICAgXCJidXR0b24xMFwiOiAnSm95TGVmdENsaWNrJyxcbiAgICAgICAgXCJidXR0b24xMVwiOiAnSm95UmlnaHRDbGljaycsXG4gICAgICAgIFwiYnV0dG9uMTJcIjogJ0RwYWRVcCcsXG4gICAgICAgIFwiYnV0dG9uMTNcIjogJ0RwYWREb3duJyxcbiAgICAgICAgXCJidXR0b24xNFwiOiAnRHBhZExlZnQnLFxuICAgICAgICBcImJ1dHRvbjE1XCI6ICdEcGFkUmlnaHQnLFxuICAgICAgICBcImJ1dHRvbjE2XCI6ICdQb3dlcicsXG4gICAgICAgIFwiYnV0dG9uMTdcIjogJ01pc2MnLFxuICAgICAgICBcInVwMFwiOiAnSm95TGVmdFVwJyxcbiAgICAgICAgXCJkb3duMFwiOiAnSm95TGVmdERvd24nLFxuICAgICAgICBcInJpZ2h0MFwiOiAnSm95TGVmdFJpZ2h0JyxcbiAgICAgICAgXCJsZWZ0MFwiOiAnSm95TGVmdExlZnQnLFxuICAgICAgICBcInVwMVwiOiAnSm95UmlnaHRVcCcsXG4gICAgICAgIFwiZG93bjFcIjogJ0pveVJpZ2h0RG93bicsXG4gICAgICAgIFwicmlnaHQxXCI6ICdKb3lSaWdodFJpZ2h0JyxcbiAgICAgICAgXCJsZWZ0MVwiOiAnSm95UmlnaHRMZWZ0JyxcbiAgICAgICAgXCJsMVwiOiAnQnVtcExlZnQnLFxuICAgICAgICBcInIxXCI6ICdCdW1wUmlnaHQnLFxuICAgICAgICBcImwyXCI6ICdUcmlnTGVmdCcsXG4gICAgICAgIFwicjJcIjogJ1RyaWdSaWdodCdcbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNsYW1wKHgsIHkpIHtcbiAgICAgICAgbGV0IG0gPSBNYXRoLnNxcnQoeCp4ICsgeSp5KTsgLy8gTWFnbml0dWRlIChsZW5ndGgpIG9mIHZlY3RvclxuXG4gICAgICAgIC8vIElmIHRoZSBsZW5ndGggZ3JlYXRlciB0aGFuIDEsIG5vcm1hbGl6ZSBpdCAoc2V0IGl0IHRvIDEpXG4gICAgICAgIGlmIChtID4gMSkge1xuICAgICAgICAgICAgeCAvPSBtO1xuICAgICAgICAgICAgeSAvPSBtO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWFkem9uZSh4LCB5LCBkZWFkem9uZT0wLjIpIHtcbiAgICAgICAgbGV0IG0gPSBNYXRoLnNxcnQoeCp4ICsgeSp5KTtcblxuICAgICAgICBpZiAobSA8IGRlYWR6b25lKVxuICAgICAgICAgICAgcmV0dXJuIFswLCAwXTtcblxuICAgICAgICBsZXQgb3ZlciA9IG0gLSBkZWFkem9uZTsgIC8vIDAgLT4gMSAtIERFQURaT05FXG4gICAgICAgIGxldCBub3ZlciA9IG92ZXIgLyAoMSAtIGRlYWR6b25lKTsgIC8vIDAgLT4gMVxuXG4gICAgICAgIGxldCBueCA9IHggLyBtO1xuICAgICAgICBsZXQgbnkgPSB5IC8gbTtcblxuICAgICAgICByZXR1cm4gW254ICogbm92ZXIsIG55ICogbm92ZXJdO1xuICAgICAgICBcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXF1ZXN0KCkge1xuICAgICAgICBjb250cm9sLnJlZnJlc2goKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlcXVlc3QpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN1cHBvcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuICh3aW5kb3cubmF2aWdhdG9yLmdldEdhbWVwYWRzICYmIHR5cGVvZiB3aW5kb3cubmF2aWdhdG9yLmdldEdhbWVwYWRzID09PSAnZnVuY3Rpb24nKSB8fFxuICAgICAgICAgICAgKHdpbmRvdy5uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMgJiYgdHlwZW9mIHdpbmRvdy5uYXZpZ2F0b3Iud2Via2l0R2V0R2FtZXBhZHMgPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgICAgICBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBxcyhzLCBwKSB7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICByZXR1cm4gcC5xdWVyeVNlbGVjdG9yKHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHMpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wuYXNzb2NpYXRlRXZlbnQoZXZlbnROYW1lLCBjYWxsYmFjaywgJ2FjdGlvbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFmdGVyKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wuYXNzb2NpYXRlRXZlbnQoZXZlbnROYW1lLCBjYWxsYmFjaywgJ2FmdGVyJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYmVmb3JlKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2wuYXNzb2NpYXRlRXZlbnQoZXZlbnROYW1lLCBjYWxsYmFjaywgJ2JlZm9yZScpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXJzKF90aGlzLCBnYW1lcGFkKSB7XG4gICAgICAgIGlmICghZ2FtZXBhZCB8fCAhbGF5b3V0KSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgT2JqZWN0LmVudHJpZXMobGF5b3V0KS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgdmFyIGtleSA9IGVudHJ5WzBdO1xuICAgICAgICAgICAgdmFyIHZhbCA9IGVudHJ5WzFdO1xuXG4gICAgICAgICAgICBiZWZvcmUoa2V5LCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLm9uRXZlbnQoJ3ByZXNzJywga2V5LCB2YWwsIHZhbHVlKTsgfSk7XG4gICAgICAgICAgICBvbihrZXksIGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gX3RoaXMub25FdmVudCgnaG9sZCcsIGtleSwgdmFsLCB2YWx1ZSk7IH0pO1xuICAgICAgICAgICAgYWZ0ZXIoa2V5LCBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIF90aGlzLm9uRXZlbnQoJ3JlbGVhc2UnLCBrZXksIHZhbCwgdmFsdWUpOyB9KTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWVwQXNzaWduKHRhcmdldCwgc291cmNlLCB7aXNNdXRhdGluZ09rID0gZmFsc2UsIGlzU3RyaWN0bHlTYWZlID0gZmFsc2V9ID0ge30pIHtcbiAgICAgICAgdGFyZ2V0ID0gaXNNdXRhdGluZ09rID8gdGFyZ2V0IDogY2xvbmUodGFyZ2V0LCBpc1N0cmljdGx5U2FmZSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gYG9iamVjdGApIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHt9O1xuICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IGRlZXBBc3NpZ24odGFyZ2V0W2tleV0sIHZhbCwge2lzTXV0YXRpbmdPazogdHJ1ZSwgaXNTdHJpY3RseVNhZmV9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjbG9uZShvYmosIGlzU3RyaWN0bHlTYWZlID0gZmFsc2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChpc1N0cmljdGx5U2FmZSkgeyB0aHJvdyBuZXcgRXJyb3IoKSB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKGBVbnNhZmUgY2xvbmUgb2Ygb2JqZWN0YCwgb2JqKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gey4uLm9ian07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZUludGVybWVkaWF0ZVBvaW50KHBvaW50MSwgcG9pbnQyLCBwZXJjKSB7XG4gICAgICAgIHZhciBsYXQxID0gZGVncmVlc1RvUmFkaWFucyhwb2ludDFbMV0pO1xuICAgICAgICB2YXIgbG5nMSA9IGRlZ3JlZXNUb1JhZGlhbnMocG9pbnQxWzBdKTtcbiAgICAgICAgdmFyIGxhdDIgPSBkZWdyZWVzVG9SYWRpYW5zKHBvaW50MlsxXSk7XG4gICAgICAgIHZhciBsbmcyID0gZGVncmVlc1RvUmFkaWFucyhwb2ludDJbMF0pO1xuXG4gICAgICAgIHZhciBkZWx0YUxhdCA9IGxhdDIgLSBsYXQxO1xuICAgICAgICB2YXIgZGVsdGFMbmcgPSBsbmcyIC0gbG5nMTtcbiAgICAgICAgXG4gICAgICAgIHZhciBjYWxjQSA9IE1hdGguc2luKGRlbHRhTGF0IC8gMikgKiBNYXRoLnNpbihkZWx0YUxhdCAvIDIpICsgTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguc2luKGRlbHRhTG5nIC8gMikgKiBNYXRoLnNpbihkZWx0YUxuZyAvIDIpO1xuICAgICAgICB2YXIgY2FsY0IgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoY2FsY0EpLCBNYXRoLnNxcnQoMSAtIGNhbGNBKSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgQSA9IE1hdGguc2luKCgxIC0gcGVyYykgKiBjYWxjQikgLyBNYXRoLnNpbihjYWxjQik7XG4gICAgICAgIHZhciBCID0gTWF0aC5zaW4ocGVyYyAqIGNhbGNCKSAvIE1hdGguc2luKGNhbGNCKTtcbiAgICAgICAgXG4gICAgICAgIHZhciB4ID0gQSAqIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobG5nMSkgKyBCICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhsbmcyKTtcbiAgICAgICAgdmFyIHkgPSBBICogTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsbmcxKSArIEIgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguc2luKGxuZzIpO1xuICAgICAgICB2YXIgeiA9IEEgKiBNYXRoLnNpbihsYXQxKSArIEIgKiBNYXRoLnNpbihsYXQyKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBsYXQzID0gTWF0aC5hdGFuMih6LCBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpO1xuICAgICAgICB2YXIgbG5nMyA9IE1hdGguYXRhbjIoeSwgeCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gW3JhZGlhbnNUb0RlZ3JlZXMobG5nMyksIHJhZGlhbnNUb0RlZ3JlZXMobGF0MyldXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcG9pbnRBdFBlcmNlbnQocDAsIHAxLCBwZXJjZW50KSB7XG4gICAgICAgIHZhciB4O1xuICAgICAgICBpZiAocDAueCAhPT0gcDEueClcbiAgICAgICAgICAgIHggPSBwMC54ICsgcGVyY2VudCAqIChwMS54IC0gcDAueCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHggPSBwMC54O1xuICAgIFxuICAgICAgICB2YXIgeTtcbiAgICAgICAgaWYgKHAwLnkgIT09IHAxLnkpXG4gICAgICAgICAgICB5ID0gcDAueSArIHBlcmNlbnQgKiAocDEueSAtIHAwLnkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB5ID0gcDAueTtcbiAgICBcbiAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgeTogeVxuICAgICAgICB9O1xuICAgIFxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWdyZWVzVG9SYWRpYW5zKGRlZ3JlZXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZ3JlZXMgKiAoTWF0aC5QSSAvIDE4MCk7XG4gICAgfVxuICAgICAgICBcbiAgICBmdW5jdGlvbiByYWRpYW5zVG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgICAgICAgcmV0dXJuIHJhZGlhbnMgKiAoMTgwIC8gTWF0aC5QSSApO1xuICAgIH1cblxuICAgIFxuXG5cblxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkdhbWVwYWRcblx0ICogQG5hbWUgaW5pdFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBpbml0aWFsaXplcyB0aGUgZ2FtZXBhZCB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy4gSXQgZmlyZXMgYW4gZXZlbnQgdG8gbm90aWZ5IHRoZSBnYW1lcGFkIGluaXRpYWxpemF0aW9uLCBzZXRzIHRoZSBnYW1lcGFkLCBhZGRzIGV2ZW50IGxpc3RlbmVycywgYW5kIHJlcXVlc3RzIGFuaW1hdGlvbiBmcmFtZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGdhbWVwYWQgLSBUaGUgZ2FtZXBhZCBvYmplY3QgdG8gYmUgaW5pdGlhbGl6ZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGdhbWVwYWQgaW5pdGlhbGl6YXRpb24uXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjdXJyZW50IG9iamVjdCBpbnN0YW5jZS5cblx0ICovXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKGdhbWVwYWQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFnYW1lcGFkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZSkgcmV0dXJuIGNvbnNvbGUuZXJyb3IoJ0dhbWVwYWQgb3B0aW9uIGlzIG5vdCBlbmFibGVkIScpXG4gICAgICAgIGdlb2Zsby5tYXAuZmlyZShnZW9mbG8uaWQgKyAnOmdhbWVwYWQuaW5pdCcsIHsgZGV0YWlsOiB7IGdhbWVwYWQ6IGdhbWVwYWQgfSB9KTtcbiAgICAgICAgdGhpcy5zZXRHYW1lcGFkKGdhbWVwYWQpO1xuICAgICAgICBhZGRFdmVudExpc3RlbmVycyh0aGlzLCB0aGlzLmdhbWVwYWQpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVxdWVzdCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uR2FtZXBhZFxuXHQgKiBAbmFtZSByZWZyZXNoXG5cdCAqIEBkZXNjcmlwdGlvbiBSZWZyZXNoZXMgdGhlIGdhbWVwYWQgc3RhdGUgYnkgY2hlY2tpbmcgYnV0dG9uIHByZXNzZXMsIGF4ZXMgdmFsdWVzLCBhbmQgdHJpZ2dlcnMuXG5cdCAqIEBwYXJhbXMge3ZvaWR9XG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBnYW1lcGFkcyA9IHdpbmRvdy5uYXZpZ2F0b3IuZ2V0R2FtZXBhZHMoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdhbWVwYWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZ2FtZXBhZCA9IGdhbWVwYWRzW3RoaXMuZ2FtZXBhZC5pZF07XG4gICAgICAgICAgICB2YXIgajtcblxuICAgICAgICAgICAgaWYgKCFnYW1lcGFkIHx8ICFnYW1lcGFkLmNvbm5lY3RlZCkgeyBjb250aW51ZTsgfVxuXG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2FtZXBhZC5idXR0b25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGdhbWVwYWQuYnV0dG9uc1tqXTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBidXR0b24udmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWUgPSB0aGlzLmdhbWVwYWQubGF5b3V0W2BidXR0b24ke2p9YF1cblxuICAgICAgICAgICAgICAgIGlmIChidXR0b24ucHJlc3NlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuZ2FtZXBhZC5wcmVzc2VkW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVwYWQucHJlc3NlZFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVwYWQuYnV0dG9uQWN0aW9uc1tqXS5iZWZvcmUgPyB0aGlzLmdhbWVwYWQuYnV0dG9uQWN0aW9uc1tqXS5iZWZvcmUodmFsdWUpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdhbWVwYWQuYnV0dG9uQWN0aW9uc1tqXS5hY3Rpb24gPyB0aGlzLmdhbWVwYWQuYnV0dG9uQWN0aW9uc1tqXS5hY3Rpb24odmFsdWUpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmdhbWVwYWQucHJlc3NlZFtuYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5nYW1lcGFkLnByZXNzZWRbbmFtZV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2FtZXBhZC5idXR0b25BY3Rpb25zW2pdLmFmdGVyID8gdGhpcy5nYW1lcGFkLmJ1dHRvbkFjdGlvbnNbal0uYWZ0ZXIodmFsdWUpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgYXhlc0JveENvdW50ID0gKChnYW1lcGFkLmF4ZXMubGVuZ3RoICsgMSkgLyAyKXwwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGF4ZXNCb3hDb3VudDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlWCwgdmFsdWVZLCB2YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdF9vZGRfYXhpcyA9IGogPT0gYXhlc0JveENvdW50IC0gMSAmJiBnYW1lcGFkLmF4ZXMubGVuZ3RoICUgMiA9PSAxO1xuXG4gICAgICAgICAgICAgICAgdmFsdWVYID0gZ2FtZXBhZC5heGVzW2oqMl07XG4gICAgICAgICAgICAgICAgdmFsdWVZID0gbGFzdF9vZGRfYXhpcyA/IDAgOiBnYW1lcGFkLmF4ZXNbaioyICsgMV07XG4gICAgICAgICAgICAgICAgW3ZhbHVlWCwgdmFsdWVZXSA9IGRlYWR6b25lKHZhbHVlWCwgdmFsdWVZKTsgICAgXG4gICAgICAgICAgICAgICAgW3ZhbHVlWCwgdmFsdWVZXSA9IGNsYW1wKHZhbHVlWCwgdmFsdWVZKTtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFtOdW1iZXIodmFsdWVYLnRvRml4ZWQoMikpLCBOdW1iZXIodmFsdWVZLnRvRml4ZWQoMikpXTtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGdhbWVwYWQuYXhlc1tqICsgYXhlc0JveENvdW50XS50b0ZpeGVkKDQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGF4ZSA9IE1hdGguZmxvb3IoaiAvIDIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZXBhZC5heGVWYWx1ZXNbYXhlXVtqICUgMl0gPSB2YWw7XG5cbiAgICAgICAgICAgICAgICB2YXIgcmlnaHRUcmlnZ2VyID0gdmFsdWVbMF0gPj0gdGhpcy5vcHRpb25zLmpveXN0aWNrLm1pbjtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdFRyaWdnZXIgPSB2YWx1ZVswXSA8PSAtdGhpcy5vcHRpb25zLmpveXN0aWNrLm1pbjtcbiAgICAgICAgICAgICAgICB2YXIgdXBUcmlnZ2VyID0gdmFsdWVbMV0gPD0gLXRoaXMub3B0aW9ucy5qb3lzdGljay5taW47XG4gICAgICAgICAgICAgICAgdmFyIGRvd25UcmlnZ2VyID0gdmFsdWVbMV0gPj0gdGhpcy5vcHRpb25zLmpveXN0aWNrLm1pbjtcblxuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcigncmlnaHQnLCByaWdodFRyaWdnZXIsIGosIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2xlZnQnLCBsZWZ0VHJpZ2dlciwgaiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcignZG93bicsIGRvd25UcmlnZ2VyLCBqLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCd1cCcsIHVwVHJpZ2dlciwgaiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5HYW1lcGFkXG5cdCAqIEBuYW1lIHRyaWdnZXJcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gaGFuZGxlcyB0cmlnZ2VyaW5nIGFjdGlvbnMgYmFzZWQgb24gZ2FtZXBhZCBpbnB1dC4gSXQgY2hlY2tzIGlmIGEgc3BlY2lmaWMgYnV0dG9uIG9yIGF4aXMgaXMgdHJpZ2dlcmVkIGFuZCBwZXJmb3JtcyBjb3JyZXNwb25kaW5nIGFjdGlvbnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZGVudGlmaWVyIG9mIHRoZSBnYW1lcGFkIGlucHV0LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWdnZXJlZCAtIEluZGljYXRlcyBpZiB0aGUgaW5wdXQgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGlucHV0LlxuXHQgKiBAcGFyYW0ge251bWJlcltdfSB2YWx1ZSAtIFRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQuXG5cdCAqL1xuICAgIHRoaXMudHJpZ2dlciA9IGZ1bmN0aW9uIChpZCwgdHJpZ2dlcmVkLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGFjdGlvbnMgPSB0aGlzLmdhbWVwYWQuYXhlc0FjdGlvbnM7XG4gICAgICAgIHZhciBuYW1lID0gdGhpcy5nYW1lcGFkLmxheW91dFtgJHtpZH0ke2luZGV4fWBdO1xuICAgICAgICB2YXIgcHJlc3NlZCA9IHRoaXMuZ2FtZXBhZC5wcmVzc2VkXG5cbiAgICAgICAgaWYgKHRyaWdnZXJlZCkge1xuICAgICAgICAgICAgaWYgKCFwcmVzc2VkW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgcHJlc3NlZFtuYW1lXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYWN0aW9uc1tpbmRleF1baWRdLmJlZm9yZSA/IGFjdGlvbnNbaW5kZXhdW2lkXS5iZWZvcmUodmFsdWUpIDogZmFsc2VcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWUgPSBbdGhpcy5vcHRpb25zLmpveXN0aWNrLm1heCAqIHZhbHVlWzBdLCB0aGlzLm9wdGlvbnMuam95c3RpY2subWF4ICogdmFsdWVbMV1dXG4gICAgICAgICAgICBhY3Rpb25zW2luZGV4XVtpZF0uYWN0aW9uID8gYWN0aW9uc1tpbmRleF1baWRdLmFjdGlvbih2YWx1ZSkgOiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChwcmVzc2VkW25hbWVdKSB7XG4gICAgICAgICAgICBkZWxldGUgcHJlc3NlZFtuYW1lXTtcblxuICAgICAgICAgICAgaWYgKCFwcmVzc2VkWydKb3lMZWZ0VXAnXSAmJiAhcHJlc3NlZFsnSm95TGVmdERvd24nXSAmJiAhcHJlc3NlZFsnSm95TGVmdExlZnQnXSAmJiAhcHJlc3NlZFsnSm95TGVmdFJpZ2h0J10pIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zWzBdW2lkXS5hZnRlciA/IGFjdGlvbnNbMF1baWRdLmFmdGVyKHZhbHVlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXByZXNzZWRbJ0pveVJpZ2h0VXAnXSAmJiAhcHJlc3NlZFsnSm95UmlnaHREb3duJ10gJiYgIXByZXNzZWRbJ0pveVJpZ2h0TGVmdCddICYmICFwcmVzc2VkWydKb3lSaWdodFJpZ2h0J10pIHtcbiAgICAgICAgICAgICAgICBhY3Rpb25zWzFdW2lkXS5hZnRlciA/IGFjdGlvbnNbMV1baWRdLmFmdGVyKHZhbHVlKSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkdhbWVwYWRcblx0ICogQG5hbWUgcmVtb3ZlXG5cdCAqIEBkZXNjcmlwdGlvbiBEaXNjb25uZWN0cyBhbmQgcmVtb3ZlcyB0aGUgZ2FtZXBhZCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBnYW1lcGFkIC0gVGhlIGdhbWVwYWQgb2JqZWN0IHRvIGJlIGRpc2Nvbm5lY3RlZCBhbmQgcmVtb3ZlZC5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2FtZXBhZC5kaXNjb25uZWN0ID8gdGhpcy5nYW1lcGFkLmRpc2Nvbm5lY3QoKSA6IGZhbHNlO1xuICAgICAgICB0aGlzLmdhbWVwYWQucmVtb3ZlID8gdGhpcy5nYW1lcGFkLnJlbW92ZSgpIDogZmFsc2U7XG4gICAgICAgIHRoaXMuZ2FtZXBhZCA9IG51bGw7XG4gICAgfVxuXG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5HYW1lcGFkXG5cdCAqIEBuYW1lIHNldE1hcFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBtYXAgcHJvcGVydGllcyB1c2luZyB0aGUgaGFuZGxlTW92ZSBmdW5jdGlvbiBhbmQgc2V0cyB0aGUgY2VudGVyLCB6b29tLCBwaXRjaCwgYW5kIGJlYXJpbmcgYWNjb3JkaW5nbHkuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZU1vdmUgLSBUaGUgZnVuY3Rpb24gdXNlZCB0byBoYW5kbGUgbWFwIG1vdmVtZW50LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdXBkYXRlZCBtYXAgb2JqZWN0IHdpdGggbmV3IHByb3BlcnRpZXMuXG5cdCAqL1xuICAgIHRoaXMuc2V0TWFwID0gZnVuY3Rpb24gKGhhbmRsZU1vdmUpIHtcbiAgICAgICAgY29uc3QgbWFwID0gZ2VvZmxvLm1hcDtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gbWFwLnRyYW5zZm9ybTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubWFwID0gdGhpcy5tYXAgfHwge1xuICAgICAgICAgICAgY2VudGVyOiBtYXAuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgICB6b29tOiBtYXAuZ2V0Wm9vbSgpLFxuICAgICAgICAgICAgcGl0Y2g6IG1hcC5nZXRQaXRjaCgpLFxuICAgICAgICAgICAgYmVhcmluZzogbWFwLmdldEJlYXJpbmcoKVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgY2VudGVyID0gdGhpcy5tYXAuY2VudGVyLnggPyB0aGlzLm1hcC5jZW50ZXIgOiB0aGlzLm1hcC5jZW50ZXIubGF0ID8gdGhpcy5tYXAuY2VudGVyIDogbmV3IG1hcGJveGdsLkxuZ0xhdCh0aGlzLm1hcC5jZW50ZXJbMF0sIHRoaXMubWFwLmNlbnRlclsxXSlcbiAgICAgICAgY2VudGVyID0gY2VudGVyLnggPyB0cmFuc2Zvcm0ucG9pbnRMb2NhdGlvbihjZW50ZXIpIDogY2VudGVyO1xuXG4gICAgICAgIHRyYW5zZm9ybS5jZW50ZXIgPSBjZW50ZXI7XG4gICAgICAgIHRyYW5zZm9ybS5iZWFyaW5nID0gdGhpcy5tYXAuYmVhcmluZztcbiAgICAgICAgdHJhbnNmb3JtLnpvb20gPSB0aGlzLm1hcC56b29tO1xuICAgICAgICB0cmFuc2Zvcm0ucGl0Y2ggPSB0aGlzLm1hcC5waXRjaDtcblxuICAgICAgICBtYXAuX3VwZGF0ZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY3Jvc3NoYWlycyAmJiBnZW9mbG8uY2VudGVyTWFya2VyKSB0aGlzLnNldE1hcmtlcigpO1xuICAgICAgICBpZiAoaGFuZGxlTW92ZSkgZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZU1vdmUoeyBsbmdMYXQ6ICF0aGlzLm9wdGlvbnMuY2FtZXJhLmZyZWUgPyB0aGlzLm1hcC5jZW50ZXIgOiBtYXAuZ2V0Q2VudGVyKCksIGdhbWVwYWQ6IHRoaXMgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uR2FtZXBhZFxuXHQgKiBAbmFtZSBzZXRDb250YWluZXJcblx0ICogQGRlc2NyaXB0aW9uIENyZWF0ZXMgYSBuZXcgSFRNTCBlbGVtZW50IHdpdGggdGhlIHNwZWNpZmllZCB0YWcgbmFtZSBhbmQgY2xhc3MgbmFtZSwgYXBwZW5kcyBpdCB0byBhIGNvbnRhaW5lciBpZiBwcm92aWRlZCwgYW5kIHNldHMgaXQgYXMgdGhlIGNvbnRhaW5lciBwcm9wZXJ0eSBvZiB0aGUgY3VycmVudCBvYmplY3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0YWdOYW1lIC0gVGhlIHRhZyBuYW1lIG9mIHRoZSBIVE1MIGVsZW1lbnQgdG8gY3JlYXRlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIC0gVGhlIGNsYXNzIG5hbWUgdG8gYXNzaWduIHRvIHRoZSBjcmVhdGVkIGVsZW1lbnQgKG9wdGlvbmFsKS5cblx0ICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gVGhlIGNvbnRhaW5lciBlbGVtZW50IHRvIGFwcGVuZCB0aGUgY3JlYXRlZCBlbGVtZW50IHRvIChvcHRpb25hbCkuXG5cdCAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH0gVGhlIGNyZWF0ZWQgSFRNTCBlbGVtZW50LlxuXHQgKi9cblx0XG4gICAgdGhpcy5zZXRDb250YWluZXIgPSBmdW5jdGlvbiAodGFnTmFtZSwgY2xhc3NOYW1lLCBjb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgZWwgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgaWYgKGNsYXNzTmFtZSAhPT0gdW5kZWZpbmVkKSBlbC5jbGFzc05hbWUgPSBjbGFzc05hbWU7XG4gICAgICAgIGlmIChjb250YWluZXIpIGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyID0gZWw7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkdhbWVwYWQgXG5cdCAqIEBuYW1lIHNldExvY2F0aW9uXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgdGhlIHZpc2liaWxpdHksIGxlZnQsIGFuZCB0b3AgcHJvcGVydGllcyBvZiB0aGUgY29udGFpbmVyIGVsZW1lbnQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHZhbHVlLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHZhbHVlIC0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBmb3IgdGhlIG5ldyBsb2NhdGlvbi5cblx0ICogQHJldHVybnMge0RPTVJlY3R9IFRoZSBib3VuZGluZyByZWN0YW5nbGUgb2YgdGhlIGNvbnRhaW5lciBlbGVtZW50IGFmdGVyIHRoZSBsb2NhdGlvbiBpcyBzZXQuXG5cdCAqL1xuICAgIHRoaXMuc2V0TG9jYXRpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9IHRoaXMub3B0aW9ucy5kZWJ1ZyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gKHZhbHVlWzBdICsgMSkgLyAyICogMTAwICsgJyUnO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS50b3AgPSAodmFsdWVbMV0gKyAxKSAvIDIgKiAxMDAgKyAnJSc7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkdhbWVwYWRcblx0ICogQG5hbWUgc2V0TWFya2VyXG5cdCAqIEBkZXNjcmlwdGlvbiBTZXRzIGEgbWFya2VyIG9uIHRoZSBtYXAgdXNpbmcgdGhlIGNlbnRlciBjb29yZGluYXRlcyBwcm92aWRlZCBieSB0aGUgY29udGV4dC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXJrZXIgb2JqZWN0IGNyZWF0ZWQgb24gdGhlIG1hcC5cblx0ICovXG4gICAgdGhpcy5zZXRNYXJrZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZW9mbG8uc2V0Q2VudGVyTWFya2VyKHsgZ2FtZXBhZDogdHJ1ZSB9KTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkdhbWVwYWRcblx0ICogQG5hbWUgc2V0R2FtZXBhZFxuXHQgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZXMgYSBnYW1lcGFkIG9iamVjdCB3aXRoIHNwZWNpZmljIHByb3BlcnRpZXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGdhbWVwYWQgaW5wdXQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBnYW1lcGFkIC0gVGhlIGdhbWVwYWQgb2JqZWN0IHRvIGJlIHByb2Nlc3NlZC5cblx0ICogQHJldHVybnMge09iamVjdH0gLSBUaGUgcHJvY2Vzc2VkIGdhbWVwYWQgb2JqZWN0IHdpdGggZGVmaW5lZCBwcm9wZXJ0aWVzLlxuXHQgKi9cbiAgICB0aGlzLnNldEdhbWVwYWQgPSBmdW5jdGlvbiAoZ2FtZXBhZCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHR5cGU6IGdhbWVwYWQuaWQsXG4gICAgICAgICAgICBjb25uZWN0ZWQ6IGdhbWVwYWQuY29ubmVjdGVkLFxuICAgICAgICAgICAgaWQ6IGdhbWVwYWQuaW5kZXgsXG4gICAgICAgICAgICBidXR0b25zOiBnYW1lcGFkLmJ1dHRvbnMubGVuZ3RoLFxuICAgICAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgICBheGVzOiBNYXRoLmZsb29yKGdhbWVwYWQuYXhlcy5sZW5ndGggLyAyKSxcbiAgICAgICAgICAgIGF4ZVZhbHVlczogW10sXG4gICAgICAgICAgICBoYXB0aWNBY3R1YXRvcjogbnVsbCxcbiAgICAgICAgICAgIHZpYnJhdGlvbk1vZGU6IC0xLFxuICAgICAgICAgICAgdmlicmF0aW9uOiBmYWxzZSxcbiAgICAgICAgICAgIG1hcHBpbmc6IGdhbWVwYWQubWFwcGluZyxcbiAgICAgICAgICAgIGJ1dHRvbkFjdGlvbnM6IHt9LFxuICAgICAgICAgICAgYXhlc0FjdGlvbnM6IHt9LFxuICAgICAgICAgICAgcHJlc3NlZDoge31cbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3B0aW9ucy5idXR0b25zOyB4KyspIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYnV0dG9uQWN0aW9uc1t4XSA9ICgpID0+ICh7IGFjdGlvbjogKCkgPT4geyB9LCBhZnRlcjogKCkgPT4geyB9LCBiZWZvcmU6ICgpID0+IHsgfSB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgb3B0aW9ucy5heGVzOyB4KyspIHtcbiAgICAgICAgICAgIG9wdGlvbnMuYXhlc0FjdGlvbnNbeF0gPSB7XG4gICAgICAgICAgICAgICAgZG93bjogKCkgPT4gKHsgYWN0aW9uOiAoKSA9PiB7IH0sIGFmdGVyOiAoKSA9PiB7IH0sIGJlZm9yZTogKCkgPT4geyB9IH0pLFxuICAgICAgICAgICAgICAgIGxlZnQ6ICgpID0+ICh7IGFjdGlvbjogKCkgPT4geyB9LCBhZnRlcjogKCkgPT4geyB9LCBiZWZvcmU6ICgpID0+IHsgfSB9KSxcbiAgICAgICAgICAgICAgICByaWdodDogKCkgPT4gKHsgYWN0aW9uOiAoKSA9PiB7IH0sIGFmdGVyOiAoKSA9PiB7IH0sIGJlZm9yZTogKCkgPT4geyB9IH0pLFxuICAgICAgICAgICAgICAgIHVwOiAoKSA9PiAoeyBhY3Rpb246ICgpID0+IHsgfSwgYWZ0ZXI6ICgpID0+IHsgfSwgYmVmb3JlOiAoKSA9PiB7IH0gfSlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIG9wdGlvbnMuYXhlVmFsdWVzW3hdID0gWzAsIDBdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGdhbWVwYWQuaGFwdGljQWN0dWF0b3JzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGdhbWVwYWQuaGFwdGljQWN0dWF0b3JzLnB1bHNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oYXB0aWMgPSBnYW1lcGFkLmhhcHRpY0FjdHVhdG9ycztcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpYnJhdGlvbk1vZGUgPSAwO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlicmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2FtZXBhZC5oYXB0aWNBY3R1YXRvcnNbMF0gJiYgdHlwZW9mIGdhbWVwYWQuaGFwdGljQWN0dWF0b3JzWzBdLnB1bHNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oYXB0aWMgPSBnYW1lcGFkLmhhcHRpY0FjdHVhdG9yc1swXTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnZpYnJhdGlvbk1vZGUgPSAwO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlicmF0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGdhbWVwYWQudmlicmF0aW9uQWN0dWF0b3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZ2FtZXBhZC52aWJyYXRpb25BY3R1YXRvci5wbGF5RWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5oYXB0aWMgPSBnYW1lcGFkLnZpYnJhdGlvbkFjdHVhdG9yO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudmlicmF0aW9uTW9kZSA9IDE7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy52aWJyYXRpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5nYW1lcGFkID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5oYXNKb3lzdGlja3MgPSBvcHRpb25zLmF4ZXMgPiAwICYmIE9iamVjdC52YWx1ZXModGhpcy5nYW1lcGFkLmxheW91dCkubWFwKGZ1bmN0aW9uKG0pIHsgcmV0dXJuIG0uaW5jbHVkZXMoJ0pveScpIH0pLmZpbHRlcihmdW5jdGlvbiAoYikgeyByZXR1cm4gYiB9KS5sZW5ndGggPiAwO1xuICAgICAgICByZXR1cm4gdGhpcy5nYW1lcGFkO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uR2FtZXBhZFxuXHQgKiBAbmFtZSBzZXRDZW50ZXJcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgbmV3IGNlbnRlciBvZiB0aGUgbWFwIGJhc2VkIG9uIHRoZSBpbnB1dCB2YWx1ZXMgYW5kIGdhbWVwYWQgY29udHJvbHMuIEl0IGhhbmRsZXMgYm90aCBqb3lzdGljayBhbmQgRC1wYWQgaW5wdXRzIHRvIGFkanVzdCB0aGUgbWFwIGNlbnRlciBhY2NvcmRpbmdseS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gVGhlIHZhbHVlIHVzZWQgdG8gY2FsY3VsYXRlIHRoZSBuZXcgY2VudGVyIG9mIHRoZSBtYXAuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZnJlZSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIG1hcCBjZW50ZXIgc2hvdWxkIGJlIHNldCBmcmVlbHkuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZHBhZCAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIEQtcGFkIGNvbnRyb2xzIGFyZSB1c2VkIGZvciBzZXR0aW5nIHRoZSBtYXAgY2VudGVyLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGFmdGVyIHNldHRpbmcgdGhlIG1hcCBjZW50ZXIuXG5cdCAqL1xuXHRcbiAgICB0aGlzLnNldENlbnRlciA9IGZ1bmN0aW9uICh2YWx1ZSwgZnJlZSwgZHBhZCkge1xuICAgICAgICB2YXIgY2VudGVyID0gZ2VvZmxvLm1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgdmFyIHByZXNzZWQgPSB0aGlzLmdhbWVwYWQucHJlc3NlZDtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLmhhc0pveXN0aWNrcyA/ICdKb3knIDogJ0RwYWQnO1xuICAgICAgICB2YXIgZGlhZyA9IE9iamVjdC5rZXlzKHByZXNzZWQpLmZpbHRlcihmdW5jdGlvbihwKSB7IHJldHVybiBwLmluY2x1ZGVzKHR5cGUpIH0pLmxlbmd0aCA+IDE7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RhcnQgPSBmcmVlIHx8IGRwYWQgPyBjZW50ZXIgOiBmYWxzZTtcbiAgICAgICAgc3RhcnQgPSBnZW9mbG8uaG90RmVhdHVyZSAmJiAhc3RhcnQgPyBnZW9mbG8ubGFzdE1vdmUgfHwgY2VudGVyIDogZmFsc2U7XG4gICAgICAgIHN0YXJ0ID0gIXN0YXJ0ID8gY2VudGVyIDogc3RhcnQ7XG5cbiAgICAgICAgdmFyIGVuZDtcbiAgICBcbiAgICAgICAgaWYgKGRwYWQpIHtcbiAgICAgICAgICAgIHZhciBiZWFyaW5nID0gdGhpcy5tYXAuYmVhcmluZztcbiAgICAgICAgICAgIGJlYXJpbmcgPSBwcmVzc2VkWydVcCddID8gYmVhcmluZyA6XG4gICAgICAgICAgICBwcmVzc2VkWydEb3duJ10gPyBiZWFyaW5nICsgMTgwIDpcbiAgICAgICAgICAgIHByZXNzZWRbJ0xlZnQnXSA/IGJlYXJpbmcgLSA5MCA6XG4gICAgICAgICAgICBwcmVzc2VkWydSaWdodCddID8gYmVhcmluZyArIDkwIDpcbiAgICAgICAgICAgIGJlYXJpbmc7XG5cbiAgICAgICAgICAgIHZhciBkZXN0ID0gdHVyZi5kZXN0aW5hdGlvbih0dXJmLnBvaW50KHN0YXJ0KSwgZGlzdGFuY2UsIGJlYXJpbmcpLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuXG4gICAgICAgICAgICBsbmdMYXRzID0gZnJlZSA/IHsgbG5nOiBkZXN0WzFdLCBsYXQ6IGRlc3RbMF0gfSA6IGRlc3Q7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IHRoaXMuc2V0TG9jYXRpb24odmFsdWUpO1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGxvY2F0aW9uICYmIGxvY2F0aW9uLnggPyBbbG9jYXRpb24ueCwgbG9jYXRpb24ueV0gOiBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZW5kID0gZ2VvZmxvLm1hcC51bnByb2plY3QoY29vcmRzKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIHBlcmNlbnQgPSBkaWFnID8gdGhpcy5vcHRpb25zLnBhbi5zcGVlZCAvIDIgOiB0aGlzLm9wdGlvbnMucGFuLnNwZWVkO1xuICAgICAgICAgICAgdmFyIG1pZCA9IGNhbGN1bGF0ZUludGVybWVkaWF0ZVBvaW50KFtzdGFydC5sbmcsIHN0YXJ0LmxhdF0sIFtlbmQubG5nLCBlbmQubGF0XSwgcGVyY2VudClcbiAgICAgICAgICAgIG1pZCA9IGdlb2Zsby5tYXAuZ2V0UGl0Y2goKSA+IDYwID8gY2FsY3VsYXRlSW50ZXJtZWRpYXRlUG9pbnQoW3N0YXJ0LmxuZywgc3RhcnQubGF0XSwgW21pZFswXSwgbWlkWzFdXSwgMC40KSA6IG1pZDtcblxuICAgICAgICAgICAgZW5kID0gbWlkO1xuICAgICAgICAgICAgZ2VvZmxvLmxhc3RNb3ZlID0gZW5kO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGdlb2Zsby5ob3RGZWF0dXJlID8gZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgOiBmYWxzZTtcbiAgICAgICAgICAgIGVuZCA9IGZyZWUgPyBnZW9mbG8ubWFwLmdldENlbnRlcigpIDpcbiAgICAgICAgICAgIGNvb3JkcyA/IHsgbGF0OiBjb29yZHNbY29vcmRzLmxlbmd0aC0xXVsxXSwgbG5nOiBjb29yZHNbY29vcmRzLmxlbmd0aC0xXVswXSB9IDogZ2VvZmxvLm1hcC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICAgIGdlb2Zsby5sYXN0TW92ZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zZXRMb2NhdGlvbihbMCwgMF0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tYXAuY2VudGVyID0gZW5kO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRNYXAodHJ1ZSk7XG4gICAgfVxuICAgIFxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uR2FtZXBhZFxuXHQgKiBAbmFtZSBzZXRCZWFyaW5nXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgdGhlIGJlYXJpbmcgb2YgdGhlIG1hcCBieSBhZGp1c3RpbmcgaXQgd2l0aCB0aGUgc3BlY2lmaWVkIHZhbHVlIGFuZCBkaXJlY3Rpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyIHwgQXJyYXk8bnVtYmVyPn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYWRqdXN0IHRoZSBiZWFyaW5nIGJ5LiBJZiBkcGFkIGlzIGZhbHNlLCBpdCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgbnVtYmVycywgb3RoZXJ3aXNlIGEgc2luZ2xlIG51bWJlci5cblx0ICogQHBhcmFtIHtib29sZWFufSBsZWZ0IC0gSW5kaWNhdGVzIHRoZSBkaXJlY3Rpb24gb2YgYWRqdXN0bWVudC4gSWYgdHJ1ZSwgdGhlIGJlYXJpbmcgaXMgZGVjcmVhc2VkOyBvdGhlcndpc2UsIGl0IGlzIGluY3JlYXNlZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBkcGFkIC0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIHZhbHVlIGlzIGNvbWluZyBmcm9tIGEgZHBhZCBpbnB1dC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBzZXRNYXAgZnVuY3Rpb24gYWZ0ZXIgdXBkYXRpbmcgdGhlIGJlYXJpbmcuXG5cdCAqL1xuICAgIHRoaXMuc2V0QmVhcmluZyA9IGZ1bmN0aW9uICh2YWx1ZSwgbGVmdCwgZHBhZCkge1xuICAgICAgICB2YXIgYmVhcmluZyA9IHRoaXMubWFwLmJlYXJpbmc7XG4gICAgICAgIHZhciBiZWFyaW5nTXVsdGkgPSAhZHBhZCA/IE1hdGguYWJzKHZhbHVlWzBdKSA6IHZhbHVlO1xuICAgIFxuICAgICAgICBpZiAobGVmdCkge1xuICAgICAgICAgICAgYmVhcmluZyA9IGJlYXJpbmcgLSAodGhpcy5vcHRpb25zLmJlYXJpbmcuc3BlZWQgKiBiZWFyaW5nTXVsdGkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiZWFyaW5nID0gYmVhcmluZyArICh0aGlzLm9wdGlvbnMuYmVhcmluZy5zcGVlZCAqIGJlYXJpbmdNdWx0aSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFwLmJlYXJpbmcgPSBiZWFyaW5nO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRNYXAoKTtcbiAgICB9XG4gICAgXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5HYW1lcGFkXG5cdCAqIEBuYW1lIHNldFBpdGNoXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGFkanVzdHMgdGhlIHBpdGNoIG9mIHRoZSBtYXAgYnkgYSBzcGVjaWZpZWQgYW1vdW50IGluIHRoZSBnaXZlbiBkaXJlY3Rpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfEFycmF5PG51bWJlcj59IHZhbHVlIC0gVGhlIHZhbHVlIG9yIGFycmF5IG9mIHZhbHVlcyB0byBhZGp1c3QgdGhlIHBpdGNoIGJ5LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHVwIC0gQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGl0Y2ggc2hvdWxkIGJlIGluY3JlYXNlZCAodHJ1ZSkgb3IgZGVjcmVhc2VkIChmYWxzZSkuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZHBhZCAtIEEgYm9vbGVhbiBmbGFnIHRvIGRldGVybWluZSBpZiB0aGUgdmFsdWUgaXMgY29taW5nIGZyb20gYSBELXBhZCBpbnB1dC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgbWFwIGlzIHN1Y2Nlc3NmdWxseSB1cGRhdGVkIHdpdGggdGhlIG5ldyBwaXRjaC5cblx0ICovXG4gICAgdGhpcy5zZXRQaXRjaCA9IGZ1bmN0aW9uICh2YWx1ZSwgdXAsIGRwYWQpIHtcbiAgICAgICAgdmFyIHBpdGNoID0gdGhpcy5tYXAucGl0Y2g7XG4gICAgICAgIHZhciBwaXRjaE11bHRpID0gIWRwYWQgPyBNYXRoLmFicyh2YWx1ZVsxXSkgOiB2YWx1ZTtcblxuICAgICAgICBpZiAocGl0Y2ggPCAwKSBwaXRjaCA9IDA7XG4gICAgICAgIGlmIChwaXRjaCA+IHRoaXMub3B0aW9ucy5waXRjaC5tYXgpIHBpdGNoID0gdGhpcy5vcHRpb25zLnBpdGNoLm1heDtcbiAgICBcbiAgICAgICAgaWYgKHVwKSB7XG4gICAgICAgICAgICBwaXRjaCA9IHBpdGNoICsgKHRoaXMub3B0aW9ucy5waXRjaC5zcGVlZCAqIHBpdGNoTXVsdGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGl0Y2ggPSBwaXRjaCAtICh0aGlzLm9wdGlvbnMucGl0Y2guc3BlZWQgKiBwaXRjaE11bHRpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5tYXAucGl0Y2ggPSBwaXRjaDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TWFwKCk7XG4gICAgfVxuICAgIFxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uR2FtZXBhZFxuXHQgKiBAbmFtZSBzZXRab29tXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGFkanVzdHMgdGhlIHpvb20gbGV2ZWwgb2YgYSBtYXAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIHZhbHVlIGFuZCBkaXJlY3Rpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBhbW91bnQgYnkgd2hpY2ggdG8gY2hhbmdlIHRoZSB6b29tIGxldmVsLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG91dCAtIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdG8gem9vbSBvdXQgKHRydWUpIG9yIHpvb20gaW4gKGZhbHNlKS5cblx0ICogQHBhcmFtIHtib29sZWFufSBkcGFkIC0gQSBmbGFnIGluZGljYXRpbmcgdGhlIGRpcmVjdGlvbiBvZiB0aGUgem9vbSBjaGFuZ2UuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdGhlIHJlc3VsdCBvZiBzZXR0aW5nIHRoZSBtYXAgd2l0aCB0aGUgbmV3IHpvb20gbGV2ZWwuXG5cdCAqL1xuICAgIHRoaXMuc2V0Wm9vbSA9IGZ1bmN0aW9uICh2YWx1ZSwgb3V0LCBkcGFkKSB7XG4gICAgICAgIHZhciB6b29tID0gdGhpcy5tYXAuem9vbTtcbiAgICBcbiAgICAgICAgaWYgKG91dCkge1xuICAgICAgICAgICAgem9vbSA9IHpvb20gLSAoIHRoaXMub3B0aW9ucy56b29tLnNwZWVkICogTWF0aC5hYnModmFsdWUpIClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHpvb20gPSB6b29tICsgKCB0aGlzLm9wdGlvbnMuem9vbS5zcGVlZCAqIE1hdGguYWJzKHZhbHVlKSApXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMubWFwLnpvb20gPSB6b29tO1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRNYXAoKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkdhbWVwYWRcblx0ICogQG5hbWUgc2V0U3BlZWRcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgc3BlZWQgb2YgcGFubmluZyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgdmFsdWUgYW5kIGRpcmVjdGlvbi4gSXQgZW5zdXJlcyB0aGF0IHRoZSBzcGVlZCBmYWxscyB3aXRoaW4gdGhlIHNwZWNpZmllZCBtaW5pbXVtIGFuZCBtYXhpbXVtIHZhbHVlcy5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgaW5mbHVlbmNlcyB0aGUgc3BlZWQgb2YgcGFubmluZy5cblx0ICogQHBhcmFtIHtib29sZWFufSBkb3duIC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyB0aGUgZGlyZWN0aW9uIG9mIHBhbm5pbmcgKHRydWUgZm9yIGRvd24sIGZhbHNlIGZvciB1cCkuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB1cGRhdGVkIHNwZWVkIG9mIHBhbm5pbmcgYWZ0ZXIgYXBwbHlpbmcgdGhlIGNhbGN1bGF0aW9ucy5cblx0ICovXG4gICAgdGhpcy5zZXRTcGVlZCA9IGZ1bmN0aW9uICh2YWx1ZSwgZG93bikge1xuICAgICAgICB2YXIgc3BlZWQgPSB0aGlzLm9wdGlvbnMucGFuLnNwZWVkID4gdGhpcy5vcHRpb25zLnBhbi5taW4gP1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBhbi5zcGVlZCA6XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMucGFuLm1heCAmJiB0aGlzLm9wdGlvbnMucGFuLnNwZWVkID4gdGhpcy5vcHRpb25zLnBhbi5tYXggP1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBhbi5taW4gOlxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnBhbi5taW47XG5cbiAgICAgICAgc3BlZWQgPSBkb3duID8gc3BlZWQgLSB0aGlzLm9wdGlvbnMucGFuLm1pbiA6IHNwZWVkICsgdGhpcy5vcHRpb25zLnBhbi5taW47XG5cbiAgICAgICAgc3BlZWQgPSBzcGVlZCA8IHRoaXMub3B0aW9ucy5wYW4ubWluID8gdGhpcy5vcHRpb25zLnBhbi5taW4gOlxuICAgICAgICB0aGlzLm9wdGlvbnMucGFuLm1heCAmJiBzcGVlZCA+IHRoaXMub3B0aW9ucy5wYW4ubWF4ID8gdGhpcy5vcHRpb25zLnBhbi5tYXggOlxuICAgICAgICBzcGVlZDtcblxuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLnBhbi5zcGVlZCA9IHNwZWVkICogTWF0aC5hYnModmFsdWUpO1xuICAgIH1cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5HYW1lcGFkIGFzc29jaWF0ZUV2ZW50XG5cdCAqIEBuYW1lIGFzc29jaWF0ZUV2ZW50XG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGFsbG93cyB0aGUgdXNlciB0byBhc3NvY2lhdGUgYW4gZXZlbnQgd2l0aCBhIGNhbGxiYWNrIGZ1bmN0aW9uIGZvciBhIHNwZWNpZmljIGJ1dHRvbiBvciBheGlzIG9uIHRoZSBnYW1lcGFkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIGV2ZW50IChlLmcuLCAncHJlc3MnLCAncmVsZWFzZScpIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICogQHJldHVybnMge29iamVjdH0gVGhlIHVwZGF0ZWQgZ2FtZXBhZCBvYmplY3Qgd2l0aCB0aGUgYXNzb2NpYXRlZCBldmVudCBhbmQgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuICAgIHRoaXMuYXNzb2NpYXRlRXZlbnQgPSBmdW5jdGlvbihldmVudE5hbWUsIGNhbGxiYWNrLCB0eXBlKSB7XG4gICAgICAgIGlmIChldmVudE5hbWUubWF0Y2goL15idXR0b25cXGQrJC8pKSB7XG4gICAgICAgICAgICBjb25zdCBidXR0b25JZCA9IHBhcnNlSW50KGV2ZW50TmFtZS5tYXRjaCgvXmJ1dHRvbihcXGQrKSQvKVsxXSk7XG5cbiAgICAgICAgICAgIGlmIChidXR0b25JZCA+PSAwICYmIGJ1dHRvbklkIDwgdGhpcy5nYW1lcGFkLmJ1dHRvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVwYWQuYnV0dG9uQWN0aW9uc1tidXR0b25JZF1bdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYnV0dG9uSWQsICdUaGlzIGJ1dHRvbiBpcyBub3Qgb24gZ2FtZXBhZCcpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZXBhZC5idXR0b25BY3Rpb25zWzldW3R5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAnc2VsZWN0Jykge1xuICAgICAgICAgICAgdGhpcy5nYW1lcGFkLmJ1dHRvbkFjdGlvbnNbOF1bdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdyMScpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZXBhZC5idXR0b25BY3Rpb25zWzVdW3R5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAncjInKSB7XG4gICAgICAgICAgICB0aGlzLmdhbWVwYWQuYnV0dG9uQWN0aW9uc1s3XVt0eXBlXSA9IGNhbGxiYWNrO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gJ2wxJykge1xuICAgICAgICAgICAgdGhpcy5nYW1lcGFkLmJ1dHRvbkFjdGlvbnNbNF1bdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgfSBlbHNlIGlmIChldmVudE5hbWUgPT09ICdsMicpIHtcbiAgICAgICAgICAgIHRoaXMuZ2FtZXBhZC5idXR0b25BY3Rpb25zWzZdW3R5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnROYW1lID09PSAncG93ZXInKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5nYW1lcGFkLmJ1dHRvbnMgPj0gMTcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdhbWVwYWQuYnV0dG9uQWN0aW9uc1sxNl1bdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoTUVTU0FHRVMuSU5WQUxJRF9CVVRUT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZS5tYXRjaCgvXih1cHxkb3dufGxlZnR8cmlnaHQpKFxcZCspJC8pKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZXZlbnROYW1lLm1hdGNoKC9eKHVwfGRvd258bGVmdHxyaWdodCkoXFxkKykkLyk7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBtYXRjaGVzWzFdO1xuICAgICAgICAgICAgY29uc3QgYXhlID0gcGFyc2VJbnQobWF0Y2hlc1syXSk7XG5cbiAgICAgICAgICAgIGlmIChheGUgPj0gMCAmJiBheGUgPCB0aGlzLmdhbWVwYWQuYXhlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2FtZXBhZC5heGVzQWN0aW9uc1theGVdW2RpcmVjdGlvbl1bdHlwZV0gPSBjYWxsYmFjaztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IoTUVTU0FHRVMuSU5WQUxJRF9CVVRUT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZS5tYXRjaCgvXih1cHxkb3dufGxlZnR8cmlnaHQpJC8pKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBldmVudE5hbWUubWF0Y2goL14odXB8ZG93bnxsZWZ0fHJpZ2h0KSQvKVsxXTtcbiAgICAgICAgICAgIHRoaXMuZ2FtZXBhZC5heGVzQWN0aW9uc1swXVtkaXJlY3Rpb25dW3R5cGVdID0gY2FsbGJhY2s7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5nYW1lcGFkO1xuICAgIH1cblxuICAgIHRoaXMub25Jbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0aWF0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnNldENvbnRhaW5lcignZGl2JywgJ2dhbWVwYWQnLCBnZW9mbG8ubWFwLmdldENvbnRhaW5lcigpKTtcbiAgICAgICAgdGhpcy5zZXRNYXJrZXIoKTtcbiAgICAgICAgdGhpcy5zZXRNYXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uRXZlbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCBhY3Rpb24sIHZhbHVlKSB7XG4gICAgICAgIHZhciBwcmVzc2VkID0ge1thY3Rpb25dOiB0cnVlfTtcbiAgICAgICAgdmFyIGxuZ0xhdCA9IHRoaXMub3B0aW9ucy5jYW1lcmEuZnJlZSA/IGdlb2Zsby5tYXAuZ2V0Q2VudGVyKCkgOiBnZW9mbG8ubGFzdE1vdmUgPyBnZW9mbG8ubGFzdE1vdmUgOiBnZW9mbG8ubWFwLmdldENlbnRlcigpO1xuXG4gICAgICAgIHZhciBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmFtZTogYWN0aW9uLFxuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbW9kZTogZ2VvZmxvLmN1cnJlbnRNb2RlLFxuICAgICAgICAgICAgZ2FtZXBhZDogdGhpcyxcbiAgICAgICAgICAgIGxuZ0xhdDogbG5nTGF0LFxuICAgICAgICAgICAgZ2VvZmxvOiBnZW9mbG8sXG4gICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiB7fVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmluaXRpYXRlZCkgdGhpcy5vbkluaXQob3B0aW9ucyk7XG5cbiAgICAgICAgZ2VvZmxvLm1hcC5maXJlKGdlb2Zsby5pZCArICc6Z2FtZXBhZC4nICsgdHlwZSwgeyBkZXRhaWw6IG9wdGlvbnMgfSk7XG5cbiAgICAgICAgaWYgKHByZXNzZWRbJ0pveUxlZnRVcCddIHx8IHByZXNzZWRbJ0pveUxlZnREb3duJ10gfHwgcHJlc3NlZFsnSm95TGVmdExlZnQnXSB8fCBwcmVzc2VkWydKb3lMZWZ0UmlnaHQnXSkgdGhpcy5vcHRpb25zLm1hcHBpbmdbJ0pveUxlZnRNb3ZlJ10ob3B0aW9ucyk7XG4gICAgICAgIGlmIChwcmVzc2VkWydKb3lSaWdodFVwJ10gfHwgcHJlc3NlZFsnSm95UmlnaHREb3duJ10gfHwgcHJlc3NlZFsnSm95UmlnaHRMZWZ0J10gfHwgcHJlc3NlZFsnSm95UmlnaHRSaWdodCddKSB0aGlzLm9wdGlvbnMubWFwcGluZ1snSm95UmlnaHRNb3ZlJ10ob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHByZXNzZWRbJ0pveUxlZnRDbGljayddKSB0aGlzLm9wdGlvbnMubWFwcGluZ1snSm95TGVmdENsaWNrJ10ob3B0aW9ucyk7XG4gICAgICAgIGlmIChwcmVzc2VkWydKb3lSaWdodENsaWNrJ10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydKb3lSaWdodENsaWNrJ10ob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHByZXNzZWRbJ0J1bXBMZWZ0J10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydCdW1wTGVmdCddKG9wdGlvbnMpO1xuICAgICAgICBpZiAocHJlc3NlZFsnQnVtcFJpZ2h0J10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydCdW1wUmlnaHQnXShvcHRpb25zKTtcblxuICAgICAgICBpZiAocHJlc3NlZFsnVHJpZ0xlZnQnXSkgdGhpcy5vcHRpb25zLm1hcHBpbmdbJ1RyaWdMZWZ0J10ob3B0aW9ucyk7XG4gICAgICAgIGlmIChwcmVzc2VkWydUcmlnUmlnaHQnXSkgdGhpcy5vcHRpb25zLm1hcHBpbmdbJ1RyaWdSaWdodCddKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChwcmVzc2VkWydBJ10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydBJ10ob3B0aW9ucyk7XG4gICAgICAgIGlmIChwcmVzc2VkWydCJ10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydCJ10ob3B0aW9ucyk7XG4gICAgICAgIGlmIChwcmVzc2VkWydYJ10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydYJ10ob3B0aW9ucyk7XG4gICAgICAgIGlmIChwcmVzc2VkWydZJ10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydZJ10ob3B0aW9ucyk7XG5cbiAgICAgICAgaWYgKHByZXNzZWRbJ1N0YXJ0J10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydTdGFydCddKG9wdGlvbnMpO1xuICAgICAgICBpZiAocHJlc3NlZFsnU2VsZWN0J10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydTZWxlY3QnXShvcHRpb25zKTtcbiAgICAgICAgaWYgKHByZXNzZWRbJ1Bvd2VyJ10pIHRoaXMub3B0aW9ucy5tYXBwaW5nWydQb3dlciddKG9wdGlvbnMpO1xuICAgICAgICBpZiAocHJlc3NlZFsnSG9tZSddKSB0aGlzLm9wdGlvbnMubWFwcGluZ1snSG9tZSddKG9wdGlvbnMpO1xuICAgICAgICBpZiAocHJlc3NlZFsnTWlzYyddKSB0aGlzLm9wdGlvbnMubWFwcGluZ1snTWlzYyddKG9wdGlvbnMpO1xuXG4gICAgICAgIGlmIChwcmVzc2VkWydEcGFkVXAnXSkgdGhpcy5vcHRpb25zLm1hcHBpbmdbJ0RwYWRVcCddKG9wdGlvbnMpO1xuICAgICAgICBpZiAocHJlc3NlZFsnRHBhZERvd24nXSkgdGhpcy5vcHRpb25zLm1hcHBpbmdbJ0RwYWREb3duJ10ob3B0aW9ucyk7XG4gICAgICAgIGlmIChwcmVzc2VkWydEcGFkTGVmdCddKSB0aGlzLm9wdGlvbnMubWFwcGluZ1snRHBhZExlZnQnXShvcHRpb25zKTtcbiAgICAgICAgaWYgKHByZXNzZWRbJ0RwYWRSaWdodCddKSB0aGlzLm9wdGlvbnMubWFwcGluZ1snRHBhZFJpZ2h0J10ob3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdGhpcy5vbkRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoZ2FtZXBhZCkge1xuICAgICAgICBpZiAoIWdhbWVwYWQgfHwgIXRoaXMuZ2FtZXBhZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5nYW1lcGFkLmlkICE9PSBnYW1lcGFkLmlkKSB0aHJvdyBuZXcgRXJyb3IoJ0dhbWVwYWQgaWQgZG9lcyBub3QgbWF0Y2ghJyk7XG4gICAgICAgIHRoaXMuZ2FtZXBhZC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy5nYW1lcGFkID0gbnVsbDtcbiAgICB9XG5cblxuICAgIHRoaXMuaW5pdChnYW1lcGFkKTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEdhbWVwYWQ7IiwiLyoqXG4gKiBAbWl4aW5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvXG4gKiBAbmFtZSBMYXllcnNcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1vZHVsZSBwcm92aWRlcyB0aGUgbGF5ZXIgZnVuY3Rpb25hbGl0eSBmb3IgdGhlIEdlb2ZsbyBhcHBsaWNhdGlvbi4gSXQgYWxsb3dzIHVzZXJzIHRvIGFkZCwgcmVtb3ZlLCBhbmQgbWFuaXB1bGF0ZSBsYXllcnMgb24gdGhlIG1hcC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IHRvIGNvbmZpZ3VyZSB0aGUgb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgTGF5ZXJzIG9iamVjdC5cbiAqL1xuXG5jb25zdCBMYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZ2VvZmxvID0gdGhpcy5nZW9mbG87XG4gICAgaWYgKCFnZW9mbG8ubWFwKSB0aHJvdyBuZXcgRXJyb3IoJ05vIG1hcCBvYmplY3QgcHJvdmlkZWQhJyk7XG5cbiAgICBjb25zdCBMYXllcnMgPSB0aGlzO1xuICAgIGNvbnN0IG1hcCA9IGdlb2Zsby5tYXA7XG4gICAgY29uc3QgaWQgPSBnZW9mbG8uaWQ7XG5cbiAgICBjb25zdCBsYXllclR5cGVzID0ge1xuICAgICAgICBQb2x5Z29uOiBbJy1maWxsJywgJy1ib3JkZXInXSxcbiAgICAgICAgUG9seWxpbmU6IFsnLWxpbmUnLCAnLWRhc2gnLCAnLWJ1ZmZlciddLFxuICAgICAgICBQb2ludDogWyctY2lyY2xlJywgJy1pY29uJywgJy1jbHVzdGVyLWNpcmNsZScsICctY2x1c3Rlci1pY29uJywgJy1jb3VudC1pY29uJywgJy1jb3VudC10ZXh0J10sXG4gICAgICAgIEltYWdlOiBbJy1pbWFnZSddLFxuICAgICAgICBBbGw6IFsnLWZpbGwnLCAnLWJvcmRlcicsICctbGluZScsICctZGFzaCcsICctYnVmZmVyJywgJy1jaXJjbGUnLCAnLWljb24nLCAnLWNsdXN0ZXItY2lyY2xlJywgJy1jbHVzdGVyLWljb24nLCAnLWNvdW50LWljb24nLCAnLWNvdW50LXRleHQnLCAnLWltYWdlJ11cbiAgICB9XG5cbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLnNvdXJjZXMgPSBbXTtcbiAgICB0aGlzLmxheWVycyA9IFtdO1xuICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgIHRoaXMuX3NvdXJjZXMgPSBbXTtcblxuXHQvKiogXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxheWVyc1xuXHQgKiBAbmFtZSBpbml0XG5cdCAqIEBkZXNjcmlwdGlvbiBJbml0aWFsaXplcyB0aGUgb2JqZWN0IHdpdGggdGhlIHByb3ZpZGVkIG9wdGlvbnMgYW5kIHJlZnJlc2hlcyBpdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgdG8gY29uZmlndXJlIHRoZSBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZWZyZXNoZWQgb2JqZWN0IHdpdGggdGhlIHVwZGF0ZWQgb3B0aW9ucy5cblx0ICovXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnM9e30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuZGVmYXVsdExheWVycyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkNPTEQsXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgJy1maWxsLWNvbGQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxsJyxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IHt9LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogW1wiPT1cIiwgXCIkdHlwZVwiLCBcIlBvbHlnb25cIl0sXG4gICAgICAgICAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuc2Vjb25kYXJ5Q29sZCxcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsIDAuM11cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuQ09MRCxcbiAgICAgICAgICAgICAgICBpZDogaWQgKyAnLWxpbmUtY29sZCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgICAgICAgICAnbGluZS1jYXAnOiAncm91bmQnLFxuICAgICAgICAgICAgICAgICAgICAnbGluZS1qb2luJzogJ21pdGVyJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMucHJpbWFyeUNvbGQsXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLXdpZHRoJzogNCxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtZ2FwLXdpZHRoJzogW1wibWF0Y2hcIiwgW1wiZ2V0XCIsIFwidHlwZVwiXSwgXCJQb2x5Z29uXCIsIDAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAnbGluZS1vZmZzZXQnOiBbJ2Nhc2UnLCBbXCJib29sZWFuXCIsIFtcImhhc1wiLCBcIm9mZnNldFwiXSwgdHJ1ZV0sIFtcImdldFwiLCBcIm9mZnNldFwiXSwgMF0sXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLW9wYWNpdHknOiBbJ2Nhc2UnLCBbXCJib29sZWFuXCIsIFtcImZlYXR1cmUtc3RhdGVcIiwgXCJoaWRkZW5cIl0sIHRydWVdLCAwLCAxXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5DT0xELFxuICAgICAgICAgICAgICAgIGlkOiBpZCArICctY2lyY2xlLWNvbGQnLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogWydhbGwnLCBbJz09JywgWydnZXQnLCAndHlwZSddLCAnQ2lyY2xlJ10sIFtcIiE9XCIsIFtcImdlb21ldHJ5LXR5cGVcIl0sIFwiUG9seWdvblwiXSBdLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtcmFkaXVzJzogeyAnYmFzZSc6IDYsICdzdG9wcyc6IFtbMTAsIDhdLCBbMTQsIDEwXV0gfSxcbiAgICAgICAgICAgICAgICAgICAgJ2NpcmNsZS1zdHJva2Utd2lkdGgnOiAxLFxuICAgICAgICAgICAgICAgICAgICAnY2lyY2xlLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlDb2xkLFxuICAgICAgICAgICAgICAgICAgICAnY2lyY2xlLXN0cm9rZS1jb2xvcic6IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5zZWNvbmRhcnlDb2xkLFxuICAgICAgICAgICAgICAgICAgICAnY2lyY2xlLW9wYWNpdHknOiBbJ2Nhc2UnLCBbXCJib29sZWFuXCIsIFtcImZlYXR1cmUtc3RhdGVcIiwgXCJoaWRkZW5cIl0sIHRydWVdLCAwLCAxXSxcbiAgICAgICAgICAgICAgICAgICAgJ2NpcmNsZS1zdHJva2Utb3BhY2l0eSc6IFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsIDFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkNPTEQsXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgJy1pY29uLWNvbGQnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzeW1ib2wnLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogWyc9PScsIFsnZ2V0JywgJ3R5cGUnXSwgJ0ljb24nXSxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsXG4gICAgICAgICAgICAgICAgICAgICdpY29uLW9wdGlvbmFsJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtZmllbGQnOiBbJ2dldCcsICdwcmltYXJ5SWNvbicsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1zaXplJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2Jhc2UnOiAxNixcbiAgICAgICAgICAgICAgICAgICAgICAgICdzdG9wcyc6IFtbMTAsIDE2XSwgWzE0LCAxMl1dXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWxpbmUtaGVpZ2h0JzogMSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtcGFkZGluZyc6IDAsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LW9mZnNldCc6IFswLCAwLjJdLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1qdXN0aWZ5JzogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1hbmNob3InOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtYWxsb3ctb3ZlcmxhcCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWZvbnQnOiBbJ0ZvbnQgQXdlc29tZSA2IFBybyBTb2xpZCddLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1pZ25vcmUtcGxhY2VtZW50JzogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtdHJhbnNsYXRlLWFuY2hvcic6ICd2aWV3cG9ydCcsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWhhbG8td2lkdGgnOiAwLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1oYWxvLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlDb2xkLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1jb2xvcic6IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5zZWNvbmRhcnlCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1vcGFjaXR5JzogWydjYXNlJywgW1wiYm9vbGVhblwiLCBbXCJmZWF0dXJlLXN0YXRlXCIsIFwiaGlkZGVuXCJdLCB0cnVlXSwgMCwgMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuQ09MRCxcbiAgICAgICAgICAgICAgICBpZDogaWQgKyAnLXRleHQtY29sZCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N5bWJvbCcsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBbXCI9PVwiLCBcIiR0eXBlXCIsIFwiUG9pbnRcIl0sXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICAgIFwic3ltYm9sLXBsYWNlbWVudFwiOiBcInBvaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWZpZWxkJzogWydnZXQnLCAndGV4dCddLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1mb250JzogWydESU4gUHJvIFJlZ3VsYXInLCAnRElOIFBybyBJdGFsaWMnLCAnQXJpYWwgVW5pY29kZSBNUyBSZWd1bGFyJywgJ0RJTiBPZmZjIFBybyBNZWRpdW0nLCAnQXJpYWwgVW5pY29kZSBNUyBCb2xkJ10sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWtlZXAtdXByaWdodCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXNpemUnOiAxOCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtanVzdGlmeSc6IFsnZ2V0JywgJ2p1c3RpZnknXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtbGV0dGVyLXNwYWNpbmcnOiAwLjA1LFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1saW5lLWhlaWdodCc6IDEuMixcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtbWF4LWFuZ2xlJzogMTAsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LW9mZnNldCc6IFswLDBdLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1wYWRkaW5nJzogMixcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtcm90YXRlJzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtdHJhbnNmb3JtJzogWydnZXQnLCAndHJhbnNmb3JtJ11cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlDb2xkLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1oYWxvLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlCYWNrZ3JvdW5kLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1oYWxvLXdpZHRoJzogMC41LFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1vcGFjaXR5JzogWydjYXNlJywgW1wiYm9vbGVhblwiLCBbXCJmZWF0dXJlLXN0YXRlXCIsIFwiaGlkZGVuXCJdLCB0cnVlXSwgMCwgMV1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuQ09MRCxcbiAgICAgICAgICAgICAgICBpZDogaWQgKyAnLXRleHQtaWNvbi1jb2xkJyxcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3ltYm9sJyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IFsnPT0nLCBbJ2dldCcsICd0eXBlJ10sICdUZXh0J10sXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICAnaWNvbi1vcHRpb25hbCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWZpZWxkJzogWydnZXQnLCAncHJpbWFyeUljb24nLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtc2l6ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICdiYXNlJzogMTYsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc3RvcHMnOiBbWzEwLCAxNl0sIFsxNCwgMTJdXVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1saW5lLWhlaWdodCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXBhZGRpbmcnOiAwLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1vZmZzZXQnOiBbMCwgMC4yXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtanVzdGlmeSc6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWFsbG93LW92ZXJsYXAnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1mb250JzogWydGb250IEF3ZXNvbWUgNiBQcm8gU29saWQnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtaWdub3JlLXBsYWNlbWVudCc6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXRyYW5zbGF0ZS1hbmNob3InOiAndmlld3BvcnQnLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1oYWxvLXdpZHRoJzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtaGFsby1jb2xvcic6IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5wcmltYXJ5Q29sZCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuc2Vjb25kYXJ5QmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtb3BhY2l0eSc6IFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsIDFdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZDogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLmxheWVycy5NRVNIICsgJy1saW5lJyxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLk1FU0gsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJsaW5lXCIsXG4gICAgICAgICAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJsaW5lLWNvbG9yXCI6IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5wcmltYXJ5QmFzZSxcbiAgICAgICAgICAgICAgICAgICAgXCJsaW5lLXdpZHRoXCI6IDIsXG4gICAgICAgICAgICAgICAgICAgIFwibGluZS1vcGFjaXR5XCI6IDAuM1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5sYXllcnMuTUVTSCArICctY2lyY2xlJyxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLk1FU0gsXG4gICAgICAgICAgICAgICAgdHlwZTogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NpcmNsZS1yYWRpdXMnOiAyLFxuICAgICAgICAgICAgICAgICAgICAnY2lyY2xlLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlCYXNlLFxuICAgICAgICAgICAgICAgICAgICAnY2lyY2xlLW9wYWNpdHknOiAwLjNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuSE9ULFxuICAgICAgICAgICAgICAgIGlkOiBpZCArICctZmlsbC1ob3QnLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxsJyxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IHt9LFxuICAgICAgICAgICAgICAgIGZpbHRlcjogW1wiPT1cIiwgXCIkdHlwZVwiLCBcIlBvbHlnb25cIl0sXG4gICAgICAgICAgICAgICAgcGFpbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuc2Vjb25kYXJ5SG90LFxuICAgICAgICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogWydjYXNlJywgW1wiYm9vbGVhblwiLCBbXCJoYXNcIiwgXCJuZXdcIl0sIHRydWVdLCAwLjUsIDAuMV0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAnc291cmNlJzogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuSE9ULFxuICAgICAgICAgICAgICAgICdpZCc6IGlkICsgJy1saW5lLWhvdCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnbGluZScsXG4gICAgICAgICAgICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY2FwJzogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMucHJpbWFyeUhvdCxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtd2lkdGgnOiA0LFxuICAgICAgICAgICAgICAgICAgICAnbGluZS1kYXNoYXJyYXknOiBbMSwyXSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICdzb3VyY2UnOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5IT1QsXG4gICAgICAgICAgICAgICAgJ2lkJzogaWQgKyAnLXBvaW50LWhvdCcsXG4gICAgICAgICAgICAgICAgJ2ZpbHRlcic6IFsnPT0nLCAnJHR5cGUnLCAnUG9pbnQnXSxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgIC8vJ2ZpbHRlcic6IFtcIj09XCIsIDAsIFsnbnVtYmVyJywgWydnZXQnLCAncGFpbnRpbmcnXV1dLFxuICAgICAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NpcmNsZS1yYWRpdXMnOiBbXCJtYXRjaFwiLCBbXCJnZXRcIiwgXCJ0eXBlXCJdLCBcIkNpcmNsZVwiLCA4LCA0XSxcbiAgICAgICAgICAgICAgICAgICAgJ2NpcmNsZS1zdHJva2Utd2lkdGgnOiAxLFxuICAgICAgICAgICAgICAgICAgICAnY2lyY2xlLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlIb3QsXG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtc3Ryb2tlLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnNlY29uZGFyeUhvdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5IT1QsXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgJy1pY29uLWhvdCcsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBbJz09JywgWydnZXQnLCAndHlwZSddLCAnSWNvbiddLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzeW1ib2wnLFxuICAgICAgICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ljb24tb3B0aW9uYWwnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1maWVsZCc6IFsnZ2V0JywgJ3ByaW1hcnlJY29uJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXNpemUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFzZSc6IDE2LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0b3BzJzogW1sxMCwgMTZdLCBbMTQsIDEyXV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtbGluZS1oZWlnaHQnOiAxLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1wYWRkaW5nJzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtb2Zmc2V0JzogWzAsIDAuMl0sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWp1c3RpZnknOiAnYXV0bycsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1hbGxvdy1vdmVybGFwJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtZm9udCc6IFsnRm9udCBBd2Vzb21lIDYgUHJvIFNvbGlkJ10sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWlnbm9yZS1wbGFjZW1lbnQnOiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBwYWludDoge1xuICAgICAgICAgICAgICAgICAgICAndGV4dC10cmFuc2xhdGUtYW5jaG9yJzogJ3ZpZXdwb3J0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtaGFsby1jb2xvcic6IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5wcmltYXJ5SG90LFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1oYWxvLXdpZHRoJzogMCwgLy9bICdjYXNlJywgWydib29sZWFuJywgWydmZWF0dXJlLXN0YXRlJywgJ2hvdmVyJ10sIGZhbHNlXSwgMC41LCAwIF0sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnNlY29uZGFyeUhvdFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5IT1QsXG4gICAgICAgICAgICAgICAgaWQ6IGlkICsgJy1pbWFnZS1ob3QnLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogWyc9PScsIFsnZ2V0JywgJ3R5cGUnXSwgJ0ltYWdlJ10sXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N5bWJvbCcsXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICAnaWNvbi1pbWFnZSc6IFsnZ2V0JywgJ3ByaW1hcnlJbWFnZScsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLFxuICAgICAgICAgICAgICAgICAgICAnaWNvbi1zaXplJzogWydpbnRlcnBvbGF0ZScsIFsnbGluZWFyJ10sIFsnem9vbSddLCAxLCAwLjQsIDE1LCAxXSxcbiAgICAgICAgICAgICAgICAgICAgJ2ljb24tYWxsb3ctb3ZlcmxhcCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdpY29uLWFuY2hvcic6ICdib3R0b20nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAnc291cmNlJzogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuSE9UVEVYVCxcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCArICctdGV4dC1ob3QnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ3N5bWJvbCcsXG4gICAgICAgICAgICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ3N5bWJvbC1wbGFjZW1lbnQnOiAncG9pbnQnLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1maWVsZCc6IFsnZ2V0JywgJ3RleHQnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtZm9udCc6IFsnQXJpYWwgVW5pY29kZSBNUyBSZWd1bGFyJywgJ0RJTiBPZmZjIFBybyBNZWRpdW0nLCAnQXJpYWwgVW5pY29kZSBNUyBCb2xkJ10sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWtlZXAtdXByaWdodCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWFuY2hvcic6IFsnZ2V0JywnYW5jaG9yJ10sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXNpemUnOiAxOCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtanVzdGlmeSc6IFsnZ2V0JywnanVzdGlmeSddLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1sZXR0ZXItc3BhY2luZyc6IDAuMSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtbGluZS1oZWlnaHQnOiAxLjIsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LW1heC1hbmdsZSc6IDEwLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1vZmZzZXQnOiBbMCwgLTEuNV0sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXBhZGRpbmcnOiAyLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1yb3RhdGUnOiAwLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC10cmFuc2Zvcm0nOiBbJ2dldCcsICd0cmFuc2Zvcm0nXVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAndGV4dC1jb2xvcic6IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5wcmltYXJ5VGV4dCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtaGFsby1jb2xvcic6IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5wcmltYXJ5QmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtaGFsby13aWR0aCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LW9wYWNpdHknOiAxLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3NvdXJjZSc6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNOQVAsXG4gICAgICAgICAgICAgICAgJ2lkJzogaWQgKyAnLXBvaW50LXNuYXAnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgICAgICAgICAgICAgJ2ZpbHRlcic6IFsnPT0nLCAnJHR5cGUnLCAnUG9pbnQnXSxcbiAgICAgICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtcmFkaXVzJzogW1wibWF0Y2hcIiwgW1wiZ2V0XCIsIFwidHlwZVwiXSwgXCJDaXJjbGVcIiwgNiwgXCJJY29uXCIsIDAsIDZdLFxuICAgICAgICAgICAgICAgICAgICAnY2lyY2xlLXN0cm9rZS13aWR0aCc6IDIsXG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMucHJpbWFyeVNuYXAsXG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtc3Ryb2tlLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnNlY29uZGFyeVNuYXBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU05BUCxcbiAgICAgICAgICAgICAgICBpZDogaWQgKyAnLWljb24tc25hcCcsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N5bWJvbCcsXG4gICAgICAgICAgICAgICAgZmlsdGVyOiBbJz09JywgWydnZXQnLCAndHlwZSddLCAnSWNvbiddLFxuICAgICAgICAgICAgICAgIGxheW91dDoge1xuICAgICAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ljb24tb3B0aW9uYWwnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1maWVsZCc6IFsnZ2V0JywgJ3ByaW1hcnlJY29uJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXNpemUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAnYmFzZSc6IDE4LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3N0b3BzJzogW1sxMCwgMThdLCBbMTQsIDE2XV1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtbGluZS1oZWlnaHQnOiAxLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1wYWRkaW5nJzogMCxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtb2Zmc2V0JzogWzAsMC4yXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtanVzdGlmeSc6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWFsbG93LW92ZXJsYXAnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1mb250JzogWydGb250IEF3ZXNvbWUgNiBQcm8gU29saWQnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtaWdub3JlLXBsYWNlbWVudCc6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBhaW50OiB7XG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXRyYW5zbGF0ZS1hbmNob3InOiAndmlld3BvcnQnLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1oYWxvLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlTbmFwLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1oYWxvLXdpZHRoJzogMCwgLy9bICdjYXNlJywgWydib29sZWFuJywgWydmZWF0dXJlLXN0YXRlJywgJ2hvdmVyJ10sIGZhbHNlXSwgMC41LCAwIF0sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnNlY29uZGFyeVNuYXBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU05BUCxcbiAgICAgICAgICAgICAgICBpZDogaWQgKyAnLWltYWdlLXNuYXAnLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogWyc9PScsIFsnZ2V0JywgJ3R5cGUnXSwgJ0ltYWdlJ10sXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N5bWJvbCcsXG4gICAgICAgICAgICAgICAgbGF5b3V0OiB7XG4gICAgICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICAnaWNvbi1pbWFnZSc6IFsnZ2V0JywgJ3ByaW1hcnlJbWFnZScsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLFxuICAgICAgICAgICAgICAgICAgICAnaWNvbi1zaXplJzogWydpbnRlcnBvbGF0ZScsIFsnbGluZWFyJ10sIFsnem9vbSddLCAxLCAwLjQsIDE1LCAxXSxcbiAgICAgICAgICAgICAgICAgICAgJ2ljb24tYWxsb3ctb3ZlcmxhcCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdpY29uLWFuY2hvcic6ICdib3R0b20nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAnc291cmNlJzogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU05BUCxcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCArICctbGluZS1zbmFwJyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAvLydmaWx0ZXInOiBbXCI9PVwiLCBcIiR0eXBlXCIsIFwiTGluZVN0cmluZ1wiXSxcbiAgICAgICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY2FwJzogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuc2Vjb25kYXJ5U25hcCxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtd2lkdGgnOiA0LFxuICAgICAgICAgICAgICAgICAgICAnbGluZS1kYXNoYXJyYXknOlsxLDJdXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAnc291cmNlJzogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuUk9VVEUsXG4gICAgICAgICAgICAgICAgJ2lkJzogaWQgKyAnLWxpbmUtcm91dGUnLFxuICAgICAgICAgICAgICAgICd0eXBlJzogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICdmaWx0ZXInOiBbXCI9PVwiLCBcIiR0eXBlXCIsIFwiTGluZVN0cmluZ1wiXSxcbiAgICAgICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY2FwJzogJ3JvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLXdpZHRoJzogNCxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtZGFzaGFycmF5JzpbXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgJ3NvdXJjZSc6IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlZFUlRFWCxcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCArICctcG9pbnQtdmVydGV4JyxcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdjaXJjbGUnLFxuICAgICAgICAgICAgICAgICdmaWx0ZXInOiBbJz09JywgXCIkdHlwZVwiLCAnTGluZVN0cmluZyddLFxuICAgICAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAgICAgJ2NpcmNsZS1yYWRpdXMnOiA0LFxuICAgICAgICAgICAgICAgICAgICAnY2lyY2xlLXN0cm9rZS13aWR0aCc6IDMsXG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMucHJpbWFyeVZlcnRleCxcbiAgICAgICAgICAgICAgICAgICAgJ2NpcmNsZS1zdHJva2UtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuc2Vjb25kYXJ5VmVydGV4XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAnc291cmNlJzogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuR0FNRVBBRCxcbiAgICAgICAgICAgICAgICAnaWQnOiBpZCArICctZ2FtZXBhZCcsXG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnc3ltYm9sJyxcbiAgICAgICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAgICAgJ2ljb24taW1hZ2UnOiAnZ2FtZXBhZCcsXG4gICAgICAgICAgICAgICAgICAgICdpY29uLXNpemUnOiAwLjI1XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBdXG4gICAgXG4gICAgICAgIHRoaXMuc2VsZWN0TGF5ZXJzID0gW3tcbiAgICAgICAgICAgICdzb3VyY2UnOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TRUxFQ1QsXG4gICAgICAgICAgICAnaWQnOiBpZCArICctbGluZS1zZWxlY3QnLFxuICAgICAgICAgICAgJ3R5cGUnOiAnbGluZScsXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAncGFpbnQnOiB7XG4gICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuc2Vjb25kYXJ5U2VsZWN0LFxuICAgICAgICAgICAgICAgICdsaW5lLXdpZHRoJzogNCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWV0YWRhdGEnOiB7IHR5cGVzOiBbJ1BvbHlsaW5lJywgJ1BvbHlnb24nLCAnUmVjdGFuZ2xlJ10gfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAnc291cmNlJzogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU0VMRUNULFxuICAgICAgICAgICAgJ2lkJzogaWQgKyAnLWZpbGwtc2VsZWN0JyxcbiAgICAgICAgICAgICd0eXBlJzogJ2ZpbGwnLFxuICAgICAgICAgICAgJ2xheW91dCc6IHt9LFxuICAgICAgICAgICAgJ2ZpbHRlcic6IFtcIj09XCIsIFwiJHR5cGVcIiwgXCJQb2x5Z29uXCJdLFxuICAgICAgICAgICAgJ3BhaW50Jzoge1xuICAgICAgICAgICAgICAgICdmaWxsLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlTZWxlY3QsXG4gICAgICAgICAgICAgICAgJ2ZpbGwtb3BhY2l0eSc6IDAuNFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtZXRhZGF0YSc6IHsgdHlwZXM6IFsnUG9seWdvbicsICdSZWN0YW5nbGUnXSB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgICdzb3VyY2UnOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TRUxFQ1QsXG4gICAgICAgICAgICAnaWQnOiBpZCArICctcG9pbnQtc2VsZWN0JyxcbiAgICAgICAgICAgICdmaWx0ZXInOiBbJ2FsbCcsIFsnIT0nLCBbJ2dldCcsICd0eXBlJ10sICdUZXh0J10sIFtcIj09XCIsIFtcImdlb21ldHJ5LXR5cGVcIl0sIFwiUG9pbnRcIl0gXSxcbiAgICAgICAgICAgICd0eXBlJzogJ2NpcmNsZScsXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAnY2lyY2xlLXJhZGl1cyc6IDEyLFxuICAgICAgICAgICAgICAgICdjaXJjbGUtc3Ryb2tlLXdpZHRoJzogMyxcbiAgICAgICAgICAgICAgICAnY2lyY2xlLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlTZWxlY3QsXG4gICAgICAgICAgICAgICAgJ2NpcmNsZS1zdHJva2UtY29sb3InOiBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuc2Vjb25kYXJ5U2VsZWN0LFxuICAgICAgICAgICAgICAgICdjaXJjbGUtc3Ryb2tlLW9wYWNpdHknOiAxLFxuICAgICAgICAgICAgICAgICdjaXJjbGUtb3BhY2l0eSc6IDAuOFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtZXRhZGF0YSc6IHsgdHlwZXM6IFsnUG9pbnQnLCAnQ2lyY2xlJywgJ01hcmtlcicsICdJY29uJ10gfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICAnc291cmNlJzogZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU0VMRUNULFxuICAgICAgICAgICAgJ2lkJzogaWQgKyAnLXN5bWJvbC1zZWxlY3QnLFxuICAgICAgICAgICAgJ2ZpbHRlcic6IFsnPT0nLCBbJ2dldCcsICd0eXBlJ10sICdJY29uJ10sXG4gICAgICAgICAgICAndHlwZSc6ICdzeW1ib2wnLFxuICAgICAgICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAnaWNvbi1vcHRpb25hbCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3N5bWJvbC1wbGFjZW1lbnQnOiAncG9pbnQnLFxuICAgICAgICAgICAgICAgICd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCc6ICd2aWV3cG9ydCcsXG4gICAgICAgICAgICAgICAgJ3RleHQtZmllbGQnOiBbJ2dldCcsICdwcmltYXJ5SWNvbicsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLFxuICAgICAgICAgICAgICAgICd0ZXh0LXJvdGF0ZSc6IFsnZ2V0JywgJ3JvdGF0ZScsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLFxuICAgICAgICAgICAgICAgICd0ZXh0LXNpemUnOiAxNCxcbiAgICAgICAgICAgICAgICAndGV4dC1saW5lLWhlaWdodCc6IDEsXG4gICAgICAgICAgICAgICAgJ3RleHQtcGFkZGluZyc6IDAsXG4gICAgICAgICAgICAgICAgJ3RleHQtb2Zmc2V0JzogWzAsIDAuMl0sXG4gICAgICAgICAgICAgICAgJ3RleHQtanVzdGlmeSc6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAndGV4dC1hbmNob3InOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICAndGV4dC1hbGxvdy1vdmVybGFwJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndGV4dC1mb250JzogWydGb250IEF3ZXNvbWUgNiBQcm8gU29saWQnXSxcbiAgICAgICAgICAgICAgICAndGV4dC1pZ25vcmUtcGxhY2VtZW50JzogdHJ1ZVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAndGV4dC10cmFuc2xhdGUtYW5jaG9yJzogJ3ZpZXdwb3J0JyxcbiAgICAgICAgICAgICAgICAndGV4dC1oYWxvLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnNlY29uZGFyeVNlbGVjdCxcbiAgICAgICAgICAgICAgICAndGV4dC1oYWxvLXdpZHRoJzogMixcbiAgICAgICAgICAgICAgICAndGV4dC1jb2xvcic6IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5wcmltYXJ5QmFja2dyb3VuZCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWV0YWRhdGEnOiB7IHR5cGVzOiBbJ0ljb24nXSB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgICdzb3VyY2UnOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TRUxFQ1QsXG4gICAgICAgICAgICAnaWQnOiBpZCArICctdGV4dC1zZWxlY3QnLFxuICAgICAgICAgICAgJ2ZpbHRlcic6IFsnPT0nLCBbJ2dldCcsICd0eXBlJ10sICdUZXh0J10sXG4gICAgICAgICAgICAndHlwZSc6ICdzeW1ib2wnLFxuICAgICAgICAgICAgJ2xheW91dCc6IHtcbiAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICBcInN5bWJvbC1wbGFjZW1lbnRcIjogXCJwb2ludFwiLFxuICAgICAgICAgICAgICAgICd0ZXh0LXJvdGF0aW9uLWFsaWdubWVudCc6ICd2aWV3cG9ydCcsXG4gICAgICAgICAgICAgICAgJ3RleHQtZmllbGQnOiBbJ2dldCcsICd0ZXh0J10sXG4gICAgICAgICAgICAgICAgJ3RleHQtZm9udCc6IFsnRElOIFBybyBSZWd1bGFyJywgJ0RJTiBQcm8gSXRhbGljJywgJ0FyaWFsIFVuaWNvZGUgTVMgUmVndWxhcicsICdESU4gT2ZmYyBQcm8gTWVkaXVtJywgJ0FyaWFsIFVuaWNvZGUgTVMgQm9sZCddLFxuICAgICAgICAgICAgICAgICd0ZXh0LWtlZXAtdXByaWdodCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3RleHQtYWxsb3ctb3ZlcmxhcCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ3RleHQtc2l6ZSc6IDE4LFxuICAgICAgICAgICAgICAgICd0ZXh0LWp1c3RpZnknOiBbJ2dldCcsICdqdXN0aWZ5J10sXG4gICAgICAgICAgICAgICAgJ3RleHQtbGV0dGVyLXNwYWNpbmcnOiAwLjEyLFxuICAgICAgICAgICAgICAgICd0ZXh0LWxpbmUtaGVpZ2h0JzogMS4yLFxuICAgICAgICAgICAgICAgICd0ZXh0LW1heC1hbmdsZSc6IDEwLFxuICAgICAgICAgICAgICAgICd0ZXh0LW9mZnNldCc6IFswLDEuNV0sXG4gICAgICAgICAgICAgICAgJ3RleHQtcGFkZGluZyc6IDIsXG4gICAgICAgICAgICAgICAgJ3RleHQtcm90YXRlJzogMCxcbiAgICAgICAgICAgICAgICAndGV4dC10cmFuc2Zvcm0nOiBbJ2dldCcsICd0cmFuc2Zvcm0nXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdwYWludCc6IHtcbiAgICAgICAgICAgICAgICAndGV4dC1jb2xvcic6IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5wcmltYXJ5QmFja2dyb3VuZCxcbiAgICAgICAgICAgICAgICAndGV4dC1oYWxvLWNvbG9yJzogZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlDb2xvcixcbiAgICAgICAgICAgICAgICAndGV4dC1oYWxvLXdpZHRoJzogMixcbiAgICAgICAgICAgICAgICAndGV4dC1vcGFjaXR5JzogMSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWV0YWRhdGEnOiB7IHR5cGVzOiBbJ1RleHQnXSB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgICdzb3VyY2UnOiBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TRUxFQ1QsXG4gICAgICAgICAgICAnaWQnOiBpZCArICctaW1hZ2Utc2VsZWN0JyxcbiAgICAgICAgICAgICdmaWx0ZXInOiBbJz09JywgWydnZXQnLCAndHlwZSddLCAnSW1hZ2UnXSxcbiAgICAgICAgICAgICd0eXBlJzogJ3N5bWJvbCcsXG4gICAgICAgICAgICAnbGF5b3V0Jzoge1xuICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICdpY29uLWltYWdlJzogWydnZXQnLCAncHJpbWFyeUltYWdlJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sXG4gICAgICAgICAgICAgICAgJ2ljb24tc2l6ZSc6IFsnaW50ZXJwb2xhdGUnLCBbJ2xpbmVhciddLCBbJ3pvb20nXSwgMSwgMC40LCAxNSwgMV0sXG4gICAgICAgICAgICAgICAgJ2ljb24tYWxsb3ctb3ZlcmxhcCc6IHRydWUsXG4gICAgICAgICAgICAgICAgJ2ljb24tYW5jaG9yJzogJ2JvdHRvbSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnbWV0YWRhdGEnOiB7IHR5cGVzOiBbJ0ltYWdlJ10gfVxuICAgICAgICB9XVxuXG4gICAgICAgIHJldHVybiB0aGlzLnJlZnJlc2goeyBpbml0OiB0cnVlIH0pO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTGF5ZXJzXG5cdCAqIEBuYW1lIHJlZnJlc2hcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gcmVmcmVzaGVzIHRoZSBtYXAgYnkgcmVtb3ZpbmcgZXhpc3RpbmcgbGF5ZXJzIGFuZCBzb3VyY2VzLCBhZGRpbmcgZGVmYXVsdCBsYXllcnMgYW5kIHNvdXJjZXMsIGFuZCByZWJ1aWxkaW5nIHRoZSBsYXllcnMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9uYWwgcGFyYW1ldGVyIGZvciBhZGRpdGlvbmFsIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gLSBBbiBhcnJheSBvZiBsYXllcnMgYWZ0ZXIgdGhlIHJlZnJlc2ggb3BlcmF0aW9uLlxuXHQgKi9cbiAgICB0aGlzLnJlZnJlc2ggPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucz17fSkge1xuICAgICAgICBpZiAob3B0aW9ucy5zZWxlY3QpIHJldHVybiBnZW9mbG8uTGF5ZXJzLm1vdmVMYXllcnModGhpcy5zZWxlY3RMYXllcnMpO1xuICAgICAgICBpZiAoIW9wdGlvbnMuaW5pdCkgcmV0dXJuIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBsYXllcnMgPSBnZW9mbG8uVXRpbGl0aWVzLmNsb25lRGVlcCh0aGlzLl9sYXllcnMpO1xuXG4gICAgICAgIHRoaXMuX2xheWVycyA9IFtdO1xuICAgICAgICB0aGlzLl9zb3VyY2VzID0gW107XG5cbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnJlbW92ZUxheWVycyh0aGlzLmRlZmF1bHRMYXllcnMpO1xuICAgICAgICB0aGlzLnJlbW92ZUxheWVycyh0aGlzLnNlbGVjdExheWVycyk7XG4gICAgICAgIHRoaXMucmVtb3ZlU291cmNlcyhPYmplY3QudmFsdWVzKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzKSk7XG5cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLmFkZFNvdXJjZXMoT2JqZWN0LnZhbHVlcyhnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcykpO1xuICAgICAgICB0aGlzLmFkZExheWVycyh0aGlzLmRlZmF1bHRMYXllcnMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGF3YWl0IGJ1aWxkTGF5ZXJzLmNhbGwodGhpcywgbGF5ZXJzKTtcbiAgICAgICAgdGhpcy5hZGRMYXllcnModGhpcy5zZWxlY3RMYXllcnMsIHRoaXMub3B0aW9ucyk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHsgZ2VvZmxvLkxheWVycy5tb3ZlTGF5ZXJzKHRoaXMuc2VsZWN0TGF5ZXJzKTsgfSwgMjUwKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgfVxuXG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgc2V0Q3VzdG9tTGF5ZXJzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIGN1c3RvbSBsYXllcnMgYW5kIG9wdGlvbnMsIGJ1aWxkcyB0aGUgbGF5ZXJzIHVzaW5nIHRoZSBidWlsZExheWVycyBmdW5jdGlvbiwgYW5kIHJldHVybnMgdGhlIHJlc3VsdGluZyBsYXllcnMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGxheWVycyAtIEFuIGFycmF5IG9mIGN1c3RvbSBsYXllcnMgdG8gYmUgcHJvY2Vzc2VkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3IgYnVpbGRpbmcgdGhlIGxheWVycy5cblx0ICogQHJldHVybnMge1Byb21pc2U8QXJyYXk+fSBUaGUgcHJvY2Vzc2VkIGN1c3RvbSBsYXllcnMuXG5cdCAqL1xuICAgIHRoaXMuc2V0Q3VzdG9tTGF5ZXJzID0gYXN5bmMgZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWxheWVycykgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gYXdhaXQgYnVpbGRMYXllcnMuY2FsbCh0aGlzLCBsYXllcnMsIG9wdGlvbnMpO1xuICAgIH1cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgZ2V0Q3VzdG9tTGF5ZXJzXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgdGhlIGN1c3RvbSBsYXllcnMgc3RvcmVkIGluIHRoZSBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgY29udGFpbmluZyB0aGUgY3VzdG9tIGxheWVycy5cblx0ICovXG4gICAgdGhpcy5nZXRDdXN0b21MYXllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sYXllcnM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgaGFzQ3VzdG9tTGF5ZXJzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgdGhlcmUgYXJlIGFueSBjdXN0b20gbGF5ZXJzIHByZXNlbnQgaW4gdGhlIGFwcGxpY2F0aW9uLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGN1c3RvbSBsYXllcnMgYXZhaWxhYmxlLlxuXHQgKi9cbiAgICB0aGlzLmhhc0N1c3RvbUxheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q3VzdG9tTGF5ZXJzKCkubGVuZ3RoO1xuICAgIH1cblxuICAgIFxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxheWVyc1xuXHQgKiBAbmFtZSBnZXRGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBmZWF0dXJlcyBmcm9tIGEgc291cmNlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBJRC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIElEIG9mIHRoZSBzb3VyY2UgdG8gcmV0cmlldmUgZmVhdHVyZXMgZnJvbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBmZWF0dXJlcyBmcm9tIHRoZSBzcGVjaWZpZWQgc291cmNlLCBvciBhbiBlbXB0eSBhcnJheSBpZiB0aGUgc291cmNlIG9yIGZlYXR1cmVzIGFyZSBub3QgZm91bmQuXG5cdCAqL1xuICAgIHRoaXMuZ2V0RmVhdHVyZXMgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHRoaXMuZ2V0U291cmNlKGlkKTtcbiAgICAgICAgaWYgKCFzb3VyY2UgfHwgIXNvdXJjZS5fZGF0YSkgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gc291cmNlLl9kYXRhLmZlYXR1cmVzO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTGF5ZXJzXG5cdCAqIEBuYW1lIGdldFNlbGVjdGlvblxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIHRoZSBzZWxlY3RlZCBmZWF0dXJlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBmZWF0dXJlcyBhcnJheSBhbmQgY29vcmRpbmF0ZXMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZlYXR1cmVzIC0gQW4gYXJyYXkgb2YgZmVhdHVyZXMgdG8gc2VsZWN0IGZyb20uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBjb29yZHMgLSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHNlbGVjdGVkIGZlYXR1cmUuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYSBmZWF0dXJlIGlzIHNlbGVjdGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuICAgIHRoaXMuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24gKGZlYXR1cmVzPVtdLCBjb29yZHMpIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlcyAmJiBmZWF0dXJlcy5sZW5ndGggPyBmZWF0dXJlc1swXSA6IGZhbHNlO1xuICAgICAgICBpZiAoIWZlYXR1cmUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGZlYXR1cmUucHJvcGVydGllcy5jbHVzdGVyKSByZXR1cm4gTGF5ZXJzLm9uQ2x1c3RlckNsaWNrKGZlYXR1cmUsIGNvb3JkcyksIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxheWVyc1xuXHQgKiBAbmFtZSBnZXRUeXBlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgZ2VvbWV0cnkgdHlwZSBhcyBpbnB1dCBhbmQgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBnZW5lcmFsIHR5cGUgKFBvbHlnb24sIFBvbHlsaW5lLCBvciBQb2ludCkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgZ2VvbWV0cnkgdG8gYmUgZXZhbHVhdGVkLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfGJvb2xlYW59IFJldHVybnMgdGhlIGdlbmVyYWwgdHlwZSBvZiB0aGUgZ2VvbWV0cnkgKFBvbHlnb24sIFBvbHlsaW5lLCBQb2ludCkgb3IgZmFsc2UgaWYgdGhlIHR5cGUgaXMgbm90IHJlY29nbml6ZWQuXG5cdCAqL1xuICAgIHRoaXMuZ2V0VHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnUG9seWdvbicgfHwgdHlwZSA9PT0gJ1JlY3RhbmdsZScgPyAnUG9seWdvbicgOlxuICAgICAgICB0eXBlID09PSAnUG9seWxpbmUnIHx8IHR5cGUgPT09ICdMaW5lU3RyaW5nJyB8fCB0eXBlID09PSAnTGluZScgPyAnUG9seWxpbmUnIDpcbiAgICAgICAgdHlwZSA9PT0gJ1BvaW50JyB8fCB0eXBlID09PSAnQ2lyY2xlJyB8fCB0eXBlID09PSAnTWFya2VyJyB8fCB0eXBlID09PSAnSWNvbicgfHwgdHlwZSA9PT0gJ1RleHQnID8gJ1BvaW50JyA6XG4gICAgICAgIHR5cGUgPT09ICdJbWFnZScgPyAnSW1hZ2UnIDpcbiAgICAgICAgZmFsc2U7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgZ2V0U291cmNlc1xuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBzb3VyY2VzIHN0b3JlZCBpbiB0aGUgb2JqZWN0LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHNvdXJjZXMuXG5cdCAqL1xuICAgIHRoaXMuZ2V0U291cmNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc291cmNlcztcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxheWVyc1xuXHQgKiBAbmFtZSBnZXRTb3VyY2Vcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBhIHNwZWNpZmljIHNvdXJjZSBvYmplY3QgYnkgaXRzIElEIGZyb20gdGhlIGxpc3Qgb2Ygc291cmNlcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIElEIG9mIHRoZSBzb3VyY2UgdG8gcmV0cmlldmUuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R8Ym9vbGVhbn0gVGhlIHNvdXJjZSBvYmplY3Qgd2l0aCB0aGUgc3BlY2lmaWVkIElEIGlmIGZvdW5kLCBvdGhlcndpc2UgZmFsc2UuXG5cdCAqL1xuICAgIHRoaXMuZ2V0U291cmNlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghaWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIHNvdXJjZXMgPSB0aGlzLmdldFNvdXJjZXMoKTtcbiAgICAgICAgcmV0dXJuIHNvdXJjZXMuZmluZChmdW5jdGlvbihzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZS5pZCA9PT0gaWQgfSlcbiAgICB9XG5cblx0LyoqIFxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgZ2V0U291cmNlSWRzXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgdGhlIElEcyBvZiBhbGwgc291cmNlcy5cblx0ICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBzb3VyY2UgSURzLlxuXHQgKi9cbiAgICB0aGlzLmdldFNvdXJjZUlkcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlcygpLm1hcChmdW5jdGlvbiAocykgeyByZXR1cm4gcy5pZCB9KTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxheWVyc1xuXHQgKiBAbmFtZSBnZXRMYXllcnNcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyB0aGUgbGF5ZXJzIGFycmF5IGZyb20gdGhlIG9iamVjdC5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbGF5ZXJzIGFycmF5LlxuXHQgKi9cbiAgICB0aGlzLmdldExheWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5ZXJzO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTGF5ZXJzXG5cdCAqIEBuYW1lIGdldExheWVyXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgYSBsYXllciBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgSUQgb3Igc291cmNlIElELlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgSUQgb2YgdGhlIGxheWVyIHRvIHJldHJpZXZlLlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fGJvb2xlYW59IFRoZSBsYXllciBvYmplY3QgaWYgZm91bmQsIG9yIGZhbHNlIGlmIG5vdCBmb3VuZC5cblx0ICovXG4gICAgdGhpcy5nZXRMYXllciA9IGZ1bmN0aW9uIChpZCwgY3VzdG9tKSB7XG4gICAgICAgIGlmICghaWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGxheWVycyA9IGN1c3RvbSA/IHRoaXMuZ2V0Q3VzdG9tTGF5ZXJzKCkgOiB0aGlzLmdldExheWVycygpO1xuICAgICAgICB2YXIgbGF5ZXIgPSBsYXllcnMuZmluZChmdW5jdGlvbihsYXllcikgeyByZXR1cm4gbGF5ZXIuaWQgPT09IGlkIH0pO1xuICAgICAgICBpZiAoIWxheWVyKSBsYXllciA9IGxheWVycy5maWx0ZXIoZnVuY3Rpb24obGF5ZXIpIHsgcmV0dXJuIGxheWVyLnNvdXJjZSA9PT0gaWQgfSk7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxheWVyc1xuXHQgKiBAbmFtZSBnZXRMYXllcklkc1xuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBJRHMgb2YgdGhlIGxheWVycyBwcm92aWRlZCBvciB0aGUgZGVmYXVsdCBsYXllcnMgaWYgbm9uZSBhcmUgcHJvdmlkZWQuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGxheWVycyAtIEFuIGFycmF5IG9mIGxheWVyIG9iamVjdHMuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgbGF5ZXIgSURzLlxuXHQgKi9cbiAgICB0aGlzLmdldExheWVySWRzID0gZnVuY3Rpb24gKGxheWVycykge1xuICAgICAgICB2YXIgX2xheWVycyA9IGxheWVycyB8fCB0aGlzLmdldEN1c3RvbUxheWVycygpO1xuICAgICAgICByZXR1cm4gX2xheWVycy5tYXAoZnVuY3Rpb24gKGwpIHsgcmV0dXJuIGwuaWQgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRMYXllclR5cGUgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgbGV0IHR5cGUgPSAnJztcbiAgICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmdldExheWVyKGlkLCB0cnVlKTtcbiAgICAgICAgaWYgKGxheWVyICYmIGxheWVyLmRldGFpbHMpIHR5cGUgPSBsYXllci5kZXRhaWxzLnR5cGU7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuXG5cbiAgICBcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTGF5ZXJzXG5cdCAqIEBuYW1lIGFkZFNvdXJjZXNcblx0ICogQGRlc2NyaXB0aW9uIEFkZHMgbXVsdGlwbGUgc291cmNlcyB0byB0aGUgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBzb3VyY2VzIC0gQW4gYXJyYXkgb2Ygc291cmNlcyB0byBiZSBhZGRlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGFkZGluZyB0aGUgc291cmNlcy5cblx0ICogQHJldHVybnMge0FycmF5fSAtIEFuIGFycmF5IG9mIGFsbCB0aGUgYWRkZWQgc291cmNlcy5cblx0ICovXG4gICAgdGhpcy5hZGRTb3VyY2VzID0gZnVuY3Rpb24gKHNvdXJjZXM9W10sIG9wdGlvbnM9e30pIHtcbiAgICAgICAgc291cmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNvdXJjZSkgeyB0aGlzLmFkZFNvdXJjZShzb3VyY2UsIGZhbHNlLCBvcHRpb25zKSB9LCB0aGlzKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ3NvdXJjZXMuYWRkJywgeyBzb3VyY2VzOiB0aGlzLmdldFNvdXJjZXMoKSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U291cmNlcygpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTGF5ZXJzXG5cdCAqIEBuYW1lIGFkZFNvdXJjZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBhZGRzIGEgbmV3IHNvdXJjZSB0byB0aGUgbWFwIHVzaW5nIHRoZSBwcm92aWRlZCBJRCBhbmQgdHlwZS4gSXQgYWxzbyBhY2NlcHRzIG9wdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHNvdXJjZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIHVuaXF1ZSBpZGVudGlmaWVyIGZvciB0aGUgc291cmNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBzb3VyY2UgKGUuZy4sICdnZW9qc29uJywgJ3ZlY3RvcicsICdyYXN0ZXInLCBldGMuKS5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIEFkZGl0aW9uYWwgY29uZmlndXJhdGlvbiBvcHRpb25zIGZvciB0aGUgc291cmNlIChlLmcuLCBmZWF0dXJlcywgcHJvbW90ZUlkLCBjbHVzdGVyTWF4Wm9vbSwgY2x1c3RlclJhZGl1cykuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBuZXdseSBhZGRlZCBzb3VyY2Ugb2JqZWN0LlxuXHQgKi9cbiAgICB0aGlzLmFkZFNvdXJjZSA9IGZ1bmN0aW9uIChpZCwgdHlwZSwgb3B0aW9ucz17fSkge1xuICAgICAgICBpZiAoIWlkKSB0aHJvdyBuZXcgRXJyb3IoJ05vIHNvdXJjZSB3YXMgcHJvdmlkZWQhJyk7XG4gICAgICAgIFxuICAgICAgICB2YXIgb3B0cyA9IHsgdHlwZTogb3B0aW9ucy50eXBlIHx8IFwiZ2VvanNvblwiLCBkYXRhOiB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKG9wdGlvbnMuZmVhdHVyZXMgfHwgW10pLCBwcm9tb3RlSWQ6IG9wdGlvbnMucHJvbW90ZUlkIHx8ICdpZCcgfTtcbiAgICAgICAgaWYgKHR5cGUgJiYgdHlwZSA9PT0gJ1BvaW50JyAmJiAhb3B0aW9ucy5ub0NsdXN0ZXIpIHsgb3B0cyA9IE9iamVjdC5hc3NpZ24ob3B0cywgeyBjbHVzdGVyOiB0cnVlLCBjbHVzdGVyTWF4Wm9vbTogb3B0aW9ucy5jbHVzdGVyTWF4Wm9vbSB8fCAxNCwgY2x1c3RlclJhZGl1czogb3B0aW9ucy5jbHVzdGVyUmFkaXVzIHx8IDUwIH0pIH1cblxuICAgICAgICBtYXAuYWRkU291cmNlKGlkLCBvcHRzKTtcbiAgICAgICAgdGhpcy5zb3VyY2VzLnB1c2gobWFwLmdldFNvdXJjZShpZCkpO1xuICAgICAgICBnZW9mbG8uZmlyZSgnc291cmNlLmFkZCcsIHsgaWQ6IGlkLCBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKGlkKSB9KVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTb3VyY2UoaWQpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTGF5ZXJzXG5cdCAqIEBuYW1lIGFkZExheWVyc1xuXHQgKiBAZGVzY3JpcHRpb24gQWRkcyBtdWx0aXBsZSBsYXllcnMgdG8gdGhlIG1hcC5cblx0ICogQHBhcmFtIHtBcnJheX0gbGF5ZXJzIC0gQW4gYXJyYXkgb2YgbGF5ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBtYXAuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBhZGRpbmcgdGhlIGxheWVycy5cblx0ICogQHJldHVybnMge0FycmF5fSAtIEFuIGFycmF5IG9mIGxheWVycyB0aGF0IGhhdmUgYmVlbiBhZGRlZCB0byB0aGUgbWFwLlxuXHQgKi9cbiAgICB0aGlzLmFkZExheWVycyA9IGZ1bmN0aW9uIChsYXllcnM9W10sIG9wdGlvbnM9e30pIHtcbiAgICAgICAgbGF5ZXJzLmZvckVhY2goZnVuY3Rpb24obGF5ZXIsIGluZGV4KSB7IHRoaXMuYWRkTGF5ZXIobGF5ZXIsIG9wdGlvbnMsIGluZGV4KSB9LCB0aGlzKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ2xheWVycy5hZGQnLCB7IGxheWVyczogdGhpcy5nZXRMYXllcnMoKSB9KTtcbiAgICAgICAgYnVpbGRFdmVudHMuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgYWRkTGF5ZXJcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gYWRkcyBhIGxheWVyIHRvIHRoZSBtYXAgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucy4gSXQgYWxzbyB1cGRhdGVzIHRoZSBsYXllcidzIG1ldGFkYXRhLCBhZGRzIHRoZSBsYXllciB0byB0aGUgbWFwLCBhbmQgcHVzaGVzIHRoZSBsYXllciB0byB0aGUgbGF5ZXJzIGFycmF5LiBJdCB0cmlnZ2VycyBhICdsYXllci5hZGQnIGV2ZW50IGFuZCByZXR1cm5zIHRoZSBhZGRlZCBsYXllci5cblx0ICogQHBhcmFtIHtPYmplY3R9IGxheWVyIC0gVGhlIGxheWVyIG9iamVjdCB0byBiZSBhZGRlZCB0byB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgbGF5ZXIuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBhZGRlZCBsYXllci5cblx0ICovXG4gICAgdGhpcy5hZGRMYXllciA9IGZ1bmN0aW9uIChsYXllciwgb3B0aW9ucz17fSwgaW5kZXgpIHtcbiAgICAgICAgaWYgKCFsYXllciB8fCAhbGF5ZXIuaWQpIHJldHVybiBmYWxzZTsgICAgICAgIFxuICAgICAgICBsYXllci5tZXRhZGF0YSA9IGxheWVyLm1ldGFkYXRhIHx8IG9wdGlvbnM7XG5cbiAgICAgICAgaWYgKG1hcC5nZXRMYXllcihsYXllci5pZCkpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sYXllcnMuZmluZChmdW5jdGlvbihsKSB7IHJldHVybiBsLmlkID09PSBsYXllci5pZCB9KSkgdGhpcy5sYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcihsYXllci5pZCk7XG4gICAgICAgIH1cblxuICAgICAgICBtYXAuYWRkTGF5ZXIobGF5ZXIpO1xuXG4gICAgICAgIGxheWVyID0gbWFwLmdldExheWVyKGxheWVyLmlkKTtcbiAgICAgICAgaWYgKCFsYXllcikgcmV0dXJuIGNvbnNvbGUuZXJyb3IoaWQsICdMYXllciBOb3QgQWRkZWQhJyk7XG5cbiAgICAgICAgdGhpcy5sYXllcnMucHVzaChsYXllcik7XG4gICAgICAgIGdlb2Zsby5maXJlKCdsYXllci5hZGQnLCB7IGlkOiBsYXllci5pZCwgbGF5ZXI6IHRoaXMuZ2V0TGF5ZXIobGF5ZXIuaWQpIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMYXllcihsYXllci5pZCk7XG4gICAgfVxuXG4gICAgdGhpcy5hZGRUZXh0TGF5ZXIgPSBmdW5jdGlvbiAob3B0aW9ucz17fSkge1xuICAgICAgICB2YXIgbGF5ZXJzID0gb3B0aW9ucy5zZWxlY3QgPyB0aGlzLmdldExheWVyKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNFTEVDVCkgOiB0aGlzLmdldEN1c3RvbUxheWVycygpO1xuICAgICAgICB2YXIgZmllbGQgPSBvcHRpb25zLmZpZWxkIHx8ICd0ZXh0JztcblxuICAgICAgICB0aGlzLnJlbW92ZVRleHRMYXllcihvcHRpb25zKTtcblxuICAgICAgICBsYXllcnMuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgdmFyIGlkID0gbGF5ZXIuaWQgKyAnLVRleHQnO1xuXG4gICAgICAgICAgICB2YXIgZmlsdGVyID0gWydhbGwnLCBbJz09JywgW1wiZ2VvbWV0cnktdHlwZVwiXSwgJ1BvaW50J10sIFtcImhhc1wiLCBmaWVsZF0gXTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmZpbHRlcikgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2VsZWN0ICYmIG9wdGlvbnMuaWRzKSBmaWx0ZXIgPSBbJ2luJywgJ2lkJywgLi4ub3B0aW9ucy5pZHNdO1xuXG4gICAgICAgICAgICB2YXIgbGF5b3V0ID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICdzeW1ib2wtcGxhY2VtZW50JzogJ3BvaW50JyxcbiAgICAgICAgICAgICAgICAndGV4dC1yb3RhdGlvbi1hbGlnbm1lbnQnOiAndmlld3BvcnQnLFxuICAgICAgICAgICAgICAgICd0ZXh0LWZpZWxkJzogWydnZXQnLCBmaWVsZF0sXG4gICAgICAgICAgICAgICAgJ3RleHQta2VlcC11cHJpZ2h0JzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndGV4dC1hbGxvdy1vdmVybGFwJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAndGV4dC1hbmNob3InOiAndG9wJyxcbiAgICAgICAgICAgICAgICAndGV4dC1zaXplJzogMTIsXG4gICAgICAgICAgICAgICAgJ3RleHQtanVzdGlmeSc6ICdjZW50ZXInLFxuICAgICAgICAgICAgICAgICd0ZXh0LWxldHRlci1zcGFjaW5nJzogMC4yNSxcbiAgICAgICAgICAgICAgICAndGV4dC1saW5lLWhlaWdodCc6IDEuMixcbiAgICAgICAgICAgICAgICAndGV4dC1tYXgtYW5nbGUnOiAxMCxcbiAgICAgICAgICAgICAgICAndGV4dC1vZmZzZXQnOiBbMCwgMC41XSxcbiAgICAgICAgICAgICAgICAndGV4dC1wYWRkaW5nJzogMixcbiAgICAgICAgICAgICAgICAndGV4dC1yb3RhdGUnOiAwLFxuICAgICAgICAgICAgICAgICd0ZXh0LXRyYW5zZm9ybSc6ICdub25lJyxcbiAgICAgICAgICAgICAgICAndGV4dC1mb250JzogWydBcmlhbCBVbmljb2RlIE1TIFJlZ3VsYXInLCAnRElOIE9mZmMgUHJvIE1lZGl1bScsICdBcmlhbCBVbmljb2RlIE1TIEJvbGQnXSxcbiAgICAgICAgICAgICAgICAndGV4dC1pZ25vcmUtcGxhY2VtZW50JzogZmFsc2UsXG4gICAgICAgICAgICAgICAgJ3RleHQtbWF4LXdpZHRoJzogMTVcbiAgICAgICAgICAgIH0sIGxheWVyLnRleHQgPyBsYXllci50ZXh0LmxheW91dCB8fCB7fSA6IHt9LCBvcHRpb25zLmxheW91dCk7XG5cbiAgICAgICAgICAgIHZhciBwYWludCA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICAndGV4dC10cmFuc2xhdGUtYW5jaG9yJzogJ3ZpZXdwb3J0JyxcbiAgICAgICAgICAgICAgICAndGV4dC1oYWxvLWNvbG9yJzogWydnZXQnLCAncHJpbWFyeUNvbG9yJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sXG4gICAgICAgICAgICAgICAgJ3RleHQtaGFsby13aWR0aCc6IDEuMixcbiAgICAgICAgICAgICAgICAndGV4dC1jb2xvcic6IFsnZ2V0JywgJ3NlY29uZGFyeUNvbG9yJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sXG4gICAgICAgICAgICAgICAgJ3RleHQtb3BhY2l0eSc6IFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsIFsnZ2V0JywgJ29wYWNpdHknLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXV1cbiAgICAgICAgICAgIH0sIGxheWVyLnRleHQgPyBsYXllci50ZXh0LnBhaW50IHx8IHt9IDoge30sIG9wdGlvbnMucGFpbnQpO1xuXG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgIHR5cGU6ICdzeW1ib2wnLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogbGF5ZXIuc291cmNlIHx8IGxheWVyLmRldGFpbHMuc291cmNlIHx8IGlkLFxuICAgICAgICAgICAgICAgIHNsb3Q6ICd0b3AnLFxuICAgICAgICAgICAgICAgIGZpbHRlcjogZmlsdGVyLFxuICAgICAgICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgICAgIHBhaW50OiBwYWludCxcbiAgICAgICAgICAgICAgICBtZXRhZGF0YTogeyB0ZXh0OiB0cnVlLCBuYW1lOiBpZCB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghbWFwLmdldExheWVyKGlkKSkgbWFwLmFkZExheWVyKHN0eWxlKTtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJzLnB1c2gobWFwLmdldExheWVyKGlkKSk7XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIHRoaXMuc2hvd1RleHRMYXllcnMgPSB0cnVlO1xuICAgIH1cblxuXG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgcmVtb3ZlU291cmNlc1xuXHQgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBzb3VyY2VzIGZyb20gdGhlIG1hcC5cblx0ICogQHBhcmFtIHtBcnJheX0gc291cmNlcyAtIEFuIGFycmF5IG9mIHNvdXJjZSBJRHMgdG8gYmUgcmVtb3ZlZC4gSWYgbm90IHByb3ZpZGVkLCBpdCBkZWZhdWx0cyB0byBhbGwgc291cmNlIElEcy5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMucmVtb3ZlU291cmNlcyA9IGZ1bmN0aW9uIChzb3VyY2VzKSB7XG4gICAgICAgIHNvdXJjZXMgPSBzb3VyY2VzIHx8IHRoaXMuZ2V0U291cmNlSWRzKCk7XG4gICAgICAgIHNvdXJjZXMuZm9yRWFjaChmdW5jdGlvbihpZCkgeyB0aGlzLnJlbW92ZVNvdXJjZShpZCkgfSwgdGhpcyk7XG4gICAgICAgIGdlb2Zsby5maXJlKCdzb3VyY2VzLnJlbW92ZScsIHsgcmVtb3ZlZDogdHJ1ZSB9KVxuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTGF5ZXJzXG5cdCAqIEBuYW1lIHJlbW92ZVNvdXJjZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiByZW1vdmVzIGEgc291cmNlIGZyb20gdGhlIG1hcCBhbmQgdGhlIGludGVybmFsIHNvdXJjZXMgYXJyYXkgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGlkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIHNvdXJjZSB0byBiZSByZW1vdmVkLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgaWQgb2YgdGhlIHJlbW92ZWQgc291cmNlLlxuXHQgKi9cbiAgICB0aGlzLnJlbW92ZVNvdXJjZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIWlkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChtYXAuZ2V0U291cmNlKGlkKSkgbWFwLnJlbW92ZVNvdXJjZShpZCk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGluZGV4ID0gdGhpcy5zb3VyY2VzLmZpbmRJbmRleChmdW5jdGlvbihsKSB7IHJldHVybiBsLmlkID09PSBpZCB9KTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHRoaXMuc291cmNlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICBcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ3NvdXJjZS5yZW1vdmUnLCB7IHJlbW92ZWQ6IGlkIH0pO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgcmVtb3ZlTGF5ZXJzXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIG11bHRpcGxlIGxheWVycyBmcm9tIHRoZSBjb250ZXh0LlxuXHQgKiBAcGFyYW0ge0FycmF5fSBsYXllcnMgLSBBbiBhcnJheSBvZiBsYXllciBvYmplY3RzIHRvIGJlIHJlbW92ZWQuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gLSBBbiBhcnJheSBvZiBJRHMgb2YgdGhlIHJlbW92ZWQgbGF5ZXJzLlxuXHQgKi9cbiAgICB0aGlzLnJlbW92ZUxheWVycyA9IGZ1bmN0aW9uIChsYXllcnMpIHtcbiAgICAgICAgdmFyIGlkcyA9IHRoaXMuZ2V0TGF5ZXJJZHMobGF5ZXJzKTtcbiAgICAgICAgdGhpcy5yZW1vdmVUZXh0TGF5ZXIoKTtcbiAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24oaWQpIHsgdGhpcy5yZW1vdmVMYXllcihpZCkgfSwgdGhpcyk7XG4gICAgICAgIGdlb2Zsby5maXJlKCdsYXllcnMucmVtb3ZlJywgeyByZW1vdmVkOiBpZHMgfSk7XG4gICAgICAgIHJldHVybiBpZHM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgcmVtb3ZlTGF5ZXJcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gcmVtb3ZlcyBhIGxheWVyIGZyb20gdGhlIG1hcCBhbmQgdGhlIGxheWVycyBhcnJheSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgaWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCBvZiB0aGUgbGF5ZXIgdG8gYmUgcmVtb3ZlZC5cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIGlkIG9mIHRoZSByZW1vdmVkIGxheWVyLlxuXHQgKi9cbiAgICB0aGlzLnJlbW92ZUxheWVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghaWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKG1hcC5nZXRMYXllcihpZCkpIG1hcC5yZW1vdmVMYXllcihpZCk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIGluZGV4ID0gdGhpcy5sYXllcnMuZmluZEluZGV4KGZ1bmN0aW9uKGwpIHsgcmV0dXJuIGwuaWQgPT09IGlkIH0pO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSkgdGhpcy5sYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcblxuICAgICAgICBnZW9mbG8uZmlyZSgnbGF5ZXIucmVtb3ZlJywgeyByZW1vdmVkOiBpZCB9KTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cblxuICAgIHRoaXMucmVtb3ZlVGV4dExheWVyID0gZnVuY3Rpb24gKG9wdGlvbnM9e30pIHtcbiAgICAgICAgdmFyIGxheWVycyA9IHRoaXMuZ2V0TGF5ZXJzKCk7XG4gICAgICAgIGxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKGxheWVyKSB7IGlmIChsYXllci5tZXRhZGF0YS50ZXh0ICYmIG1hcC5nZXRMYXllcihsYXllci5pZCkpIG1hcC5yZW1vdmVMYXllcihsYXllci5pZCkgfSwgdGhpcyk7XG4gICAgICAgIHRoaXMuc2hvd1RleHRMYXllcnMgPSBmYWxzZTtcbiAgICB9XG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgbW92ZUxheWVyc1xuXHQgKiBAZGVzY3JpcHRpb24gTW92ZXMgdGhlIHNwZWNpZmllZCBsYXllcnMgb24gdGhlIG1hcC5cblx0ICogQHBhcmFtIHtBcnJheX0gbGF5ZXJzIC0gQW4gYXJyYXkgb2YgbGF5ZXIgb2JqZWN0cyB0byBiZSBtb3ZlZCBvbiB0aGUgbWFwLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5tb3ZlTGF5ZXJzID0gZnVuY3Rpb24gKGxheWVycykge1xuICAgICAgICBsYXllcnMgPSAhbGF5ZXJzID8gdGhpcy5kZWZhdWx0TGF5ZXJzIHx8IFtdIDogbGF5ZXJzO1xuICAgICAgICBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHsgaWYgKGdlb2Zsby5tYXAuZ2V0TGF5ZXIobGF5ZXIuaWQpKSBnZW9mbG8ubWFwLm1vdmVMYXllcihsYXllci5pZCkgfSlcbiAgICB9XG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcblx0ICogQG5hbWUgYWRkRXZlbnRMaXN0ZW5lcnNcblx0ICogQGRlc2NyaXB0aW9uIEF0dGFjaGVzIGV2ZW50IGxpc3RlbmVycyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgb3B0aW9ucy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBbiBvYmplY3QgY29udGFpbmluZyBjb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIGV2ZW50IGxpc3RlbmVycy5cblx0ICogQHJldHVybnMge09iamVjdH0gLSBUaGUgcmVzdWx0IG9mIHRoZSBidWlsZEV2ZW50cyBmdW5jdGlvbiB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuXHQgKi9cbiAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKG9wdGlvbnM9e30pIHtcbiAgICAgICAgcmV0dXJuIGJ1aWxkRXZlbnRzLmNhbGwodGhpcywgeyBvbjogdHJ1ZSB9KVxuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTGF5ZXJzXG5cdCAqIEBuYW1lIHJlbW92ZUV2ZW50TGlzdGVuZXJzXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHJlbW92aW5nIGV2ZW50IGxpc3RlbmVycy5cblx0ICogQHBhcmFtIHtib29sZWFufSBvcHRpb25zLm9mZiAtIEEgYm9vbGVhbiBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgdG8gdHVybiBvZmYgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVycyA9IGZ1bmN0aW9uIChvcHRpb25zPXt9KSB7XG4gICAgICAgIHJldHVybiBidWlsZEV2ZW50cy5jYWxsKHRoaXMsIHsgb2ZmOiB0cnVlIH0pXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgb25DbHVzdGVyQ2xpY2tcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgY2xpY2sgZXZlbnQgb24gYSBjbHVzdGVyIGZlYXR1cmUsIGV4cGFuZGluZyB0aGUgY2x1c3RlciBpZiBhcHBsaWNhYmxlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgLSBUaGUgY2x1c3RlciBmZWF0dXJlIHRoYXQgd2FzIGNsaWNrZWQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgdGhlIGZlYXR1cmUgZG9lcyBub3QgaGF2ZSBhIHNvdXJjZTsgb3RoZXJ3aXNlLCBpdCBwZXJmb3JtcyBhbiBhY3Rpb24gd2l0aG91dCByZXR1cm5pbmcgYSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLm9uQ2x1c3RlckNsaWNrID0gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlLnNvdXJjZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSBtYXAuZ2V0U291cmNlKGZlYXR1cmUuc291cmNlKTtcblxuICAgICAgICBzb3VyY2UuZ2V0Q2x1c3RlckV4cGFuc2lvblpvb20oZmVhdHVyZS5wcm9wZXJ0aWVzLmNsdXN0ZXJfaWQsIGZ1bmN0aW9uKGVycix6b29tKSB7XG4gICAgICAgICAgICBpZiAoIWVycikgbWFwLmVhc2VUbyh7IGNlbnRlcjogZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcywgem9vbTogem9vbSArIDIgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIG9uTGF5ZXJNb3VzZW92ZXJcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5MYXllcnNcbiAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgbW91c2VvdmVyIGV2ZW50IG9uIGEgbGF5ZXIsIGhpZ2hsaWdodGluZyB0aGUgZmVhdHVyZXMgaWYgY2VydGFpbiBjb25kaXRpb25zIGFyZSBtZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1vdXNlb3ZlciBldmVudC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBlZGl0aW5nLCBkcmF3aW5nLCBvciB2aWV3aW5nIGFjdGlvbnMgYXJlIGFjdGl2ZSwgaWYgdGhlIGxheWVyIGlzIGltcG9ydGluZywgb3IgaWYgdGhlcmUgYXJlIG5vIGZlYXR1cmVzOyBvdGhlcndpc2UsIGl0IGhpZ2hsaWdodHMgdGhlIGZlYXR1cmVzLlxuICAgICAqL1xuICAgIHRoaXMub25MYXllck1vdXNlb3ZlciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBcblxuICAgICAgICB2YXIgTWFwID0gYXBwLk1hcDtcbiAgICAgICAgaWYgKE1hcC5nZXRBY3Rpb25zKCkuZWRpdGluZyB8fCBNYXAuZ2V0QWN0aW9ucygpLmRyYXdpbmcgfHwgTWFwLmdldEFjdGlvbnMoKS52aWV3aW5nKSB7IHJldHVybiBmYWxzZSB9O1xuICAgICAgICBpZiAoYXBwW2FwcC5ucygnbGF5ZXInKV0uX2ltcG9ydGluZykgeyByZXR1cm4gZmFsc2UgfVxuICAgICAgICBpZiAoIWV2ZW50LmZlYXR1cmVzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2UgfVxuXG4gICAgICAgIE1hcC5zZXRIaWdobGlnaHQoeyBjbGVhcjogdHJ1ZSwgZmVhdHVyZXM6IGV2ZW50LmZlYXR1cmVzfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgb25MYXllck1vdXNlb3V0XG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTGF5ZXJzXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIG1vdXNlb3V0IGV2ZW50IGZvciBhIGxheWVyLCByZW1vdmluZyBoaWdobGlnaHRzIGlmIGNlcnRhaW4gY29uZGl0aW9ucyBhcmUgbWV0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBhc3NvY2lhdGVkIHdpdGggdGhlIG1vdXNlb3V0IGV2ZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIHRoZSBtYXAgaXMgaW4gZWRpdGluZywgZHJhd2luZywgb3Igdmlld2luZyBtb2RlLCBvciBpZiB0aGUgbGF5ZXIgaXMgYmVpbmcgaW1wb3J0ZWQ7IG90aGVyd2lzZSwgaXQgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICovXG4gICAgdGhpcy5vbkxheWVyTW91c2VvdXQgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gXG5cbiAgICAgICAgdmFyIE1hcCA9IGFwcC5NYXA7XG4gICAgICAgIGlmIChNYXAuZ2V0QWN0aW9ucygpLmVkaXRpbmcgfHwgTWFwLmdldEFjdGlvbnMoKS5kcmF3aW5nIHx8IE1hcC5nZXRBY3Rpb25zKCkudmlld2luZykgeyByZXR1cm4gZmFsc2UgfTtcbiAgICAgICAgaWYgKGFwcFthcHAubnMoJ2xheWVyJyldLl9pbXBvcnRpbmcpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgXG4gICAgICAgIE1hcC5fcmVtb3ZlSGlnaGxpZ2h0KCk7XG4gICAgfVxuXG5cbiAgICB0aGlzLmluaXQoKTtcblxuXG4gICAgYXN5bmMgZnVuY3Rpb24gYnVpbGRMYXllcnMgKGxheWVycz1bXSwgb3B0aW9ucz17fSkge1xuICAgICAgICBhd2FpdCBidWlsZFRleHQuY2FsbCh0aGlzKTtcbiAgICAgICAgaWYgKCFsYXllcnMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGxheWVycy5tYXAobGF5ZXIgPT4gYnVpbGRMYXllci5jYWxsKHRoaXMsIGxheWVyLCBvcHRpb25zKSkpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBnZW9mbG8uTGF5ZXJzLm1vdmVMYXllcnMoKTsgfSwgMjUwKTtcbiAgICAgICAgaWYgKHRoaXMuc2hvd1RleHRMYXllcnMpIHRoaXMuYWRkVGV4dExheWVyKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldExheWVycygpO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGJ1aWxkTGF5ZXIgKGxheWVyLCBvcHRzKSB7XG4gICAgICAgIHZhciBkZXRhaWxzID0gIWxheWVyLmRldGFpbHMgJiYgbGF5ZXIuaWQgPyBsYXllciA6IGxheWVyLmRldGFpbHMgfHwge307XG4gICAgICAgIHZhciBvcHRpb25zID0gbGF5ZXIub3B0aW9ucyB8fCB7fTtcbiAgICAgICAgdmFyIGxheWVycyA9IGxheWVyLmxheWVycyB8fCBbXTtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gbGF5ZXIuZmVhdHVyZXMgfHwgW107XG4gICAgICAgIHZhciBoYXNGZWF0dXJlcyA9IGZlYXR1cmVzICYmIGZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgdmFyIHN0eWxlID0gbGF5ZXIuc3R5bGUgfHwgZmFsc2U7XG4gICAgICAgIHZhciBlcnJvcjtcblxuICAgICAgICBpZiAoIWRldGFpbHMuaWQgfHwgIWRldGFpbHMudHlwZSkgZXJyb3IgPSB0cnVlO1xuXG4gICAgICAgIGNvbnN0IHR5cGUgPSBkZXRhaWxzLnR5cGUgPT09ICdBTEwnID8gJ0FMTCcgOiB0aGlzLmdldFR5cGUoZGV0YWlscy50eXBlKTtcbiAgICAgICAgaWYgKCF0eXBlKSBlcnJvciA9IHRydWU7XG5cbiAgICAgICAgdmFyIG1ldGFkYXRhID0geyB0eXBlOiBkZXRhaWxzLnR5cGV9IDtcbiAgICAgICAgZGV0YWlscy5kZWZhdWx0ID8gbWV0YWRhdGEuZGVmYXVsdCA9IHRydWUgOiBtZXRhZGF0YS5jdXN0b20gPSB0cnVlO1xuICAgICAgICBkZXRhaWxzLm5hbWUgPyBtZXRhZGF0YS5uYW1lID0gZGV0YWlscy5uYW1lIDogZmFsc2U7XG5cbiAgICAgICAgdmFyIHNvdXJjZSA9IGRldGFpbHMuc291cmNlIHx8IGRldGFpbHMuaWQ7XG4gICAgICAgIG1ldGFkYXRhLnNvdXJjZSA9IHNvdXJjZTtcblxuICAgICAgICBpZiAoZGV0YWlscy5zdHlsZSkgZGVsZXRlIGRldGFpbHMuc3R5bGU7XG5cbiAgICAgICAgdmFyIHNldHRpbmdzID0ge1xuICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgaWQ6IGRldGFpbHMuaWQsXG4gICAgICAgICAgICB0eXBlczogbGF5ZXJUeXBlc1t0eXBlXSxcbiAgICAgICAgICAgIHN0eWxlOiBzdHlsZSB8fCB7fSxcbiAgICAgICAgICAgIGZpbHRlcjogbGF5ZXIuZmlsdGVyLFxuICAgICAgICAgICAgaW1hZ2VzOiBsYXllci5pbWFnZXMsXG4gICAgICAgICAgICBkZXRhaWxzOiBkZXRhaWxzLFxuICAgICAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgICAgIGxheWVyczogbGF5ZXJzXG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZSA9PT0gJ0FMTCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gT2JqZWN0LmtleXMobGF5ZXJUeXBlcykuZmlsdGVyKGtleSA9PiBrZXkgIT09ICdBbGwnKS5tYXAoYXN5bmMga2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXllckNvbmZpZyA9IHsgLi4uc2V0dGluZ3MsIHR5cGU6IGtleSwgdHlwZXM6IGxheWVyVHlwZXNba2V5XSB9O1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleSA9PT0gJ0ltYWdlJyA/IGJ1aWxkSW1hZ2UuY2FsbCh0aGlzLCBsYXllckNvbmZpZywgb3B0aW9ucykgOlxuICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09ICdQb2x5Z29uJyA/IGJ1aWxkUG9seWdvbi5jYWxsKHRoaXMsIGxheWVyQ29uZmlnLCBvcHRpb25zKSA6XG4gICAgICAgICAgICAgICAgICAgICAgIGtleSA9PT0gJ1BvbHlsaW5lJyA/IGJ1aWxkUG9seWxpbmUuY2FsbCh0aGlzLCBsYXllckNvbmZpZywgb3B0aW9ucykgOlxuICAgICAgICAgICAgICAgICAgICAgICBrZXkgPT09ICdQb2ludCcgPyBidWlsZFBvaW50LmNhbGwodGhpcywgbGF5ZXJDb25maWcsIG9wdGlvbnMpIDogW107XG4gICAgICAgICAgICB9KTtcbiAgICBcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgICAgICAgICBsYXllcnMgPSByZXN1bHRzLmZsYXQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxheWVycyA9IHR5cGUgPT09ICdJbWFnZScgPyBhd2FpdCBidWlsZEltYWdlLmNhbGwodGhpcywgc2V0dGluZ3MsIG9wdGlvbnMpIDpcbiAgICAgICAgICAgIHR5cGUgPT09ICdQb2x5Z29uJyA/IGF3YWl0IGJ1aWxkUG9seWdvbi5jYWxsKHRoaXMsIHNldHRpbmdzLCBvcHRpb25zKSA6XG4gICAgICAgICAgICB0eXBlID09PSAnUG9seWxpbmUnID8gYXdhaXQgYnVpbGRQb2x5bGluZS5jYWxsKHRoaXMsIHNldHRpbmdzLCBvcHRpb25zKSA6XG4gICAgICAgICAgICB0eXBlID09PSAnUG9pbnQnID8gYXdhaXQgYnVpbGRQb2ludC5jYWxsKHRoaXMsIHNldHRpbmdzLCBvcHRpb25zKSA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLnJlbW92ZUxheWVycyhsYXllcnMpO1xuICAgICAgICB0aGlzLnJlbW92ZVNvdXJjZShzb3VyY2UpO1xuICAgICAgICB0aGlzLmFkZFNvdXJjZShzb3VyY2UsIHR5cGUsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLmFkZExheWVycyhsYXllcnMsIG1ldGFkYXRhKTtcblxuICAgICAgICByZW1vdmVMYXllci5jYWxsKHRoaXMsIHsgbGF5ZXI6IGRldGFpbHMuaWQsIHNvdXJjZTogc291cmNlIH0pO1xuXG4gICAgICAgIHNldHRpbmdzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG5cbiAgICAgICAgaWYgKG1ldGFkYXRhLmN1c3RvbSkge1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzLnB1c2goc2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5fc291cmNlcy5wdXNoKHsgaWQ6IHNvdXJjZSwgdHlwZTogdHlwZSwgb3B0aW9uczogb3B0aW9ucyB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNGZWF0dXJlcykgZ2VvZmxvLkZlYXR1cmVzLmFkZEZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHJldHVybiByZXNvbHZlKGVycm9yKTtcblxuICAgICAgICAgICAgY29uc3QgcmVhZHkgPSBzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmVhdHMgPSBnZW9mbG8uTGF5ZXJzLmdldEZlYXR1cmVzKG1ldGFkYXRhLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0ZlYXR1cmVzICYmICFmZWF0cy5sZW5ndGgpIHJldHVybjtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcC5nZXRTb3VyY2UobWV0YWRhdGEuc291cmNlKSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwocmVhZHkpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoeyBsYXllcjogc2V0dGluZ3MsIGZlYXR1cmVzOiBmZWF0cyB9KTtcbiAgICAgICAgICAgIH0sIDEpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBidWlsZFRleHQgKCkge1xuICAgICAgICBjb25zdCBtYXAgPSBnZW9mbG8ubWFwO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSAnaHR0cHM6Ly9kb2NzLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL2Fzc2V0cy9wb3B1cC5wbmcnO1xuXG4gICAgICAgICAgICBpZiAobWFwLmhhc0ltYWdlKCd0ZXh0LW1hcmtlcicpKSByZXR1cm4gcmVzb2x2ZSh0cnVlKTtcblxuICAgICAgICAgICAgbWFwLmxvYWRJbWFnZSh1cmwsIGFzeW5jIGZ1bmN0aW9uKGVycm9yLCBpbWFnZSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5oYXNJbWFnZSgndGV4dC1tYXJrZXInKSkgcmV0dXJuIHJlc29sdmUoaW1hZ2UpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG1hcC5hZGRJbWFnZSgndGV4dC1tYXJrZXInLCBpbWFnZSwge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBbMjUsIDI1LCAxMTUsIDEwMF0sXG4gICAgICAgICAgICAgICAgICAgIHN0cmV0Y2hYOiBbWzI1LCAxMTVdXSxcbiAgICAgICAgICAgICAgICAgICAgc3RyZXRjaFk6IFtbMjUsIDEwMF1dLFxuICAgICAgICAgICAgICAgICAgICBwaXhlbFJhdGlvOiAyLFxuICAgICAgICAgICAgICAgICAgICBzZGY6IGZhbHNlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoaW1hZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGJ1aWxkSW1hZ2UgKHNldHRpbmdzPXt9LCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICghc2V0dGluZ3Muc291cmNlKSByZXR1cm4gW107XG5cbiAgICAgICAgdmFyIGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgc291cmNlID0gc2V0dGluZ3Muc291cmNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0dGluZ3MudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gc2V0dGluZ3MudHlwZXNbaV07XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBzZXR0aW5ncy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBpZCA9IHNldHRpbmdzLmlkICsgdHlwZTtcbiAgICAgICAgICAgIHZhciBsYXlvdXQsIHBhaW50O1xuXG4gICAgICAgICAgICBpZiAoIXNldHRpbmdzLmltYWdlcyB8fCAhc2V0dGluZ3MuaW1hZ2VzLmxlbmd0aCkgY29udGludWU7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2V0dGluZ3MuaW1hZ2VzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltYWdlID0gc2V0dGluZ3MuaW1hZ2VzW2pdO1xuICAgICAgICAgICAgICAgIGlmICghaW1hZ2UpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgdmFyIGltZyA9IGF3YWl0IGxvYWRJbWFnZShpbWFnZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpbWcpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG1hcC5oYXNJbWFnZShpbWFnZS5pZCkgP1xuICAgICAgICAgICAgICAgIG1hcC51cGRhdGVJbWFnZShpbWFnZS5pZCwgaW1nLCB7cGl4ZWxSYXRpbzogMn0pIDpcbiAgICAgICAgICAgICAgICBtYXAuYWRkSW1hZ2UoaW1hZ2UuaWQsIGltZywge3BpeGVsUmF0aW86IDJ9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGF5b3V0ID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5Jzogb3B0aW9ucy52aXNpYmlsaXR5IHx8ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICAnaWNvbi1pbWFnZSc6IFsnZ2V0JywgJ3ByaW1hcnlJbWFnZScsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLFxuICAgICAgICAgICAgICAgICdpY29uLXNpemUnOiBbJ2ludGVycG9sYXRlJywgWydsaW5lYXInXSwgWyd6b29tJ10sIDEsIDAuNiwgMTAsIDAuOCwgMTUsIDFdLFxuICAgICAgICAgICAgICAgICdpY29uLWFsbG93LW92ZXJsYXAnOiB0cnVlLFxuICAgICAgICAgICAgICAgICdpY29uLWFuY2hvcic6ICdib3R0b20nXG4gICAgICAgICAgICB9LCBzdHlsZS5pbWFnZSA/IHN0eWxlLmltYWdlLmxheW91dCB8fCB7fSA6IHt9KTtcblxuICAgICAgICAgICAgcGFpbnQgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgJ2ljb24tb3BhY2l0eSc6IFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsXG4gICAgICAgICAgICAgICAgICAgIFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsXG4gICAgICAgICAgICAgICAgICAgIFsnZ2V0JywgJ29wYWNpdHknLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXV1dXG4gICAgICAgICAgICB9LCBzdHlsZS5pbWFnZSA/IHN0eWxlLmltYWdlLnBhaW50IHx8IHt9IDoge30pO1xuXG4gICAgICAgICAgICBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogJ3N5bWJvbCcsXG4gICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgc2xvdDogc3R5bGUuc2xvdCB8fCAndG9wJyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHNldHRpbmdzLmZpbHRlciB8fCBbJz09JywgXCIkdHlwZVwiLCBcIlBvaW50XCJdLFxuICAgICAgICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgICAgIHBhaW50OiBwYWludFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0eWxlKSBjb250aW51ZTtcbiAgICAgICAgICAgIGxheWVycy5wdXNoKHN0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBidWlsZFBvbHlnb24gKHNldHRpbmdzPXt9LCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICghc2V0dGluZ3Muc291cmNlKSByZXR1cm4gW107XG5cbiAgICAgICAgdmFyIGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgc291cmNlID0gc2V0dGluZ3Muc291cmNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0dGluZ3MudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gc2V0dGluZ3MudHlwZXNbaV07XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBzZXR0aW5ncy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBpZCA9IHNldHRpbmdzLmlkICsgdHlwZTtcbiAgICAgICAgICAgIHZhciBsYXlvdXQsIHBhaW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZS5pbmNsdWRlcygnYm9yZGVyJykpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5Jzogb3B0aW9ucy52aXNpYmlsaXR5IHx8ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICB9LCBzdHlsZS5ib3JkZXIgPyBzdHlsZS5ib3JkZXIubGF5b3V0IHx8IHt9IDoge30pO1xuXG4gICAgICAgICAgICAgICAgcGFpbnQgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICdsaW5lLWNvbG9yJzogWydnZXQnLCAncHJpbWFyeUNvbG9yJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLXdpZHRoJzogWydjYXNlJywgW1wiYm9vbGVhblwiLCBbJ2hhcycsICd3aWR0aCcsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLCB0cnVlXSwgWydnZXQnLCAnd2lkdGgnLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXSwgMl0sXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLW9wYWNpdHknOiBbJ2Nhc2UnLCBbXCJib29sZWFuXCIsIFtcImZlYXR1cmUtc3RhdGVcIiwgXCJoaWRkZW5cIl0sIHRydWVdLCAwLCAwLjhdXG4gICAgICAgICAgICAgICAgfSwgc3R5bGUuYm9yZGVyID8gc3R5bGUuYm9yZGVyLnBhaW50IHx8IHt9IDoge30pO1xuXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2xpbmUnLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgc2xvdDogc3R5bGUuc2xvdCB8fCAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBzdHlsZS5ib3JkZXIgPyBzdHlsZS5ib3JkZXIuZmlsdGVyIHx8IFsnPT0nLCBcIiR0eXBlXCIsIFwiUG9seWdvblwiXSA6IFsnPT0nLCAnJHR5cGUnLCAnUG9seWdvbiddLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgcGFpbnQ6IHBhaW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlLmluY2x1ZGVzKCdmaWxsJykpIHtcbiAgICAgICAgICAgICAgICBsYXlvdXQgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5Jzogb3B0aW9ucy52aXNpYmlsaXR5IHx8ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICB9LCBzdHlsZS5maWxsID8gc3R5bGUuZmlsbC5sYXlvdXQgfHwge30gOiB7fSk7XG5cbiAgICAgICAgICAgICAgICBwYWludCA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGwtY29sb3InOiBbJ2dldCcsICdzZWNvbmRhcnlDb2xvcicsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLFxuICAgICAgICAgICAgICAgICAgICAnZmlsbC1vcGFjaXR5JzogWydjYXNlJywgW1wiYm9vbGVhblwiLCBbXCJmZWF0dXJlLXN0YXRlXCIsIFwiaGlkZGVuXCJdLCB0cnVlXSwgMCwgMC41XVxuICAgICAgICAgICAgICAgIH0sIHN0eWxlLmZpbGwgPyBzdHlsZS5maWxsLnBhaW50IHx8IHt9IDoge30pO1xuXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2ZpbGwnLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgc2xvdDogc3R5bGUuc2xvdCB8fCAnYm90dG9tJyxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiBzdHlsZS5maWxsID8gc3R5bGUuZmlsbC5maWx0ZXIgfHwgWyc9PScsIFwiJHR5cGVcIiwgXCJQb2x5Z29uXCJdIDogWyc9PScsICckdHlwZScsICdQb2x5Z29uJ10sXG4gICAgICAgICAgICAgICAgICAgIGxheW91dDogbGF5b3V0LFxuICAgICAgICAgICAgICAgICAgICBwYWludDogcGFpbnRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghc3R5bGUpIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGF5ZXJzLnB1c2goc3R5bGUpXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbGF5ZXJzO1xuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGJ1aWxkUG9seWxpbmUgKHNldHRpbmdzPXt9LCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICghc2V0dGluZ3Muc291cmNlKSByZXR1cm4gW107XG5cbiAgICAgICAgdmFyIGxheWVycyA9IFtdO1xuICAgICAgICB2YXIgc291cmNlID0gc2V0dGluZ3Muc291cmNlO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0dGluZ3MudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gc2V0dGluZ3MudHlwZXNbaV07XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBzZXR0aW5ncy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBpZCA9IHNldHRpbmdzLmlkICsgdHlwZTtcbiAgICAgICAgICAgIHZhciBsYXlvdXQsIHBhaW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZS5pbmNsdWRlcygnbGluZScpKSB7XG4gICAgICAgICAgICAgICAgbGF5b3V0ID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6IG9wdGlvbnMudmlzaWJpbGl0eSB8fCAndmlzaWJsZScsXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLW1pdGVyLWxpbWl0JzogMixcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtam9pbic6ICdyb3VuZCcsXG4gICAgICAgICAgICAgICAgICAgICdsaW5lLWNhcCc6ICdyb3VuZCdcbiAgICAgICAgICAgICAgICB9LCBzdHlsZS5saW5lID8gc3R5bGUubGluZS5sYXlvdXQgfHwge30gOiB7fSk7XG5cbiAgICAgICAgICAgICAgICBwYWludCA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtY29sb3InOiBbJ2dldCcsICdwcmltYXJ5Q29sb3InLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXSxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtd2lkdGgnOiBbJ2Nhc2UnLCBbXCJib29sZWFuXCIsIFsnaGFzJywgJ3dpZHRoJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sIHRydWVdLCBbJ2dldCcsICd3aWR0aCcsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLCA0XSxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtb2Zmc2V0JzogWydjYXNlJywgW1wiYm9vbGVhblwiLCBbXCJoYXNcIiwgXCJvZmZzZXRcIl0sIHRydWVdLCBbXCJnZXRcIiwgXCJvZmZzZXRcIl0sIDBdLFxuICAgICAgICAgICAgICAgICAgICAnbGluZS1vcGFjaXR5JzogWydjYXNlJywgW1wiYm9vbGVhblwiLCBbXCJmZWF0dXJlLXN0YXRlXCIsIFwiaGlkZGVuXCJdLCB0cnVlXSwgMCwgMV1cbiAgICAgICAgICAgICAgICB9LCBzdHlsZS5saW5lID8gc3R5bGUubGluZS5wYWludCB8fCB7fSA6IHt9KTtcblxuICAgICAgICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHNsb3Q6IHN0eWxlLnNsb3QgfHwgJ21pZGRsZScsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogc3R5bGUubGluZSA/IHN0eWxlLmxpbmUuZmlsdGVyIHx8IFsnPT0nLCBcIiR0eXBlXCIsIFwiTGluZVN0cmluZ1wiXSA6IFsnPT0nLCAnJHR5cGUnLCAnTGluZVN0cmluZyddLFxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgcGFpbnQ6IHBhaW50XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0eWxlKSBjb250aW51ZTtcbiAgICAgICAgICAgIGxheWVycy5wdXNoKHN0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBidWlsZFBvaW50IChzZXR0aW5ncz17fSwgb3B0aW9ucz17fSkge1xuICAgICAgICBpZiAoIXNldHRpbmdzLnNvdXJjZSkgcmV0dXJuIFtdO1xuXG4gICAgICAgIHZhciBsYXllcnMgPSBbXTtcbiAgICAgICAgdmFyIHNvdXJjZSA9IHNldHRpbmdzLnNvdXJjZTtcbiAgICAgICAgdmFyIGRvbnRSZW5kZXIgPSBmYWxzZTsgLy9tYXAuZ2V0U3R5bGUoKS5pbXBvcnRzICYmIG1hcC5nZXRTdHlsZSgpLmltcG9ydHMubGVuZ3RoO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2V0dGluZ3MudHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gc2V0dGluZ3MudHlwZXNbaV07XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSBzZXR0aW5ncy5zdHlsZTtcbiAgICAgICAgICAgIHZhciBpZCA9IHNldHRpbmdzLmlkICsgdHlwZTtcbiAgICAgICAgICAgIHZhciBsYXlvdXQsIHBhaW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZS5pbmNsdWRlcygnY2lyY2xlJykpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ub0NpcmNsZSkgY29udGludWU7XG5cbiAgICAgICAgICAgICAgICBsYXlvdXQgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICd2aXNpYmlsaXR5Jzogb3B0aW9ucy52aXNpYmlsaXR5IHx8ICd2aXNpYmxlJyxcbiAgICAgICAgICAgICAgICB9LCBzdHlsZS5jaXJjbGUgPyBzdHlsZS5jaXJjbGUubGF5b3V0IHx8IHt9IDoge30pO1xuXG4gICAgICAgICAgICAgICAgcGFpbnQgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtcmFkaXVzJzogMTAsXG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtc3Ryb2tlLXdpZHRoJzogMixcbiAgICAgICAgICAgICAgICAgICAgJ2NpcmNsZS1jb2xvcic6IFsnZ2V0JywgJ3NlY29uZGFyeUNvbG9yJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sXG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtc3Ryb2tlLWNvbG9yJzogWydnZXQnLCAncHJpbWFyeUNvbG9yJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sXG4gICAgICAgICAgICAgICAgICAgICdjaXJjbGUtb3BhY2l0eSc6IFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsIFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsIFsnZ2V0JywgJ29wYWNpdHknLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXV1dLFxuICAgICAgICAgICAgICAgICAgICAnY2lyY2xlLXN0cm9rZS1vcGFjaXR5JzogWydjYXNlJywgW1wiYm9vbGVhblwiLCBbXCJmZWF0dXJlLXN0YXRlXCIsIFwiaGlkZGVuXCJdLCB0cnVlXSwgMCwgWydjYXNlJywgW1wiYm9vbGVhblwiLCBbXCJmZWF0dXJlLXN0YXRlXCIsIFwiaGlkZGVuXCJdLCB0cnVlXSwgMCwgWydnZXQnLCAnb3BhY2l0eScsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dXV1cbiAgICAgICAgICAgICAgICB9LCBzdHlsZS5jaXJjbGUgPyBzdHlsZS5jaXJjbGUucGFpbnQgfHwge30gOiB7fSk7XG5cbiAgICAgICAgICAgICAgICBzdHlsZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnY2lyY2xlJyxcbiAgICAgICAgICAgICAgICAgICAgc291cmNlOiBzb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgIHNsb3Q6IHN0eWxlLnNsb3QgfHwgJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcjogc3R5bGUuY2lyY2xlID8gc3R5bGUuY2lyY2xlLmZpbHRlciB8fCBbJz09JywgXCIkdHlwZVwiLCBcIlBvaW50XCJdIDogWyc9PScsIFwiJHR5cGVcIiwgXCJQb2ludFwiXSxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgIHBhaW50OiBwYWludFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlLmluY2x1ZGVzKCdjbHVzdGVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubm9DbHVzdGVyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZmlsdGVyID0gWydoYXMnLCAncG9pbnRfY291bnQnXTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUucGFpbnRbJ2NpcmNsZS1jb2xvciddID0gb3B0aW9ucy5zZWNvbmRhcnlDb2xvciB8fCBnZW9mbG8ub3B0aW9ucy5jb2xvcnMuc2Vjb25kYXJ5Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnBhaW50WydjaXJjbGUtc3Ryb2tlLWNvbG9yJ10gPSBvcHRpb25zLnByaW1hcnlDb2xvciB8fCBnZW9mbG8ub3B0aW9ucy5jb2xvcnMucHJpbWFyeUNvbG9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZS5pbmNsdWRlcygnaWNvbicpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbnRSZW5kZXIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgbGF5b3V0ID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgICAgICAndmlzaWJpbGl0eSc6IG9wdGlvbnMudmlzaWJpbGl0eSB8fCAndmlzaWJsZScsXG4gICAgICAgICAgICAgICAgICAgICdpY29uLW9wdGlvbmFsJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtZmllbGQnOiBbJ2dldCcsICdwcmltYXJ5SWNvbicsIFsnZ2V0Jywnc3R5bGUnLCBbJ3Byb3BlcnRpZXMnXV1dLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1yb3RhdGUnOiBbJ2dldCcsICdyb3RhdGUnLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtcm90YXRpb24tYWxpZ25tZW50JzogJ3ZpZXdwb3J0JyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtc2l6ZSc6IDE0LFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1saW5lLWhlaWdodCc6IDEsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LXBhZGRpbmcnOiAwLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1vZmZzZXQnOiBbMCwgMC4yXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtanVzdGlmeSc6ICdhdXRvJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWFsbG93LW92ZXJsYXAnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1mb250JzogWydGb250IEF3ZXNvbWUgNiBQcm8gU29saWQnXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtaWdub3JlLXBsYWNlbWVudCc6IHRydWVcbiAgICAgICAgICAgICAgICB9LCBzdHlsZS5pY29uID8gc3R5bGUuaWNvbi5sYXlvdXQgfHwge30gOiB7fSk7XG5cbiAgICAgICAgICAgICAgICBwYWludCA9IE9iamVjdC5hc3NpZ24oe30sIHtcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtdHJhbnNsYXRlLWFuY2hvcic6ICd2aWV3cG9ydCcsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWhhbG8tY29sb3InOiBbJ2dldCcsICdwcmltYXJ5Q29sb3InLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXSxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtaGFsby13aWR0aCc6IDAsXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LWNvbG9yJzogWydnZXQnLCAncHJpbWFyeUNvbG9yJywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV0sXG4gICAgICAgICAgICAgICAgICAgICd0ZXh0LW9wYWNpdHknOiBbJ2Nhc2UnLCBbXCJib29sZWFuXCIsIFtcImZlYXR1cmUtc3RhdGVcIiwgXCJoaWRkZW5cIl0sIHRydWVdLCAwLCBbJ2Nhc2UnLCBbXCJib29sZWFuXCIsIFtcImZlYXR1cmUtc3RhdGVcIiwgXCJoaWRkZW5cIl0sIHRydWVdLCAwLCBbJ2dldCcsICdvcGFjaXR5JywgWydnZXQnLCdzdHlsZScsIFsncHJvcGVydGllcyddXV1dXVxuICAgICAgICAgICAgICAgIH0sIHN0eWxlLmljb24gPyBzdHlsZS5pY29uLnBhaW50IHx8IHt9IDoge30pO1xuXG4gICAgICAgICAgICAgICAgc3R5bGUgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N5bWJvbCcsXG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICAgICAgICAgICAgICBzbG90OiBzdHlsZS5zbG90IHx8ICd0b3AnLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IHN0eWxlLmljb24gPyBzdHlsZS5pY29uLmZpbHRlciB8fCBbJz09JywgXCIkdHlwZVwiLCBcIlBvaW50XCJdIDogWyc9PScsIFwiJHR5cGVcIiwgXCJQb2ludFwiXSxcbiAgICAgICAgICAgICAgICAgICAgbGF5b3V0OiBsYXlvdXQsXG4gICAgICAgICAgICAgICAgICAgIHBhaW50OiBwYWludFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0eXBlLmluY2x1ZGVzKCdjbHVzdGVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubm9DbHVzdGVyKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUuZmlsdGVyID0gWydoYXMnLCAncG9pbnRfY291bnQnXTtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGUubGF5b3V0Wyd0ZXh0LWZpZWxkJ10gPSBvcHRpb25zLnByaW1hcnlJY29uIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5wYWludFsndGV4dC1oYWxvLWNvbG9yJ10gPSBvcHRpb25zLnNlY29uZGFyeUNvbG9yIHx8IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5zZWNvbmRhcnlDb2xkO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZS5wYWludFsndGV4dC1jb2xvciddID0gb3B0aW9ucy5wcmltYXJ5Q29sb3IgfHwgZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnNlY29uZGFyeVRleHQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlLmluY2x1ZGVzKCdjb3VudCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm5vQ2x1c3RlcikgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLmZpbHRlciA9IFsnaGFzJywgJ3BvaW50X2NvdW50J107XG5cbiAgICAgICAgICAgICAgICAgICAgc3R5bGUubGF5b3V0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3Zpc2liaWxpdHknOiBvcHRpb25zLnZpc2liaWxpdHkgfHwgJ3Zpc2libGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2ljb24tb3B0aW9uYWwnOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtZmllbGQnOiBvcHRpb25zLmNvdW50SWNvbiB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0LXNpemUnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2Jhc2UnOiAxNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3RvcHMnOiBbWzEwLCAxNl0sIFsxNCwgMTRdXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0LWxpbmUtaGVpZ2h0JzogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0LXBhZGRpbmcnOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtb2Zmc2V0JzogWzAuNSwgLTAuNl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dC1qdXN0aWZ5JzogJ2F1dG8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtYW5jaG9yJzogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dC1hbGxvdy1vdmVybGFwJzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICd0ZXh0LWZvbnQnOiBbJ0ZvbnQgQXdlc29tZSA2IFBybyBTb2xpZCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtaWdub3JlLXBsYWNlbWVudCc6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlLnBhaW50ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtdHJhbnNsYXRlLWFuY2hvcic6ICd2aWV3cG9ydCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dC1jb2xvcic6IG9wdGlvbnMuY291bnRJY29uQ29sb3IgfHwgZ2VvZmxvLm9wdGlvbnMuY29sb3JzLnByaW1hcnlUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtb3BhY2l0eSc6IFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsIFsnZ2V0JywgJ29wYWNpdHknLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXV1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZS5pbmNsdWRlcygndGV4dCcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRvbnRSZW5kZXIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUuaW5jbHVkZXMoJ2NvdW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMubm9DbHVzdGVyKSBjb250aW51ZTtcblxuICAgICAgICAgICAgICAgICAgICBsYXlvdXQgPSBPYmplY3QuYXNzaWduKHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dC1maWVsZCc6IFsnZ2V0JywgJ3BvaW50X2NvdW50X2FiYnJldmlhdGVkJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICAndGV4dC1mb250JzogWydESU4gT2ZmYyBQcm8gTWVkaXVtJywgJ0FyaWFsIFVuaWNvZGUgTVMgQm9sZCddLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtc2l6ZSc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnYmFzZSc6IDE0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzdG9wcyc6IFtbMTAsIDE0XSwgWzE0LCAxMl1dXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtb2Zmc2V0JzogWzAuNTUsIC0wLjldLFxuICAgICAgICAgICAgICAgICAgICB9LCBzdHlsZS50ZXh0ID8gc3R5bGUudGV4dC5sYXlvdXQgfHwge30gOiB7fSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHBhaW50ID0gT2JqZWN0LmFzc2lnbih7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtY29sb3InOiBvcHRpb25zLmNvdW50VGV4dENvbG9yIHx8IGdlb2Zsby5vcHRpb25zLmNvbG9ycy5zZWNvbmRhcnlUZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3RleHQtb3BhY2l0eSc6IFsnY2FzZScsIFtcImJvb2xlYW5cIiwgW1wiZmVhdHVyZS1zdGF0ZVwiLCBcImhpZGRlblwiXSwgdHJ1ZV0sIDAsIFsnZ2V0JywgJ29wYWNpdHknLCBbJ2dldCcsJ3N0eWxlJywgWydwcm9wZXJ0aWVzJ11dXV1cbiAgICAgICAgICAgICAgICAgICAgfSwgc3R5bGUudGV4dCA/IHN0eWxlLnRleHQucGFpbnQgfHwge30gOiB7fSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N5bWJvbCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsb3Q6IHN0eWxlLnNsb3QgfHwgJ3RvcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXI6IFsnaGFzJywgJ3BvaW50X2NvdW50J10sXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXlvdXQ6IGxheW91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhaW50OiBwYWludFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXN0eWxlKSBjb250aW51ZTtcbiAgICAgICAgICAgIGxheWVycy5wdXNoKHN0eWxlKVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEV2ZW50cyAob3B0aW9ucz17fSkge1xuICAgICAgICB2YXIgaWRzID0gdGhpcy5nZXRMYXllcklkcygpO1xuICAgICAgICBpZiAoIWlkcy5sZW5ndGgpIHJldHVybjtcblxuICAgICAgICBpZiAob3B0aW9ucy5vZmYpIHtcbiAgICAgICAgICAgIG1hcC5vZmYoJ21vdXNlbW92ZScsIGlkcywgdGhpcy5vbkxheWVyTW91c2VvdmVyKTtcbiAgICAgICAgICAgIG1hcC5vZmYoJ21vdXNlbGVhdmUnLCBpZHMsIHRoaXMub25MYXllck1vdXNlb3V0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvcHRpb25zLm9uKSB7XG4gICAgICAgICAgICBtYXAub24oJ21vdXNlbW92ZScsIGlkcywgdGhpcy5vbkxheWVyTW91c2VvdmVyKTtcbiAgICAgICAgICAgIG1hcC5vbignbW91c2VsZWF2ZScsIGlkcywgdGhpcy5vbkxheWVyTW91c2VvdXQpO1xuICAgICAgICB9IGVsc2UgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBidWlsZEV2ZW50cyh7IG9mZjogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGJ1aWxkRXZlbnRzKHsgb246IHRydWUgfSlcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUxheWVyIChvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcnMuZmluZEluZGV4KChlKSA9PiB7IHJldHVybiBlLmlkID09PSBvcHRpb25zLmxheWVyIH0pO1xuICAgICAgICB2YXIgc291cmNlID0gdGhpcy5fc291cmNlcy5maW5kSW5kZXgoKGUpID0+IHsgcmV0dXJuIGUuaWQgPT09IG9wdGlvbnMuc291cmNlIH0pO1xuICAgICAgICBpZiAobGF5ZXIgIT09IC0xKSB0aGlzLl9sYXllcnMuc3BsaWNlKGxheWVyLCAxKTtcbiAgICAgICAgaWYgKHNvdXJjZSAhPT0gLTEpIHRoaXMuX3NvdXJjZXMuc3BsaWNlKHNvdXJjZSwgMSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9hZEltYWdlIChvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy51cmwgfHwgIW9wdGlvbnMuaWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG9wdGlvbnMudXJsICsgJz8nICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICBtYXAubG9hZEltYWdlKHVybCwgZnVuY3Rpb24oZXJyb3IsIGltYWdlKSB7IHJldHVybiBlcnJvciA/IHJlamVjdChlcnJvcikgOiByZXNvbHZlKGltYWdlKTsgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvYWRJbWFnZUFzRGF0YVVSTChpbWFnZVVybCwgY2FsbGJhY2spIHtcbiAgICAgICAgLyogbG9hZEltYWdlQXNEYXRhVVJMKG9wdGlvbnMudXJsLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgb3B0aW9ucy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHN2Z01hcmtlciA9IGNyZWF0ZVNWR01hcmtlcihvcHRpb25zKTtcbiAgICAgICAgICAgIHN2Z1RvSW1hZ2Uoc3ZnTWFya2VyLCAoaW1nKSA9PiByZXNvbHZlKGltZykgKTtcbiAgICAgICAgfSk7ICovXG4gICAgICAgIFxuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnY3Jvc3NPcmlnaW4nLCAnYW5vbnltb3VzJyk7XG4gICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZShpbWcsIDAsIDApO1xuICAgICAgICAgICAgY29uc3QgZGF0YVVSTCA9IGNhbnZhcy50b0RhdGFVUkwoXCJpbWFnZS9wbmdcIik7XG4gICAgICAgICAgICBjYWxsYmFjayhkYXRhVVJMKTtcbiAgICAgICAgfTtcbiAgICAgICAgaW1nLnNyYyA9IGltYWdlVXJsICsgJz8nICsgbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlU1ZHTWFya2VyKG9wdGlvbnM9e30pIHtcbiAgICAgICAgY29uc3Qgc3ZnTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBvcHRpb25zLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBvcHRpb25zLmhlaWdodDtcbiAgICAgICAgY29uc3QgYm9yZGVyV2lkdGggPSBvcHRpb25zW1wic3Ryb2tlLXdpZHRoXCJdIHx8IDU7XG5cbiAgICAgICAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCBcInN2Z1wiKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBoZWlnaHQpO1xuICAgICAgICBzdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7d2lkdGggKyAyICogYm9yZGVyV2lkdGh9ICR7aGVpZ2h0ICsgMiAqIGJvcmRlcldpZHRofWApO1xuICAgIFxuICAgICAgICBjb25zdCBtYXJrZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnTlMsIFwiZWxsaXBzZVwiKTtcbiAgICAgICAgbWFya2VyLnNldEF0dHJpYnV0ZShcImN4XCIsICh3aWR0aCArIDIgKiBib3JkZXJXaWR0aCkgLyAyKTtcbiAgICAgICAgbWFya2VyLnNldEF0dHJpYnV0ZShcImN5XCIsIChoZWlnaHQgKyAyICogYm9yZGVyV2lkdGgpIC8gMik7XG4gICAgICAgIG1hcmtlci5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIpO1xuICAgICAgICBtYXJrZXIuc2V0QXR0cmlidXRlKFwicnlcIiwgaGVpZ2h0IC8gMik7XG4gICAgICAgIG1hcmtlci5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsICd0cmFuc3BhcmVudCcpO1xuICAgICAgICBtYXJrZXIuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIG9wdGlvbnMuc3Ryb2tlIHx8IGdlb2Zsby5nZXRDb2xvcnMoKS5zZWNvbmRhcnlCYWNrZ3JvdW5kKTtcbiAgICAgICAgbWFya2VyLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBib3JkZXJXaWR0aCk7XG4gICAgXG4gICAgICAgIGNvbnN0IGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCBcImltYWdlXCIpO1xuICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGVOUyhcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIiwgXCJocmVmXCIsIGRhdGEpO1xuICAgICAgICBpbWFnZS5zZXRBdHRyaWJ1dGUoXCJ4XCIsIGJvcmRlcldpZHRoKTtcbiAgICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwieVwiLCBib3JkZXJXaWR0aCk7XG4gICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoKTtcbiAgICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIGhlaWdodCk7XG4gICAgICAgIGltYWdlLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJ4TWlkWU1pZCBzbGljZVwiKTtcbiAgICAgICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiY2xpcC1wYXRoXCIsIFwiZWxsaXBzZSgpXCIpO1xuICAgIFxuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQobWFya2VyKTtcbiAgICAgICAgc3ZnLmFwcGVuZENoaWxkKGltYWdlKTtcbiAgICBcbiAgICAgICAgcmV0dXJuIHN2ZztcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gc3ZnVG9JbWFnZShzdmdFbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBzdmdEYXRhID0gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmdFbGVtZW50KTtcbiAgICAgICAgY29uc3Qgc3ZnQmxvYiA9IG5ldyBCbG9iKFtzdmdEYXRhXSwgeyB0eXBlOiBcImltYWdlL3N2Zyt4bWw7Y2hhcnNldD11dGYtOFwiIH0pO1xuICAgICAgICBjb25zdCB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHN2Z0Jsb2IpO1xuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgICBpbWcub25sb2FkID0gKCkgPT4geyBVUkwucmV2b2tlT2JqZWN0VVJMKHVybCksIGNhbGxiYWNrKGltZyk7IH07XG4gICAgICAgIGltZy5zcmMgPSB1cmw7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTGF5ZXJzOyIsIi8qKlxuICogQG1peGluXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsb1xuICogQG5hbWUgTG9jYXRlXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBtb2R1bGUgcHJvdmlkZXMgdGhlIGdlb2xvY2F0aW9uIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBHZW9mbG8gYXBwbGljYXRpb24uIEl0IGFsbG93cyB1c2VycyB0byBsb2NhdGUgdGhlaXIgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgbWFwIGFuZCB0cmFjayB0aGVpciBsb2NhdGlvbi5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIExvY2F0ZSBvYmplY3QuXG4gKi9cbmNvbnN0IExvY2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBnZW9mbG8gPSB0aGlzLmdlb2ZsbztcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTG9jYXRlXG5cdCAqIEBuYW1lIGluaXRcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gaW5pdGlhbGl6ZXMgdGhlIGdlb2xvY2F0aW9uIGNvbnRyb2wgb24gdGhlIG1hcCB3aXRoIHRoZSBzcGVjaWZpZWQgb3B0aW9ucy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgY29uZmlndXJpbmcgdGhlIGdlb2xvY2F0aW9uIGNvbnRyb2wuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZW5hYmxlSGlnaEFjY3VyYWN5PXRydWVdIC0gV2hldGhlciB0byBlbmFibGUgaGlnaCBhY2N1cmFjeSBmb3IgZ2VvbG9jYXRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhY2tVc2VyTG9jYXRpb249dHJ1ZV0gLSBXaGV0aGVyIHRvIHRyYWNrIHRoZSB1c2VyJ3MgbG9jYXRpb24uXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2hvd1VzZXJIZWFkaW5nPXRydWVdIC0gV2hldGhlciB0byBzaG93IHRoZSB1c2VyJ3MgaGVhZGluZy5cblx0ICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5zaG93QWNjdXJhY3lDaXJjbGU9ZmFsc2VdIC0gV2hldGhlciB0byBzaG93IHRoZSBhY2N1cmFjeSBjaXJjbGUuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBtYXAgd2l0aCB0aGUgZ2VvbG9jYXRpb24gY29udHJvbCBhZGRlZC5cblx0ICovXG4gICAgdGhpcy5pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnM9e30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZ2VvZmxvLlV0aWxpdGllcy5leHRlbmQoe30sIG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuY29udHJvbCA9IG5ldyBtYXBib3hnbC5HZW9sb2NhdGVDb250cm9sKHtcbiAgICAgICAgICAgIHBvc2l0aW9uT3B0aW9uczogeyBlbmFibGVIaWdoQWNjdXJhY3k6IHRydWUgfSxcbiAgICAgICAgICAgIHRyYWNrVXNlckxvY2F0aW9uOiB0cnVlLFxuICAgICAgICAgICAgc2hvd1VzZXJIZWFkaW5nOiB0cnVlLFxuICAgICAgICAgICAgc2hvd0FjY3VyYWN5Q2lyY2xlOiBmYWxzZVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmNvbnRyb2wub24oJ2dlb2xvY2F0ZScsIHRoaXMub25Db250cm9sRXZlbnQuYmluZCh0aGlzKSlcbiAgICAgICAgZ2VvZmxvLm1hcC5hZGRDb250cm9sKHRoaXMuY29udHJvbCwgJ3RvcC1yaWdodCcpO1xuICAgICAgICAvL3RoaXMucmVhZHkoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmNvbnRyb2wuX2NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5jb250cm9sLl9jb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Mb2NhdGVcblx0ICogQG5hbWUgcmVhZHlcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIHRoZSBnZW9sb2NhdGUgYnV0dG9uIGlzIGF2YWlsYWJsZSBpbiB0aGUgY29udHJvbCBhbmQgdGhlbiBjYWxscyB0aGUgYnVpbGQgZnVuY3Rpb24uXG5cdCAqIEBwYXJhbXMge09iamVjdH0gY29udHJvbCAtIFRoZSBjb250cm9sIG9iamVjdCBjb250YWluaW5nIHRoZSBnZW9sb2NhdGUgYnV0dG9uLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5yZWFkeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbnRyb2wgPSB0aGlzLmNvbnRyb2w7XG5cbiAgICAgICAgdmFyIHJlYWR5ID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRyb2wuX2dlb2xvY2F0ZUJ1dHRvbikgcmV0dXJuO1xuICAgICAgICAgICAgX3RoaXMuYnVpbGQoKTtcbiAgICAgICAgICAgIHJldHVybiBjbGVhckludGVydmFsKHJlYWR5KTtcbiAgICAgICAgfSwgMSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Mb2NhdGVcblx0ICogQG5hbWUgYnVpbGRcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gaGlkZXMgdGhlIHVzZXIgbG9jYXRpb24gZG90IG1hcmtlciBhbmQgdGhlIGFzc29jaWF0ZWQgYnV0dG9uLlxuXHQgKiBAcGFyYW1zIHt2b2lkfSBOb25lXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmJ1aWxkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmJ1dHRvbiA9IHRoaXMuY29udHJvbC5fZ2VvbG9jYXRlQnV0dG9uO1xuICAgICAgICB0aGlzLm1hcmtlciA9IHRoaXMuY29udHJvbC5fdXNlckxvY2F0aW9uRG90TWFya2VyO1xuICAgICAgICB0aGlzLmJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMub25Db250cm9sRXZlbnQuYmluZCh0aGlzKSk7XG4gICAgICAgIC8vdGhpcy5nZXRCdXR0b24oKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTG9jYXRlXG5cdCAqIEBuYW1lIHVwZGF0ZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBtYXAgYmVhcmluZyBhbmQgY2VudGVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMuYWxwaGEgLSBUaGUgYWxwaGEgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChvcHRpb25zPXt9KSB7XG4gICAgICAgIGNvbnN0IGFscGhhID0gb3B0aW9ucy5hbHBoYTtcbiAgICAgICAgY29uc3QgaGVhZGluZyA9IHRoaXMuaGVhZGluZygpO1xuICAgICAgICBjb25zdCBiZWFyaW5nID0gdGhpcy5iZWFyaW5nKCk7XG4gICAgICAgIGNvbnN0IGZvbGxvd2luZyA9IHRoaXMuZm9sbG93aW5nO1xuICAgICAgICBpZiAoIWhlYWRpbmcgfHwgIWZvbGxvd2luZyB8fCBnZW9mbG8ubWFwTW92aW5nKSByZXR1cm47XG4gICAgICAgIGdlb2Zsby5tYXAuc2V0QmVhcmluZyhoZWFkaW5nIC0gMSk7XG4gICAgICAgIGdlb2Zsby5tYXAuc2V0Q2VudGVyKHRoaXMubWFya2VyLl9sbmdMYXQpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTG9jYXRlXG5cdCAqIEBuYW1lIGhlYWRpbmdcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyB0aGUgaGVhZGluZyB2YWx1ZSBmcm9tIHRoZSBjb250cm9sIG9iamVjdC5cblx0ICogQHJldHVybnMge3N0cmluZ30gVGhlIGhlYWRpbmcgdmFsdWUgZnJvbSB0aGUgY29udHJvbCBvYmplY3QuXG5cdCAqL1xuICAgIHRoaXMuaGVhZGluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbC5faGVhZGluZztcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxvY2F0ZVxuXHQgKiBAbmFtZSBiZWFyaW5nXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHJldHJpZXZlcyB0aGUgY3VycmVudCBiZWFyaW5nIG9mIHRoZSBtYXAuXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBiZWFyaW5nIG9mIHRoZSBtYXAuXG5cdCAqL1xuICAgIHRoaXMuYmVhcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdlb2Zsby5tYXAuZ2V0QmVhcmluZygpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTG9jYXRlXG5cdCAqIEBuYW1lIGxvY2F0ZVxuXHQgKiBAZGVzY3JpcHRpb24gSW5pdGlhdGVzIHRoZSBwcm9jZXNzIG9mIGxvY2F0aW5nIHRoZSB1c2VyJ3MgY3VycmVudCBwb3NpdGlvbiBvbiB0aGUgbWFwLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5sb2NhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubG9jYXRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLnVubG9jYXRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRyb2wuX2ZvbGxvdyA9IHRoaXMuZm9sbG93aW5nID0gZmFsc2U7XG4gICAgICAgIGFkZENsYXNzZXModGhpcy5idXR0b24sIFsnbWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZyddKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ2xvY2F0ZS5vbicsIHsgc3RhdGU6IHRoaXMuc3RhdGUoKSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbC50cmlnZ2VyKCk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Mb2NhdGVcblx0ICogQG5hbWUgcmVsb2NhdGVcblx0ICogQGRlc2NyaXB0aW9uIFJlbG9jYXRlcyB0aGUgZ2VvbG9jYXRpb24gY29udHJvbCB0byB0aGUgdXNlcidzIGN1cnJlbnQgbG9jYXRpb24uIElmIHRoZSBjb250cm9sIGlzIHNldCB0byBmb2xsb3cgdGhlIHVzZXIncyBsb2NhdGlvbiwgaXQgY2hhbmdlcyB0aGUgc3RhdGUgdG8gJ0FDVElWRV9MT0NLJy4gQWRkcyB0aGUgJ21hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZScgY2xhc3MgdG8gdGhlIGJ1dHRvbiBlbGVtZW50LiBUcmlnZ2VycyB0aGUgY29udHJvbFxuXHQgKiBAcGFyYW1zIHt2b2lkfVxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5yZWxvY2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9sbG93aW5nKSB0aGlzLnN0YXRlKCdBQ1RJVkVfTE9DSycpO1xuICAgICAgICBhZGRDbGFzc2VzKHRoaXMuYnV0dG9uLCBbJ21hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWFjdGl2ZSddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbC50cmlnZ2VyKCk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Mb2NhdGVcblx0ICogQG5hbWUgdW5sb2NhdGVcblx0ICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIHN0YXRlIHRvICdBQ1RJVkVfTE9DSycsIGRpc2FibGVzIGZvbGxvd2luZywgZW5hYmxlcyBkcmFnIHBhbiBvbiB0aGUgbWFwLCBhbmQgdHJpZ2dlcnMgdGhlIGNvbnRyb2wuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSByZXN1bHQgb2YgdHJpZ2dlcmluZyB0aGUgY29udHJvbC5cblx0ICovXG4gICAgdGhpcy51bmxvY2F0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSgnQUNUSVZFX0xPQ0snKTtcbiAgICAgICAgdGhpcy5jb250cm9sLl9mb2xsb3cgPSB0aGlzLmZvbGxvd2luZyA9IGZhbHNlO1xuICAgICAgICBnZW9mbG8ubWFwLmRyYWdQYW4uZW5hYmxlKCk7XG4gICAgICAgIHRoaXMudW5sb2NhdGVkID0gdHJ1ZTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ2xvY2F0ZS5vZmYnLCB7IHN0YXRlOiB0aGlzLnN0YXRlKCkgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wudHJpZ2dlcigpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTG9jYXRlXG5cdCAqIEBuYW1lIGZvbGxvd1xuXHQgKiBAZGVzY3JpcHRpb24gRW5hYmxlcyB0aGUgZm9sbG93IGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBnZW9sb2NhdGUgY29udHJvbC4gV2hlbiBhY3RpdmF0ZWQsIGFkZHMgYSBzcGVjaWZpYyBjbGFzcyB0byB0aGUgYnV0dG9uLCBkaXNhYmxlcyBkcmFnIHBhbm5pbmcgb24gdGhlIG1hcCwgYW5kIHNldHMgdGhlIGZvbGxvdyBzdGF0ZSB0byB0cnVlLlxuXHQgKiBAcGFyYW1zIHtPYmplY3R9IGdlb2ZsbyAtIFRoZSBjb250ZXh0IG9iamVjdCBjb250YWluaW5nIHRoZSBtYXAgYW5kIGNvbnRyb2wgcmVmZXJlbmNlcy5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IC0gUmV0dXJucyB0cnVlIHRvIGluZGljYXRlIHRoYXQgdGhlIGZvbGxvdyBmdW5jdGlvbmFsaXR5IGhhcyBiZWVuIGVuYWJsZWQuXG5cdCAqL1xuICAgIHRoaXMuZm9sbG93ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBhZGRDbGFzc2VzKHRoaXMuYnV0dG9uLCBbJ21hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWZvbGxvdyddKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5kcmFnUGFuLmRpc2FibGUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbC5fZm9sbG93ID0gdGhpcy5mb2xsb3dpbmcgPSB0cnVlO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTG9jYXRlXG5cdCAqIEBuYW1lIHN0YXRlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gZ2V0IG9yIHNldCB0aGUgc3RhdGUgb2YgdGhlIGNvbnRyb2wuIElmIGEgc3RhdGUgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCBpdCBzZXRzIHRoZSBjb250cm9sJ3Mgd2F0Y2ggc3RhdGUgdG8gdGhhdCB2YWx1ZS4gSWYgbm8gc3RhdGUgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCBpdCByZXR1cm5zIHRoZSBjdXJyZW50IHdhdGNoIHN0YXRlIG9mIHRoZSBjb250cm9sLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHN0YXRlIC0gVGhlIHN0YXRlIHRvIHNldCBmb3IgdGhlIGNvbnRyb2wuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSAtIFRoZSBjdXJyZW50IHdhdGNoIHN0YXRlIG9mIHRoZSBjb250cm9sLlxuXHQgKi9cbiAgICB0aGlzLnN0YXRlID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZSA/IHRoaXMuY29udHJvbC5fd2F0Y2hTdGF0ZSA9IHN0YXRlIDogdGhpcy5jb250cm9sLl93YXRjaFN0YXRlO1xuICAgIH1cblxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxvY2F0ZVxuXHQgKiBAbmFtZSBnZXRCdXR0b25cblx0ICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGdlb2xvY2F0ZSBidXR0b24gZWxlbWVudCBmcm9tIHRoZSBjb250cm9sLlxuXHQgKiBAcmV0dXJucyB7RWxlbWVudH0gVGhlIGdlb2xvY2F0ZSBidXR0b24gZWxlbWVudC5cblx0ICovXG4gICAgdGhpcy5nZXRCdXR0b24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2wuX2dlb2xvY2F0ZUJ1dHRvbjtcbiAgICB9XG5cblxuICAgIFxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5Mb2NhdGVcblx0ICogQG5hbWUgcmVtb3ZlQ2xhc3Nlc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiByZW1vdmVzIGNsYXNzZXMgcmVsYXRlZCB0byBnZW9sb2NhdGlvbiBjb250cm9sIGZyb20gYSBidXR0b24gZWxlbWVudC5cblx0ICogQHBhcmFtcyB7RWxlbWVudH0gYnV0dG9uIC0gVGhlIGJ1dHRvbiBlbGVtZW50IGZyb20gd2hpY2ggY2xhc3NlcyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqL1xuICAgIHRoaXMucmVtb3ZlQ2xhc3NlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuYnV0dG9uO1xuICAgICAgICBpZiAoIWJ1dHRvbikgcmV0dXJuO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnbWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtd2FpdGluZycpO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZSgnbWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlJyk7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUtZXJyb3InKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQnKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQtZXJyb3InKTtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ21hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWZvbGxvdycpO1xuICAgIH1cblxuXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBvbkFkZFxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxvY2F0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBMb2dzIHRoZSBldmVudCBvYmplY3QgdG8gdGhlIGNvbnNvbGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgdGhhdCBpcyB0cmlnZ2VyZWQgd2hlbiBhbiBhY3Rpb24gb2NjdXJzLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAqIFxuICAgICAqIEBhdXRob3IgU29sdXRlZ3JhdGVcbiAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgKi9cbiAgICB0aGlzLm9uQWRkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGV2ZW50KVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIG9uQ29udHJvbEV2ZW50XG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTG9jYXRlXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgY29udHJvbCBldmVudHMsIHVwZGF0aW5nIHRoZSBtYXJrZXIgYW5kIG1hbmFnaW5nIHRoZSBzdGF0ZSBiYXNlZCBvbiB0aGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBjb250cm9sIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5jb29yZHMgLSBUaGUgY29vcmRpbmF0ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudCwgaWYgYXZhaWxhYmxlLlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGV2ZW50LnRhcmdldCAtIFRoZSB0YXJnZXQgZWxlbWVudCB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnQuXG4gICAgICogQHJldHVybnMge3ZvaWR9IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICogXG4gICAgICogQGF1dGhvciBTb2x1dGVncmF0ZVxuICAgICAqIEBjb3B5cmlnaHQgMjAyNVxuICAgICAqL1xuICAgIHRoaXMub25Db250cm9sRXZlbnQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy90aGlzLmJ1dHRvbiA9IHRoaXMuYnV0dG9uIHx8IGV2ZW50LmJ1dHRvbjtcbiAgICAgICAgdGhpcy5tYXJrZXIgPSB0aGlzLmNvbnRyb2wuX3VzZXJMb2NhdGlvbkRvdE1hcmtlcjtcblxuICAgICAgICB0aGlzLnJlbW92ZUNsYXNzZXMoKTtcblxuICAgICAgICBpZiAoZXZlbnQuY29vcmRzKSB7XG4gICAgICAgICAgICB0aGlzLm9uTG9jYXRlKGV2ZW50KVxuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5idXR0b24pIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvY2F0ZTogJywgdGhpcy5zdGF0ZSgpLCBldmVudCwgdGhpcy5idXR0b24pO1xuICAgICAgICAgICAgZ2VvZmxvLm1hcC5kcmFnUGFuLmVuYWJsZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA9PT0gJ09GRicpIHJldHVybiB0aGlzLmxvY2F0ZSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA9PT0gJ0JBQ0tHUk9VTkQnICYmICF0aGlzLmZvbGxvd2luZykgcmV0dXJuIHRoaXMucmVsb2NhdGUoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlKCkgPT09ICdBQ1RJVkVfTE9DSycgJiYgIXRoaXMuZm9sbG93aW5nKSByZXR1cm4gdGhpcy5mb2xsb3coKTtcbiAgICAgICAgICAgIHRoaXMudW5sb2NhdGUoKTtcbiAgICAgICAgfSBcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBvbkxvY2F0ZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxvY2F0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBsb2NhdGlvbiB1cGRhdGUgZXZlbnQsIHVwZGF0aW5nIHRoZSBjdXJyZW50IGxvY2F0aW9uIGFuZCBmaXJpbmcgYW4gZXZlbnQgd2l0aCB0aGUgbmV3IHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGxvY2F0aW9uIGRhdGEuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmNvb3JkcyAtIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgY3VycmVudCBsb2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgKiBcbiAgICAgKiBAYXV0aG9yIFNvbHV0ZWdyYXRlXG4gICAgICogQGNvcHlyaWdodCAyMDI1XG4gICAgICovXG4gICAgdGhpcy5vbkxvY2F0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSgpID09PSAnQUNUSVZFX0xPQ0snICYmIHRoaXMubG9jYXRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudExvY2F0aW9uID0gZXZlbnQuY29vcmRzO1xuICAgICAgICAgICAgYWRkQ2xhc3Nlcyh0aGlzLmJ1dHRvbiwgWydtYXBib3hnbC1jdHJsLWdlb2xvY2F0ZS1hY3RpdmUnXSk7XG4gICAgICAgIH1cblxuICAgICAgICBnZW9mbG8uZmlyZSgnbG9jYXRlLnVwZGF0ZScsIHsgbG9jYXRpbmc6IHRoaXMubG9jYXRpbmcsIGNvb3JkczogZXZlbnQuY29vcmRzLCBzdGF0ZTogdGhpcy5zdGF0ZSgpIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIG9uTWFwTW92ZVxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLkxvY2F0ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBtYXAgbW92ZW1lbnQgZXZlbnQsIHVwZGF0aW5nIHRoZSBidXR0b24gY2xhc3NlcyBiYXNlZCBvbiB0aGUgY3VycmVudCBzdGF0ZSBhbmQgY29uZGl0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBtYXAgbW92ZW1lbnQuXG4gICAgICogQHJldHVybnMge3ZvaWR9IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICogXG4gICAgICogQGF1dGhvciBTb2x1dGVncmF0ZVxuICAgICAqIEBjb3B5cmlnaHQgMjAyNVxuICAgICAqL1xuICAgIHRoaXMub25NYXBNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5idXR0b24gfHwgdGhpcy5mb2xsb3dpbmcgfHwgdGhpcy51bmxvY2F0ZWQpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA9PT0gJ0FDVElWRV9MT0NLJykgcmV0dXJuIGFkZENsYXNzZXModGhpcy5idXR0b24sIFsnbWFwYm94Z2wtY3RybC1nZW9sb2NhdGUtYWN0aXZlJ10pO1xuICAgICAgICBhZGRDbGFzc2VzKHRoaXMuYnV0dG9uLCBbJ21hcGJveGdsLWN0cmwtZ2VvbG9jYXRlLWJhY2tncm91bmQnXSk7XG4gICAgfVxuXG4gICAgdGhpcy5pbml0KCk7XG5cbiAgICBmdW5jdGlvbiBhZGRDbGFzc2VzIChidXR0b24sIGNsYXNzZXM9W10pIHtcbiAgICAgICAgaWYgKCFidXR0b24pIHJldHVybjtcbiAgICAgICAgY2xhc3Nlcy5mb3JFYWNoKGZ1bmN0aW9uKGMpIHsgYyA/IGJ1dHRvbi5jbGFzc0xpc3QuYWRkKGMpIDogZmFsc2UgfSlcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IExvY2F0ZTsiLCIvKipcbiAqIEBtaXhpblxuICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG9cbiAqIEBuYW1lIE1lc2hcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1vZHVsZSBwcm92aWRlcyB0aGUgbWVzaCBmdW5jdGlvbmFsaXR5IGZvciB0aGUgR2VvZmxvIGFwcGxpY2F0aW9uLiBJdCBhbGxvd3MgdXNlcnMgdG8gY3JlYXRlIGEgbWVzaCBvZiBmZWF0dXJlcyBieSBzcGxpdHRpbmcgdGhlbSBpbnRvIHNlZ21lbnRzIGFuZCBjaGVja2luZyBmb3IgaW50ZXJzZWN0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXl9IG9yaWdpbmFsRmVhdHVyZXMgLSBBbiBhcnJheSBvZiBmZWF0dXJlcyB0byBiZSBhZGRlZCB0byB0aGUgbWVzaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbGluZXNPbmx5IC0gQSBmbGFnIGluZGljYXRpbmcgd2hldGhlciBvbmx5IGxpbmVzIHNob3VsZCBiZSBhZGRlZCB0byB0aGUgbWVzaC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIE1lc2ggb2JqZWN0LlxuICovXG5jb25zdCBNZXNoID0gZnVuY3Rpb24gKG9yaWdpbmFsRmVhdHVyZXMsIGxpbmVzT25seSkge1xuICAgIHZhciBzZWdtZW50SWQgPSAxO1xuICAgIHZhciBhbGxTZWdtZW50cyA9IFtdO1xuICAgIHZhciBmZWF0dXJlSW5kZXggPSB7fTtcblxuICAgIGNvbnN0IGdlb2ZsbyA9IHRoaXMuZ2VvZmxvO1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5NZXNoXG5cdCAqIEBuYW1lIGFkZE5ld0ZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIG5ldyBmZWF0dXJlcywgc3BsaXRzIHRoZW0gaW50byBzZWdtZW50cywgY2hlY2tzIGZvciBpbnRlcnNlY3Rpb25zLCBhbmQgdXBkYXRlcyB0aGUgZXhpc3Rpbmcgc2VnbWVudHMgYWNjb3JkaW5nbHkuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZlYXR1cmVzIC0gQW4gYXJyYXkgb2YgbmV3IGZlYXR1cmVzIHRvIGJlIGFkZGVkLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBtZXNoIHNlZ21lbnRzLlxuXHQgKi9cbiAgICB0aGlzLmFkZE5ld0ZlYXR1cmVzID0gZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICAgICAgdmFyIGFsbE5ld0ZlYXR1cmVzID0gc3BsaXRBbmRDaGVja0ZvckludGVyc2VjdGlvbnMoZmVhdHVyZXMpO1xuICAgICAgICB2YXIgbmV3U2VnbWVudHMgPSBzcGxpdEludG9Ud29Qb2ludFNlZ21lbnRzQW5kQWRkSWRzKGFsbE5ld0ZlYXR1cmVzKTtcbiAgICAgICAgdmFyIHNlZ21lbnRzV2l0aEN1dFBvaW50cyA9IGNoZWNrRm9ySW50ZXJzZWN0aW9ucyhuZXdTZWdtZW50cywgYWxsU2VnbWVudHMpO1xuICAgICAgICBhbGxTZWdtZW50cyA9IFtdLmNvbmNhdChnZW9mbG8uVXRpbGl0aWVzLmNvbnN1bWFibGVBcnJheShjdXRTZWdtZW50cyhhbGxTZWdtZW50cywgc2VnbWVudHNXaXRoQ3V0UG9pbnRzKSksIGdlb2Zsby5VdGlsaXRpZXMuY29uc3VtYWJsZUFycmF5KGN1dFNlZ21lbnRzKG5ld1NlZ21lbnRzLCBzZWdtZW50c1dpdGhDdXRQb2ludHMpKSk7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZlYXR1cmVzKCk7XG4gICAgfTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTWVzaFxuXHQgKiBAbmFtZSBnZXRGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gUmV0dXJucyBhbGwgb2YgdGhlIGZlYXR1cmVzIGluIHRoZSBtZXNoLlxuXHQgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGFsbCBmZWF0dXJlIHNlZ21lbnRzLlxuXHQgKi9cbiAgICB0aGlzLmdldEZlYXR1cmVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBhbGxTZWdtZW50cztcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5NZXNoXG5cdCAqIEBuYW1lIHNwbGl0U2VnbWVudEF0UG9pbnRcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBzZWdtZW50IElEIGFuZCBjb29yZGluYXRlcyBvZiBhIHBvaW50IHRvIHNwbGl0IHRoZSBzZWdtZW50LiBJdCBjcmVhdGVzIHR3byBuZXcgc2VnbWVudHMgYnkgc3BsaXR0aW5nIHRoZSBvcmlnaW5hbCBzZWdtZW50IGF0IHRoZSBzcGVjaWZpZWQgcG9pbnQgYW5kIHVwZGF0ZXMgdGhlIGZlYXR1cmUgaW5kZXguXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzZWdtZW50SWQgLSBUaGUgSUQgb2YgdGhlIHNlZ21lbnQgdG8gYmUgc3BsaXQuXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcG9pbnRDb29yZHMgLSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IHdoZXJlIHRoZSBzZWdtZW50IHNob3VsZCBiZSBzcGxpdC5cblx0ICovXG4gICAgdGhpcy5zcGxpdFNlZ21lbnRBdFBvaW50ID0gZnVuY3Rpb24oc2VnbWVudElkLCBwb2ludENvb3Jkcykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVJbmRleFtzZWdtZW50SWRdO1xuICAgICAgICBpZiAoZmVhdHVyZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gYWxsU2VnbWVudHMuaW5kZXhPZihmZWF0dXJlKTtcbiAgICAgICAgICAgIGFsbFNlZ21lbnRzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgdmFyIGxpbmUxID0gZ2VvZmxvLlV0aWxpdGllcy5jcmVhdGVMaW5lV2l0aExlbmd0aChbcG9pbnRDb29yZHMsIGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1dKTtcbiAgICAgICAgICAgIHZhciBsaW5lMiA9IGdlb2Zsby5VdGlsaXRpZXMuY3JlYXRlTGluZVdpdGhMZW5ndGgoW3BvaW50Q29vcmRzLCBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdXSk7XG4gICAgICAgICAgICBhZGRGZWF0dXJlVG9JbmRleChsaW5lMSk7XG4gICAgICAgICAgICBhZGRGZWF0dXJlVG9JbmRleChsaW5lMik7XG4gICAgICAgICAgICBhbGxTZWdtZW50cy5wdXNoKGxpbmUxLCBsaW5lMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwic3BsaXRTZWdtZW50QXRQb2ludDogbm8gb3JpZ2luYWwgZmVhdHVyZSBmb3IgaWQgXCIsIHNlZ21lbnRJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5NZXNoXG5cdCAqIEBuYW1lIGdldEZlYXR1cmVzRnJvbUluZGV4XG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIGZlYXR1cmVzIGFuZCByZXRyaWV2ZXMgdGhlIGNvcnJlc3BvbmRpbmcgZmVhdHVyZXMgZnJvbSBhbiBpbmRleCBiYXNlZCBvbiB0aGVpciBJRHMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZlYXR1cmVzIC0gVGhlIGFycmF5IG9mIGZlYXR1cmVzIHRvIHJldHJpZXZlIGZyb20gdGhlIGluZGV4LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBhcnJheSBvZiBmZWF0dXJlcyByZXRyaWV2ZWQgZnJvbSB0aGUgaW5kZXguXG5cdCAqL1xuICAgIHRoaXMuZ2V0RmVhdHVyZXNGcm9tSW5kZXggPSBmdW5jdGlvbihmZWF0dXJlcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIGlkID0gZmVhdHVyZS5pZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICB2YXIgb3JpZ2luYWxGZWF0dXJlID0gZmVhdHVyZUluZGV4W2lkXTtcbiAgICAgICAgICAgIGlmIChvcmlnaW5hbEZlYXR1cmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG9yaWdpbmFsRmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLk1lc2hcblx0ICogQG5hbWUgZ2V0RmVhdHVyZUJ5SWRcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBhIGZlYXR1cmUgYnkgaXRzIElELlxuXHQgKiBAcGFyYW0ge251bWJlcn0gaWQgLSBUaGUgSUQgb2YgdGhlIGZlYXR1cmUgdG8gcmV0cmlldmUuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IFRoZSBmZWF0dXJlIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm92aWRlZCBJRC5cblx0ICovXG4gICAgdGhpcy5nZXRGZWF0dXJlQnlJZCA9IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgIHJldHVybiBnZXRGZWF0dXJlQnlJZChpZCk7XG4gICAgfTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTWVzaFxuXHQgKiBAbmFtZSBnZXRGZWF0dXJlc0J5UGFyZW50SWRcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgcGFyZW50IElELiBUaGUgcGFyZW50IElEIGlzIHVzZWQgdG8gcmV0cmlldmUgY29sZCBmZWF0dXJlcyBhc3NvY2lhdGVkIHdpdGggdGhlIHNlZ21lbnQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIFRoZSBwYXJlbnQgSUQgdG8gcmV0cmlldmUgZmVhdHVyZXMgZm9yLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgb2YgZmVhdHVyZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBwYXJlbnQgSUQuXG5cdCAqL1xuICAgIHRoaXMuZ2V0RmVhdHVyZXNCeVBhcmVudElkID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIGdldEZlYXR1cmVzQnlQYXJlbnRJZChpZCk7XG4gICAgfTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTWVzaFxuXHQgKiBAbmFtZSByZW1vdmVGZWF0dXJlXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGEgZmVhdHVyZSB3aXRoIHRoZSBzcGVjaWZpZWQgSUQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBpZCAtIFRoZSBJRCBvZiB0aGUgZmVhdHVyZSB0byBiZSByZW1vdmVkLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgdGhlIGZlYXR1cmUgd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuICAgIHRoaXMucmVtb3ZlRmVhdHVyZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gcmVtb3ZlRmVhdHVyZShpZCk7XG4gICAgfTtcblxuXG4gICAgaWYgKG9yaWdpbmFsRmVhdHVyZXMpIGFsbFNlZ21lbnRzID0gc3BsaXRBbmRDaGVja0ZvckludGVyc2VjdGlvbnMob3JpZ2luYWxGZWF0dXJlcyk7XG5cblxuICAgIGZ1bmN0aW9uIGFkZEZlYXR1cmVUb0luZGV4KGZlYXR1cmUsIHBhcmVudCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4W3NlZ21lbnRJZF0gfHwgZ2V0RmVhdHVyZUJ5SWQoc2VnbWVudElkKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGZlYXR1cmVJbmRleFtzZWdtZW50SWRdID0gZmVhdHVyZTtcbiAgICAgICAgZmVhdHVyZS5pZCA9IHNlZ21lbnRJZDtcbiAgICAgICAgZmVhdHVyZS5wYXJlbnQgPSBwYXJlbnQ7XG5cbiAgICAgICAgZ2VvZmxvLlV0aWxpdGllcy5zZXRQcm9wZXJ0eShmZWF0dXJlLCAnaWQnLCBzZWdtZW50SWQpO1xuICAgICAgICBnZW9mbG8uVXRpbGl0aWVzLnNldFByb3BlcnR5KGZlYXR1cmUsICdwYXJlbnQnLCBwYXJlbnQpO1xuXG4gICAgICAgIHNlZ21lbnRJZCsrO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDbGlja1NlZ2VtZW50c1RvTWVzaCgpIHtcbiAgICAgICAgaWYgKCFnZW9mbG8ub3B0aW9ucy5zbmFwcGluZy5lbmFibGUpIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAgICAgdmFyIG1lc2hGZWF0dXJlcyA9IFtdO1xuICAgIFxuICAgICAgICBpZiAoZ2VvZmxvLmNsb3Nlc3RQb2ludCAmJiBnZW9mbG8uY2xvc2VzdFBvaW50LmJvcmRlcnMgJiYgZ2VvZmxvLmNsb3Nlc3RQb2ludC5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBnZW9mbG8ubWVzaEluZGV4LnNwbGl0U2VnbWVudEF0UG9pbnQoZ2VvZmxvLmNsb3Nlc3RQb2ludC5pZCwgZ2VvZmxvLmNsb3Nlc3RQb2ludC5jb29yZHMpO1xuICAgICAgICAgICAgZ2VvZmxvLnVwZGF0ZU1lc2hEYXRhKCk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKGdlb2Zsby5zbmFwRmVhdHVyZSkge1xuICAgICAgICAgICAgaWYgKGdlb2Zsby5zbmFwRmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGlmICghZ2VvZmxvLlV0aWxpdGllcy5pc0VtcHR5TGluZVN0cmluZyhnZW9mbG8uc25hcEZlYXR1cmUpKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc2hGZWF0dXJlcy5wdXNoKGdlb2Zsby5zbmFwRmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9mbG8uc25hcEZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJQb2ludFwiKSB7XG4gICAgICAgICAgICAgICAgZ2VvZmxvLlV0aWxpdGllcy5zZXRQcm9wZXJ0eShnZW9mbG8uc25hcEZlYXR1cmUsICdzdGFydFBvaW50JywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgZ2VvZmxvLnN0YXJ0UG9pbnQgPSBnZW9mbG8uVXRpbGl0aWVzLmNsb25lRGVlcChnZW9mbG8uc25hcEZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIG1lc2hGZWF0dXJlcy5wdXNoKGdlb2Zsby5zbmFwRmVhdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKG1lc2hGZWF0dXJlcy5sZW5ndGggPiAwKSBnZW9mbG8uYWRkRmVhdHVyZXNUb01lc2gobWVzaEZlYXR1cmVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb29yZGluYXRlc1RvTGluZVN0cmluZ3MoY29vcmRzLCByZXN1bHQsIHBhcmVudCkge1xuICAgICAgICB2YXIgZmlyc3RQb2ludCA9IHR1cmYudHJ1bmNhdGUodHVyZi5wb2ludChjb29yZHNbMF0pLCB7IHByZWNpc2lvbjogNywgY29vcmRpbmF0ZXM6IDIsIG11dGF0ZTogdHJ1ZSB9KTtcbiAgICAgICAgdmFyIHNlY29uZFBvaW50ID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgY29vcmRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgc2Vjb25kUG9pbnQgPSB0dXJmLnRydW5jYXRlKHR1cmYucG9pbnQoY29vcmRzW2luZGV4XSksIHsgcHJlY2lzaW9uOiA3LCBjb29yZGluYXRlczogMiwgbXV0YXRlOiB0cnVlIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIWdlb2Zsby5VdGlsaXRpZXMuaXNQb2ludEVxdWFsKGZpcnN0UG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHNlY29uZFBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzKSkge1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gdHVyZi5saW5lU3RyaW5nKFtmaXJzdFBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBzZWNvbmRQb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc10pO1xuICAgICAgICAgICAgICAgIHZhciBhZGRlZCA9IGFkZEZlYXR1cmVUb0luZGV4KGxpbmUsIHBhcmVudCk7XG4gICAgICAgICAgICAgICAgYWRkZWQgPyByZXN1bHQucHVzaChsaW5lKSA6IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmaXJzdFBvaW50ID0gc2Vjb25kUG9pbnQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzcGxpdEludG9Ud29Qb2ludFNlZ21lbnRzQW5kQWRkSWRzKGZlYXR1cmVzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgaWYgKCFmZWF0dXJlcyB8fCAhZmVhdHVyZXMubGVuZ3RoKSByZXR1cm4gcmVzdWx0O1xuXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgICB2YXIgaWQgPSBmZWF0dXJlLnBhcmVudCB8fCBmZWF0dXJlLnByb3BlcnRpZXMucGFyZW50IHx8IGZlYXR1cmUuaWQgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkO1xuICAgICAgICAgICAgdmFyIGFkZGVkO1xuXG4gICAgICAgICAgICBpZiAobGluZXNPbmx5ICYmIHR5cGUgIT09IFwiTGluZVN0cmluZ1wiICYmICFmZWF0dXJlLnByb3BlcnRpZXMudW5maWxsKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZSA9IGdlb2Zsby5VdGlsaXRpZXMuY2xvbmVEZWVwKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIGFkZGVkID0gYWRkRmVhdHVyZVRvSW5kZXgoZmVhdHVyZSwgaWQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhZGRlZCA/IHJlc3VsdC5wdXNoKGZlYXR1cmUpIDogZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlID09PSBcIk11bHRpUG9seWdvblwiKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBjb29yZHMuZm9yRWFjaChmdW5jdGlvbihzdWJDb29yZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzVG9MaW5lU3RyaW5ncyhzdWJDb29yZHMsIHJlc3VsdCwgaWQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goZnVuY3Rpb24oY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3JkaW5hdGVzVG9MaW5lU3RyaW5ncyhjb29yZHMsIHJlc3VsdCwgaWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIk11bHRpTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGNvb3Jkcykge1xuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlc1RvTGluZVN0cmluZ3MoY29vcmRzLCByZXN1bHQsIGlkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlc1RvTGluZVN0cmluZ3MoZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcywgcmVzdWx0LCBpZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiUG9pbnRcIikge1xuICAgICAgICAgICAgICAgIGZlYXR1cmUgPSBnZW9mbG8uVXRpbGl0aWVzLmNsb25lRGVlcChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IGFkZEZlYXR1cmVUb0luZGV4KGZlYXR1cmUsIGlkKTtcbiAgICAgICAgICAgICAgICBhZGRlZCA/IHJlc3VsdC5wdXNoKGZlYXR1cmUpIDogZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwZW5kQ3V0RmVhdHVyZXMoc2VnbWVudHNXaXRoQ3V0UG9pbnRzLCBmZWF0dXJlLCBjdXRQb2ludEZlYXR1cmVzKSB7XG4gICAgICAgIHZhciBpZCA9IGZlYXR1cmUuaWQgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkO1xuICAgICAgICB2YXIgc2VnQ3V0UG9pbnRzID0gc2VnbWVudHNXaXRoQ3V0UG9pbnRzW2lkXTtcbiAgICBcbiAgICAgICAgaWYgKHNlZ0N1dFBvaW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzZWdDdXRQb2ludHMgPSBbXTtcbiAgICAgICAgICAgIHNlZ21lbnRzV2l0aEN1dFBvaW50c1tpZF0gPSBzZWdDdXRQb2ludHM7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgY3V0UG9pbnRGZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBuZXdDdXRQb2ludCA9IGdlb2Zsby5VdGlsaXRpZXMucmVkdWNlUHJlY2lzaW9uKGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgdmFyIGN1dFBvaW50ID0gc2VnQ3V0UG9pbnRzLmZpbmRJbmRleChmdW5jdGlvbihlbGVtZW50KSB7IHJldHVybiBlbGVtZW50WzBdID09PSBuZXdDdXRQb2ludFswXSAmJiBlbGVtZW50WzFdID09PSBuZXdDdXRQb2ludFsxXTsgfSk7XG4gICAgICAgICAgICBpZiAoY3V0UG9pbnQgPT09IC0xKSB7IHNlZ0N1dFBvaW50cy5wdXNoKG5ld0N1dFBvaW50KTsgfVxuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gY2hlY2tGb3JJbnRlcnNlY3Rpb25zKGtub3duU2VnbWVudHMsIG5ld1NlZ21lbnRzKSB7XG4gICAgICAgIHZhciBzZWdtZW50c1dpdGhDdXRQb2ludHMgPSB7fTtcblxuICAgICAgICB2YXIgcHJvY2Vzc0ludGVyc2VjdGlvblBvaW50ID0gZnVuY3Rpb24gcHJvY2Vzc0ludGVyc2VjdGlvblBvaW50KHBvaW50LCBmZWF0dXJlMSwgZmVhdHVyZTIpIHtcbiAgICAgICAgICAgIHZhciBwb2ludENvb3JkcyA9IHBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgdmFyIHNlZzFDb29yZHMgPSBmZWF0dXJlMS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIHZhciBzZWcyQ29vcmRzID0gZmVhdHVyZTIuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICB2YXIgYWRkRmVhdHVyZTFQb2ludCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGFkZEZlYXR1cmUyUG9pbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjbG9zZXN0UG9pbnRBZGRlZCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoIWdlb2Zsby5VdGlsaXRpZXMuaXNQb2ludEVxdWFsKHBvaW50Q29vcmRzLCBzZWcxQ29vcmRzWzBdKSAmJiAhZ2VvZmxvLlV0aWxpdGllcy5pc1BvaW50RXF1YWwocG9pbnRDb29yZHMsIHNlZzFDb29yZHNbMV0pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50MSA9IHR1cmYucG9pbnQoc2VnMUNvb3Jkc1swXSk7XG4gICAgICAgICAgICAgICAgdmFyIGVuZHBvaW50MiA9IHR1cmYucG9pbnQoc2VnMUNvb3Jkc1sxXSk7XG4gICAgICAgICAgICAgICAgdmFyIGRpc3RhbmNlRW5kcG9pbnQxID0gdHVyZi5kaXN0YW5jZShwb2ludCwgZW5kcG9pbnQxKTtcbiAgICAgICAgICAgICAgICB2YXIgZGlzdGFuY2VFbmRwb2ludDIgPSB0dXJmLmRpc3RhbmNlKHBvaW50LCBlbmRwb2ludDIpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGNsb3Nlc3RFbmRwb2ludCA9IGRpc3RhbmNlRW5kcG9pbnQxIDwgZGlzdGFuY2VFbmRwb2ludDIgPyBlbmRwb2ludDEgOiBlbmRwb2ludDI7XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9pbnRPbkxpbmUgPSB0dXJmLnBvaW50T25MaW5lKGZlYXR1cmUyLCBjbG9zZXN0RW5kcG9pbnQpO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludE9uTGluZS5wcm9wZXJ0aWVzLmRpc3QgPCBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuTUlOX0RJU1RBTkNFKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZEN1dEZlYXR1cmVzKHNlZ21lbnRzV2l0aEN1dFBvaW50cywgZmVhdHVyZTIsIFtjbG9zZXN0RW5kcG9pbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFBvaW50QWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEZlYXR1cmUxUG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZ2VvZmxvLlV0aWxpdGllcy5pc1BvaW50RXF1YWwocG9pbnRDb29yZHMsIHNlZzJDb29yZHNbMF0pICYmICFnZW9mbG8uVXRpbGl0aWVzLmlzUG9pbnRFcXVhbChwb2ludENvb3Jkcywgc2VnMkNvb3Jkc1sxXSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2VuZHBvaW50ID0gdHVyZi5wb2ludChzZWcyQ29vcmRzWzBdKTtcbiAgICAgICAgICAgICAgICB2YXIgX2VuZHBvaW50MiA9IHR1cmYucG9pbnQoc2VnMkNvb3Jkc1sxXSk7XG4gICAgICAgICAgICAgICAgdmFyIF9kaXN0YW5jZUVuZHBvaW50ID0gdHVyZi5kaXN0YW5jZShwb2ludCwgX2VuZHBvaW50KTtcbiAgICAgICAgICAgICAgICB2YXIgX2Rpc3RhbmNlRW5kcG9pbnQyID0gdHVyZi5kaXN0YW5jZShwb2ludCwgX2VuZHBvaW50Mik7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2Nsb3Nlc3RFbmRwb2ludCA9IF9kaXN0YW5jZUVuZHBvaW50IDwgX2Rpc3RhbmNlRW5kcG9pbnQyID8gX2VuZHBvaW50IDogX2VuZHBvaW50MjtcblxuICAgICAgICAgICAgICAgIHZhciBfcG9pbnRPbkxpbmUgPSB0dXJmLnBvaW50T25MaW5lKGZlYXR1cmUxLCBfY2xvc2VzdEVuZHBvaW50KTtcbiAgICAgICAgICAgICAgICBpZiAoX3BvaW50T25MaW5lLnByb3BlcnRpZXMuZGlzdCA8IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5NSU5fRElTVEFOQ0UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kQ3V0RmVhdHVyZXMoc2VnbWVudHNXaXRoQ3V0UG9pbnRzLCBmZWF0dXJlMSwgW19jbG9zZXN0RW5kcG9pbnRdKTtcbiAgICAgICAgICAgICAgICAgICAgY2xvc2VzdFBvaW50QWRkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZEZlYXR1cmUyUG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFjbG9zZXN0UG9pbnRBZGRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhZGRGZWF0dXJlMVBvaW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZEN1dEZlYXR1cmVzKHNlZ21lbnRzV2l0aEN1dFBvaW50cywgZmVhdHVyZTEsIFtwb2ludF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYWRkRmVhdHVyZTJQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRDdXRGZWF0dXJlcyhzZWdtZW50c1dpdGhDdXRQb2ludHMsIGZlYXR1cmUyLCBbcG9pbnRdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGNoZWNrSWZQb2ludEluQ2xvc2VSYW5nZSA9IGZ1bmN0aW9uIGNoZWNrSWZQb2ludEluQ2xvc2VSYW5nZShmZWF0dXJlLCBjb29yZHMpIHtcbiAgICAgICAgICAgIHZhciBwb2ludE9ubGluZSA9IHR1cmYucG9pbnRPbkxpbmUoZmVhdHVyZSwgdHVyZi5wb2ludChjb29yZHMpKTtcbiAgICAgICAgICAgIGlmIChwb2ludE9ubGluZS5wcm9wZXJ0aWVzLmRpc3QgPCBnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuTUlOX0RJU1RBTkNFKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFnZW9mbG8uVXRpbGl0aWVzLmlzUG9pbnRBdFZlcnRleChmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBjb29yZHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZEN1dEZlYXR1cmVzKHNlZ21lbnRzV2l0aEN1dFBvaW50cywgZmVhdHVyZSwgW3BvaW50T25saW5lXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgc2FtZVNlZ21lbnRzID0ga25vd25TZWdtZW50cyA9PT0gbmV3U2VnbWVudHM7XG5cbiAgICAgICAgZm9yICh2YXIga25vd25JbmRleCA9IDA7IGtub3duSW5kZXggPCBrbm93blNlZ21lbnRzLmxlbmd0aDsga25vd25JbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgc2VnbWVudEZlYXR1cmUxID0ga25vd25TZWdtZW50c1trbm93bkluZGV4XTtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlMVR5cGUgPSBzZWdtZW50RmVhdHVyZTEuZ2VvbWV0cnkudHlwZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgbmV3SW5kZXggPSBzYW1lU2VnbWVudHMgPyBrbm93bkluZGV4ICsgMSA6IDA7IG5ld0luZGV4IDwgbmV3U2VnbWVudHMubGVuZ3RoOyBuZXdJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlZ21lbnRGZWF0dXJlMiA9IG5ld1NlZ21lbnRzW25ld0luZGV4XTtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZTJUeXBlID0gc2VnbWVudEZlYXR1cmUyLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gc2VnbWVudEZlYXR1cmUyLmlkIHx8IHNlZ21lbnRGZWF0dXJlMi5wcm9wZXJ0aWVzLmlkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUxVHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIgJiYgZmVhdHVyZTJUeXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VvZmxvLlV0aWxpdGllcy5pc092ZXJsYXBwaW5nKHNlZ21lbnRGZWF0dXJlMSwgc2VnbWVudEZlYXR1cmUyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvblBvaW50cyA9IHR1cmYubGluZUludGVyc2VjdChzZWdtZW50RmVhdHVyZTEsIHNlZ21lbnRGZWF0dXJlMikuZmVhdHVyZXM7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoID4gMSkgY29uc29sZS5lcnJvcihpbnRlcnNlY3Rpb25Qb2ludHMubGVuZ3RoICsgXCIgaW50ZXJzZWN0aW9uIHBvaW50cyByZWNlaXZlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9pbnQgPSBpbnRlcnNlY3Rpb25Qb2ludHNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0ludGVyc2VjdGlvblBvaW50KHBvaW50LCBzZWdtZW50RmVhdHVyZTEsIHNlZ21lbnRGZWF0dXJlMik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWcxQ29vcmRzID0gc2VnbWVudEZlYXR1cmUxLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzZWcyQ29vcmRzID0gc2VnbWVudEZlYXR1cmUyLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSWZQb2ludEluQ2xvc2VSYW5nZShzZWdtZW50RmVhdHVyZTEsIHNlZzJDb29yZHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSWZQb2ludEluQ2xvc2VSYW5nZShzZWdtZW50RmVhdHVyZTEsIHNlZzJDb29yZHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSWZQb2ludEluQ2xvc2VSYW5nZShzZWdtZW50RmVhdHVyZTIsIHNlZzFDb29yZHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrSWZQb2ludEluQ2xvc2VSYW5nZShzZWdtZW50RmVhdHVyZTIsIHNlZzFDb29yZHNbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZ2V0RmVhdHVyZUJ5SWQoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4aXN0aW5nIExpbmU6ICcsIHNlZ21lbnRGZWF0dXJlMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gYWxsU2VnbWVudHMuaW5kZXhPZihnZXRGZWF0dXJlQnlJZChpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbFNlZ21lbnRzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChmZWF0dXJlMVR5cGUgPT09IFwiUG9pbnRcIiB8fCBmZWF0dXJlMlR5cGUgPT09IFwiUG9pbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZTJUeXBlID09PSBcIlBvaW50XCIgJiYgZmVhdHVyZTJUeXBlID09PSBcIlBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUG9pbnQgJiBQb2ludFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUG9pbnQgJiBMaW5lU3RyaW5nXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9wb2ludCA9IGZlYXR1cmUxVHlwZSA9PT0gXCJQb2ludFwiID8gc2VnbWVudEZlYXR1cmUxIDogc2VnbWVudEZlYXR1cmUyO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxpbmUgPSBmZWF0dXJlMVR5cGUgPT09IFwiTGluZVN0cmluZ1wiID8gc2VnbWVudEZlYXR1cmUxIDogc2VnbWVudEZlYXR1cmUyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZCA9IF9wb2ludC5pZCB8fCBfcG9pbnQucHJvcGVydGllcy5pZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrSWZQb2ludEluQ2xvc2VSYW5nZShsaW5lLCBfcG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudHNXaXRoQ3V0UG9pbnRzW2lkXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdldEZlYXR1cmVCeUlkKGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0V4aXN0aW5nIFBvaW50OiAnLCBzZWdtZW50RmVhdHVyZTIpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcG9zID0gYWxsU2VnbWVudHMuaW5kZXhPZihnZXRGZWF0dXJlQnlJZChpZCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsU2VnbWVudHMuc3BsaWNlKHBvcywgMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc2VnbWVudHNXaXRoQ3V0UG9pbnRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGN1dFNlZ21lbnRzKG5ld1NlZ21lbnRzLCBzZWdtZW50c1dpdGhDdXRQb2ludHMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgIG5ld1NlZ21lbnRzLmZvckVhY2goZnVuY3Rpb24oc2VnbWVudCkge1xuICAgICAgICAgICAgdmFyIGlkID0gc2VnbWVudC5pZCB8fCBzZWdtZW50LnByb3BlcnRpZXMuaWQ7XG5cbiAgICAgICAgICAgIGlmIChzZWdtZW50Lmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1dFBvaW50cyA9IHNlZ21lbnRzV2l0aEN1dFBvaW50c1tpZF07XG5cbiAgICAgICAgICAgICAgICBpZiAoY3V0UG9pbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZjID0gdHVyZi5saW5lU3BsaXQoc2VnbWVudCwgdHVyZi5tdWx0aVBvaW50KGN1dFBvaW50cykpO1xuICAgICAgICAgICAgICAgICAgICB0dXJmLmZlYXR1cmVFYWNoKGZjLCBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGVuZ3RoID0gdHVyZi5saW5lRGlzdGFuY2UoZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID4gZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLk1JTl9TRUdNRU5UX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5VdGlsaXRpZXMuc2V0UHJvcGVydGllcyhmZWF0dXJlLCB7IGxlbmd0aDogbGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZlYXR1cmVUb0luZGV4KGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiMCBsZW5ndGggZmVhdHVyZSAoXCIsIGxlbmd0aCwgXCIpIGFmdGVyIGxpbmUgc3BsaXQ6IFwiLCBKU09OLnN0cmluZ2lmeShmZWF0dXJlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW5ndGggPSB0dXJmLmxpbmVEaXN0YW5jZShzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxlbmd0aCA+IGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5NSU5fU0VHTUVOVF9MRU5HVEgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb2Zsby5VdGlsaXRpZXMuc2V0UHJvcGVydGllcyhzZWdtZW50LCB7IGxlbmd0aDogbGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiMCBsZW5ndGggZmVhdHVyZSAoXCIsIGxlbmd0aCwgXCIpIGV4aXN0aW5nIHNlZ21lbnQ6IFwiLCBKU09OLnN0cmluZ2lmeShzZWdtZW50KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBfY3V0UG9pbnRzID0gc2VnbWVudHNXaXRoQ3V0UG9pbnRzW2lkXTtcblxuICAgICAgICAgICAgICAgIGlmIChfY3V0UG9pbnRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNwbGl0QW5kQ2hlY2tGb3JJbnRlcnNlY3Rpb25zKG5ld0ZlYXR1cmVzKSB7XG4gICAgICAgIHZhciBuZXdGZWF0dXJlc1NlZ21lbnRzID0gc3BsaXRJbnRvVHdvUG9pbnRTZWdtZW50c0FuZEFkZElkcyhuZXdGZWF0dXJlcyk7XG4gICAgICAgIGlmIChsaW5lc09ubHkpIHJldHVybiBuZXdGZWF0dXJlc1NlZ21lbnRzO1xuICAgICAgICB2YXIgbmV3RmVhdHVyZXNXaXRoQ3V0UG9pbnRzID0gY2hlY2tGb3JJbnRlcnNlY3Rpb25zKG5ld0ZlYXR1cmVzU2VnbWVudHMsIG5ld0ZlYXR1cmVzU2VnbWVudHMpO1xuICAgICAgICByZXR1cm4gY3V0U2VnbWVudHMobmV3RmVhdHVyZXNTZWdtZW50cywgbmV3RmVhdHVyZXNXaXRoQ3V0UG9pbnRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRGZWF0dXJlQnlJZChpZCkge1xuICAgICAgICByZXR1cm4gYWxsU2VnbWVudHMuZmluZChmdW5jdGlvbihmKSB7IHJldHVybiBmLmlkID09PSBpZCB8fCBmLnByb3BlcnRpZXMuaWQgPT09IGlkIH0pIFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEZlYXR1cmVzQnlQYXJlbnRJZChpZCkge1xuICAgICAgICByZXR1cm4gYWxsU2VnbWVudHMuZmlsdGVyKGZ1bmN0aW9uKGYpIHsgcmV0dXJuIGYucGFyZW50ID09PSBpZCB8fCBmLnByb3BlcnRpZXMucGFyZW50ID09PSBpZCB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZlYXR1cmUoaWQpIHtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gZ2V0RmVhdHVyZXNCeVBhcmVudElkKGlkKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChmZWF0dXJlcyAmJiBmZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBwb3MgPSBhbGxTZWdtZW50cy5pbmRleE9mKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIGFsbFNlZ21lbnRzLnNwbGljZShwb3MsIDEpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZ2VvZmxvLnVwZGF0ZU1lc2hEYXRhKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYWxsU2VnbWVudHM7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgTWVzaDsiLCIvKipcbiAqIEBtaXhpblxuICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG9cbiAqIEBuYW1lIE9wdGlvbnNcbiAqIEBkZXNjcmlwdGlvbiBPcHRpb25zIGZvciB0aGUgR2VvZmxvIG1hcC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aGVtZSAtIFRoZSB0aGVtZSBvZiB0aGUgbWFwLiBEZWZhdWx0IGlzICdkYXJrJy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd0xpbmVVbml0cyAtIFNob3cgbGluZSB1bml0cy4gRGVmYXVsdCBpcyBmYWxzZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2hvd0ZlYXR1cmVUZXh0IC0gU2hvdyBmZWF0dXJlIHRleHQuIERlZmF1bHQgaXMgdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjb250cm9scyAtIENvbnRyb2xzIGZvciB0aGUgbWFwLlxuICogQHByb3BlcnR5IHtib29sZWFufSBjb250cm9scy5vcHRpb25zIC0gU2hvdyBvcHRpb25zIGNvbnRyb2wuIERlZmF1bHQgaXMgdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29udHJvbHMubW9kZXMgLSBTaG93IG1vZGVzIGNvbnRyb2wuIERlZmF1bHQgaXMgdHJ1ZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29udHJvbHMudXRpbHMgLSBTaG93IHV0aWxpdGllcyBjb250cm9sLiBEZWZhdWx0IGlzIHRydWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbnRyb2xzLnR5cGVzIC0gU2hvdyB0eXBlcyBjb250cm9sLiBEZWZhdWx0IGlzIHRydWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGNvbnRyb2xzLmFjdGlvbnMgLSBTaG93IGFjdGlvbnMgY29udHJvbC4gRGVmYXVsdCBpcyB0cnVlLlxuICogQHByb3BlcnR5IHtvYmplY3R9IG1hcCAtIE1hcCBvcHRpb25zLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IG1hcC5jb250YWluZXIgLSBNYXAgY29udGFpbmVyLiBEZWZhdWx0IGlzICdtYXAnLlxuICogQHByb3BlcnR5IHthcnJheX0gbWFwLmNlbnRlciAtIE1hcCBjZW50ZXIuIERlZmF1bHQgaXMgWy05NS41MjgxNjY4MDIzNjg5MiwgMzkuNTY0MzExNDM5ODYwMzVdLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1hcC56b29tIC0gTWFwIHpvb20uIERlZmF1bHQgaXMgMy41LlxuICogQHByb3BlcnR5IHtudW1iZXJ9IG1hcC5tYXhQaXRjaCAtIE1heGltdW0gcGl0Y2ggb2YgdGhlIG1hcC4gRGVmYXVsdCBpcyA1MC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXAucHJvamVjdGlvbiAtIE1hcCBwcm9qZWN0aW9uLiBEZWZhdWx0IGlzICdtZXJjYXRvcicuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gbWFwLnN0eWxlIC0gTWFwIHN0eWxlLiBEZWZhdWx0IGlzICdtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2RhcmstdjExJy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gbWFwLmhhc2ggLSBFbmFibGUgbWFwIGhhc2ggbmF2aWdhdGlvbi4gRGVmYXVsdCBpcyB0cnVlLlxuICogQHByb3BlcnR5IHthcnJheX0gbWFwLmV4dGVudCAtIE1hcCBib3VuZGluZyBleHRlbnQuXG4gKiBAcHJvcGVydHkge29iamVjdH0ga2V5cyAtIEtleWJvYXJkIHNob3J0Y3V0cy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlzLmltcG9ydCAtIEltcG9ydCBrZXkuIERlZmF1bHQgaXMgJ3UnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleXMuZXhwb3J0IC0gRXhwb3J0IGtleS4gRGVmYXVsdCBpcyAnZCcuXG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5cy5kZWxldGUgLSBEZWxldGUga2V5LiBEZWZhdWx0IGlzICdEZWxldGUnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleXMuY2FuY2VsIC0gQ2FuY2VsIGtleS4gRGVmYXVsdCBpcyAnRXNjYXBlJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlzLnNlbGVjdCAtIFNlbGVjdCBrZXkuIERlZmF1bHQgaXMgJ0VzY2FwZScuXG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5cy5lZGl0IC0gRWRpdCBrZXkuIERlZmF1bHQgaXMgJ0VudGVyJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlzLnJlZnJlc2ggLSBSZWZyZXNoIGtleS4gRGVmYXVsdCBpcyAncicuXG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5cy5zbmFwcGluZyAtIFNuYXBwaW5nIGtleS4gRGVmYXVsdCBpcyAnIScuXG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5cy5waW5uaW5nIC0gUGlubmluZyBrZXkuIERlZmF1bHQgaXMgJ0AnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleXMucm91dGluZyAtIFJvdXRpbmcga2V5LiBEZWZhdWx0IGlzICcjJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlzLmV4cGxvcmluZyAtIEV4cGxvcmluZyBrZXkuIERlZmF1bHQgaXMgJyQnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleXMucGFpbnRpbmcgLSBQYWludGluZyBrZXkuIERlZmF1bHQgaXMgJyUnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleXMucG9seWxpbmUgLSBQb2x5bGluZSBrZXkuIERlZmF1bHQgaXMgJzEnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleXMucG9seWdvbiAtIFBvbHlnb24ga2V5LiBEZWZhdWx0IGlzICcyJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBrZXlzLnJlY3RhbmdsZSAtIFJlY3RhbmdsZSBrZXkuIERlZmF1bHQgaXMgJzMnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGtleXMuY2lyY2xlIC0gQ2lyY2xlIGtleS4gRGVmYXVsdCBpcyAnNCcuXG4gKiBAcHJvcGVydHkge3N0cmluZ30ga2V5cy50ZXh0IC0gVGV4dCBrZXkuIERlZmF1bHQgaXMgJzUnLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHVuaXRzIC0gTWVhc3VyZW1lbnQgdW5pdHMgZm9yIGRpZmZlcmVudCBnZW9tZXRyaWVzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVuaXRzLlBvbHlsaW5lIC0gUG9seWxpbmUgdW5pdC4gRGVmYXVsdCBpcyAnZmVldCcuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdW5pdHMuUG9seWdvbiAtIFBvbHlnb24gdW5pdC4gRGVmYXVsdCBpcyAnYWNyZXMnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVuaXRzLlJlY3RhbmdsZSAtIFJlY3RhbmdsZSB1bml0LiBEZWZhdWx0IGlzICdhY3JlcycuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdW5pdHMuSWNvbiAtIEljb24gdW5pdC4gRGVmYXVsdCBpcyAnZmVhdHVyZScuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gdW5pdHMuQ2lyY2xlIC0gQ2lyY2xlIHVuaXQuIERlZmF1bHQgaXMgJ2ZlYXR1cmUnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHVuaXRzLk1hcmtlciAtIE1hcmtlciB1bml0LiBEZWZhdWx0IGlzICdmZWF0dXJlJy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBjb2xvcnMgLSBDb2xvciBzY2hlbWUgc2V0dGluZ3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29sb3JzLmVycm9yIC0gRXJyb3IgY29sb3IuIERlZmF1bHQgaXMgJyNmZjc2NzYnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbG9ycy5wcmltYXJ5Q29sb3IgLSBQcmltYXJ5IGNvbG9yLiBEZWZhdWx0IGlzICcjZDdlZjdlJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvcnMucHJpbWFyeUJhY2tncm91bmQgLSBQcmltYXJ5IGJhY2tncm91bmQgY29sb3IuIERlZmF1bHQgaXMgJyM1YTVhNWEnLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGNvbG9ycy5wcmltYXJ5VGV4dCAtIFByaW1hcnkgdGV4dCBjb2xvci4gRGVmYXVsdCBpcyAnI2M1YzVjNScuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29sb3JzLnByaW1hcnlCb3JkZXIgLSBQcmltYXJ5IGJvcmRlciBjb2xvci4gRGVmYXVsdCBpcyAnIzZmYWZkYicuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gY29sb3JzLnNlY29uZGFyeUNvbG9yIC0gU2Vjb25kYXJ5IGNvbG9yLiBEZWZhdWx0IGlzICcjNmZhZmRiJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvcnMuc2Vjb25kYXJ5QmFja2dyb3VuZCAtIFNlY29uZGFyeSBiYWNrZ3JvdW5kIGNvbG9yLiBEZWZhdWx0IGlzICcjMzMzMzMzJy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2xvcnMuc2Vjb25kYXJ5VGV4dCAtIFNlY29uZGFyeSB0ZXh0IGNvbG9yLiBEZWZhdWx0IGlzICcjMzMzMzMzJy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBzZWxlY3QgLSBTZWxlY3Rpb24gb3B0aW9ucy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gc2VsZWN0LnBvcHVwIC0gRW5hYmxlIHNlbGVjdGlvbiBwb3B1cHMuIERlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNlbGVjdC5tdWx0aXBsZSAtIEFsbG93IG11bHRpcGxlIHNlbGVjdGlvbi4gRGVmYXVsdCBpcyBmYWxzZS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBzbmFwcGluZyAtIFNuYXBwaW5nIHNldHRpbmdzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBzbmFwcGluZy5lbmFibGUgLSBFbmFibGUgc25hcHBpbmcgdG8gZmVhdHVyZXMuIERlZmF1bHQgaXMgZmFsc2UuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHNuYXBwaW5nLnBpeGVscyAtIFBpeGVsLWJhc2VkIHNuYXBwaW5nLiBEZWZhdWx0IGlzIGZhbHNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHNuYXBwaW5nLmRpc3RhbmNlIC0gU25hcHBpbmcgZGlzdGFuY2UgaW4ga2lsb21ldGVycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBzbmFwcGluZy50b2xlcmFuY2UgLSBTbmFwcGluZyB0b2xlcmFuY2UgaW4ga2lsb21ldGVycy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSByb3V0aW5nIC0gUm91dGluZyBzZXR0aW5ncy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcm91dGluZy5lbmFibGUgLSBFbmFibGUgcm91dGluZyBmdW5jdGlvbmFsaXR5LiBEZWZhdWx0IGlzIGZhbHNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHJvdXRpbmcucHJlY2lzaW9uIC0gUm91dGluZyBjb29yZGluYXRlIHByZWNpc2lvbi5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBwaW5uaW5nIC0gUGlubmluZyBzZXR0aW5ncy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gcGlubmluZy5lbmFibGUgLSBFbmFibGUgZmVhdHVyZSBwaW5uaW5nLiBEZWZhdWx0IGlzIGZhbHNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBpbm5pbmcuYnVmZmVyIC0gUGlubmluZyBidWZmZXIgZGlzdGFuY2UgaW4ga2lsb21ldGVycy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwaW5uaW5nLmlkbGUgLSBJZGxlIHRpbWUgYmVmb3JlIHVwZGF0aW5nIHBpbm5lZCBmZWF0dXJlcy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBleHBsb3JpbmcgLSBFeHBsb3Jpbmcgc2V0dGluZ3MuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGV4cGxvcmluZy5lbmFibGUgLSBFbmFibGUgZmVhdHVyZSBleHBsb3JhdGlvbi4gRGVmYXVsdCBpcyBmYWxzZS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBleHBsb3JpbmcubWluWm9vbSAtIE1pbmltdW0gem9vbSBsZXZlbCBmb3IgZXhwbG9yYXRpb24uIERlZmF1bHQgaXMgOS5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBleHBsb3JpbmcuYnVmZmVyIC0gRXhwbG9yYXRpb24gYnVmZmVyIGRpc3RhbmNlIGluIGtpbG9tZXRlcnMuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZXhwbG9yaW5nLnRvbGVyYW5jZSAtIEV4cGxvcmF0aW9uIGNvb3JkaW5hdGUgc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlLlxuICogQHByb3BlcnR5IHtvYmplY3R9IHBhaW50aW5nIC0gUGFpbnRpbmcgc2V0dGluZ3MuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IHBhaW50aW5nLmVuYWJsZSAtIEVuYWJsZSBwYWludGluZyBtb2RlLiBEZWZhdWx0IGlzIGZhbHNlLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IHBhaW50aW5nLnRvbGVyYW5jZSAtIFBhaW50aW5nIGNvb3JkaW5hdGUgc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlLlxuICogQHByb3BlcnR5IHtvYmplY3R9IGdhbWVwYWQgLSBHYW1lcGFkIGNvbmZpZ3VyYXRpb24gc2V0dGluZ3MuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGdhbWVwYWQuZW5hYmxlIC0gRW5hYmxlIGdhbWVwYWQgc3VwcG9ydC4gRGVmYXVsdCBpcyB0cnVlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBnYW1lcGFkLmRlYnVnIC0gRW5hYmxlIGdhbWVwYWQgZGVidWdnaW5nLiBEZWZhdWx0IGlzIGZhbHNlLlxuICogQHByb3BlcnR5IHtib29sZWFufSBnYW1lcGFkLmNyb3NzaGFpcnMgLSBTaG93IGNyb3NzaGFpcnMgb24gdGhlIG1hcC4gRGVmYXVsdCBpcyB0cnVlLlxuICogQHByb3BlcnR5IHtvYmplY3R9IGdhbWVwYWQuam95c3RpY2sgLSBKb3lzdGljayBzZXR0aW5ncy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBnYW1lcGFkLmpveXN0aWNrLm1pbiAtIE1pbmltdW0gam95c3RpY2sgdGhyZXNob2xkLiBEZWZhdWx0IGlzIDAuMi5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBnYW1lcGFkLmpveXN0aWNrLm1heCAtIE1heGltdW0gam95c3RpY2sgdGhyZXNob2xkLiBEZWZhdWx0IGlzIDAuNy5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBnYW1lcGFkLnBhbiAtIFBhbiBzZXR0aW5ncy5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBnYW1lcGFkLnBhbi5zcGVlZCAtIFBhbiBzcGVlZC4gRGVmYXVsdCBpcyAwLjAwMS5cbiAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBnYW1lcGFkLnpvb20gLSBab29tIHNldHRpbmdzLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGdhbWVwYWQuem9vbS5zcGVlZCAtIFpvb20gc3BlZWQuIERlZmF1bHQgaXMgMC4wMDguXG4gKi9cblxuXG5jb25zdCBPcHRpb25zID0ge1xuICAgIHRoZW1lOiAnZGFyaycsXG4gICAgc2hvd0xpbmVVbml0czogZmFsc2UsXG4gICAgc2hvd0ZlYXR1cmVUZXh0OiB0cnVlLFxuICAgIGNvbnRyb2xzOiB7XG4gICAgICAgIG9wdGlvbnM6IHRydWUsXG4gICAgICAgIG1vZGVzOiB0cnVlLFxuICAgICAgICB1dGlsczogdHJ1ZSxcbiAgICAgICAgdHlwZXM6IHRydWUsXG4gICAgICAgIGFjdGlvbnM6IHRydWVcbiAgICB9LFxuICAgIG1hcDoge1xuICAgICAgICBjb250YWluZXI6ICdtYXAnLFxuICAgICAgICBjZW50ZXI6IFstOTUuNTI4MTY2ODAyMzY4OTIsIDM5LjU2NDMxMTQzOTg2MDM1XSxcbiAgICAgICAgem9vbTogMy41LFxuICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICBtYXhQaXRjaDogNTAsXG4gICAgICAgIHByb2plY3Rpb246ICdtZXJjYXRvcicsXG4gICAgICAgIHN0eWxlOiAnU3RhbmRhcmQnLFxuICAgICAgICBoYXNoOiB0cnVlLFxuICAgICAgICBleHRlbnQ6IFtbWy0xMjcuMzYzODQ1OSw0OS42MjEyNzUyXSxbLTczLjcyOTUxMzYsNDkuNjIxMjc1Ml0sWy03My43Mjk1MTM2LDI0Ljc0NzMyMDFdLFstMTI3LjM2Mzg0NTksMjQuNzQ3MzIwMV0sWy0xMjcuMzYzODQ1OSw0OS42MjEyNzUyXV1dLFxuICAgICAgICBzdHlsZXM6IFtcbiAgICAgICAgICAgIHsgdGl0bGU6IFwiU3RhbmRhcmRcIiwgdXJpOiBcIm1hcGJveDovL3N0eWxlcy9tYXBib3gvc3RhbmRhcmRcIiB9LFxuICAgICAgICAgICAgeyB0aXRsZTogXCJTYXRlbGxpdGVcIiwgdXJpOiBcIm1hcGJveDovL3N0eWxlcy9tYXBib3gvc3RhbmRhcmQtc2F0ZWxsaXRlXCIgfSxcbiAgICAgICAgICAgIHsgdGl0bGU6IFwiRGFya1wiLCB1cmk6IFwibWFwYm94Oi8vc3R5bGVzL21hcGJveC9kYXJrLXYxMVwiIH0sXG4gICAgICAgICAgICB7IHRpdGxlOiBcIkxpZ2h0XCIsIHVyaTogXCJtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2xpZ2h0LXYxMVwiIH0sXG4gICAgICAgICAgICB7IHRpdGxlOiBcIk91dGRvb3JzXCIsIHVyaTogXCJtYXBib3g6Ly9zdHlsZXMvbWFwYm94L291dGRvb3JzLXYxMlwiIH0sXG4gICAgICAgICAgICB7IHRpdGxlOiBcIlN0cmVldHNcIiwgdXJpOiBcIm1hcGJveDovL3N0eWxlcy9tYXBib3gvbmF2aWdhdGlvbi1uaWdodC12MVwiIH1cbiAgICAgICAgXVxuICAgIH0sXG4gICAga2V5czoge1xuICAgICAgICBpbXBvcnQ6ICd1JyxcbiAgICAgICAgZXhwb3J0OiAnZCcsXG4gICAgICAgIGRlbGV0ZTogJ0RlbGV0ZScsXG4gICAgICAgIGNhbmNlbDogJ0VzY2FwZScsXG4gICAgICAgIHNlbGVjdDogJ0VzY2FwZScsXG4gICAgICAgIGVkaXQ6ICdFbnRlcicsXG4gICAgICAgIHJlZnJlc2g6ICdyJyxcbiAgICAgICAgc25hcHBpbmc6ICchJyxcbiAgICAgICAgcGlubmluZzogJ0AnLFxuICAgICAgICByb3V0aW5nOiAnIycsXG4gICAgICAgIGV4cGxvcmluZzogJyQnLFxuICAgICAgICBwYWludGluZzogJyUnLFxuICAgICAgICBwb2x5bGluZTogJzEnLFxuICAgICAgICBwb2x5Z29uOiAnMicsXG4gICAgICAgIHJlY3RhbmdsZTogJzMnLFxuICAgICAgICBjaXJjbGU6ICc0JyxcbiAgICAgICAgdGV4dDogJzUnXG4gICAgfSxcbiAgICBjb21tYW5kczogW3tcbiAgICAgICAga2V5OiAnLicsXG4gICAgICAgIG1vZGlmaWVyOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgKiBAbmFtZSBjb21tYW5kXG4gICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLk9wdGlvbnMuY29tbWFuZHNcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEV4ZWN1dGVzIGEgY29tbWFuZCBiYXNlZCBvbiB0aGUgY3VycmVudCBtb2RlIGFuZCBnZW9mbG8gY29udGV4dC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgYWJvdXQgdGhlIGNvbW1hbmQgZXhlY3V0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VvZmxvIC0gVGhlIGdlb2ZsbyBjb250ZXh0IGNvbnRhaW5pbmcgbWFwIGFuZCBtb2RlIGluZm9ybWF0aW9uLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY29tbWFuZCAtIFRoZSBjb21tYW5kIGlkZW50aWZpZXIgdG8gYmUgZXhlY3V0ZWQuXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgY29tbWFuZDogZnVuY3Rpb24gKGV2ZW50LCBnZW9mbG8sIGNvbW1hbmQpIHtcbiAgICAgICAgICAgIHZhciBvcHRpb25zID0geyBsbmdMYXQ6IGdlb2Zsby5tYXAuZ2V0Q2VudGVyKCkgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZ2VvZmxvLmN1cnJlbnRNb2RlLmlkID09PSAnZHJhdycpIHtcbiAgICAgICAgICAgICAgICBnZW9mbG8uY3VycmVudE1vZGUuaGFuZGxlVXAob3B0aW9ucyk7IFxuICAgICAgICAgICAgICAgIGdlb2Zsby5jdXJyZW50TW9kZS5oYW5kbGVDbGljayhvcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLmhhbmRsZUNsaWNrKG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfV0sXG4gICAgdW5pdHM6IHtcbiAgICAgICAgUG9seWxpbmU6ICdmZWV0JyxcbiAgICAgICAgUG9seWdvbjogJ2FjcmVzJyxcbiAgICAgICAgUmVjdGFuZ2xlOiAnYWNyZXMnLFxuICAgICAgICBJY29uOiAnZmVhdHVyZScsXG4gICAgICAgIENpcmNsZTogJ2ZlYXR1cmUnLFxuICAgICAgICBNYXJrZXI6ICdmZWF0dXJlJ1xuICAgIH0sXG4gICAgY29sb3JzOiB7XG4gICAgICAgIGVycm9yOiAnI2ZmNzY3NicsXG5cbiAgICAgICAgcHJpbWFyeUNvbG9yOiBcIiNkN2VmN2VcIixcbiAgICAgICAgcHJpbWFyeUJhY2tncm91bmQ6IFwiIzVhNWE1YVwiLFxuICAgICAgICBwcmltYXJ5VGV4dDogXCIjYzVjNWM1XCIsXG4gICAgICAgIHByaW1hcnlCb3JkZXI6IFwiIzZmYWZkYlwiLFxuICAgICAgICBcbiAgICAgICAgc2Vjb25kYXJ5Q29sb3I6IFwiIzZmYWZkYlwiLFxuICAgICAgICBzZWNvbmRhcnlCYWNrZ3JvdW5kOiBcIiMzMzMzMzNcIixcbiAgICAgICAgc2Vjb25kYXJ5VGV4dDogXCIjMzMzMzMzXCIsXG4gICAgICAgIHNlY29uZGFyeUJvcmRlcjogXCIjNDA0MDQwXCIsXG5cbiAgICAgICAgcHJpbWFyeVNlbGVjdDogXCIjZDdlZjdlXCIsXG4gICAgICAgIHByaW1hcnlFZGl0OiBcIiNkN2VmN2VcIixcbiAgICAgICAgcHJpbWFyeUhvdDogXCIjMjQyNDI0XCIsXG4gICAgICAgIHByaW1hcnlDb2xkOiBcIiMzMzMzMzNcIixcbiAgICAgICAgcHJpbWFyeVNuYXA6IFwiI2Q3ZWY3ZVwiLFxuICAgICAgICBwcmltYXJ5QmFzZTogXCIjYzVjNWM1XCIsXG4gICAgICAgIHByaW1hcnlEZWJ1ZzogXCIjZmY3Njc2XCIsXG4gICAgICAgIHByaW1hcnlWZXJ0ZXg6IFwiI2Q3ZWY3ZVwiLFxuXG4gICAgICAgIHNlY29uZGFyeVNlbGVjdDogXCIjYzVjNWM1XCIsXG4gICAgICAgIHNlY29uZGFyeUVkaXQ6IFwiI2M1YzVjNVwiLFxuICAgICAgICBzZWNvbmRhcnlIb3Q6IFwiIzMzMzMzM1wiLFxuICAgICAgICBzZWNvbmRhcnlDb2xkOiBcIiNjNWM1YzVcIixcbiAgICAgICAgc2Vjb25kYXJ5U25hcDogXCIjYzVjNWM1XCIsXG4gICAgICAgIHNlY29uZGFyeUJhc2U6IFwiIzVhNWE1YVwiLFxuICAgICAgICBzZWNvbmRhcnlEZWJ1ZzogXCIjZDdlZjdlXCIsXG4gICAgICAgIHNlY29uZGFyeVZlcnRleDogXCIjMzMzMzMzXCJcbiAgICB9LFxuICAgIHNlbGVjdDoge1xuICAgICAgICBwb3B1cDogZmFsc2UsXG4gICAgICAgIG11bHRpcGxlOiBmYWxzZVxuICAgIH0sXG4gICAgc25hcHBpbmc6IHtcbiAgICAgICAgZW5hYmxlOiBmYWxzZSwgLy8gRW5hYmxlcyBzbmFwcGluZyB0byBmZWF0dXJlc1xuICAgICAgICBwaXhlbHM6IGZhbHNlLCAvLyBzdGlsbCB3b3JraW5nIG9uIHRoaXNcbiAgICAgICAgZGlzdGFuY2U6IDIwMCAqIDEuNjA5MzQ0LCAvLyAyMDAgbWlsZXMgdG8ga2lsb21ldGVycy4gQ2FsY3VsYXRlZCBieSB6b29tIGxldmVsOiAoZGlzdGFuY2UgKiBNYXRoLnBvdygyLCBNYXRoLm1heCgxLCAxOSAtIG1hcC5nZXRab29tKCkpKSkgLyAxMDAwMDBcbiAgICAgICAgdG9sZXJhbmNlOiAwLjAwMiAvLyBraWxvbWV0ZXJzLiBEaXN0YW5jZSBmcm9tIHRoZSBsYXN0IGNsaWNrIHRvIGhpZGUvc2hvdyBtb3VzZSBsaW5lXG4gICAgfSxcbiAgICByb3V0aW5nOiB7XG4gICAgICAgIGVuYWJsZTogZmFsc2UsIC8vIGZpbmQgc2hvcnRlc3QgcGF0aFxuICAgICAgICBwcmVjaXNpb246IDAuMDAwMDAxNSAvLyByb3VuZGluZyBjb29yZHMgdG8gY3JlYXRlIHRvcG9sb2d5LiBIaWdoZXIgdGhlIG51bWJlciB3aWxsIGNsb3NlIGdhcHMgaW4gbGluZXMgYW5kIGFsbG93IHRvIGZpbmQgcGF0aFxuICAgIH0sXG4gICAgcGlubmluZzoge1xuICAgICAgICBlbmFibGU6IGZhbHNlLCAvLyBFbmFibGVzIHBpbm5pbmcgKGdsdWVpbmcpIGZlYXR1cmVzIHRvZ2V0aGVyIGF0IHZlcnRpY2VzL3BvaW50cy4gV2hlbiBlZGl0aW5nL2RyYWdnaW5nIGEgcG9pbnQsIGFsbCBwaW5uZWQgcG9pbnRzIHdpbGwgbW92ZSB0b2dldGhlci5cbiAgICAgICAgYnVmZmVyOiAoNTAgLyA1MjgwKSAqIDEuNjA5MzQ0LCAvLyA1MCBmZWV0IHRvIG1pbGVzIHRvIGtpbG9tZXRlci4gUGluIGZlYXR1cmVzIHdpdGhpbiBhIDUwIGZvb3QgcmFkaXVzLiBGYWxzZSBmb3IgZXhhY3QgcG9pbnQgbG9jYXRpb24uXG4gICAgICAgIGlkbGU6IDIwIC8vIG1pbGxpc2Vjb25kcyBvZiBob3cgbG9uZyB0byBpZGxlIGFmdGVyIHVwZGF0aW5nIHBpbm5lZCBmZWF0dXJlcyBiZWZvcmUgY2hlY2tpbmcgZm9yIG5lYXJieSBmZWF0dXJlcyB0byBzbmFwIHRvIChoZWxwcyB3aXRoIGVkaXRpbmcgcGVyZm9ybWFuY2UpXG4gICAgfSxcbiAgICBleHBsb3Jpbmc6IHtcbiAgICAgICAgZW5hYmxlOiBmYWxzZSxcbiAgICAgICAgbWluWm9vbTogOSxcbiAgICAgICAgYnVmZmVyOiAoNTAwMCAvIDUyODApICogMS42MDkzNDQsIC8vIDMwMCBmZWV0IHRvIG1pbGVzIHRvIGtpbG9tZXRlci4gRG93bmxvYWQgcm9hZHdheXMgd2l0aGluIGEgMzAwIGZvb3QgcmFkaXVzLlxuICAgICAgICB0b2xlcmFuY2U6IDAuMDAwMDEgLy8gSG93IG11Y2ggdG9sZXJhbmNlIHRvIHNpbXBsaWZ5IGNvb3JkaW5hdGVzLiBDYW4gYmUgYSBmdW5jdGlvbiB3aXRoIG1hcCBhcmd1bWVudC5cbiAgICB9LFxuICAgIG1vdmluZzoge1xuICAgICAgICBlbmFibGU6IGZhbHNlLCAvLyBFbmFibGVzIG1vdmluZyBmZWF0dXJlXG4gICAgICAgIGRpc3RhbmNlOiAoMyAvIDUyODApICogMS42MDkzNDQgLy8gMyBmZWV0IHRvIG1pbGVzIHRvIGtpbG9tZXRlci4gVGhlIGRpc3RhbmNlIGluIHdoaWNoIHRvIG1vdmUgdGhlIGZlYXR1cmVcbiAgICB9LFxuICAgIHBhaW50aW5nOiB7XG4gICAgICAgIGVuYWJsZTogZmFsc2UsIC8vIEVuYWJsZXMgcGFpbnRpbmcgZHJhd2luZyBmb3IgbGluZXN0cmluZ3MgYW5kIHBvbHlnb25zXG4gICAgICAgIHRvbGVyYW5jZTogMC4wMDAwMDUgLy8gSG93IG11Y2ggdG9sZXJhbmNlIHRvIHNpbXBsaWZ5IGNvb3JkaW5hdGVzLiBDYW4gYmUgYSBmdW5jdGlvbiB3aXRoIG1hcCBhcmd1bWVudC5cbiAgICB9LFxuICAgIGdhbWVwYWQ6IHtcbiAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICBkZWJ1ZzogZmFsc2UsXG4gICAgICAgIGNyb3NzaGFpcnM6IHRydWUsXG4gICAgICAgIGpveXN0aWNrOiB7XG4gICAgICAgICAgICBtaW46IDAuMixcbiAgICAgICAgICAgIG1heDogMC43XG4gICAgICAgIH0sXG4gICAgICAgIGNhbWVyYToge1xuICAgICAgICAgICAgZnJlZTogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICBwYW46IHtcbiAgICAgICAgICAgIHNwZWVkOiAwLjAwMSxcbiAgICAgICAgICAgIG1pbjogMC4wMDEsXG4gICAgICAgICAgICBtYXg6IDAuMDVcbiAgICAgICAgfSxcbiAgICAgICAgYmVhcmluZzoge1xuICAgICAgICAgICAgc3BlZWQ6IDAuOFxuICAgICAgICB9LFxuICAgICAgICBwaXRjaDoge1xuICAgICAgICAgICAgc3BlZWQ6IDEuNSxcbiAgICAgICAgICAgIG1heDogNzBcbiAgICAgICAgfSxcbiAgICAgICAgem9vbToge1xuICAgICAgICAgICAgc3BlZWQ6IDAuMDA4XG4gICAgICAgIH0sXG4gICAgICAgIHJ1bWJsZToge1xuICAgICAgICAgICAgc3RhcnREZWxheTogMCxcbiAgICAgICAgICAgIGR1cmF0aW9uOiAyMDAsXG4gICAgICAgICAgICB3ZWFrTWFnbml0dWRlOiAxLjAsXG4gICAgICAgICAgICBzdHJvbmdNYWduaXR1ZGU6IDEuMFxuICAgICAgICB9LFxuICAgICAgICBtYXBwaW5nOiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgU2VsZWN0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5PcHRpb25zLmdhbWVwYWQubWFwcGluZ1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgZGlmZmVyZW50IHR5cGVzIG9mIGV2ZW50czogcHJlc3MsIGhvbGQsIGFuZCByZWxlYXNlLiBcbiAgICAgICAgICAgICAqIE9uIHJlbGVhc2UsIGl0IHRyaWdnZXJzIHRoZSBjbGljayBhY3Rpb24gZm9yIHRoZSAnY2xlYXInIGJ1dHRvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAoZS5nLiwgJ3ByZXNzJywgJ2hvbGQnLCAncmVsZWFzZScpLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lmdlb2ZsbyAtIFRoZSBjb250ZXh0IG9iamVjdCB0aGF0IGNvbnRhaW5zIG1ldGhvZHMgcmVsYXRlZCB0byB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQGF1dGhvciBTb2x1dGVncmF0ZVxuICAgICAgICAgICAgICogQGNvcHlyaWdodCAyMDI1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdTZWxlY3QnOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3ByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdob2xkJykge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdyZWxlYXNlJykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5nZW9mbG8uZ2V0QnV0dG9ucygnY2xlYXInKS5idXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqIEBuYW1lIFN0YXJ0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5PcHRpb25zLmdhbWVwYWQubWFwcGluZ1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgZGlmZmVyZW50IHR5cGVzIG9mIGV2ZW50cyBzdWNoIGFzIHByZXNzLCBob2xkLCBhbmQgcmVsZWFzZSBmb3IgZ2FtZXBhZCBpbnRlcmFjdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgYWJvdXQgdGhlIGlucHV0IGV2ZW50LlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKHByZXNzLCBob2xkLCByZWxlYXNlKS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nYW1lcGFkIC0gVGhlIGdhbWVwYWQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzIC0gSW5kaWNhdGVzIGlmIHRoZSBnYW1lcGFkIGhhcyBqb3lzdGlja3MuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubW9kZSAtIFRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIGFwcGxpY2F0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50Lm1vZGUuaWQgLSBUaGUgaWRlbnRpZmllciBmb3IgdGhlIGN1cnJlbnQgbW9kZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nZW9mbG8gLSBUaGUgY29udGV4dCBvYmplY3QgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBhcHBsaWNhdGlvbi5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAYXV0aG9yIFNvbHV0ZWdyYXRlXG4gICAgICAgICAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ1N0YXJ0JzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnaG9sZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVsZWFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9uID0gZXZlbnQubW9kZS5pZCA9PT0gJ3NlbGVjdCcgPyAnZWRpdCcgOiAnc2VsZWN0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lmdlb2Zsby5nZXRCdXR0b25zKGJ1dHRvbikuYnV0dG9uLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqIEBuYW1lIFBvd2VyXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5PcHRpb25zLmdhbWVwYWQubWFwcGluZ1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgZGlmZmVyZW50IHR5cGVzIG9mIHBvd2VyIGV2ZW50cyBzdWNoIGFzIHByZXNzLCBob2xkLCBhbmQgcmVsZWFzZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHBvd2VyIGV2ZW50LlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIHdoaWNoIGNhbiBiZSAncHJlc3MnLCAnaG9sZCcsIG9yICdyZWxlYXNlJy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nZW9mbG8gLSBUaGUgY29udGV4dCBvYmplY3QgdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gVUkgZWxlbWVudHMuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQGF1dGhvciBTb2x1dGVncmF0ZVxuICAgICAgICAgICAgICogQGNvcHlyaWdodCAyMDI1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdQb3dlcic6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAncHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2hvbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50Lmdlb2Zsby5nZXRCdXR0b25zKCdzYXZlJykuYnV0dG9uLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAbmFtZSBNZW51XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5PcHRpb25zLmdhbWVwYWQubWFwcGluZ1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgZGlmZmVyZW50IHR5cGVzIG9mIG1lbnUgZXZlbnRzIHN1Y2ggYXMgcHJlc3MsIGhvbGQsIGFuZCByZWxlYXNlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgdGhhdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCwgd2hpY2ggY2FuIGJlICdwcmVzcycsICdob2xkJywgb3IgJ3JlbGVhc2UnLlxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBhdXRob3IgU29sdXRlZ3JhdGVcbiAgICAgICAgICAgICAqIEBjb3B5cmlnaHQgMjAyNVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnTWVudSc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAncHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2hvbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgTWlzY1xuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIGRpZmZlcmVudCB0eXBlcyBvZiBldmVudHMgcmVsYXRlZCB0byBnYW1lcGFkIGludGVyYWN0aW9ucywgaW5jbHVkaW5nIHByZXNzLCBob2xkLCBhbmQgcmVsZWFzZSBhY3Rpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBnYW1lcGFkIGludGVyYWN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQsIHdoaWNoIGNhbiBiZSAncHJlc3MnLCAnaG9sZCcsIG9yICdyZWxlYXNlJy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nYW1lcGFkIC0gVGhlIGdhbWVwYWQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzIC0gSW5kaWNhdGVzIGlmIHRoZSBnYW1lcGFkIGhhcyBqb3lzdGljayBjb250cm9scy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nZW9mbG8gLSBUaGUgY29udGV4dCBvYmplY3QgcHJvdmlkaW5nIGFjY2VzcyB0byB0aGUgbWFwIGFuZCBidXR0b25zLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lmdlb2Zsby5tYXAgLSBUaGUgbWFwIG9iamVjdCB0aGF0IGNvbnRhaW5zIG1ldGhvZHMgZm9yIGdldHRpbmcgdGhlIGNlbnRlciBhbmQgem9vbSBsZXZlbC5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAYXV0aG9yIFNvbHV0ZWdyYXRlXG4gICAgICAgICAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ01pc2MnOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3ByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdob2xkJykge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdyZWxlYXNlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZ2FtZXBhZC5oYXNKb3lzdGlja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lmdlb2Zsby5nZXRCdXR0b25zKCd6b29tJykuYnV0dG9uLmNsaWNrKCk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVhZHkgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN0eC5tYXBNb3ZpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWFkeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdhbWVwYWQubWFwLmNlbnRlciA9IGV2ZW50Lmdlb2Zsby5tYXAuZ2V0Q2VudGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdhbWVwYWQubWFwLnpvb20gPSBldmVudC5nZW9mbG8ubWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgQVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIGRpZmZlcmVudCB0eXBlcyBvZiBldmVudHMgc3VjaCBhcyBwcmVzcywgaG9sZCwgYW5kIHJlbGVhc2UgZm9yIGdhbWVwYWQgaW50ZXJhY3Rpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBnYW1lcGFkIGludGVyYWN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKGUuZy4sICdwcmVzcycsICdob2xkJywgJ3JlbGVhc2UnKS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nYW1lcGFkIC0gVGhlIGdhbWVwYWQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzIC0gSW5kaWNhdGVzIGlmIHRoZSBnYW1lcGFkIGhhcyBqb3lzdGlja3MuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZC5wcmVzc2VkIC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcHJlc3NlZCBidXR0b25zIG9uIHRoZSBnYW1lcGFkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lmdlb2ZsbyAtIFRoZSBjb250ZXh0IG9iamVjdCBmb3IgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBKb3lMZWZ0Q2xpY2sgZnVuY3Rpb24gaWYgY2VydGFpbiBjb25kaXRpb25zIGFyZSBtZXQ7IG90aGVyd2lzZSwgaXQgcGVyZm9ybXMgYSBidXR0b24gY2xpY2sgYWN0aW9uIG9yXG4gICAgICAgICAgICAgKiByZXR1cm5zIHVuZGVmaW5lZC5cbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQGF1dGhvciBTb2x1dGVncmF0ZVxuICAgICAgICAgICAgICogQGNvcHlyaWdodCAyMDI1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdBJzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnaG9sZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVsZWFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5nYW1lcGFkLmhhc0pveXN0aWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5nYW1lcGFkLnByZXNzZWRbJ0J1bXBMZWZ0J10gJiYgIWV2ZW50LmdhbWVwYWQucHJlc3NlZFsnQnVtcFJpZ2h0J10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1snSm95TGVmdENsaWNrJ10oZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2VvZmxvLmdldEJ1dHRvbnMoJ3JvdXRpbmcnKS5idXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgQlxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIGRpZmZlcmVudCB0eXBlcyBvZiBldmVudHMgcmVsYXRlZCB0byBhIGdhbWVwYWQgYnV0dG9uIHByZXNzLCBob2xkLCBhbmQgcmVsZWFzZSBhY3Rpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBidXR0b24gYWN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKGUuZy4sICdwcmVzcycsICdob2xkJywgJ3JlbGVhc2UnKS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nYW1lcGFkIC0gVGhlIGdhbWVwYWQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzIC0gSW5kaWNhdGVzIGlmIHRoZSBnYW1lcGFkIGhhcyBqb3lzdGlja3MuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZC5wcmVzc2VkIC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcHJlc3NlZCBidXR0b25zIG9uIHRoZSBnYW1lcGFkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lmdlb2ZsbyAtIFRoZSBjb250ZXh0IG9iamVjdCBmb3IgdGhlIGV2ZW50LlxuICAgICAgICAgICAgICogQHJldHVybnMge0Z1bmN0aW9ufHVuZGVmaW5lZH0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBKb3lSaWdodENsaWNrIGZ1bmN0aW9uIGlmIGNlcnRhaW4gY29uZGl0aW9ucyBhcmUgbWV0LCBvdGhlcndpc2UgcmV0dXJucyB1bmRlZmluZWQuXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBhdXRob3IgU29sdXRlZ3JhdGVcbiAgICAgICAgICAgICAqIEBjb3B5cmlnaHQgMjAyNVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnQic6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAncHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2hvbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQuZ2FtZXBhZC5oYXNKb3lzdGlja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQuZ2FtZXBhZC5wcmVzc2VkWydCdW1wTGVmdCddICYmICFldmVudC5nYW1lcGFkLnByZXNzZWRbJ0J1bXBSaWdodCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbJ0pveVJpZ2h0Q2xpY2snXShldmVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nZW9mbG8uZ2V0QnV0dG9ucygncGFpbnRpbmcnKS5idXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgWVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIGdhbWVwYWQgZXZlbnRzIGZvciBwcmVzc2luZywgaG9sZGluZywgYW5kIHJlbGVhc2luZyBidXR0b25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZ2FtZXBhZCBhY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAoZS5nLiwgJ3ByZXNzJywgJ2hvbGQnLCAncmVsZWFzZScpLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmdhbWVwYWQgLSBUaGUgZ2FtZXBhZCBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc3RhdGUgb2YgdGhlIGdhbWVwYWQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzIC0gSW5kaWNhdGVzIGlmIHRoZSBnYW1lcGFkIGhhcyBqb3lzdGlja3MuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZC5wcmVzc2VkIC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcHJlc3NlZCBidXR0b25zIG9uIHRoZSBnYW1lcGFkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnQuZ2FtZXBhZC5zZXRTcGVlZCAtIEEgZnVuY3Rpb24gdG8gc2V0IHRoZSBzcGVlZCBvZiB0aGUgZ2FtZXBhZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nZW9mbG8gLSBUaGUgY29udGV4dCBvYmplY3QgdXNlZCB0byBpbnRlcmFjdCB3aXRoIHRoZSBnYW1lcGFkLlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAYXV0aG9yIFNvbHV0ZWdyYXRlXG4gICAgICAgICAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ1knOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3ByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGV2ZW50LmdhbWVwYWQucHJlc3NlZFsnQnVtcExlZnQnXSB8fCBldmVudC5nYW1lcGFkLnByZXNzZWRbJ0J1bXBSaWdodCddKSkgZXZlbnQuZ2FtZXBhZC5zZXRTcGVlZChldmVudC52YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnaG9sZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVsZWFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nZW9mbG8uZ2V0QnV0dG9ucygnc25hcHBpbmcnKS5idXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgWFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIGdhbWVwYWQgZXZlbnRzIGZvciBwcmVzcywgaG9sZCwgYW5kIHJlbGVhc2UgYWN0aW9ucy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgZ2FtZXBhZCBhY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAoZS5nLiwgJ3ByZXNzJywgJ2hvbGQnLCAncmVsZWFzZScpLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmdhbWVwYWQgLSBUaGUgZ2FtZXBhZCBvYmplY3QgdGhhdCBjb250YWlucyB0aGUgc3RhdGUgb2YgdGhlIGdhbWVwYWQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzIC0gSW5kaWNhdGVzIGlmIHRoZSBnYW1lcGFkIGhhcyBqb3lzdGlja3MuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZC5wcmVzc2VkIC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYnV0dG9ucyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGV2ZW50LmdhbWVwYWQuc2V0U3BlZWQgLSBBIG1ldGhvZCB0byBzZXQgdGhlIHNwZWVkIG9mIHRoZSBnYW1lcGFkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lmdlb2ZsbyAtIFRoZSBjb250ZXh0IG9iamVjdCB0aGF0IHByb3ZpZGVzIGFjY2VzcyB0byB0aGUgZ2FtZXBhZCdzIGJ1dHRvbnMuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQGF1dGhvciBTb2x1dGVncmF0ZVxuICAgICAgICAgICAgICogQGNvcHlyaWdodCAyMDI1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdYJzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5nYW1lcGFkLmhhc0pveXN0aWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKChldmVudC5nYW1lcGFkLnByZXNzZWRbJ0J1bXBMZWZ0J10gfHwgZXZlbnQuZ2FtZXBhZC5wcmVzc2VkWydCdW1wUmlnaHQnXSkpIGV2ZW50LmdhbWVwYWQuc2V0U3BlZWQoZXZlbnQudmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnaG9sZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVsZWFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nZW9mbG8uZ2V0QnV0dG9ucygncGlubmluZycpLmJ1dHRvbi5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAbmFtZSBKb3lMZWZ0TW92ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBqb3lzdGljayBsZWZ0IG1vdmVtZW50IGV2ZW50cywgaW5jbHVkaW5nIHByZXNzLCBob2xkLCBhbmQgcmVsZWFzZSBhY3Rpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBqb3lzdGljayBhY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAocHJlc3MsIGhvbGQsIG9yIHJlbGVhc2UpLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmdhbWVwYWQgLSBUaGUgZ2FtZXBhZCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXZlbnQudmFsdWUgLSBUaGUgdmFsdWUgaW5kaWNhdGluZyB0aGUgZGlyZWN0aW9uIG9yIHN0YXRlIG9mIHRoZSBqb3lzdGljay5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAYXV0aG9yIFNvbHV0ZWdyYXRlXG4gICAgICAgICAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ0pveUxlZnRNb3ZlJzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnaG9sZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2FtZXBhZC5zZXRDZW50ZXIoZXZlbnQudmFsdWUsIGV2ZW50LmdhbWVwYWQub3B0aW9ucy5jYW1lcmEuZnJlZSkgLy8gUGFuIG1hcFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmdhbWVwYWQuc2V0Q2VudGVyKGZhbHNlLCBldmVudC5nYW1lcGFkLm9wdGlvbnMuY2FtZXJhLmZyZWUpIC8vIFJlc2V0IG1hcCBjZW50ZXJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqIEBuYW1lIEpveVJpZ2h0TW92ZVxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBtb3ZlbWVudCBvZiB0aGUgZ2FtZXBhZCBiYXNlZCBvbiB0aGUgZXZlbnQgdHlwZSBhbmQgbmFtZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgZGV0YWlscyBhYm91dCB0aGUgaW5wdXQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAoZS5nLiwgJ3ByZXNzJywgJ2hvbGQnLCAncmVsZWFzZScpLlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50Lm5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgaW5wdXQgZXZlbnQgKGUuZy4sICdVcCcsICdEb3duJywgJ0xlZnQnLCAnUmlnaHQnKS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC52YWx1ZSAtIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGlucHV0IGV2ZW50LlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmdhbWVwYWQgLSBUaGUgZ2FtZXBhZCBvYmplY3QgdGhhdCBoYW5kbGVzIG1vdmVtZW50LlxuICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnQuZ2FtZXBhZC5zZXRQaXRjaCAtIEZ1bmN0aW9uIHRvIHNldCB0aGUgcGl0Y2ggb2YgdGhlIG1hcC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGV2ZW50LmdhbWVwYWQuc2V0QmVhcmluZyAtIEZ1bmN0aW9uIHRvIHNldCB0aGUgYmVhcmluZyBvZiB0aGUgbWFwLlxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBhdXRob3IgU29sdXRlZ3JhdGVcbiAgICAgICAgICAgICAqIEBjb3B5cmlnaHQgMjAyNVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnSm95UmlnaHRNb3ZlJzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnaG9sZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50Lm5hbWUuaW5jbHVkZXMoJ1VwJykgfHwgZXZlbnQubmFtZS5pbmNsdWRlcygnRG93bicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nYW1lcGFkLnNldFBpdGNoKGV2ZW50LnZhbHVlLCBldmVudC5uYW1lLmluY2x1ZGVzKCdVcCcpKTsgLy8gUGl0Y2ggbWFwXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQubmFtZS5pbmNsdWRlcygnTGVmdCcpIHx8IGV2ZW50Lm5hbWUuaW5jbHVkZXMoJ1JpZ2h0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdhbWVwYWQuc2V0QmVhcmluZyhldmVudC52YWx1ZSwgZXZlbnQubmFtZS5pbmNsdWRlcygnTGVmdCcpKTsgLy8gUm90YXRlIG1hcFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVsZWFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAbmFtZSBKb3lMZWZ0Q2xpY2tcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLk9wdGlvbnMuZ2FtZXBhZC5tYXBwaW5nXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgbGVmdCBjbGljayBldmVudHMgZm9yIGRyYXdpbmcgYWN0aW9ucywgaW5jbHVkaW5nIHByZXNzLCBob2xkLCBhbmQgcmVsZWFzZSBhY3Rpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBjbGljayBhY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCwgd2hpY2ggY2FuIGJlICdwcmVzcycsICdob2xkJywgb3IgJ3JlbGVhc2UnLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGUgLSBUaGUgbW9kZSBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC5tb2RlLmlkIC0gVGhlIGlkZW50aWZpZXIgZm9yIHRoZSBtb2RlLCB3aGljaCBkZXRlcm1pbmVzIHRoZSBhY3Rpb24gdGFrZW4gb24gcmVsZWFzZS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAYXV0aG9yIFNvbHV0ZWdyYXRlXG4gICAgICAgICAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ0pveUxlZnRDbGljayc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAncHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2hvbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5tb2RlLmlkID09PSAnZHJhdycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm1vZGUuZGVsZXRlVmVydGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICAgICAqIEBuYW1lIEpveVJpZ2h0Q2xpY2tcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLk9wdGlvbnMuZ2FtZXBhZC5tYXBwaW5nXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyByaWdodC1jbGljayBldmVudHMgZm9yIGRyYXdpbmcgbW9kZXMsIHByb2Nlc3NpbmcgZGlmZmVyZW50IGV2ZW50IHR5cGVzIHN1Y2ggYXMgcHJlc3MsIGhvbGQsIGFuZCByZWxlYXNlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSByaWdodC1jbGljayBhY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAoZS5nLiwgJ3ByZXNzJywgJ2hvbGQnLCAncmVsZWFzZScpLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lm1vZGUgLSBUaGUgY3VycmVudCBtb2RlIG9mIHRoZSBhcHBsaWNhdGlvbiwgd2hpY2ggaW5jbHVkZXMgbWV0aG9kcyBmb3IgaGFuZGxpbmcgZXZlbnRzLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmxuZ0xhdCAtIFRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIG9mIHRoZSBjbGljayBsb2NhdGlvbi5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIHRoZSBldmVudCBkb2VzIG5vdCBoYXZlIGEgdmFsaWQgbG5nTGF0IG9yIGlmIHRoZSBldmVudCB0eXBlIGlzIG5vdCBoYW5kbGVkLlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAYXV0aG9yIFNvbHV0ZWdyYXRlXG4gICAgICAgICAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ0pveVJpZ2h0Q2xpY2snOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3ByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQubW9kZS5pZCA9PT0gJ2RyYXcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmxuZ0xhdCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50Lm1vZGUuaGFuZGxlRG93bihldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdob2xkJykge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdyZWxlYXNlJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmxuZ0xhdCkgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQubW9kZS5pZCA9PT0gJ2RyYXcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5tb2RlLmhhbmRsZVVwKGV2ZW50KTsgXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5tb2RlLmhhbmRsZUNsaWNrKGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50Lm1vZGUuaGFuZGxlQ2xpY2soZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAbmFtZSBCdW1wTGVmdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBidW1wIGxlZnQgYWN0aW9uIGJhc2VkIG9uIHRoZSBldmVudCB0eXBlIGFuZCBnYW1lcGFkIHN0YXRlLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgYWN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKGUuZy4sICdwcmVzcycsICdob2xkJywgJ3JlbGVhc2UnKS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nYW1lcGFkIC0gVGhlIGdhbWVwYWQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzIC0gSW5kaWNhdGVzIGlmIHRoZSBnYW1lcGFkIGhhcyBqb3lzdGlja3MuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZC5wcmVzc2VkIC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYnV0dG9ucyBwcmVzc2VkIG9uIHRoZSBnYW1lcGFkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gZXZlbnQuZ2FtZXBhZC5zZXRTcGVlZCAtIEEgZnVuY3Rpb24gdG8gc2V0IHRoZSBzcGVlZCBvZiB0aGUgZ2FtZXBhZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC52YWx1ZSAtIFRoZSB2YWx1ZSB0byBiZSB1c2VkIGZvciBzZXR0aW5nIHRoZSBzcGVlZC5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gUmV0dXJucyBmYWxzZSBpZiB0aGUgcmlnaHQgYnVtcCBpcyBwcmVzc2VkIHdpdGhvdXQgam95c3RpY2tzLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHNldFNwZWVkLlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAYXV0aG9yIFNvbHV0ZWdyYXRlXG4gICAgICAgICAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ0J1bXBMZWZ0JzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5nYW1lcGFkLmhhc0pveXN0aWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmdhbWVwYWQucHJlc3NlZFsnQnVtcFJpZ2h0J10pIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmdhbWVwYWQuc2V0U3BlZWQoZXZlbnQudmFsdWUsIHRydWUpOyAvLyBQYW4gc3BlZWQgZG93blxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnaG9sZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5nYW1lcGFkLmhhc0pveXN0aWNrcykge1xuICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVsZWFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAbmFtZSBCdW1wUmlnaHRcbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLk9wdGlvbnMuZ2FtZXBhZC5tYXBwaW5nXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgYnVtcCByaWdodCBhY3Rpb24gYmFzZWQgb24gdGhlIGV2ZW50IHR5cGUgYW5kIGdhbWVwYWQgc3RhdGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBhY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAoZS5nLiwgJ3ByZXNzJywgJ2hvbGQnLCAncmVsZWFzZScpLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmdhbWVwYWQgLSBUaGUgZ2FtZXBhZCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXZlbnQuZ2FtZXBhZC5oYXNKb3lzdGlja3MgLSBJbmRpY2F0ZXMgaWYgdGhlIGdhbWVwYWQgaGFzIGpveXN0aWNrcy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nYW1lcGFkLnByZXNzZWQgLSBUaGUgY3VycmVudCBwcmVzc2VkIGJ1dHRvbnMgb24gdGhlIGdhbWVwYWQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBldmVudC5nYW1lcGFkLnNldFNwZWVkIC0gRnVuY3Rpb24gdG8gc2V0IHRoZSBzcGVlZCBvZiB0aGUgZ2FtZXBhZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC52YWx1ZSAtIFRoZSB2YWx1ZSB0byBzZXQgdGhlIHNwZWVkIHRvLlxuICAgICAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgdGhlIGxlZnQgYnVtcCBpcyBwcmVzc2VkIGFuZCBubyBqb3lzdGlja3MgYXJlIHByZXNlbnQsIG90aGVyd2lzZSByZXR1cm5zIHRoZSByZXN1bHQgb2Ygc2V0dGluZyB0aGUgc3BlZWQuXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBhdXRob3IgU29sdXRlZ3JhdGVcbiAgICAgICAgICAgICAqIEBjb3B5cmlnaHQgMjAyNVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnQnVtcFJpZ2h0JzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5nYW1lcGFkLmhhc0pveXN0aWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmdhbWVwYWQucHJlc3NlZFsnQnVtcExlZnQnXSkgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXZlbnQuZ2FtZXBhZC5zZXRTcGVlZChldmVudC52YWx1ZSwgZmFsc2UpOyAvLyBQYW4gc3BlZWQgZG93blxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnaG9sZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVsZWFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAbmFtZSBUcmlnTGVmdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIGRpZmZlcmVudCB0eXBlcyBvZiBldmVudHMgcmVsYXRlZCB0byBnYW1lcGFkIGlucHV0LCBzcGVjaWZpY2FsbHkgcHJlc3MsIGhvbGQsIGFuZCByZWxlYXNlIGFjdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBnYW1lcGFkIGlucHV0LlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiBldmVudCwgd2hpY2ggY2FuIGJlICdwcmVzcycsICdob2xkJywgb3IgJ3JlbGVhc2UnLlxuICAgICAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGV2ZW50LnZhbHVlIC0gVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQsIHVzZWQgd2hlbiB0aGUgZXZlbnQgdHlwZSBpcyAnaG9sZCcuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZCAtIFRoZSBnYW1lcGFkIG9iamVjdCB0aGF0IHByb3ZpZGVzIG1ldGhvZHMgZm9yIGludGVyYWN0aW9uLlxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBhdXRob3IgU29sdXRlZ3JhdGVcbiAgICAgICAgICAgICAqIEBjb3B5cmlnaHQgMjAyNVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnVHJpZ0xlZnQnOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3ByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdob2xkJykge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5nYW1lcGFkLnNldFpvb20oZXZlbnQudmFsdWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgVHJpZ1JpZ2h0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5PcHRpb25zLmdhbWVwYWQubWFwcGluZ1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgZGlmZmVyZW50IHR5cGVzIG9mIGV2ZW50cyByZWxhdGVkIHRvIGdhbWVwYWQgaW50ZXJhY3Rpb25zLCBpbmNsdWRpbmcgcHJlc3MsIGhvbGQsIGFuZCByZWxlYXNlIGFjdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgYWJvdXQgdGhlIGludGVyYWN0aW9uLlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKGUuZy4sICdwcmVzcycsICdob2xkJywgJ3JlbGVhc2UnKS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBldmVudC52YWx1ZSAtIFRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LCB1c2VkIHdoZW4gdGhlIGV2ZW50IHR5cGUgaXMgJ2hvbGQnLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmdhbWVwYWQgLSBUaGUgZ2FtZXBhZCBvYmplY3QgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciBpbnRlcmFjdGlvbi5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt2b2lkfSBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHJldHVybiBhIHZhbHVlLlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAYXV0aG9yIFNvbHV0ZWdyYXRlXG4gICAgICAgICAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgJ1RyaWdSaWdodCc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAncHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2hvbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmdhbWVwYWQuc2V0Wm9vbShldmVudC52YWx1ZSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgRHBhZFVwXG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5PcHRpb25zLmdhbWVwYWQubWFwcGluZ1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIEQtcGFkIHVwIGlucHV0IGV2ZW50cyBmb3IgZ2FtZXBhZCBjb250cm9scywgbWFuYWdpbmcgZGlmZmVyZW50IGFjdGlvbnMgYmFzZWQgb24gdGhlIGV2ZW50IHR5cGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGRldGFpbHMgYWJvdXQgdGhlIGlucHV0IGV2ZW50LlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50LnR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgZXZlbnQgKGUuZy4sICdwcmVzcycsICdob2xkJywgJ3JlbGVhc2UnKS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nYW1lcGFkIC0gVGhlIGdhbWVwYWQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzIC0gSW5kaWNhdGVzIGlmIHRoZSBnYW1lcGFkIGhhcyBqb3lzdGlja3MuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZC5wcmVzc2VkIC0gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgYnV0dG9ucyBjdXJyZW50bHkgcHJlc3NlZCBvbiB0aGUgZ2FtZXBhZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGV2ZW50LmdhbWVwYWQuc2V0UGl0Y2ggLSBGdW5jdGlvbiB0byBzZXQgdGhlIHBpdGNoIGJhc2VkIG9uIHRoZSBldmVudCB2YWx1ZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGV2ZW50LmdhbWVwYWQuc2V0Q2VudGVyIC0gRnVuY3Rpb24gdG8gc2V0IHRoZSBjZW50ZXIgYmFzZWQgb24gdGhlIGV2ZW50IHZhbHVlIGFuZCBjYW1lcmEgb3B0aW9ucy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nZW9mbG8gLSBUaGUgY29udGV4dCBvYmplY3QgZm9yIGFjY2Vzc2luZyBnYW1lcGFkIGJ1dHRvbnMuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2VvZmxvLmdldEJ1dHRvbnMgLSBGdW5jdGlvbiB0byByZXRyaWV2ZSBidXR0b24gc3RhdGVzLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LnZhbHVlIC0gVGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQGF1dGhvciBTb2x1dGVncmF0ZVxuICAgICAgICAgICAgICogQGNvcHlyaWdodCAyMDI1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdEcGFkVXAnOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ3ByZXNzJykge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09ICdob2xkJykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZ2FtZXBhZC5wcmVzc2VkWydCdW1wTGVmdCddICYmIGV2ZW50LmdhbWVwYWQucHJlc3NlZFsnQnVtcFJpZ2h0J10pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nYW1lcGFkLnNldFBpdGNoKGV2ZW50LnZhbHVlLCB0cnVlKTsgLy8gUGl0Y2ggbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdhbWVwYWQuc2V0Q2VudGVyKGV2ZW50LnZhbHVlLCBldmVudC5nYW1lcGFkLm9wdGlvbnMuY2FtZXJhLmZyZWUpIC8vIFBhbiBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5nYW1lcGFkLmhhc0pveXN0aWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2VvZmxvLmdldEJ1dHRvbnMoJ1BvbHlnb24nKS5idXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgRHBhZERvd25cbiAgICAgICAgICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLk9wdGlvbnMuZ2FtZXBhZC5tYXBwaW5nXG4gICAgICAgICAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgRC1wYWQgZG93biBpbnB1dCBldmVudCBmb3IgZ2FtZXBhZCBjb250cm9scywgbWFuYWdpbmcgZGlmZmVyZW50IGFjdGlvbnMgYmFzZWQgb24gdGhlIGV2ZW50IHR5cGUuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbnB1dCBldmVudC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50IChlLmcuLCAncHJlc3MnLCAnaG9sZCcsICdyZWxlYXNlJykuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZCAtIFRoZSBnYW1lcGFkIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzdGF0ZSBvZiB0aGUgZ2FtZXBhZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXZlbnQuZ2FtZXBhZC5oYXNKb3lzdGlja3MgLSBJbmRpY2F0ZXMgaWYgdGhlIGdhbWVwYWQgaGFzIGpveXN0aWNrIGNvbnRyb2xzLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmdhbWVwYWQucHJlc3NlZCAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJ1dHRvbnMgY3VycmVudGx5IHByZXNzZWQgb24gdGhlIGdhbWVwYWQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5nYW1lcGFkLnNldFBpdGNoIC0gRnVuY3Rpb24gdG8gc2V0IHRoZSBwaXRjaCBiYXNlZCBvbiB0aGUgZXZlbnQgdmFsdWUuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5nYW1lcGFkLnNldENlbnRlciAtIEZ1bmN0aW9uIHRvIHNldCB0aGUgY2VudGVyIGJhc2VkIG9uIHRoZSBldmVudCB2YWx1ZSBhbmQgY2FtZXJhIG9wdGlvbnMuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2VvZmxvIC0gVGhlIGNvbnRleHQgb2JqZWN0IGZvciB0aGUgZ2FtZXBhZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nZW9mbG8uZ2V0QnV0dG9ucyAtIEZ1bmN0aW9uIHRvIHJldHJpZXZlIGJ1dHRvbiBzdGF0ZXMuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2VvZmxvLmdldEJ1dHRvbnMoJ0NpcmNsZScpIC0gVGhlIGJ1dHRvbiBvYmplY3QgZm9yIHRoZSAnQ2lyY2xlJyBidXR0b24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5nZW9mbG8uZ2V0QnV0dG9ucygnQ2lyY2xlJykuYnV0dG9uLmNsaWNrIC0gRnVuY3Rpb24gdG8gc2ltdWxhdGUgYSBidXR0b24gY2xpY2suXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQGF1dGhvciBTb2x1dGVncmF0ZVxuICAgICAgICAgICAgICogQGNvcHlyaWdodCAyMDI1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdEcGFkRG93bic6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAncHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2hvbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQuZ2FtZXBhZC5oYXNKb3lzdGlja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5nYW1lcGFkLnByZXNzZWRbJ0J1bXBMZWZ0J10gJiYgZXZlbnQuZ2FtZXBhZC5wcmVzc2VkWydCdW1wUmlnaHQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdhbWVwYWQuc2V0UGl0Y2goZXZlbnQudmFsdWUsIGZhbHNlKTsgLy8gUGl0Y2ggbWFwXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdhbWVwYWQuc2V0Q2VudGVyKGV2ZW50LnZhbHVlLCBldmVudC5nYW1lcGFkLm9wdGlvbnMuY2FtZXJhLmZyZWUpIC8vIFBhbiBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ3JlbGVhc2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5nYW1lcGFkLmhhc0pveXN0aWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2VvZmxvLmdldEJ1dHRvbnMoJ0NpcmNsZScpLmJ1dHRvbi5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAgICAgKiBAbmFtZSBEcGFkTGVmdFxuICAgICAgICAgICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uT3B0aW9ucy5nYW1lcGFkLm1hcHBpbmdcbiAgICAgICAgICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBELXBhZCBsZWZ0IGlucHV0IGV2ZW50cyBmb3IgYSBnYW1lcGFkLCBwcm9jZXNzaW5nIHByZXNzLCBob2xkLCBhbmQgcmVsZWFzZSBhY3Rpb25zLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBpbnB1dCBhY3Rpb24uXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQudHlwZSAtIFRoZSB0eXBlIG9mIHRoZSBldmVudCAocHJlc3MsIGhvbGQsIG9yIHJlbGVhc2UpLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmdhbWVwYWQgLSBUaGUgZ2FtZXBhZCBvYmplY3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXZlbnQuZ2FtZXBhZC5oYXNKb3lzdGlja3MgLSBJbmRpY2F0ZXMgaWYgdGhlIGdhbWVwYWQgaGFzIGpveXN0aWNrcy5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nYW1lcGFkLnByZXNzZWQgLSBBbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBidXR0b25zIGN1cnJlbnRseSBwcmVzc2VkIG9uIHRoZSBnYW1lcGFkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXZlbnQuZ2FtZXBhZC5zZXRCZWFyaW5nIC0gRnVuY3Rpb24gdG8gc2V0IHRoZSBiZWFyaW5nIG9mIHRoZSBtYXAuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5nYW1lcGFkLnNldENlbnRlciAtIEZ1bmN0aW9uIHRvIHNldCB0aGUgY2VudGVyIG9mIHRoZSBtYXAuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZC5vcHRpb25zIC0gT3B0aW9ucyByZWxhdGVkIHRvIHRoZSBnYW1lcGFkLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50Lmdlb2ZsbyAtIFRoZSBjb250ZXh0IG9iamVjdCBmb3IgdGhlIGdhbWVwYWQuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQGF1dGhvciBTb2x1dGVncmF0ZVxuICAgICAgICAgICAgICogQGNvcHlyaWdodCAyMDI1XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICdEcGFkTGVmdCc6IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC50eXBlID09PSAncHJlc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQudHlwZSA9PT0gJ2hvbGQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZXZlbnQuZ2FtZXBhZC5oYXNKb3lzdGlja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5nYW1lcGFkLnByZXNzZWRbJ0J1bXBMZWZ0J10gJiYgZXZlbnQuZ2FtZXBhZC5wcmVzc2VkWydCdW1wUmlnaHQnXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmdhbWVwYWQuc2V0QmVhcmluZyhldmVudC52YWx1ZSwgdHJ1ZSk7IC8vIFJvdGF0ZSBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2FtZXBhZC5zZXRDZW50ZXIoZXZlbnQudmFsdWUsIGV2ZW50LmdhbWVwYWQub3B0aW9ucy5jYW1lcmEuZnJlZSkgLy8gUGFuIG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVsZWFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nZW9mbG8uZ2V0QnV0dG9ucygnUG9seWxpbmUnKS5idXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICAgICAgICogQG5hbWUgRHBhZFJpZ2h0XG4gICAgICAgICAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5PcHRpb25zLmdhbWVwYWQubWFwcGluZ1xuICAgICAgICAgICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIEQtcGFkIHJpZ2h0IGlucHV0IGV2ZW50cyBmb3IgZ2FtZXBhZCBjb250cm9scywgbWFuYWdpbmcgYWN0aW9ucyBiYXNlZCBvbiB0aGUgdHlwZSBvZiBldmVudCAocHJlc3MsIGhvbGQsIHJlbGVhc2UpLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgY29udGFpbmluZyBkZXRhaWxzIGFib3V0IHRoZSBpbnB1dCBldmVudC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudC50eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50IChwcmVzcywgaG9sZCwgcmVsZWFzZSkuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQuZ2FtZXBhZCAtIFRoZSBnYW1lcGFkIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBzdGF0ZSBvZiB0aGUgZ2FtZXBhZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZXZlbnQuZ2FtZXBhZC5oYXNKb3lzdGlja3MgLSBJbmRpY2F0ZXMgaWYgdGhlIGdhbWVwYWQgaGFzIGpveXN0aWNrIGNvbnRyb2xzLlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50LmdhbWVwYWQucHJlc3NlZCAtIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIGJ1dHRvbnMgY3VycmVudGx5IHByZXNzZWQgb24gdGhlIGdhbWVwYWQuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBldmVudC5nYW1lcGFkLnNldEJlYXJpbmcgLSBGdW5jdGlvbiB0byBzZXQgdGhlIGJlYXJpbmcgb2YgdGhlIG1hcC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGV2ZW50LmdhbWVwYWQuc2V0Q2VudGVyIC0gRnVuY3Rpb24gdG8gc2V0IHRoZSBjZW50ZXIgb2YgdGhlIG1hcC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nYW1lcGFkLm9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgZ2FtZXBhZC5cbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5nZW9mbG8gLSBUaGUgY29udGV4dCBvYmplY3QgZm9yIHRoZSBnYW1lcGFkLlxuICAgICAgICAgICAgICogQHJldHVybnMge3ZvaWR9IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgcmV0dXJuIGEgdmFsdWUuXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBhdXRob3IgU29sdXRlZ3JhdGVcbiAgICAgICAgICAgICAqIEBjb3B5cmlnaHQgMjAyNVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAnRHBhZFJpZ2h0JzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdwcmVzcycpIHtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAnaG9sZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFldmVudC5nYW1lcGFkLmhhc0pveXN0aWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmdhbWVwYWQucHJlc3NlZFsnQnVtcExlZnQnXSAmJiBldmVudC5nYW1lcGFkLnByZXNzZWRbJ0J1bXBSaWdodCddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2FtZXBhZC5zZXRCZWFyaW5nKGV2ZW50LnZhbHVlLCBmYWxzZSk7IC8vIFJvdGF0ZSBtYXBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuZ2FtZXBhZC5zZXRDZW50ZXIoZXZlbnQudmFsdWUsIGV2ZW50LmdhbWVwYWQub3B0aW9ucy5jYW1lcmEuZnJlZSkgLy8gUGFuIG1hcFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChldmVudC50eXBlID09PSAncmVsZWFzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmdhbWVwYWQuaGFzSm95c3RpY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5nZW9mbG8uZ2V0QnV0dG9ucygnUmVjdGFuZ2xlJykuYnV0dG9uLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE9wdGlvbnM7IiwiLyoqXG4gKiBAbWl4aW5cbiAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvXG4gKiBAbmFtZSBQYWludGluZ1xuICogQGRlc2NyaXB0aW9uIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBwYWludGluZyBmdW5jdGlvbmFsaXR5IGZvciB0aGUgR2VvZmxvIGFwcGxpY2F0aW9uLiBJdCBhbGxvd3MgdXNlcnMgdG8gcGFpbnQgZmVhdHVyZXMgb24gdGhlIG1hcCBieSBjcmVhdGluZyBhIGJ1ZmZlciBhcm91bmQgdGhlIGZlYXR1cmUgYW5kIHNuYXBwaW5nIHRvIG5lYXJieSBmZWF0dXJlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlIC0gVGhlIG1vZGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHR5cGUgb2YgbW9kZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIFBhaW50aW5nIG9iamVjdC5cbiAqL1xuY29uc3QgUGFpbnRpbmcgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgIGNvbnN0IGdlb2ZsbyA9IHRoaXMuZ2VvZmxvO1xuXG4gICAgdGhpcy50eXBlID0gbW9kZS50eXBlO1xuICAgIHRoaXMuZmVhdHVyZSA9IGZhbHNlO1xuICAgIHRoaXMuY3VycmVudENvb3JkcyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5QYWludGluZ1xuXHQgKiBAbmFtZSBhY3RpdmF0ZVxuXHQgKiBAZGVzY3JpcHRpb24gQWN0aXZhdGVzIHRoZSBwYWludGluZyBmdW5jdGlvbmFsaXR5IGJ5IGVuYWJsaW5nIHBhaW50aW5nIG1vZGUgYW5kIGNsZWFyaW5nIHRoZSBzb3VyY2UgZGF0YS5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBnZW9mbG8ub3B0aW9uc1sncGFpbnRpbmcnXS5lbmFibGUgPSB0cnVlO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TTkFQKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlBhaW50aW5nXG5cdCAqIEBuYW1lIGRlYWN0aXZhdGVcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZGVhY3RpdmF0ZXMgdGhlIGN1cnJlbnQgZmVhdHVyZSBieSBzZXR0aW5nIHRoZSAnZW5hYmxlZCcgcHJvcGVydHkgdG8gZmFsc2UsIGRpc2FibGluZyB0aGUgcGFpbnRpbmcgdG9vbCwgZW5hYmxpbmcgZHJhZyBwYW4gb24gdGhlIG1hcCwgYW5kIGRlbGV0aW5nIHRoZSBmZWF0dXJlLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5kZWFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLm9wdGlvbnNbJ3BhaW50aW5nJ10uZW5hYmxlID0gZmFsc2U7XG4gICAgICAgIGdlb2Zsby5tYXAuZHJhZ1Bhbi5lbmFibGUoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuZmVhdHVyZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlBhaW50aW5nIGdldEZlYXR1cmVcblx0ICogQG5hbWUgZ2V0RmVhdHVyZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiByZXRyaWV2ZXMgdGhlIGN1cnJlbnQgcGFpbnRlZCBmZWF0dXJlLlxuXHQgKiBAcmV0dXJucyB7YW55fSBUaGUgcGFpbnRlZCBmZWF0dXJlLlxuXHQgKi9cbiAgICB0aGlzLmdldEZlYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZlYXR1cmU7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5QYWludGluZ1xuXHQgKiBAbmFtZSBzZXRGZWF0dXJlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBmZWF0dXJlIGJhc2VkIG9uIHRoZSBnaXZlbiB0eXBlIGFuZCBjb29yZGluYXRlcy4gSXQgdXBkYXRlcyB0aGUgY3VycmVudENvb3JkcyBhcnJheSwgc2V0cyB0aGUgZmVhdHVyZSwgYW5kIHRyaWdnZXJzIGEgJ3BhaW50aW5nLnN0YXJ0JyBldmVudC5cblx0ICogQHBhcmFtIHtBcnJheX0gY29vcmRzIC0gVGhlIGNvb3JkaW5hdGVzIHRvIHNldCB0aGUgZmVhdHVyZSBhdC5cblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGNyZWF0ZWQgZmVhdHVyZS5cblx0ICovXG4gICAgdGhpcy5zZXRGZWF0dXJlID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICBpZiAoIXRoaXMudHlwZSB8fCAhY29vcmRzKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZ2VvZmxvLm1vdXNlSXNEb3duKSByZXR1cm4gZ2VvZmxvLmhvdEZlYXR1cmU7XG4gICAgICAgIFxuICAgICAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBzZXRGZWF0dXJlKHR5cGUsIGNvb3Jkcyk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudENvb3JkcyA9IFtdO1xuICAgICAgICAgICAgZ2VvZmxvLnN0YXJ0UG9pbnQgPSBjb29yZHM7XG4gICAgICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TTkFQKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2ZlYXR1cmVdKSk7XG4gICAgICAgICAgICBnZW9mbG8uZmlyZSgncGFpbnRpbmcuc3RhcnQnLCB7IHR5cGU6IHR5cGUsIGNvb3JkczogY29vcmRzLCBmZWF0dXJlOiBmZWF0dXJlIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jdXJyZW50Q29vcmRzLnB1c2goY29vcmRzKTtcbiAgICAgICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlBhaW50aW5nXG5cdCAqIEBuYW1lIHVwZGF0ZUZlYXR1cmVcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdXBkYXRlcyB0aGUgZmVhdHVyZSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZXMuIEl0IGhhbmRsZXMgZGlmZmVyZW50IHR5cGVzIG9mIGZlYXR1cmVzIGxpa2UgUmVjdGFuZ2xlLCBDaXJjbGUsIGFuZCBvdGhlcnMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkcyAtIFRoZSBjb29yZGluYXRlcyB0byB1cGRhdGUgdGhlIGZlYXR1cmUgd2l0aC5cblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHVwZGF0ZWQgZmVhdHVyZSBvYmplY3QuXG5cdCAqL1xuICAgIHRoaXMudXBkYXRlRmVhdHVyZSA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybiBnZW9mbG8uaG90RmVhdHVyZTtcbiAgICAgICAgaWYgKCF0aGlzLmZlYXR1cmUpIHJldHVybiB0aGlzLnNldEZlYXR1cmUoY29vcmRzKTtcblxuICAgICAgICB2YXIgZmVhdHVyZSA9IHRoaXMuZmVhdHVyZTtcbiAgICAgICAgdmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cbiAgICAgICAgdGhpcy5jdXJyZW50Q29vcmRzLnB1c2goY29vcmRzKTtcblxuICAgICAgICBpZiAodHlwZSA9PT0gJ1JlY3RhbmdsZScpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNvb3JkaW5hdGUoZmVhdHVyZSwgXCIwLjFcIiwgY29vcmRzWzBdLCBnZW9mbG8ubW91c2VJc0Rvd25bMV0pO1xuICAgICAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShmZWF0dXJlLCBcIjAuMlwiLCBjb29yZHNbMF0sIGNvb3Jkc1sxXSk7XG4gICAgICAgICAgICB1cGRhdGVDb29yZGluYXRlKGZlYXR1cmUsIFwiMC4zXCIsIGdlb2Zsby5tb3VzZUlzRG93blswXSwgY29vcmRzWzFdKTtcbiAgICAgICAgICAgIHVwZGF0ZUNvb3JkaW5hdGUoZmVhdHVyZSwgXCIwLjRcIiwgZ2VvZmxvLm1vdXNlSXNEb3duWzBdLCBnZW9mbG8ubW91c2VJc0Rvd25bMV0gKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnQ2lyY2xlJykge1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IGZlYXR1cmUucHJvcGVydGllcy5jZW50ZXI7XG4gICAgICAgICAgICBpZiAoIWNlbnRlciB8fCAhY2VudGVyLmxlbmd0aCkgcmV0dXJuIGZlYXR1cmU7XG5cbiAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlSW5LbSA9IHR1cmYuZGlzdGFuY2UodHVyZi5wb2ludChjZW50ZXIpLCB0dXJmLnBvaW50KGNvb3JkcyksIHsgdW5pdHMgOiAna2lsb21ldGVycyd9KTtcbiAgICAgICAgICAgIGNvbnN0IGNpcmNsZUZlYXR1cmUgPSB0dXJmLmNpcmNsZShjZW50ZXIsIGRpc3RhbmNlSW5LbSk7XG5cbiAgICAgICAgICAgIGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBjaXJjbGVGZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgZ2VvZmxvLlV0aWxpdGllcy5zZXRQcm9wZXJ0eShmZWF0dXJlLCAncmFkaXVzSW5LbScsIGRpc3RhbmNlSW5LbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLnB1c2goY29vcmRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNOQVApLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbdGhpcy5mZWF0dXJlXSkpO1xuICAgICAgICBnZW9mbG8uZmlyZSgncGFpbnRpbmcudXBkYXRlJywgeyB0eXBlOiB0eXBlLCBjb29yZHM6IGNvb3JkcywgZmVhdHVyZTogZmVhdHVyZSB9KTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5QYWludGluZ1xuXHQgKiBAbmFtZSBoYW5kbGVVcFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBmZWF0dXJlIGJhc2VkIG9uIHRoZSAnbW91c2UgdXAnIGV2ZW50LiBJdCByZXRyaWV2ZXMgdGhlIGN1cnJlbnQgZmVhdHVyZSwgdXBkYXRlcyB0aGUgaG90IHNvdXJjZSwgY2xvbmVzIHRoZSB1cGRhdGVkIGZlYXR1cmUsIGFuZCBzZXRzIHRoZSBsYXN0IGNsaWNrIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCB0cmlnZ2VyaW5nIHRoZSBmdW5jdGlvbi5cblx0ICogQHJldHVybnMge1Byb21pc2U8T2JqZWN0Pn0gVGhlIHVwZGF0ZWQgZmVhdHVyZSBvYmplY3QuXG5cdCAqL1xuXHRcbiAgICB0aGlzLmhhbmRsZVVwID0gYXN5bmMgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5mZWF0dXJlKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGZlYXR1cmU7XG5cbiAgICAgICAgaWYgKGdlb2Zsby5FeHBsb3JpbmcuZW5hYmxlZCkgdGhpcy5mZWF0dXJlID0gYXdhaXQgZ2VvZmxvLkV4cGxvcmluZy5nZXRNYXRjaCh0aGlzLmN1cnJlbnRDb29yZHMsIHsgc2V0OiB0cnVlLCBzdGFydDogZ2VvZmxvLnN0YXJ0UG9pbnQgfSk7XG5cbiAgICAgICAgZmVhdHVyZSA9IG1vZGUudXBkYXRlSG90U291cmNlKHRoaXMuZmVhdHVyZSk7XG4gICAgICAgIGZlYXR1cmUgPSBnZW9mbG8uVXRpbGl0aWVzLmNsb25lRGVlcChmZWF0dXJlKTtcblxuICAgICAgICBnZW9mbG8ubGFzdENsaWNrID0geyBjb29yZHM6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAxXSB9O1xuICAgICAgICB0aGlzLmN1cnJlbnRDb29yZHMgPSBbXTtcbiAgICAgICAgdGhpcy5mZWF0dXJlID0gZmVhdHVyZTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgfVxuXG5cblxuICAgIGlmIChnZW9mbG8ub3B0aW9uc1sncGFpbnRpbmcnXS5lbmFibGUpIHRoaXMuYWN0aXZhdGUoKTtcblxuXG5cbiAgICBmdW5jdGlvbiBzZXRGZWF0dXJlICh0eXBlLCBjb29yZHMpIHtcbiAgICAgICAgdmFyIGZlYXR1cmU7XG5cbiAgICAgICAgaWYgKHR5cGUgPT09ICdSZWN0YW5nbGUnKSB7XG4gICAgICAgICAgICBmZWF0dXJlID0gdHVyZi5wb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgZ2VvZmxvLm1vdXNlSXNEb3duLFxuICAgICAgICAgICAgICAgIGNvb3JkcyxcbiAgICAgICAgICAgICAgICBjb29yZHMsXG4gICAgICAgICAgICAgICAgZ2VvZmxvLm1vdXNlSXNEb3duXG4gICAgICAgICAgICBdXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0NpcmNsZScpIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSB0dXJmLnBvbHlnb24oW1tcbiAgICAgICAgICAgICAgICBnZW9mbG8ubW91c2VJc0Rvd24sXG4gICAgICAgICAgICAgICAgY29vcmRzLFxuICAgICAgICAgICAgICAgIGNvb3JkcyxcbiAgICAgICAgICAgICAgICBnZW9mbG8ubW91c2VJc0Rvd25cbiAgICAgICAgICAgIF1dKTtcblxuICAgICAgICAgICAgZ2VvZmxvLlV0aWxpdGllcy5zZXRQcm9wZXJ0eShmZWF0dXJlLCAnY2VudGVyJywgZ2VvZmxvLm1vdXNlSXNEb3duKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZlYXR1cmUgPSB0dXJmLmxpbmVTdHJpbmcoW2dlb2Zsby5tb3VzZUlzRG93biwgY29vcmRzXSk7XG4gICAgICAgIH1cblxuICAgICAgICBnZW9mbG8uVXRpbGl0aWVzLnNldFByb3BlcnR5KGZlYXR1cmUsICd0eXBlJywgdHlwZSk7XG4gICAgICAgIGdlb2Zsby5VdGlsaXRpZXMuc2V0UHJvcGVydHkoZmVhdHVyZSwgJ3BhaW50aW5nJywgMSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUNvb3JkaW5hdGUgKGYsIHQsIGUsIG4pIHtcbiAgICAgICAgdmFyIG8gPSB0LnNwbGl0KFwiLlwiKVxuICAgICAgICAgICAgLCByID0gcGFyc2VJbnQob1swXSwgMTApXG4gICAgICAgICAgICAsIGkgPSBwYXJzZUludChvWzFdLCAxMCk7XG4gICAgICAgIHZvaWQgMCA9PT0gZi5nZW9tZXRyeS5jb29yZGluYXRlc1tyXSAmJiAoZi5nZW9tZXRyeS5jb29yZGluYXRlc1tyXSA9IFtdKSxcbiAgICAgICAgZi5nZW9tZXRyeS5jb29yZGluYXRlc1tyXVtpXSA9IFtlLCBuXVxuICAgIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFBhaW50aW5nOyIsIi8qKlxuICogQG1peGluXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsb1xuICogQG5hbWUgUGlubmluZ1xuICogQGRlc2NyaXB0aW9uIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBwaW5uaW5nIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBHZW9mbG8gYXBwbGljYXRpb24uIEl0IGFsbG93cyB1c2VycyB0byBwaW4gZmVhdHVyZXMgdG8gdGhlIG1hcCBieSBjcmVhdGluZyBhIGJ1ZmZlciBhcm91bmQgdGhlIGZlYXR1cmUgYW5kIHNuYXBwaW5nIHRvIG5lYXJieSBmZWF0dXJlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlIC0gVGhlIG1vZGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHR5cGUgb2YgbW9kZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIFBpbm5pbmcgb2JqZWN0LlxuICovXG5jb25zdCBQaW5uaW5nID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICBjb25zdCBnZW9mbG8gPSB0aGlzLmdlb2ZsbztcblxuICAgIHRoaXMudHlwZSA9IG1vZGUudHlwZTtcbiAgICB0aGlzLnVwZGF0ZWRGZWF0dXJlcyA9IFtdO1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5QaW5uaW5nXG5cdCAqIEBuYW1lIGFjdGl2YXRlXG5cdCAqIEBkZXNjcmlwdGlvbiBBY3RpdmF0ZXMgdGhlIGZlYXR1cmUgYnkgc2V0dGluZyB0aGUgZW5hYmxlZCBmbGFnIHRvIHRydWUgYW5kIGVuYWJsaW5nIHBpbm5pbmcgaW4gdGhlIG9wdGlvbnMuXG5cdCAqIEBwYXJhbXMge3ZvaWR9IE5vbmVcblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMuYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlZEZlYXR1cmVzID0gW107XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGdlb2Zsby5vcHRpb25zWydwaW5uaW5nJ10uZW5hYmxlID0gdHJ1ZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlBpbm5pbmdcblx0ICogQG5hbWUgZGVhY3RpdmF0ZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBkZWFjdGl2YXRlcyB0aGUgcGlubmluZyBmZWF0dXJlIGJ5IHNldHRpbmcgZW5hYmxlZCB0byBmYWxzZSwgZGlzYWJsaW5nIHBpbm5pbmcgaW4gb3B0aW9ucywgY2xlYXJpbmcgYnVmZmVyLCBwaW5hYmxlRmVhdHVyZXMsIGFuZCBwaW5uaW5nRmVhdHVyZXMsIGFuZCByZXNldHRpbmcgdXBkYXRlZEZlYXR1cmVzLlxuXHQgKi9cbiAgICB0aGlzLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBnZW9mbG8ub3B0aW9uc1sncGlubmluZyddLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlc2V0RmVhdHVyZXMoKTtcbiAgICAgICAgZGVsZXRlIHRoaXMuYnVmZmVyO1xuICAgICAgICBkZWxldGUgZ2VvZmxvLnBpbmFibGVGZWF0dXJlcztcbiAgICAgICAgZGVsZXRlIGdlb2Zsby5waW5uaW5nRmVhdHVyZXM7XG4gICAgICAgIHRoaXMudXBkYXRlZEZlYXR1cmVzID0gW107XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5QaW5uaW5nXG5cdCAqIEBuYW1lIGdldEZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgdGhlIGZlYXR1cmVzIGZyb20gdGhlIHBpbm5lZEZlYXR1cmVzIGFycmF5IGluIHRoZSBjb250ZXh0IG9iamVjdC5cblx0ICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBmZWF0dXJlcyBleHRyYWN0ZWQgZnJvbSB0aGUgcGlubmVkRmVhdHVyZXMgYXJyYXkuXG5cdCAqL1xuICAgIHRoaXMuZ2V0RmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IGdlb2Zsby5waW5uZWRGZWF0dXJlcyAmJiBnZW9mbG8ucGlubmVkRmVhdHVyZXMubGVuZ3RoID8gZ2VvZmxvLnBpbm5lZEZlYXR1cmVzLm1hcChmdW5jdGlvbiAoZmVhdHVyZSkgeyByZXR1cm4gZmVhdHVyZS5mZWF0dXJlIH0pIDogW107XG4gICAgICAgIHJldHVybiBmZWF0dXJlcztcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlBpbm5pbmdcblx0ICogQG5hbWUgc2V0QnVmZmVyXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYSBidWZmZXIgYXJvdW5kIHRoZSBwcm92aWRlZCBjb29yZGluYXRlcyBiYXNlZCBvbiB0aGUgcGlubmluZyBidWZmZXIgb3B0aW9uLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkcyAtIFRoZSBjb29yZGluYXRlcyBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gdG8gY3JlYXRlIHRoZSBidWZmZXIgYXJvdW5kLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fGJvb2xlYW59IFJldHVybnMgdGhlIGJ1ZmZlciBvYmplY3QgY29udGFpbmluZyB0aGUgZmVhdHVyZSwgcmFkaXVzLCBhbmQgY29vcmRpbmF0ZXMgaWYgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlLlxuXHQgKi9cbiAgICB0aGlzLnNldEJ1ZmZlciA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYnVmZmVyO1xuXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghY29vcmRzIHx8ICFnZW9mbG8ub3B0aW9ucy5waW5uaW5nLmJ1ZmZlcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBidWZmZXIgPSB0dXJmLmJ1ZmZlcih0dXJmLnBvaW50KGNvb3JkcyksIGdlb2Zsby5vcHRpb25zLnBpbm5pbmcuYnVmZmVyKTtcbiAgICAgICAgdmFyIHJhZGl1cyA9IHR1cmYucG9seWdvbihidWZmZXIuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuXG4gICAgICAgIHRoaXMuYnVmZmVyID0ge1xuICAgICAgICAgICAgZmVhdHVyZTogYnVmZmVyLFxuICAgICAgICAgICAgcmFkaXVzOiByYWRpdXMsXG4gICAgICAgICAgICBjb29yZHM6IGNvb3Jkc1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uUGlubmluZ1xuXHQgKiBAbmFtZSBzZXRGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgcGluYWJsZSBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgY29vcmRpbmF0ZXMgYW5kIGZpcmVzIGFuIGV2ZW50LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIC0gVGhlIGNvb3JkaW5hdGVzIHRvIGRldGVybWluZSBuZWFyYnkgZmVhdHVyZXMuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gLSBBbiBhcnJheSBvZiBwaW5hYmxlIGZlYXR1cmVzLlxuXHQgKi9cbiAgICB0aGlzLnNldEZlYXR1cmVzID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICBnZW9mbG8ucGluYWJsZUZlYXR1cmVzID0gW107XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkIHx8ICFjb29yZHMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLnBpbmFibGVGZWF0dXJlcyA9IHRoaXMuZ2V0TmVhckJ5RmVhdHVyZXMoY29vcmRzKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ3Bpbm5pbmcuYWRkJywgeyBmZWF0dXJlczogZ2VvZmxvLnBpbmFibGVGZWF0dXJlcywgYnVmZmVyOiB0aGlzLmJ1ZmZlciB9KTtcbiAgICAgICAgcmV0dXJuIGdlb2Zsby5waW5hYmxlRmVhdHVyZXM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5QaW5uaW5nXG5cdCAqIEBuYW1lIHJlc2V0RmVhdHVyZXNcblx0ICogQGRlc2NyaXB0aW9uIFJlc2V0cyB0aGUgdXBkYXRlZCBmZWF0dXJlcyBieSBhZGRpbmcgdGhlbSB0byB0aGUgY2FudmFzIGNvbnRleHQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIHRoZXJlIGFyZSBubyB1cGRhdGVkIGZlYXR1cmVzIHRvIHJlc2V0LlxuXHQgKi9cbiAgICB0aGlzLnJlc2V0RmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy51cGRhdGVkRmVhdHVyZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGdlb2Zsby5hZGRGZWF0dXJlcyh0aGlzLnVwZGF0ZWRGZWF0dXJlcywgdHJ1ZSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5QaW5uaW5nXG5cdCAqIEBuYW1lIHVwZGF0ZUZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHVwZGF0ZXMgdGhlIGZlYXR1cmVzIGlmIHRoZSBwaW5uaW5nIGZ1bmN0aW9uYWxpdHkgaXMgZW5hYmxlZC4gSXQgdXBkYXRlcyB0aGUgcGluYWJsZSBmZWF0dXJlcywgcGlubmVkIGZlYXR1cmVzLCBhbmQgdHJpZ2dlcnMgZXZlbnRzIGFjY29yZGluZ2x5LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiB0aGUgcGlubmluZyBmdW5jdGlvbmFsaXR5IGlzIG5vdCBlbmFibGVkLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgdXBkYXRlZCBwaW5uaW5nIGZlYXR1cmVzLlxuXHQgKi9cbiAgICB0aGlzLnVwZGF0ZUZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWdlb2Zsby5waW5hYmxlRmVhdHVyZXMgfHwgIWdlb2Zsby5waW5hYmxlRmVhdHVyZXMubGVuZ3RoKSByZXR1cm4gZGVsZXRlIGdlb2Zsby5waW5uaW5nRmVhdHVyZXMsIGZhbHNlO1xuICAgICAgICB1cGRhdGVGZWF0dXJlcy5jYWxsKHRoaXMsIGdlb2Zsby5waW5hYmxlRmVhdHVyZXMpO1xuICAgICAgICBnZW9mbG8uRmVhdHVyZXMudXBkYXRlRmVhdHVyZXMoZ2VvZmxvLnBpbmFibGVGZWF0dXJlcywgeyB0eXBlOiAncGlubmluZycsIGNvb3JkczogZ2VvZmxvLnNuYXBwZWRWZXJ0ZXgsIGFkZFVuaXRzOiB0cnVlIH0pO1xuICAgICAgICBnZW9mbG8ucGlubmVkRmVhdHVyZXMgPSBnZW9mbG8uVXRpbGl0aWVzLmNsb25lRGVlcChnZW9mbG8ucGluYWJsZUZlYXR1cmVzKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ3Bpbm5pbmcudXBkYXRlJywgeyBmZWF0dXJlOiBnZW9mbG8uaG90RmVhdHVyZSwgdmVydGV4OiB0dXJmLnBvaW50KGdlb2Zsby5zbmFwcGVkVmVydGV4KSwgZmVhdHVyZXM6IGdlb2Zsby5waW5uZWRGZWF0dXJlcyB9KTtcbiAgICAgICAgcmV0dXJuIGdlb2Zsby5waW5uaW5nRmVhdHVyZXM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5QaW5uaW5nXG5cdCAqIEBuYW1lIGdldE5lYXJCeUZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIHJhZGl1cyBiYXNlZCBvbiB0aGUgbWFwIHpvb20gbGV2ZWwgYW5kIHJldHJpZXZlcyBuZWFyYnkgZmVhdHVyZXMgd2l0aGluIHRoYXQgcmFkaXVzLlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkcyAtIFRoZSBjb29yZGluYXRlcyBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gdG8gZmluZCBuZWFyYnkgZmVhdHVyZXMuXG5cdCAqIEByZXR1cm5zIHtBcnJheTxPYmplY3Q+fSBBbiBhcnJheSBvZiBuZWFyYnkgZmVhdHVyZXMgd2l0aCB0aGVpciBJRHMsIHR5cGVzLCBpbmRpY2VzLCBhbmQgZmVhdHVyZSBvYmplY3RzLlxuXHQgKi9cbiAgICB0aGlzLmdldE5lYXJCeUZlYXR1cmVzID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhY29vcmRzKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGhvdEZlYXR1cmUgPSBnZW9mbG8uaG90RmVhdHVyZTtcbiAgICAgICAgdmFyIGNhbGN1bGF0ZWRSYWRpdXMgPSBnZW9mbG8ub3B0aW9ucy5zbmFwcGluZy5kaXN0YW5jZSAqIE1hdGgucG93KDIsIE1hdGgubWF4KDEsIDE5IC0gZ2VvZmxvLm1hcC5nZXRab29tKCkpKTtcbiAgICAgICAgdmFyIHJhZGl1c0luS20gPSBjYWxjdWxhdGVkUmFkaXVzIC8gMTAwMDAwO1xuICAgICAgICB2YXIgYnVmZmVyID0gdGhpcy5zZXRCdWZmZXIoY29vcmRzKTtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gZ2VvZmxvLmdldFJlbmRlcmVkRHJhd25GZWF0dXJlcyh7bG5nOiBjb29yZHNbMF0sIGxhdDogY29vcmRzWzFdfSwgcmFkaXVzSW5LbSk7XG4gICAgICAgIHZhciBuZWFyYnkgPSBbXTtcblxuICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgICAgICB0dXJmLmNvb3JkRWFjaChmZWF0dXJlLCBmdW5jdGlvbiAoY29vcmQsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzTmVhcmJ5ID0gZmFsc2U7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKGJ1ZmZlci5yYWRpdXMgJiYgdHVyZi5ib29sZWFuV2l0aGluKHR1cmYucG9pbnQoY29vcmQpLCBidWZmZXIucmFkaXVzKSkgaXNOZWFyYnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmICghaXNOZWFyYnkgJiYgYnVmZmVyLmNvb3JkcyAmJiBnZW9mbG8uVXRpbGl0aWVzLmlzUG9pbnRFcXVhbChjb29yZCwgYnVmZmVyLmNvb3JkcykpIGlzTmVhcmJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTmVhcmJ5KSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGhvdEZlYXR1cmUgJiYgaG90RmVhdHVyZS5pZCA9PT0gZmVhdHVyZS5pZCkgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBuZWFyYnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBmZWF0dXJlLmlkIHx8IGZlYXR1cmUucHJvcGVydGllcy5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZmVhdHVyZS5wcm9wZXJ0aWVzLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZTogZmVhdHVyZVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5lYXJieTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGdlb2Zsby5vcHRpb25zWydwaW5uaW5nJ10uZW5hYmxlKSB0aGlzLmFjdGl2YXRlKCk7XG5cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gICAgICAgIGlmICghZmVhdHVyZXMgfHwgIWZlYXR1cmVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBwaW5uZWQgPSB0aGlzLnVwZGF0ZWRGZWF0dXJlcy5maW5kKGZ1bmN0aW9uIChmKSB7IHJldHVybiBmLmlkID09PSBmZWF0dXJlLmlkIH0pO1xuICAgICAgICAgICAgaWYgKHBpbm5lZCkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVkRmVhdHVyZXMucHVzaChnZW9mbG8uVXRpbGl0aWVzLmNsb25lRGVlcChmZWF0dXJlLmZlYXR1cmUpKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgUGlubmluZzsiLCIvKipcbiAqIEBtaXhpblxuICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG9cbiAqIEBuYW1lIFJvdXRpbmdcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1vZHVsZSBwcm92aWRlcyB0aGUgcm91dGluZyBmdW5jdGlvbmFsaXR5IGZvciB0aGUgR2VvZmxvIGFwcGxpY2F0aW9uLiBJdCBhbGxvd3MgdXNlcnMgdG8gY2FsY3VsYXRlIHJvdXRlcyBiZXR3ZWVuIHR3byBwb2ludHMgb24gdGhlIG1hcCB1c2luZyBhIFBhdGhGaW5kZXIgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGUgLSBUaGUgbW9kZSBvYmplY3QgY29udGFpbmluZyB0aGUgdHlwZSBvZiBtb2RlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgUm91dGluZyBvYmplY3QuXG4gKi9cbmNvbnN0IFJvdXRpbmcgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgIGNvbnN0IGdlb2ZsbyA9IHRoaXMuZ2VvZmxvO1xuXG4gICAgdGhpcy50eXBlID0gbW9kZS50eXBlO1xuICAgIHRoaXMuZ3JhcGhEYXRhID0ge307XG4gICAgdGhpcy5mZWF0dXJlcyA9IGdlb2Zsby5GZWF0dXJlcy5nZXRDb2xkRmVhdHVyZXMoKTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uUm91dGluZ1xuXHQgKiBAbmFtZSBhY3RpdmF0ZVxuXHQgKiBAZGVzY3JpcHRpb24gQWN0aXZhdGVzIHRoZSBmdW5jdGlvbmFsaXR5IGJ5IHNldHRpbmcgdGhlICdlbmFibGVkJyBwcm9wZXJ0eSB0byB0cnVlIGFuZCBlbmFibGluZyByb3V0aW5nIGluIHRoZSBvcHRpb25zLlxuXHQgKiBAcGFyYW1zIHt2b2lkfSBOb25lXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmFjdGl2YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBnZW9mbG8ub3B0aW9uc1sncm91dGluZyddLmVuYWJsZSA9IHRydWU7XG4gICAgfTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uUm91dGluZ1xuXHQgKiBAbmFtZSBkZWFjdGl2YXRlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGRlYWN0aXZhdGVzIHRoZSByb3V0aW5nIGZlYXR1cmUgYnkgc2V0dGluZyB0aGUgZW5hYmxlZCBmbGFnIHRvIGZhbHNlLCBkaXNhYmxpbmcgcm91dGluZyBpbiB0aGUgb3B0aW9ucywgYW5kIGNsZWFyaW5nIHRoZSByb3V0ZSBkYXRhIG9uIHRoZSBtYXAuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmRlYWN0aXZhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICBnZW9mbG8ub3B0aW9uc1sncm91dGluZyddLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlc1snUk9VVEUnXSkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgfTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uUm91dGluZ1xuXHQgKiBAbmFtZSBnZXRSb3V0ZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjYWxjdWxhdGVzIGEgcm91dGUgYmV0d2VlbiB0d28gcG9pbnRzIG9uIGEgbWFwIHVzaW5nIGEgUGF0aEZpbmRlciBvYmplY3QuIEl0IGNoZWNrcyBpZiB0aGUgcm91dGluZyBmZWF0dXJlIGlzIGVuYWJsZWQgYW5kIGlmIHRoZSBtYXAgaXMgbm90IGN1cnJlbnRseSBtb3ZpbmcuIEl0IHRoZW4gY3JlYXRlcyBhIGZlYXR1cmUgY29sbGVjdGlvbiBmcm9tIHRoZSBleGlzdGluZyBmZWF0dXJlcywgaW5pdGlhbGl6ZXMgYSBQYXRoRmluZGVyIG9iamVjdCwgYW5kIGZpbmRzIGEgcGF0aCBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzLiBUaGUgcGF0aCBpcyB2YWxpZGF0ZWQgYW5kIHRoZW4gYWRkZWQgdG8gdGhlIG1hcCB3aXRoIGEgJ3JvdXRpbmcuYWRkJyBldmVudC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZyb21Qb2ludCAtIFRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIHJvdXRlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gdG9Qb2ludCAtIFRoZSBkZXN0aW5hdGlvbiBwb2ludCBmb3IgdGhlIHJvdXRlLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl8Ym9vbGVhbn0gVGhlIGNhbGN1bGF0ZWQgcm91dGUgcGF0aCBhcyBhbiBhcnJheSBvZiBwb2ludHMsIG9yIGZhbHNlIGlmIHRoZSByb3V0ZSBjb3VsZCBub3QgYmUgY2FsY3VsYXRlZC5cblx0ICovXG4gICAgdGhpcy5nZXRSb3V0ZSA9IGZ1bmN0aW9uIChmcm9tUG9pbnQsIHRvUG9pbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgZ2VvZmxvLm1hcE1vdmluZykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKHRoaXMuZ2V0RmVhdHVyZXMoKSk7XG4gICAgICAgIHZhciBwYXRoZmluZGVyID0gbmV3IFBhdGhGaW5kZXIoZmVhdHVyZXMsIGdlb2Zsby5vcHRpb25zLnJvdXRpbmcpO1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhmaW5kZXIuZmluZFBhdGggPyBwYXRoZmluZGVyLmZpbmRQYXRoKGZyb21Qb2ludCwgdG9Qb2ludCkgOiBmYWxzZTtcbiAgICAgICAgcGF0aCA9IHZhbGlkYXRlUGF0aChmcm9tUG9pbnQsIHRvUG9pbnQsIHBhdGgpO1xuICAgICAgICBnZW9mbG8uZmlyZSgncm91dGluZy5hZGQnLCB7IGZyb206IGZyb21Qb2ludCwgdG86IHRvUG9pbnQsIHBhdGg6IHBhdGggfSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgIH07XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlJvdXRpbmdcblx0ICogQG5hbWUgZ2V0TWF0Y2hcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBhIG1hdGNoIGZvciB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMgdXNpbmcgdGhlIEV4cGxvcmluZyBzZXJ2aWNlLiBTZXRzIHRoZSBtYXRjaCBhcyBhIHN0YXJ0aW5nIHBvaW50IGZvciByb3V0aW5nLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29vcmRzIC0gVGhlIGNvb3JkaW5hdGVzIGZvciB3aGljaCB0byBmaW5kIGEgbWF0Y2guXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPE9iamVjdD59IFRoZSBtYXRjaGVkIGZlYXR1cmUgd2l0aCByb3V0aW5nIHByb3BlcnR5IHNldCB0byB0cnVlLlxuXHQgKi9cbiAgICB0aGlzLmdldE1hdGNoID0gYXN5bmMgZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGF3YWl0IGdlb2Zsby5FeHBsb3JpbmcuZ2V0TWF0Y2goY29vcmRzLCB7IHNldDogdHJ1ZSwgc3RhcnQ6IGdlb2Zsby5zdGFydFBvaW50IH0pO1xuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMucm91dGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uUm91dGluZ1xuXHQgKiBAbmFtZSBnZXRDbG9zZXN0XG5cdCAqIEBkZXNjcmlwdGlvbiBDYWxjdWxhdGVzIHRoZSBjbG9zZXN0IHBvaW50IG9uIGEgcm91dGUgYmFzZWQgb24gdGhlIGxhc3QgY2xpY2sgYW5kIHRoZSBjbG9zZXN0IHBvaW50IHRvIGl0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fGJvb2xlYW59IFJldHVybnMgYSBHZW9KU09OIExpbmVTdHJpbmcgZmVhdHVyZSB3aXRoIHJvdXRpbmcgcHJvcGVydHkgc2V0IHRvIHRydWUgaWYgc3VjY2Vzc2Z1bCwgb3RoZXJ3aXNlIGZhbHNlLlxuXHQgKi9cbiAgICB0aGlzLmdldENsb3Nlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghZ2VvZmxvLmNsb3Nlc3RQb2ludCB8fCAhZ2VvZmxvLmxhc3RDbGljaykgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgcm91dGUgPSB0aGlzLmdldFJvdXRlKGdlb2Zsby5sYXN0Q2xpY2ssIGdlb2Zsby5jbG9zZXN0UG9pbnQpO1xuICAgICAgICBpZiAoIXJvdXRlIHx8ICFyb3V0ZS5wYXRoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBmZWF0dXJlID0gdHVyZi5saW5lU3RyaW5nKHJvdXRlLnBhdGgpO1xuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMucm91dGluZyA9IHRydWU7XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH07XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlJvdXRpbmdcblx0ICogQG5hbWUgZ2V0RmVhdHVyZXNcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyBmZWF0dXJlcyBvZiB0eXBlICdMaW5lU3RyaW5nJyBmcm9tIHRoZSBtZXNoIGluZGV4LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGZlYXR1cmVzIG9mIHR5cGUgJ0xpbmVTdHJpbmcnLlxuXHQgKi9cbiAgICB0aGlzLmdldEZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWVzaCA9IGdlb2Zsby5tZXNoSW5kZXguZ2V0RmVhdHVyZXMoKTtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gW21lc2gsIHRoaXMuZmVhdHVyZXNdLmZsYXQoKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzLmZpbHRlcihmdW5jdGlvbihmZWF0dXJlKSB7IHJldHVybiBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJyB9KTtcbiAgICB9O1xuXG4gICAgXG4gICAgaWYgKGdlb2Zsby5vcHRpb25zWydyb3V0aW5nJ10uZW5hYmxlKSB0aGlzLmFjdGl2YXRlKCk7XG5cblxuICAgIGZ1bmN0aW9uIFBhdGhGaW5kZXIoZmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIFxuICAgICAgICBpZiAoIWZlYXR1cmVzLmNvbXBhY3RlZFZlcnRpY2VzKSB7IGZlYXR1cmVzID0gcHJlcHJvY2VzcyhmZWF0dXJlcywgb3B0aW9ucyk7IH1cblxuICAgICAgICB0aGlzLl9ncmFwaCA9IGZlYXR1cmVzO1xuICAgICAgICB0aGlzLl9rZXlGbiA9IG9wdGlvbnMua2V5Rm4gfHwgZnVuY3Rpb24oYykgeyByZXR1cm4gYy5qb2luKCcsJyk7IH07XG4gICAgICAgIHRoaXMuX3ByZWNpc2lvbiA9IG9wdGlvbnMucHJlY2lzaW9uIHx8IDFlLTU7XG4gICAgICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuICAgIFxuICAgICAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fZ3JhcGguY29tcGFjdGVkVmVydGljZXMpLmZpbHRlcihmdW5jdGlvbihrKSB7IHJldHVybiBrICE9PSAnZWRnZURhdGEnOyB9KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5maW5kUGF0aCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHRoaXMuX2tleUZuKHJvdW5kQ29vcmQoYS5jb29yZHMsIHRoaXMuX3ByZWNpc2lvbikpLFxuICAgICAgICAgICAgICAgIGZpbmlzaCA9IHRoaXMuX2tleUZuKHJvdW5kQ29vcmQoYi5jb29yZHMsIHRoaXMuX3ByZWNpc2lvbikpO1xuICAgIFxuICAgICAgICAgICAgaWYgKCF0aGlzLl9ncmFwaC52ZXJ0aWNlc1tzdGFydF0gfHwgIXRoaXMuX2dyYXBoLnZlcnRpY2VzW2ZpbmlzaF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHZhciBwaGFudG9tU3RhcnQgPSB0aGlzLl9jcmVhdGVQaGFudG9tKHN0YXJ0KTtcbiAgICAgICAgICAgIHZhciBwaGFudG9tRW5kID0gdGhpcy5fY3JlYXRlUGhhbnRvbShmaW5pc2gpO1xuICAgIFxuICAgICAgICAgICAgdmFyIHBhdGggPSBmaW5kUGF0aCh0aGlzLl9ncmFwaC5jb21wYWN0ZWRWZXJ0aWNlcywgc3RhcnQsIGZpbmlzaCk7XG4gICAgXG4gICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBwYXRoWzBdO1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGZ1bGxQYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLnJlZHVjZShmdW5jdGlvbiBidWlsZFBhdGgoY3MsIHYsIGksIHZzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjcyA9IGNzLmNvbmNhdCh0aGlzLl9ncmFwaC5jb21wYWN0ZWRDb29yZGluYXRlc1t2c1tpIC0gMV1dW3ZdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcztcbiAgICAgICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpLCBbXSkuY29uY2F0KFt0aGlzLl9ncmFwaC5zb3VyY2VWZXJ0aWNlc1tmaW5pc2hdXSksXG4gICAgICAgICAgICAgICAgICAgIHdlaWdodDogd2VpZ2h0LFxuICAgICAgICAgICAgICAgICAgICBlZGdlRGF0YXM6IHRoaXMuX2dyYXBoLmNvbXBhY3RlZEVkZ2VzIFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBwYXRoLnJlZHVjZShmdW5jdGlvbiBidWlsZEVkZ2VEYXRhKGVkcywgdiwgaSwgdnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWRzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkdWNlZEVkZ2U6IHRoaXMuX2dyYXBoLmNvbXBhY3RlZEVkZ2VzW3ZzW2kgLSAxXV1bdl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlZHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcyksIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVBoYW50b20ocGhhbnRvbVN0YXJ0KTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVBoYW50b20ocGhhbnRvbUVuZCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dyYXBoO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY3JlYXRlUGhhbnRvbSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9ncmFwaC5jb21wYWN0ZWRWZXJ0aWNlc1tuXSkgcmV0dXJuIG51bGw7XG4gICAgXG4gICAgICAgICAgICB2YXIgcGhhbnRvbSA9IGNvbXBhY3ROb2RlKG4sIHRoaXMuX2dyYXBoLnZlcnRpY2VzLCB0aGlzLl9ncmFwaC5jb21wYWN0ZWRWZXJ0aWNlcywgdGhpcy5fZ3JhcGguc291cmNlVmVydGljZXMsIHRoaXMuX2dyYXBoLmVkZ2VEYXRhLCB0cnVlLCB0aGlzLl9vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoLmNvbXBhY3RlZFZlcnRpY2VzW25dID0gcGhhbnRvbS5lZGdlcztcbiAgICAgICAgICAgIHRoaXMuX2dyYXBoLmNvbXBhY3RlZENvb3JkaW5hdGVzW25dID0gcGhhbnRvbS5jb29yZGluYXRlcztcbiAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLl9ncmFwaC5jb21wYWN0ZWRFZGdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoLmNvbXBhY3RlZEVkZ2VzW25dID0gcGhhbnRvbS5yZWR1Y2VkRWRnZXM7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwaGFudG9tLmluY29taW5nRWRnZXMpLmZvckVhY2goZnVuY3Rpb24obmVpZ2hib3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9ncmFwaC5jb21wYWN0ZWRWZXJ0aWNlc1tuZWlnaGJvcl1bbl0gPSBwaGFudG9tLmluY29taW5nRWRnZXNbbmVpZ2hib3JdO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoLmNvbXBhY3RlZENvb3JkaW5hdGVzW25laWdoYm9yXVtuXSA9IFt0aGlzLl9ncmFwaC5zb3VyY2VWZXJ0aWNlc1tuZWlnaGJvcl1dLmNvbmNhdChwaGFudG9tLmluY29taW5nQ29vcmRpbmF0ZXNbbmVpZ2hib3JdLnNsaWNlKDAsIC0xKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2dyYXBoLmNvbXBhY3RlZEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2dyYXBoLmNvbXBhY3RlZEVkZ2VzW25laWdoYm9yXVtuXSA9IHBoYW50b20ucmVkdWNlZEVkZ2VzW25laWdoYm9yXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG4gICAgXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JlbW92ZVBoYW50b20gPSBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICBpZiAoIW4pIHJldHVybjtcbiAgICBcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX2dyYXBoLmNvbXBhY3RlZFZlcnRpY2VzW25dKS5mb3JFYWNoKGZ1bmN0aW9uKG5laWdoYm9yKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2dyYXBoLmNvbXBhY3RlZFZlcnRpY2VzW25laWdoYm9yXVtuXTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9ncmFwaC5jb21wYWN0ZWRDb29yZGluYXRlc1tuXSkuZm9yRWFjaChmdW5jdGlvbihuZWlnaGJvcikge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ncmFwaC5jb21wYWN0ZWRDb29yZGluYXRlc1tuZWlnaGJvcl1bbl07XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgaWYgKHRoaXMuX2dyYXBoLmNvbXBhY3RlZEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fZ3JhcGguY29tcGFjdGVkRWRnZXNbbl0pLmZvckVhY2goZnVuY3Rpb24obmVpZ2hib3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2dyYXBoLmNvbXBhY3RlZEVkZ2VzW25laWdoYm9yXVtuXTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2dyYXBoLmNvbXBhY3RlZFZlcnRpY2VzW25dO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2dyYXBoLmNvbXBhY3RlZENvb3JkaW5hdGVzW25dO1xuICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMuX2dyYXBoLmNvbXBhY3RlZEVkZ2VzKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2dyYXBoLmNvbXBhY3RlZEVkZ2VzW25dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIFNob3J0ZXN0UGF0aCAoKSB7XG4gICAgICAgIHZhciBJTkZJTklUWSA9IDEgLyAwO1xuICAgICAgICB0aGlzLnZlcnRpY2VzID0ge307XG4gICAgXG4gICAgICAgIHRoaXMuYWRkVmVydGV4ID0gZnVuY3Rpb24gKG5hbWUsIGVkZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnZlcnRpY2VzW25hbWVdID0gZWRnZXM7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHRoaXMuc2V0VmVydGljZXMgPSBmdW5jdGlvbiAoZ3JhcGgpIHtcbiAgICAgICAgICAgIHRoaXMudmVydGljZXMgPSBncmFwaDtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgdGhpcy5zaG9ydGVzdFBhdGggPSBmdW5jdGlvbiAoc3RhcnQsIGZpbmlzaCkge1xuICAgICAgICAgICAgdmFyIG5vZGVzID0gbmV3IFByaW9yaXR5UXVldWUoKSxcbiAgICAgICAgICAgICAgICBkaXN0YW5jZXMgPSB7fSxcbiAgICAgICAgICAgICAgICBwcmV2aW91cyA9IHt9LFxuICAgICAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgICAgICBzbWFsbGVzdCwgdmVydGV4LCBuZWlnaGJvciwgYWx0O1xuICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmVydGV4IGluIHRoaXMudmVydGljZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVydGV4ID09PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZXNbdmVydGV4XSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmVucXVldWUoMCwgdmVydGV4KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZXNbdmVydGV4XSA9IElORklOSVRZO1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5lbnF1ZXVlKElORklOSVRZLCB2ZXJ0ZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgcHJldmlvdXNbdmVydGV4XSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgd2hpbGUgKCFub2Rlcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IG5vZGVzLmRlcXVldWUoKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHNtYWxsZXN0ID09PSBmaW5pc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChwcmV2aW91c1tzbWFsbGVzdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGgucHVzaChzbWFsbGVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbWFsbGVzdCA9IHByZXZpb3VzW3NtYWxsZXN0XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCFzbWFsbGVzdCB8fCBkaXN0YW5jZXNbc21hbGxlc3RdID09PSBJTkZJTklUWSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAobmVpZ2hib3IgaW4gdGhpcy52ZXJ0aWNlc1tzbWFsbGVzdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWx0ID0gZGlzdGFuY2VzW3NtYWxsZXN0XSArIHRoaXMudmVydGljZXNbc21hbGxlc3RdW25laWdoYm9yXTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHQgPCBkaXN0YW5jZXNbbmVpZ2hib3JdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZXNbbmVpZ2hib3JdID0gYWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNbbmVpZ2hib3JdID0gc21hbGxlc3Q7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzLmVucXVldWUoYWx0LCBuZWlnaGJvcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHBhdGg7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiBQcmlvcml0eVF1ZXVlKCkge1xuICAgICAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgIFxuICAgICAgICB0aGlzLmVucXVldWUgPSBmdW5jdGlvbiAocHJpb3JpdHksIGtleSkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMucHVzaCh7a2V5OiBrZXksIHByaW9yaXR5OiBwcmlvcml0eX0pO1xuICAgICAgICAgICAgdGhpcy5zb3J0KCk7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHRoaXMuZGVxdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub2Rlcy5zaGlmdCgpLmtleTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgdGhpcy5zb3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhpcy5fbm9kZXMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICB0aGlzLmlzRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gIXRoaXMuX25vZGVzLmxlbmd0aDtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gVGlueVF1ZXVlKGRhdGEsIGNvbXBhcmUpIHtcbiAgICAgICAgaWYgKCBkYXRhID09PSB2b2lkIDAgKSBkYXRhID0gW107XG4gICAgICAgIGlmICggY29tcGFyZSA9PT0gdm9pZCAwICkgY29tcGFyZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IGEgPiBiID8gMSA6IDA7XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gdGhpcy5kYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5jb21wYXJlID0gY29tcGFyZTtcbiAgICBcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9ICh0aGlzLmxlbmd0aCA+PiAxKSAtIDE7IGkgPj0gMDsgaS0tKSB7IHRoaXMuX2Rvd24oaSk7IH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICB0aGlzLnB1c2ggPSBmdW5jdGlvbiBwdXNoIChpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGEucHVzaChpdGVtKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICAgICAgICB0aGlzLl91cCh0aGlzLmxlbmd0aCAtIDEpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5wb3AgPSBmdW5jdGlvbiBwb3AgKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgdG9wID0gdGhpcy5kYXRhWzBdO1xuICAgICAgICAgICAgdmFyIGJvdHRvbSA9IHRoaXMuZGF0YS5wb3AoKTtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgICAgIFxuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVswXSA9IGJvdHRvbTtcbiAgICAgICAgICAgICAgICB0aGlzLl9kb3duKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB0b3A7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLnBlZWsgPSBmdW5jdGlvbiBwZWVrICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFbMF07XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLl91cCA9IGZ1bmN0aW9uIF91cCAocG9zKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlID0gcmVmLmNvbXBhcmU7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGRhdGFbcG9zXTtcbiAgICAgICAgXG4gICAgICAgICAgICB3aGlsZSAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAocG9zIC0gMSkgPj4gMTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IGRhdGFbcGFyZW50XTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShpdGVtLCBjdXJyZW50KSA+PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgZGF0YVtwb3NdID0gY3VycmVudDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgZGF0YVtwb3NdID0gaXRlbTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuX2Rvd24gPSBmdW5jdGlvbiBfZG93biAocG9zKSB7XG4gICAgICAgICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHJlZi5kYXRhO1xuICAgICAgICAgICAgICAgIHZhciBjb21wYXJlID0gcmVmLmNvbXBhcmU7XG4gICAgICAgICAgICB2YXIgaGFsZkxlbmd0aCA9IHRoaXMubGVuZ3RoID4+IDE7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGRhdGFbcG9zXTtcbiAgICAgICAgXG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgaGFsZkxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gKHBvcyA8PCAxKSArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGJlc3QgPSBkYXRhW2xlZnRdO1xuICAgICAgICAgICAgICAgIHZhciByaWdodCA9IGxlZnQgKyAxO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAocmlnaHQgPCB0aGlzLmxlbmd0aCAmJiBjb21wYXJlKGRhdGFbcmlnaHRdLCBiZXN0KSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCA9IHJpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBiZXN0ID0gZGF0YVtyaWdodF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb21wYXJlKGJlc3QsIGl0ZW0pID49IDApIHsgYnJlYWs7IH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgZGF0YVtwb3NdID0gYmVzdDtcbiAgICAgICAgICAgICAgICBwb3MgPSBsZWZ0O1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIGRhdGFbcG9zXSA9IGl0ZW07XG4gICAgICAgIH07XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGZpbmROZXh0RW5kKHByZXYsIHYsIHZlcnRpY2VzLCBlbmRzLCB2ZXJ0ZXhDb29yZHMsIGVkZ2VEYXRhLCB0cmFja0luY29taW5nLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciB3ZWlnaHQgPSB2ZXJ0aWNlc1twcmV2XVt2XSxcbiAgICAgICAgICAgIHJldmVyc2VXZWlnaHQgPSB2ZXJ0aWNlc1t2XVtwcmV2XSxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzID0gW10sXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICByZWR1Y2VkRWRnZSA9IG9wdGlvbnMuZWRnZURhdGFTZWVkO1xuICAgICAgICAgICAgXG4gICAgICAgIGlmIChvcHRpb25zLmVkZ2VEYXRhUmVkdWNlRm4pIHtcbiAgICAgICAgICAgIHJlZHVjZWRFZGdlID0gb3B0aW9ucy5lZGdlRGF0YVJlZHVjZUZuKHJlZHVjZWRFZGdlLCBlZGdlRGF0YVt2XVtwcmV2XSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgd2hpbGUgKCFlbmRzW3ZdKSB7XG4gICAgICAgICAgICB2YXIgZWRnZXMgPSB2ZXJ0aWNlc1t2XTtcbiAgICBcbiAgICAgICAgICAgIGlmICghZWRnZXMpIHsgYnJlYWs7IH1cbiAgICBcbiAgICAgICAgICAgIHZhciBuZXh0ID0gT2JqZWN0LmtleXMoZWRnZXMpLmZpbHRlcihmdW5jdGlvbiBub3RQcmV2aW91cyhrKSB7IHJldHVybiBrICE9PSBwcmV2OyB9KVswXTtcbiAgICAgICAgICAgIHdlaWdodCArPSBlZGdlc1tuZXh0XTtcbiAgICBcbiAgICAgICAgICAgIGlmICh0cmFja0luY29taW5nKSB7XG4gICAgICAgICAgICAgICAgcmV2ZXJzZVdlaWdodCArPSB2ZXJ0aWNlc1tuZXh0XVt2XTtcbiAgICBcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5pbmRleE9mKHYpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kc1t2XSA9IHZlcnRpY2VzW3ZdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKHYpO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZWRnZURhdGFSZWR1Y2VGbikge1xuICAgICAgICAgICAgICAgIHJlZHVjZWRFZGdlID0gb3B0aW9ucy5lZGdlRGF0YVJlZHVjZUZuKHJlZHVjZWRFZGdlLCBlZGdlRGF0YVt2XVtuZXh0XSk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBjb29yZGluYXRlcy5wdXNoKHZlcnRleENvb3Jkc1t2XSk7XG4gICAgICAgICAgICBwcmV2ID0gdjtcbiAgICAgICAgICAgIHYgPSBuZXh0O1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2ZXJ0ZXg6IHYsXG4gICAgICAgICAgICB3ZWlnaHQ6IHdlaWdodCxcbiAgICAgICAgICAgIHJldmVyc2VXZWlnaHQ6IHJldmVyc2VXZWlnaHQsXG4gICAgICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgICAgICAgICByZWR1Y2VkRWRnZTogcmVkdWNlZEVkZ2VcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFxuICAgIGZ1bmN0aW9uIGNvbXBhY3ROb2RlKGssIHZlcnRpY2VzLCBlbmRzLCB2ZXJ0ZXhDb29yZHMsIGVkZ2VEYXRhLCB0cmFja0luY29taW5nLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgbmVpZ2hib3JzID0gdmVydGljZXNba107XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhuZWlnaGJvcnMpLnJlZHVjZShmdW5jdGlvbiBjb21wYWN0RWRnZShyZXN1bHQsIGopIHtcbiAgICAgICAgICAgIHZhciBuZWlnaGJvciA9IGZpbmROZXh0RW5kKGssIGosIHZlcnRpY2VzLCBlbmRzLCB2ZXJ0ZXhDb29yZHMsIGVkZ2VEYXRhLCB0cmFja0luY29taW5nLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciB3ZWlnaHQgPSBuZWlnaGJvci53ZWlnaHQ7XG4gICAgICAgICAgICB2YXIgcmV2ZXJzZVdlaWdodCA9IG5laWdoYm9yLnJldmVyc2VXZWlnaHQ7XG4gICAgICAgICAgICBpZiAobmVpZ2hib3IudmVydGV4ICE9PSBrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuZWRnZXNbbmVpZ2hib3IudmVydGV4XSB8fCByZXN1bHQuZWRnZXNbbmVpZ2hib3IudmVydGV4XSA+IHdlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZWRnZXNbbmVpZ2hib3IudmVydGV4XSA9IHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvb3JkaW5hdGVzW25laWdoYm9yLnZlcnRleF0gPSBbdmVydGV4Q29vcmRzW2tdXS5jb25jYXQobmVpZ2hib3IuY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucmVkdWNlZEVkZ2VzW25laWdoYm9yLnZlcnRleF0gPSBuZWlnaGJvci5yZWR1Y2VkRWRnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRyYWNrSW5jb21pbmcgJiYgXG4gICAgICAgICAgICAgICAgICAgICFpc05hTihyZXZlcnNlV2VpZ2h0KSAmJiAoIXJlc3VsdC5pbmNvbWluZ0VkZ2VzW25laWdoYm9yLnZlcnRleF0gfHwgcmVzdWx0LmluY29taW5nRWRnZXNbbmVpZ2hib3IudmVydGV4XSA+IHJldmVyc2VXZWlnaHQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pbmNvbWluZ0VkZ2VzW25laWdoYm9yLnZlcnRleF0gPSByZXZlcnNlV2VpZ2h0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29vcmRpbmF0ZXMgPSBbdmVydGV4Q29vcmRzW2tdXS5jb25jYXQobmVpZ2hib3IuY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlcy5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5pbmNvbWluZ0Nvb3JkaW5hdGVzW25laWdoYm9yLnZlcnRleF0gPSBjb29yZGluYXRlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCB7ZWRnZXM6IHt9LCBpbmNvbWluZ0VkZ2VzOiB7fSwgY29vcmRpbmF0ZXM6IHt9LCBpbmNvbWluZ0Nvb3JkaW5hdGVzOiB7fSwgcmVkdWNlZEVkZ2VzOiB7fX0pO1xuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gY29tcGFjdEdyYXBoKHZlcnRpY2VzLCB2ZXJ0ZXhDb29yZHMsIGVkZ2VEYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIgcHJvZ3Jlc3MgPSBvcHRpb25zLnByb2dyZXNzO1xuICAgICAgICB2YXIgZW5kcyA9IE9iamVjdC5rZXlzKHZlcnRpY2VzKS5yZWR1Y2UoZnVuY3Rpb24gZmluZEVuZHMoZXMsIGssIGksIHZzKSB7XG4gICAgICAgICAgICB2YXIgdmVydGV4ID0gdmVydGljZXNba107XG4gICAgICAgICAgICB2YXIgZWRnZXMgPSBPYmplY3Qua2V5cyh2ZXJ0ZXgpO1xuICAgICAgICAgICAgdmFyIG51bWJlckVkZ2VzID0gZWRnZXMubGVuZ3RoO1xuICAgICAgICAgICAgdmFyIHJlbW92ZTtcbiAgICBcbiAgICAgICAgICAgIGlmKG9wdGlvbnMuY29tcGFjdCA9PT0gZmFsc2UpICB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG51bWJlckVkZ2VzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gdmVydGljZXNbZWRnZXNbMF1dO1xuICAgICAgICAgICAgICAgIHJlbW92ZSA9ICFvdGhlcltrXTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobnVtYmVyRWRnZXMgPT09IDIpIHtcbiAgICAgICAgICAgICAgICByZW1vdmUgPSBlZGdlcy5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmVydGljZXNbbl1ba107XG4gICAgICAgICAgICAgICAgfSkubGVuZ3RoID09PSBudW1iZXJFZGdlcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghcmVtb3ZlKSB7XG4gICAgICAgICAgICAgICAgZXNba10gPSB2ZXJ0ZXg7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoaSAlIDEwMDAgPT09IDAgJiYgcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcygnY29tcGFjdDplbmRzJywgaSwgdnMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBlcztcbiAgICAgICAgfSwge30pO1xuICAgIFxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZW5kcykucmVkdWNlKGZ1bmN0aW9uIGNvbXBhY3RFbmQocmVzdWx0LCBrLCBpLCBlcykge1xuICAgICAgICAgICAgdmFyIGNvbXBhY3RlZCA9IGNvbXBhY3ROb2RlKGssIHZlcnRpY2VzLCBlbmRzLCB2ZXJ0ZXhDb29yZHMsIGVkZ2VEYXRhLCBmYWxzZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICByZXN1bHQuZ3JhcGhba10gPSBjb21wYWN0ZWQuZWRnZXM7XG4gICAgICAgICAgICByZXN1bHQuY29vcmRpbmF0ZXNba10gPSBjb21wYWN0ZWQuY29vcmRpbmF0ZXM7XG4gICAgXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5lZGdlRGF0YVJlZHVjZUZuKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlZHVjZWRFZGdlc1trXSA9IGNvbXBhY3RlZC5yZWR1Y2VkRWRnZXM7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICBpZiAoaSAlIDEwMDAgPT09IDAgJiYgcHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcygnY29tcGFjdDpub2RlcycsIGksIGVzLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCB7Z3JhcGg6IHt9LCBjb29yZGluYXRlczoge30sIHJlZHVjZWRFZGdlczoge319KTtcbiAgICB9O1xuICAgIFxuICAgIGZ1bmN0aW9uIGZpbmRQYXRoKGdyYXBoLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciBjb3N0cyA9IHt9O1xuICAgICAgICBjb3N0c1tzdGFydF0gPSAwO1xuICAgICAgICB2YXIgaW5pdGlhbFN0YXRlID0gWzAsIFtzdGFydF0sIHN0YXJ0XTtcbiAgICAgICAgdmFyIHF1ZXVlID0gbmV3IFRpbnlRdWV1ZShbaW5pdGlhbFN0YXRlXSwgZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0pO1xuICAgICAgICB2YXIgZXhwbG9yZWQgPSB7fTtcbiAgICBcbiAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gcXVldWUucG9wKCk7XG4gICAgICAgICAgICB2YXIgY29zdCA9IHN0YXRlWzBdO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBzdGF0ZVsyXTtcbiAgICAgICAgICAgIGlmIChub2RlID09PSBlbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuc2xpY2UoMCwgMik7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB2YXIgbmVpZ2hib3VycyA9IGdyYXBoW25vZGVdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmVpZ2hib3VycykuZm9yRWFjaChmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld0Nvc3QgPSBjb3N0ICsgbmVpZ2hib3Vyc1tuXTtcbiAgICAgICAgICAgICAgICBpZiAoIShuIGluIGNvc3RzKSB8fCBuZXdDb3N0IDwgY29zdHNbbl0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29zdHNbbl0gPSBuZXdDb3N0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3U3RhdGUgPSBbbmV3Q29zdCwgc3RhdGVbMV0uY29uY2F0KFtuXSksIG5dO1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFxuICAgIGZ1bmN0aW9uIHByZXByb2Nlc3MoZ3JhcGgsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgdmFyIHRvcG87XG5cbiAgICAgICAgdmFyIHdlaWdodEZuID0gb3B0aW9ucy53ZWlnaHRGbiB8fCBmdW5jdGlvbiBkZWZhdWx0V2VpZ2h0Rm4oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIHR1cmYuZGlzdGFuY2UodHVyZi5wb2ludChhKSwgdHVyZi5wb2ludChiKSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKGdyYXBoLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEdyYXBoIGlzIEdlb0pTT04gZGF0YSwgY3JlYXRlIGEgdG9wb2xvZ3kgZnJvbSBpdFxuICAgICAgICAgICAgdG9wbyA9IHRvcG9sb2d5KGdyYXBoLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIGlmIChncmFwaC5lZGdlcykge1xuICAgICAgICAgICAgLy8gR3JhcGggaXMgYSBwcmVwcm9jZXNzZWQgdG9wb2xvZ3lcbiAgICAgICAgICAgIHRvcG8gPSBncmFwaDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICB2YXIgZ3JhcGggPSB0b3BvLmVkZ2VzLnJlZHVjZShmdW5jdGlvbiBidWlsZEdyYXBoKGcsIGVkZ2UsIGksIGVzKSB7XG4gICAgICAgICAgICB2YXIgYSA9IGVkZ2VbMF0sXG4gICAgICAgICAgICAgICAgYiA9IGVkZ2VbMV0sXG4gICAgICAgICAgICAgICAgcHJvcHMgPSBlZGdlWzJdLFxuICAgICAgICAgICAgICAgIHcgPSB3ZWlnaHRGbih0b3BvLnZlcnRpY2VzW2FdLCB0b3BvLnZlcnRpY2VzW2JdLCBwcm9wcyksXG4gICAgICAgICAgICAgICAgbWFrZUVkZ2VMaXN0ID0gZnVuY3Rpb24gbWFrZUVkZ2VMaXN0KG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFnLnZlcnRpY2VzW25vZGVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnLnZlcnRpY2VzW25vZGVdID0ge307XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lZGdlRGF0YVJlZHVjZUZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZy5lZGdlRGF0YVtub2RlXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb25jYXRFZGdlID0gZnVuY3Rpb24gY29uY2F0RWRnZShzdGFydE5vZGUsIGVuZE5vZGUsIHdlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGcudmVydGljZXNbc3RhcnROb2RlXTtcbiAgICAgICAgICAgICAgICAgICAgdltlbmROb2RlXSA9IHdlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuZWRnZURhdGFSZWR1Y2VGbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZy5lZGdlRGF0YVtzdGFydE5vZGVdW2VuZE5vZGVdID0gb3B0aW9ucy5lZGdlRGF0YVJlZHVjZUZuKG9wdGlvbnMuZWRnZURhdGFTZWVkLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgIFxuICAgICAgICAgICAgaWYgKHcpIHtcbiAgICAgICAgICAgICAgICBtYWtlRWRnZUxpc3QoYSk7XG4gICAgICAgICAgICAgICAgbWFrZUVkZ2VMaXN0KGIpO1xuICAgICAgICAgICAgICAgIGlmICh3IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3LmZvcndhcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdEVkZ2UoYSwgYiwgdy5mb3J3YXJkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAody5iYWNrd2FyZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0RWRnZShiLCBhLCB3LmJhY2t3YXJkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbmNhdEVkZ2UoYSwgYiwgdyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmNhdEVkZ2UoYiwgYSwgdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgaWYgKGkgJSAxMDAwID09PSAwICYmIG9wdGlvbnMucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zLnByb2dyZXNzKCdlZGdld2VpZ2h0cycsIGksZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICB9LCB7ZWRnZURhdGE6IHt9LCB2ZXJ0aWNlczoge319KTtcbiAgICBcbiAgICAgICAgdmFyIGNvbXBhY3QgPSBjb21wYWN0R3JhcGgoZ3JhcGgudmVydGljZXMsIHRvcG8udmVydGljZXMsIGdyYXBoLmVkZ2VEYXRhLCBvcHRpb25zKTtcbiAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnRpY2VzOiBncmFwaC52ZXJ0aWNlcyxcbiAgICAgICAgICAgIGVkZ2VEYXRhOiBncmFwaC5lZGdlRGF0YSxcbiAgICAgICAgICAgIHNvdXJjZVZlcnRpY2VzOiB0b3BvLnZlcnRpY2VzLFxuICAgICAgICAgICAgY29tcGFjdGVkVmVydGljZXM6IGNvbXBhY3QuZ3JhcGgsXG4gICAgICAgICAgICBjb21wYWN0ZWRDb29yZGluYXRlczogY29tcGFjdC5jb29yZGluYXRlcyxcbiAgICAgICAgICAgIGNvbXBhY3RlZEVkZ2VzOiBvcHRpb25zLmVkZ2VEYXRhUmVkdWNlRm4gPyBjb21wYWN0LnJlZHVjZWRFZGdlcyA6IG51bGxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIFxuICAgIGZ1bmN0aW9uIHJvdW5kQ29vcmQoYywgcHJlY2lzaW9uKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGNbMF0gLyBwcmVjaXNpb24pICogcHJlY2lzaW9uLFxuICAgICAgICAgICAgTWF0aC5yb3VuZChjWzFdIC8gcHJlY2lzaW9uKSAqIHByZWNpc2lvbixcbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFxuICAgIGZ1bmN0aW9uIGdlb0pzb25SZWR1Y2UoZ2VvanNvbiwgZm4sIHNlZWQpIHtcbiAgICAgICAgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGdlb2pzb24uZmVhdHVyZXMucmVkdWNlKGZ1bmN0aW9uIHJlZHVjZUZlYXR1cmVzKGEsIGYpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2VvSnNvblJlZHVjZShmLCBmbiwgYSk7XG4gICAgICAgICAgICB9LCBzZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmbihzZWVkLCBnZW9qc29uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gZ2VvSnNvbkZpbHRlckZlYXR1cmVzKGdlb2pzb24sIGZuKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgICAgICBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgICAgICBmZWF0dXJlcyA9IGZlYXR1cmVzLmNvbmNhdChnZW9qc29uLmZlYXR1cmVzLmZpbHRlcihmbikpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiBpc0xpbmVTdHJpbmcoZikge1xuICAgICAgICByZXR1cm4gZi5nZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZyc7XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiB0b3BvbG9neShnZW9qc29uLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICB2YXIga2V5Rm4gPSBvcHRpb25zLmtleUZuIHx8IGZ1bmN0aW9uIGRlZmF1bHRLZXlGbihjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGMuam9pbignLCcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByZWNpc2lvbiA9IG9wdGlvbnMucHJlY2lzaW9uIHx8IDFlLTU7XG4gICAgXG4gICAgICAgIHZhciBsaW5lU3RyaW5ncyA9IGdlb0pzb25GaWx0ZXJGZWF0dXJlcyhnZW9qc29uLCBpc0xpbmVTdHJpbmcpO1xuICAgICAgICB2YXIgZXhwbG9kZWRMaW5lU3RyaW5ncyA9IHR1cmYuZXhwbG9kZShsaW5lU3RyaW5ncyk7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IGV4cGxvZGVkTGluZVN0cmluZ3MuZmVhdHVyZXMucmVkdWNlKGZ1bmN0aW9uIGJ1aWxkVG9wb2xvZ3lWZXJ0aWNlcyhjcywgZiwgaSwgZnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmMgPSByb3VuZENvb3JkKGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHByZWNpc2lvbik7XG4gICAgICAgICAgICAgICAgY3Nba2V5Rm4ocmMpXSA9IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKGkgJSAxMDAwID09PSAwICYmIG9wdGlvbnMucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9ncmVzcygndG9wbzp2ZXJ0aWNlcycsIGksIGZzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBjcztcbiAgICAgICAgICAgIH0sIHt9KSxcbiAgICAgICAgICAgIGVkZ2VzID0gZ2VvSnNvblJlZHVjZShsaW5lU3RyaW5ncywgZnVuY3Rpb24gYnVpbGRUb3BvbG9neUVkZ2VzKGVzLCBmLCBpLCBmcykge1xuICAgICAgICAgICAgICAgIGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiBidWlsZExpbmVTdHJpbmdFZGdlcyhjLCBpLCBjcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrMSA9IGtleUZuKHJvdW5kQ29vcmQoY3NbaSAtIDFdLCBwcmVjaXNpb24pKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrMiA9IGtleUZuKHJvdW5kQ29vcmQoYywgcHJlY2lzaW9uKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcy5wdXNoKFtrMSwgazIsIGYucHJvcGVydGllc10pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKGkgJSAxMDAwID09PSAwICYmIG9wdGlvbnMucHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5wcm9ncmVzcygndG9wbzplZGdlcycsIGksIGZzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBlcztcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZlcnRpY2VzOiB2ZXJ0aWNlcyxcbiAgICAgICAgICAgIGVkZ2VzOiBlZGdlc1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhdGgoZnJvbVBvaW50LCB0b1BvaW50LCBwYXRoKSB7XG4gICAgICAgIGlmICh0b1BvaW50ICYmIHRvUG9pbnQudHlwZSA9PT0gJ2xpbmVwb2ludCcpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy9pZiAocHJlY2lzaW9uID4gMC4wMDA1KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGF0aCB8fCAhcGF0aC5wYXRoIHx8ICFwYXRoLnBhdGgubGVuZ3RoIHx8IHBhdGgucGF0aC5sZW5ndGggPCAyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBwYXRoO1xuXG4gICAgICAgIHByZWNpc2lvbiA9IE51bWJlcigoTnVtYmVyKHByZWNpc2lvbikgKyAwLjAwMDAwMikudG9GaXhlZCg3KSk7XG4gICAgICAgIHZhciBwYXRoZmluZGVyID0gbmV3IFBhdGhGaW5kZXIoZmVhdHVyZXMsIHsgcHJlY2lzaW9uOiBwcmVjaXNpb24gfSk7XG4gICAgICAgIHZhciBuZXdQYXRoID0gcGF0aGZpbmRlci5maW5kUGF0aChmcm9tUG9pbnQsIHRvUG9pbnQpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVQYXRoKGZyb21Qb2ludCwgdG9Qb2ludCwgZmVhdHVyZXMsIG5ld1BhdGgpO1xuICAgIH07XG59O1xuXG5leHBvcnQgZGVmYXVsdCBSb3V0aW5nOyIsIi8qKlxuICogQG1peGluXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsb1xuICogQG5hbWUgU2VsZWN0XG4gKiBAZGVzY3JpcHRpb24gVGhpcyBtb2R1bGUgcHJvdmlkZXMgdGhlIHNlbGVjdCBmdW5jdGlvbmFsaXR5IGZvciB0aGUgR2VvZmxvIGFwcGxpY2F0aW9uLiBJdCBhbGxvd3MgdXNlcnMgdG8gc2VsZWN0IGZlYXR1cmVzIG9uIHRoZSBtYXAgYnkgY2xpY2tpbmcgb24gdGhlbS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIFNlbGVjdCBvYmplY3QuXG4gKi9cbmNvbnN0IFNlbGVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBnZW9mbG8gPSB0aGlzLmdlb2ZsbztcblxuICAgIHZhciBsYXN0S25vd25TZWxlY3RJZHMgPSBbXTtcbiAgICB2YXIgcmVtb3ZlZEZlYXR1cmVzID0gW107XG4gICAgdmFyIG5lYXJGZWF0dXJlcyA9IFtdO1xuICAgIHZhciBjbGlja0Nvb3JkcztcbiAgICB2YXIgbXVsdGlwbGVTZWxlY3Q7XG4gICAgdmFyIHNlbGVjdGVkSWQ7XG5cbiAgICB0aGlzLmlkID0gJ3NlbGVjdCc7XG5cbiAgICAvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uU2VsZWN0XG5cdCAqIEBuYW1lIGFjdGl2YXRlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGFjdGl2YXRlcyB0aGUgc2VsZWN0IGZlYXR1cmUgZnVuY3Rpb25hbGl0eSBieSBlbmFibGluZyBkcmFnIHBhbiwgc2V0dGluZyBidXR0b25zLCBhbmQgc2V0dGluZyB0aGUgYWN0aXZlIGJ1dHRvbiB0byAnc2VsZWN0Jy4gSXQgYWxzbyB0cmlnZ2VycyBhICdzZWxlY3QuYWN0aXZhdGUnIGV2ZW50IHdpdGggdGhlIHByb3ZpZGVkIG9wdGlvbnMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgb2JqZWN0IGZvciBhY3RpdmF0aW9uLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuaWRdIC0gVGhlIElEIG9mIHRoZSBmZWF0dXJlIHRvIHNlbGVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmZlYXR1cmVdIC0gVGhlIGZlYXR1cmUgb2JqZWN0IHRvIHNlbGVjdC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgYWxyZWFkeSBhY3RpdmF0ZWQuXG5cdCAqL1xuICAgIHRoaXMuYWN0aXZhdGUgPSBmdW5jdGlvbiAob3B0aW9ucz17fSkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmF0ZWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGdlb2Zsby5jdXJyZW50TW9kZS5pZCAhPT0gdGhpcy5pZCkgcmV0dXJuIG9wdGlvbnMubW9kZSA9IHRoaXMuaWQsIGdlb2Zsby5zZXRNb2RlKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gdHJ1ZTtcbiAgICAgICAgZ2VvZmxvLm1hcC5kcmFnUGFuLmVuYWJsZSgpO1xuICAgICAgICBnZW9mbG8uc2V0QnV0dG9ucygpO1xuICAgICAgICBnZW9mbG8uc2V0QWN0aXZlQnV0dG9uKCdzZWxlY3QnKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ3NlbGVjdC5hY3RpdmF0ZScsIHsgYWN0aXZhdGVkOiB0cnVlLCBvcHRpb25zOiBvcHRpb25zIH0pXG4gICAgICAgIGlmICh0aGlzLmdhbWVwYWQpIHt9XG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNFTEVDVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSk7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oZSkgeyBlLnNlbGVjdEZlYXR1cmUob3B0aW9ucy5pZCA/IG9wdGlvbnMuaWQgOiBvcHRpb25zLmZlYXR1cmUgPyBvcHRpb25zLmZlYXR1cmUuaWQgOiBmYWxzZSkgfSwgNSwgdGhpcylcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5TZWxlY3Rcblx0ICogQG5hbWUgZGVhY3RpdmF0ZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBkZWFjdGl2YXRlcyB0aGUgY3VycmVudCBmZWF0dXJlIGJ5IHNldHRpbmcgdGhlICdhY3RpdmF0ZWQnIGZsYWcgdG8gZmFsc2UgYW5kIHRyaWdnZXJpbmcgbmVjZXNzYXJ5IGFjdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIHRoZSBmZWF0dXJlIGlzIG5vdCBhY3RpdmF0ZWQuXG5cdCAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFjdGl2YXRlZCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzZWxlY3RDdXJyZW50RmVhdHVyZSgpO1xuICAgICAgICBcbiAgICAgICAgZ2VvZmxvLnNldEJ1dHRvbnMoKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ3NlbGVjdC5kZWFjdGl2YXRlJywgeyBhY3RpdmF0ZWQ6IHRydWUgfSk7XG4gICAgfTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uU2VsZWN0XG5cdCAqIEBuYW1lIGNhbkhhbmRsZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZXF1YWwgdG8gdGhlIFNFTEVDVCBtb2RlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbW9kZU5hbWUgLSBUaGUgbW9kZSBuYW1lIHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIG1vZGUgbmFtZSBpcyBTRUxFQ1QsIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5jYW5IYW5kbGUgPSBmdW5jdGlvbiAobW9kZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5tb2Rlcy5TRUxFQ1QgPT09IG1vZGVOYW1lO1xuICAgIH07XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlNlbGVjdFxuXHQgKiBAbmFtZSBzZWxlY3RGZWF0dXJlXG5cdCAqIEBkZXNjcmlwdGlvbiBTZWxlY3RzIGEgZmVhdHVyZSBieSBpdHMgSUQsIGFkZHMgaXQgdG8gdGhlIHNlbGVjdGVkIGZlYXR1cmVzIGxpc3QsIGFuZCBvcHRpb25hbGx5IGFkZHMgYSBwb3B1cC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIElEIG9mIHRoZSBmZWF0dXJlIHRvIGJlIHNlbGVjdGVkLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgb2YgcmVtb3ZlZCBmZWF0dXJlcyBpZiB3YW50aW5nVG9FZGl0IGlzIGZhbHNlLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgcmVtb3ZlZCBmZWF0dXJlLlxuXHQgKi9cbiAgICB0aGlzLnNlbGVjdEZlYXR1cmUgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnM9e30pIHtcbiAgICAgICAgY29uc3QgcG9wdXAgPSBnZW9mbG8ub3B0aW9ucy5zZWxlY3QucG9wdXA7XG4gICAgICAgIFxuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TRUxFQ1QpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFpZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAobGFzdEtub3duU2VsZWN0SWRzLmluZGV4T2YoaWQpID09PSAtMSkgbGFzdEtub3duU2VsZWN0SWRzLnB1c2goaWQpO1xuICAgICAgICAvL2lmIChnZW9mbG8uaGFzU2VsZWN0aW9uKCkpIGdlb2Zsby5mb3JFYWNoU2VsZWN0ZWRGZWF0dXJlKChmZWF0dXJlKSA9PiB7IH0pO1xuXG4gICAgICAgIHJlbW92ZWRGZWF0dXJlcyA9IGdlb2Zsby5GZWF0dXJlcy5yZW1vdmVGZWF0dXJlcyhpZCwgdHJ1ZSk7XG4gICAgICAgIGdlb2Zsby5hZGRGZWF0dXJlc1RvU2VsZWN0ZWQocmVtb3ZlZEZlYXR1cmVzLCBvcHRpb25zKTtcbiAgICAgICAgcG9wdXAgPyB0aGlzLmFkZFBvcHVwKHJlbW92ZWRGZWF0dXJlcykgOiBmYWxzZTtcblxuICAgICAgICBnZW9mbG8uZmlyZSgnZmVhdHVyZS5zZWxlY3QnLCB7IGlkczogZ2VvZmxvLmdldFNlbGVjdGVkRmVhdHVyZUlkcygpLCBmZWF0dXJlczogZ2VvZmxvLmdldFNlbGVjdGVkRmVhdHVyZXMoKSB9KTtcbiAgICAgICAgaWYgKCFnZW9mbG8ud2FudGluZ1RvRWRpdCkgcmV0dXJuIHJlbW92ZWRGZWF0dXJlcztcbiAgICAgICAgaWYgKHJlbW92ZWRGZWF0dXJlcy5sZW5ndGggPT0gMSAmJiBpZCA9PT0gcmVtb3ZlZEZlYXR1cmVzWzBdLmlkKSBlZGl0RmVhdHVyZShyZW1vdmVkRmVhdHVyZXNbMF0pO1xuICAgICAgICByZXR1cm4gcmVtb3ZlZEZlYXR1cmVzO1xuICAgIH07XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlNlbGVjdFxuXHQgKiBAbmFtZSBkZXNlbGVjdEN1cnJlbnRGZWF0dXJlXG5cdCAqIEBkZXNjcmlwdGlvbiBEZXNlbGVjdHMgdGhlIGN1cnJlbnQgZmVhdHVyZSBieSByZW1vdmluZyBpdHMgc2VsZWN0aW9uLlxuXHQgKi9cbiAgICB0aGlzLmRlc2VsZWN0Q3VycmVudEZlYXR1cmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGdlb2Zsby5yZW1vdmVTZWxlY3Rpb24oKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ2ZlYXR1cmUuZGVzZWxlY3QnLCB7IGlkczogZ2VvZmxvLmdldFNlbGVjdGVkRmVhdHVyZUlkcygpLCBmZWF0dXJlczogZ2VvZmxvLmdldFNlbGVjdGVkRmVhdHVyZXMoKSB9KTtcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5TZWxlY3Rcblx0ICogQG5hbWUgYWRkUG9wdXBcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyBhIHBvcHVwIGVsZW1lbnQgd2l0aCB0aGUgc3BlY2lmaWVkIGZlYXR1cmVzIGFuZCBhZGRzIGl0IHRvIHRoZSBtYXAgYXQgdGhlIGNsaWNrIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZXMgLSBUaGUgZmVhdHVyZXMgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBwb3B1cC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVzLnRpdGxlIC0gVGhlIHRpdGxlIG9mIHRoZSBwb3B1cC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVzLmRlc2NyaXB0aW9uIC0gVGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBwb3B1cC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVzLmxhdGl0dWRlIC0gVGhlIGxhdGl0dWRlIGNvb3JkaW5hdGUgZm9yIHRoZSBwb3B1cCBsb2NhdGlvbi5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVzLmxvbmdpdHVkZSAtIFRoZSBsb25naXR1ZGUgY29vcmRpbmF0ZSBmb3IgdGhlIHBvcHVwIGxvY2F0aW9uLlxuXHQgKi9cbiAgICB0aGlzLmFkZFBvcHVwID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgIHRoaXMucG9wdXBFbGVtZW50ID0gYnVpbGRQb3B1cChmZWF0dXJlcyk7XG5cbiAgICAgICAgdGhpcy5wb3B1cCA9IG5ldyBtYXBib3hnbC5Qb3B1cCh7IGNsb3NlT25DbGljazogZmFsc2UgfSlcbiAgICAgICAgICAgIC5zZXRMbmdMYXQoY2xpY2tDb29yZHMpXG4gICAgICAgICAgICAuc2V0RE9NQ29udGVudCh0aGlzLnBvcHVwRWxlbWVudClcbiAgICAgICAgICAgIC5hZGRUbyhnZW9mbG8ubWFwKVxuICAgICAgICAgICAgLnNldE9mZnNldCgxMik7XG5cbiAgICAgICAgdGhpcy5wb3B1cC5fY29udGFpbmVyLnN0eWxlWydtYXJnaW4tYm90dG9tJ10gPSAnMTBweCdcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5TZWxlY3Rcblx0ICogQG5hbWUgcmVtb3ZlUG9wdXBcblx0ICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgdGhlIHBvcHVwIGVsZW1lbnQgZnJvbSB0aGUgRE9NIGlmIGl0IGV4aXN0cy5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwb3B1cCBlbGVtZW50IHdhcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZCwgb3RoZXJ3aXNlIGZhbHNlLlxuXHQgKi9cbiAgICB0aGlzLnJlbW92ZVBvcHVwID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wb3B1cCAmJiB0aGlzLnBvcHVwLnJlbW92ZSA/IHRoaXMucG9wdXAucmVtb3ZlKCkgOiBmYWxzZTtcbiAgICB9O1xuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5TZWxlY3Rcblx0ICogQG5hbWUgaGFuZGxlTW92ZVxuXHQgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgbW91c2UgbW92ZSBldmVudC5cblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbW91c2UgbW92ZSBldmVudC5cblx0ICovXG4gICAgdGhpcy5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vZ2VvZmxvLnNldE1hcENsYXNzKCdwb2ludGVyJyk7XG4gICAgfTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uU2VsZWN0XG5cdCAqIEBuYW1lIGhhbmRsZUNsaWNrXG5cdCAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBjbGljayBldmVudCBvbiB0aGUgbWFwIGFuZCBzZWxlY3RzIGZlYXR1cmVzIGJhc2VkIG9uIHRoZSBldmVudC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCBjb250YWluaW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGljayBldmVudC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgZ2VvZmxvLm5vU2VsZWN0IGlzIHRydWUsIG90aGVyd2lzZSBzZWxlY3RzIGZlYXR1cmVzIGJhc2VkIG9uIHRoZSBldmVudC5cblx0ICovXG4gICAgdGhpcy5oYW5kbGVDbGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSBnZW9mbG8uZ2V0UmVuZGVyZWREcmF3bkZlYXR1cmVzKGV2ZW50LmxuZ0xhdCk7XG5cbiAgICAgICAgY2xpY2tDb29yZHMgPSBbZXZlbnQubG5nTGF0LmxuZywgZXZlbnQubG5nTGF0LmxhdF07XG4gICAgICAgIG11bHRpcGxlU2VsZWN0ID0gZXZlbnQub3JpZ2luYWxFdmVudCAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ICYmIGdlb2Zsby5vcHRpb25zLnNlbGVjdC5tdWx0aXBsZTtcblxuICAgICAgICBpZiAoZmVhdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKCFnZW9mbG8uTGF5ZXJzLmdldFNlbGVjdGlvbihmZWF0dXJlcywgY2xpY2tDb29yZHMpKSByZXR1cm47XG4gICAgICAgICAgICBzZWxlY3RGZWF0dXJlLmNhbGwodGhpcywgZmVhdHVyZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKCFtdWx0aXBsZVNlbGVjdCkge1xuICAgICAgICAgICAgbGFzdEtub3duU2VsZWN0SWRzID0gW107XG4gICAgICAgICAgICBuZWFyRmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgIGNsaWNrQ29vcmRzID0gZmFsc2U7XG4gICAgICAgICAgICBzZWxlY3RlZElkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0Q3VycmVudEZlYXR1cmUoKTtcbiAgICAgICAgfVxuICAgIH07XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlNlbGVjdFxuXHQgKiBAbmFtZSBoYW5kbGVEcmFnXG5cdCAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBkcmFnIGV2ZW50IHRyaWdnZXJlZCBieSBhIHVzZXIgaW50ZXJhY3Rpb24uIEl0IHNldHMgdGhlIG1hcCBjbGFzcyB0byAnZ3JhYmJpbmcnIHRvIGluZGljYXRlIGRyYWdnaW5nLlxuXHQgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSBkcmFnIGV2ZW50LlxuXHQgKi9cbiAgICB0aGlzLmhhbmRsZURyYWcgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy9nZW9mbG8uc2V0TWFwQ2xhc3MoJ2dyYWJiaW5nJyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBidWlsZFBvcHVwIChmZWF0dXJlcykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCgncG9wdXAtdGFibGUtaG9sZGVyJyk7XG5cbiAgICAgICAgY29uc3QgdGFibGUgPSBidWlsZFRhYmxlKGZlYXR1cmVzKTtcblxuICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKHRhYmxlKTtcblxuICAgICAgICBpZiAobmVhckZlYXR1cmVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdwb3B1cC10YWJsZS1idXR0b24nKTtcbiAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBgPGJ1dHRvbj4gTmV4dCA8L2J1dHRvbj5gO1xuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc2VsZWN0RmVhdHVyZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICBcbiAgICAgICAgLyogY29uc3QgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBgPGJ1dHRvbiBjbGFzcz1cImJ0biBidG4tc3VjY2VzcyBidG4tc2ltcGxlIHRleHQtd2hpdGVcIiA+IEFzc2lnbjwvYnV0dG9uPmA7XG4gICAgICAgIGVsZW1lbnQuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHsgY29uc29sZS5sb2coJ0J1dHRvbiBjbGlja2VkJyArIG5hbWUpOyB9KTsgKi9cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gYnVpbGRUYWJsZSAoZmVhdHVyZXMpIHtcbiAgICAgICAgdmFyIHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBbJ2lkJywgJ3R5cGUnXTtcblxuICAgICAgICB0YWJsZS5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGFibGUuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICB0YWJsZS5zZXRBdHRyaWJ1dGUoJ2JvcmRlcicsICcxJyk7XG4gICAgICAgIHRhYmxlLmNsYXNzTGlzdC5hZGQoJ3BvcHVwLXRhYmxlJyk7XG5cbiAgICAgICAgdmFyIHRhYmxlQm9keSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3Rib2R5Jyk7XG5cbiAgICAgICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihmZWF0dXJlLCBpbmRleCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmZWF0dXJlLnByb3BlcnRpZXMudHlwZTtcblxuICAgICAgICAgICAgcHJvcGVydGllcy5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgICAgICB0YWJsZUJvZHkuYXBwZW5kQ2hpbGQoYnVpbGRSb3cocHJvcCwgZmVhdHVyZS5wcm9wZXJ0aWVzW3Byb3BdKSk7XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0YWJsZUJvZHkuYXBwZW5kQ2hpbGQoYnVpbGRSb3coJ2dlb21ldHJ5JywgZmVhdHVyZS5nZW9tZXRyeS50eXBlKSk7XG5cbiAgICAgICAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGdlb2Zsby5GZWF0dXJlcy5hZGRVbml0cyhmZWF0dXJlLCAnZmVldCcpO1xuICAgICAgICAgICAgICAgIHRhYmxlQm9keS5hcHBlbmRDaGlsZChidWlsZFJvdygndW5pdCcsIGZlYXR1cmUuZ2VvbWV0cnkudW5pdCkpO1xuICAgICAgICAgICAgICAgIHRhYmxlQm9keS5hcHBlbmRDaGlsZChidWlsZFJvdygndW5pdHMnLCBmZWF0dXJlLmdlb21ldHJ5LnVuaXRzKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdUZXh0Jykge1xuICAgICAgICAgICAgICAgIHRhYmxlQm9keS5hcHBlbmRDaGlsZChidWlsZFJvdygnY29udGVudCcsIGZlYXR1cmUucHJvcGVydGllcy50ZXh0KSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgICAgICAgICAgZ2VvZmxvLkZlYXR1cmVzLmFkZFVuaXRzKGZlYXR1cmUsICdhY3JlcycpO1xuICAgICAgICAgICAgICAgIHRhYmxlQm9keS5hcHBlbmRDaGlsZChidWlsZFJvdygndW5pdCcsIGZlYXR1cmUuZ2VvbWV0cnkudW5pdCkpO1xuICAgICAgICAgICAgICAgIHRhYmxlQm9keS5hcHBlbmRDaGlsZChidWlsZFJvdygndW5pdHMnLCBmZWF0dXJlLmdlb21ldHJ5LnVuaXRzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG5cbiAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGFibGVCb2R5KTtcbiAgICAgICAgcmV0dXJuIHRhYmxlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBidWlsZFJvdyAoaGVhZGVyLCBkYXRhKSB7XG4gICAgICAgIHZhciB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG4gICAgICAgIHRyLmNsYXNzTGlzdC5hZGQoJ3BvcHVwLXRhYmxlLXJvdycpO1xuXG4gICAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgICAgIHZhciB0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XG4gICAgICAgICAgICB0aC5jbGFzc0xpc3QuYWRkKCdwb3B1cC10YWJsZS1oZWFkZXInKTtcbiAgICAgICAgICAgIHRoLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGhlYWRlcikpO1xuICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICB0ZC5jbGFzc0xpc3QuYWRkKCdwb3B1cC10YWJsZS1kYXRhJyk7XG4gICAgICAgIHRkLmNsYXNzTGlzdC5hZGQoaGVhZGVyKTtcbiAgICAgICAgdGQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YSkpO1xuICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZCk7XG5cbiAgICAgICAgcmV0dXJuIHRyO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdEZlYXR1cmUgKGZlYXR1cmVzKSB7XG4gICAgICAgIG11bHRpcGxlU2VsZWN0ID0gZ2VvZmxvLm9wdGlvbnMuc2VsZWN0Lm11bHRpcGxlO1xuICAgICAgICBuZWFyRmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICAgICAgbGFzdEtub3duU2VsZWN0SWRzID0gbGFzdEtub3duU2VsZWN0SWRzID09PSB1bmRlZmluZWQgPyBbXSA6IGxhc3RLbm93blNlbGVjdElkcztcblxuICAgICAgICBpZiAoZmVhdHVyZXMubGVuZ3RoID49IGxhc3RLbm93blNlbGVjdElkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxhc3RLbm93blNlbGVjdElkcy5zcGxpY2UoMCwgZmVhdHVyZXMubGVuZ3RoIC0gbGFzdEtub3duU2VsZWN0SWRzLmxlbmd0aCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGZlYXQgPSBmZWF0dXJlc1swXTtcbiAgICAgICAgc2VsZWN0ZWRJZCA9IGZlYXQuaWQgfHwgZmVhdC5wcm9wZXJ0aWVzWydpZCddO1xuXG4gICAgICAgIGlmIChmZWF0dXJlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKChmZWF0dXJlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBmZWF0dXJlLmlkIHx8IGZlYXR1cmUucHJvcGVydGllc1snaWQnXTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEtub3duU2VsZWN0SWRzLmluZGV4T2YoaWQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZElkID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgIGZlYXQgPSBmZWF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFtdWx0aXBsZVNlbGVjdCkgZ2VvZmxvLmN1cnJlbnRNb2RlLmRlc2VsZWN0Q3VycmVudEZlYXR1cmUoKTtcbiAgICAgICAgZ2VvZmxvLmN1cnJlbnRNb2RlLnNlbGVjdEZlYXR1cmUoc2VsZWN0ZWRJZCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZWRpdEZlYXR1cmUgKGZlYXR1cmUpIHtcbiAgICAgICAgZ2VvZmxvLndhbnRpbmdUb0VkaXQgPSBmYWxzZTtcbiAgICAgICAgZ2VvZmxvLnNldE1vZGUoJ2VkaXQnLCBmZWF0dXJlLnByb3BlcnRpZXMudHlwZSwgZmVhdHVyZSk7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VsZWN0OyIsIi8qKlxuICogQG1peGluXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsb1xuICogQG5hbWUgU25hcHBpbmdcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIG1vZHVsZSBwcm92aWRlcyB0aGUgc25hcHBpbmcgZnVuY3Rpb25hbGl0eSBmb3IgdGhlIEdlb2ZsbyBhcHBsaWNhdGlvbi4gSXQgYWxsb3dzIHVzZXJzIHRvIHNuYXAgZmVhdHVyZXMgdG8gdGhlIG1hcCBieSBjcmVhdGluZyBhIGJ1ZmZlciBhcm91bmQgdGhlIGZlYXR1cmUgYW5kIHNuYXBwaW5nIHRvIG5lYXJieSBmZWF0dXJlcy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlIC0gVGhlIG1vZGUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHR5cGUgb2YgbW9kZS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIFNuYXBwaW5nIG9iamVjdC5cbiAqL1xuY29uc3QgU25hcHBpbmcgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgIGNvbnN0IGdlb2ZsbyA9IHRoaXMuZ2VvZmxvO1xuICAgIHRoaXMudHlwZSA9IG1vZGUudHlwZTtcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uU25hcHBpbmdcblx0ICogQG5hbWUgYWN0aXZhdGVcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZW5hYmxlcyB0aGUgb2JqZWN0IGFuZCBzZXRzIHRoZSBzbmFwcGluZyBvcHRpb24gdG8gdHJ1ZS5cblx0ICovXG4gICAgdGhpcy5hY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgZ2VvZmxvLm9wdGlvbnNbJ3NuYXBwaW5nJ10uZW5hYmxlID0gdHJ1ZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlNuYXBwaW5nXG5cdCAqIEBuYW1lIGRlYWN0aXZhdGVcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gc2V0cyB0aGUgJ2VuYWJsZWQnIHByb3BlcnR5IHRvIGZhbHNlLCBkaXNhYmxlcyBzbmFwcGluZywgYW5kIHVwZGF0ZXMgdGhlIG1lc2ggZGF0YS5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICAgIGdlb2Zsby5vcHRpb25zWydzbmFwcGluZyddLmVuYWJsZSA9IGZhbHNlO1xuICAgICAgICBnZW9mbG8udXBkYXRlTWVzaERhdGEoW10sIHRydWUpO1xuICAgIH1cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5TbmFwcGluZ1xuXHQgKiBAbmFtZSBnZXRDbG9zZXN0XG5cdCAqIEBkZXNjcmlwdGlvbiBGaW5kcyB0aGUgY2xvc2VzdCBwb2ludCB0byB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMgd2l0aGluIGEgc3BlY2lmaWVkIHJhZGl1cyBvciBwaXhlbCBkaXN0YW5jZS5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZHMgLSBUaGUgY29vcmRpbmF0ZXMgW2xvbmdpdHVkZSwgbGF0aXR1ZGVdIHRvIGZpbmQgdGhlIGNsb3Nlc3QgcG9pbnQgdG8uXG5cdCAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0Pn0gZmVhdHVyZXMgLSBBbiBhcnJheSBvZiBmZWF0dXJlcyB0byBzZWFyY2ggZm9yIHRoZSBjbG9zZXN0IHBvaW50IHdpdGhpbi5cblx0ICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNsb3Nlc3QgcG9pbnQgYW5kIGl0cyBjb29yZGluYXRlcy5cblx0ICovXG4gICAgdGhpcy5nZXRDbG9zZXN0ID0gZnVuY3Rpb24gKGNvb3JkcywgZmVhdHVyZXMpIHtcbiAgICAgICAgdmFyIGNhbGN1bGF0ZWRSYWRpdXMgPSBnZW9mbG8ub3B0aW9ucy5zbmFwcGluZy5kaXN0YW5jZSAqIE1hdGgucG93KDIsIE1hdGgubWF4KDEsIDE5IC0gZ2VvZmxvLm1hcC5nZXRab29tKCkpKTtcbiAgICAgICAgdmFyIHJhZGl1c0luS20gPSBjYWxjdWxhdGVkUmFkaXVzIC8gMTAwMDAwO1xuICAgICAgICB2YXIgcGl4ZWxEaXN0YW5jZSA9IGdlb2Zsby5vcHRpb25zLnNuYXBwaW5nLnBpeGVscyA/IGdlb2Zsby5vcHRpb25zLnNuYXBwaW5nLnBpeGVscyAqIG1ldGVyc1BlclBpeGVsKGNvb3Jkc1sxXSwgZ2VvZmxvLm1hcC5nZXRab29tKCkpIDogZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBmZWF0dXJlcyA9IGZlYXR1cmVzID8gZ2VvZmxvLmdldFJlbmRlcmVkU25hcEZlYXR1cmVzKHsgbG5nOiBjb29yZHNbMF0sIGxhdDogY29vcmRzWzFdIH0sIHJhZGl1c0luS20pIDogW2dlb2Zsby5ob3RGZWF0dXJlXTtcblxuICAgICAgICB2YXIgY2xvc2VzdFBvaW50ID0gZmluZENsb3Nlc3RQb2ludChmZWF0dXJlcywgY29vcmRzLCByYWRpdXNJbkttLCBwaXhlbERpc3RhbmNlKTtcblxuICAgICAgICB2YXIgY29vcmRzID0gIWNsb3Nlc3RQb2ludCA/IGZhbHNlIDpcbiAgICAgICAgICAgIHBpeGVsRGlzdGFuY2UgPyBjbG9zZXN0UG9pbnQuY29vcmRzIDpcbiAgICAgICAgICAgIGNsb3Nlc3RQb2ludC50eXBlID09PSAndmVydGV4JyAmJiBjbG9zZXN0UG9pbnQuZGlzdCA8PSByYWRpdXNJbkttID8gY2xvc2VzdFBvaW50LmNvb3JkcyA6XG4gICAgICAgICAgICBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb2ludDogY2xvc2VzdFBvaW50LFxuICAgICAgICAgICAgY29vcmRzOiBjb29yZHNcbiAgICAgICAgfTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlNuYXBwaW5nXG5cdCAqIEBuYW1lIHNldENsb3Nlc3Rcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgY2xvc2VzdCBmZWF0dXJlIHRvIHRoZSBnaXZlbiBjb29yZGluYXRlcyB3aXRoaW4gYSBzcGVjaWZpZWQgcmFkaXVzIGFuZCBzbmFwcGluZyBwYXJhbWV0ZXJzLiBJdCBkZXRlcm1pbmVzIGlmIHRoZSBjbG9zZXN0IGZlYXR1cmUgaXMgYSBwb2ludCBvciBhIHZlcnRleCBhbmQgcmV0dXJucyB0aGUgc25hcHBlZCBmZWF0dXJlIGFjY29yZGluZ2x5LlxuXHQgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNvb3JkcyAtIFRoZSBjb29yZGluYXRlcyBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0gdG8gZmluZCB0aGUgY2xvc2VzdCBmZWF0dXJlIHRvLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IGlzUG9pbnQgLSBJbmRpY2F0ZXMgaWYgdGhlIGZlYXR1cmUgaXMgYSBwb2ludC5cblx0ICogQHBhcmFtIHtib29sZWFufSBpc1ZlcnRleCAtIEluZGljYXRlcyBpZiB0aGUgZmVhdHVyZSBpcyBhIHZlcnRleC5cblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHNuYXBwZWQgZmVhdHVyZSBiYXNlZCBvbiB0aGUgY2FsY3VsYXRlZCBjbG9zZXN0IHBvaW50IG9yIGxpbmUuXG5cdCAqL1xuICAgIHRoaXMuc2V0Q2xvc2VzdCA9IGZ1bmN0aW9uIChjb29yZHMsIGlzUG9pbnQsIGlzVmVydGV4KSB7XG4gICAgICAgIHZhciBzbmFwRmVhdHVyZSA9IG51bGw7XG4gICAgICAgIHZhciBjYWxjdWxhdGVkUmFkaXVzID0gZ2VvZmxvLm9wdGlvbnMuc25hcHBpbmcuZGlzdGFuY2UgKiBNYXRoLnBvdygyLCBNYXRoLm1heCgxLCAxOSAtIGdlb2Zsby5tYXAuZ2V0Wm9vbSgpKSk7XG4gICAgICAgIHZhciByYWRpdXNJbkttID0gY2FsY3VsYXRlZFJhZGl1cyAvIDEwMDAwMDtcbiAgICAgICAgdmFyIHBpeGVsRGlzdGFuY2UgPSBnZW9mbG8ub3B0aW9ucy5zbmFwcGluZy5waXhlbHMgPyBnZW9mbG8ub3B0aW9ucy5zbmFwcGluZy5waXhlbHMgKiBtZXRlcnNQZXJQaXhlbChjb29yZHNbMV0sIGdlb2Zsby5tYXAuZ2V0Wm9vbSgpKSA6IGZhbHNlO1xuICAgICAgICB2YXIgZmlsdGVyID0gZ2VvZmxvLnBpbmFibGVGZWF0dXJlcyAmJiBnZW9mbG8ucGluYWJsZUZlYXR1cmVzLmxlbmd0aCA/IFsnY2FzZScsIFsnYW55JywgLi4uZ2VvZmxvLnBpbmFibGVGZWF0dXJlcy5tYXAoZSA9PiBbXCI9PVwiLCBbXCJnZXRcIiwgXCJpZFwiXSwgZS5pZCB8fCBlLnByb3BlcnRpZXMuaWRdKV0sIGZhbHNlLCB0cnVlXSA6IGZhbHNlO1xuICAgICAgICB2YXIgbmVhckZlYXR1cmVzID0gZ2VvZmxvLmdldFJlbmRlcmVkRmVhdHVyZXMoeyBsbmc6IGNvb3Jkc1swXSwgbGF0OiBjb29yZHNbMV0gfSwgcmFkaXVzSW5LbSwgZmlsdGVyKTtcbiAgICAgICAgdmFyIGNsb3Nlc3RQb2ludCA9IG5lYXJGZWF0dXJlcyAmJiBuZWFyRmVhdHVyZXMubGVuZ3RoID8gZmluZENsb3Nlc3RQb2ludChuZWFyRmVhdHVyZXMsIGNvb3JkcywgcmFkaXVzSW5LbSwgcGl4ZWxEaXN0YW5jZSkgOiBmYWxzZTtcbiAgICAgICAgdmFyIGxhc3RDbGlja0Rpc3RhbmNlLCBsYXN0Q2xpY2tBcnJheSwgbGFzdENsaWNrRXF1YWw7XG5cbiAgICAgICAgZ2VvZmxvLmNsb3Nlc3RQb2ludCA9IGNsb3Nlc3RQb2ludDtcblxuICAgICAgICBpZiAoKCFuZWFyRmVhdHVyZXMgJiYgIWlzUG9pbnQpIHx8ICghY2xvc2VzdFBvaW50ICYmICFpc1BvaW50KSkgcmV0dXJuIHRoaXMudXBkYXRlRmVhdHVyZShjb29yZHMpO1xuICAgICAgICBpZiAoIWNsb3Nlc3RQb2ludCB8fCAhY2xvc2VzdFBvaW50LmNvb3JkcykgcmV0dXJuIHNuYXBGZWF0dXJlO1xuXG4gICAgICAgIGlmIChpc1ZlcnRleCB8fCAhZ2VvZmxvLmxhc3RDbGljaykge1xuICAgICAgICAgICAgc25hcEZlYXR1cmUgPSB0dXJmLnBvaW50KGNsb3Nlc3RQb2ludC5jb29yZHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGFzdENsaWNrQXJyYXkgPSBBcnJheS5pc0FycmF5KGdlb2Zsby5sYXN0Q2xpY2suY29vcmRzKSAmJiBBcnJheS5pc0FycmF5KGdlb2Zsby5sYXN0Q2xpY2suY29vcmRzWzBdKTtcbiAgICAgICAgICAgIGlmIChsYXN0Q2xpY2tBcnJheSkgZ2VvZmxvLmxhc3RDbGljay5jb29yZHMgPSBnZW9mbG8ubGFzdENsaWNrLmNvb3Jkc1swXTtcblxuICAgICAgICAgICAgbGFzdENsaWNrRGlzdGFuY2UgPSB0dXJmLmRpc3RhbmNlKHR1cmYucG9pbnQoY29vcmRzKSwgdHVyZi5wb2ludChnZW9mbG8ubGFzdENsaWNrLmNvb3JkcykpO1xuICAgICAgICAgICAgbGFzdENsaWNrRXF1YWwgPSBnZW9mbG8uVXRpbGl0aWVzLmlzUG9pbnRFcXVhbChnZW9mbG8ubGFzdENsaWNrLmNvb3JkcywgY2xvc2VzdFBvaW50LmNvb3Jkcyk7XG5cbiAgICAgICAgICAgIGlmIChsYXN0Q2xpY2tFcXVhbCAmJiBsYXN0Q2xpY2tEaXN0YW5jZSA+IGdlb2Zsby5vcHRpb25zLnNuYXBwaW5nLnRvbGVyYW5jZSkgcmV0dXJuIHRoaXMudXBkYXRlRmVhdHVyZShjb29yZHMpO1xuXG4gICAgICAgICAgICBzbmFwRmVhdHVyZSA9IHR1cmYubGluZVN0cmluZyhbZ2VvZmxvLmxhc3RDbGljay5jb29yZHMsIGNsb3Nlc3RQb2ludC5jb29yZHNdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdlb2Zsby5maXJlKCdzbmFwcGluZy5hZGQnLCB7IGNsb3Nlc3Q6IGNsb3Nlc3RQb2ludCwgc25hcHBlZDogc25hcEZlYXR1cmUgfSk7XG4gICAgICAgIHJldHVybiBzbmFwRmVhdHVyZTtcbiAgICB9XG5cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uU25hcHBpbmdcblx0ICogQG5hbWUgc2V0RmVhdHVyZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBzZXRzIGEgZmVhdHVyZSBvbiB0aGUgbWFwIHVzaW5nIHRoZSBwcm92aWRlZCBmZWF0dXJlIGFuZCBjb29yZGluYXRlcy4gSXQgaGFuZGxlcyBkaWZmZXJlbnQgc2NlbmFyaW9zIHN1Y2ggYXMgY3JlYXRpbmcgYSBwb2ludCwgbGluZSwgb3IgcG9seWdvbiBmZWF0dXJlIGJhc2VkIG9uIHRoZSBpbnB1dCBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZSAtIFRoZSBmZWF0dXJlIHRvIGJlIHNldCBvbiB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgLSBUaGUgY29vcmRpbmF0ZXMgZm9yIHRoZSBmZWF0dXJlLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZmVhdHVyZSB0aGF0IHdhcyBzZXQgb24gdGhlIG1hcC5cblx0ICovXG4gICAgdGhpcy5zZXRGZWF0dXJlID0gZnVuY3Rpb24gKGZlYXR1cmUsIGNvb3Jkcykge1xuICAgICAgICBpZiAoZ2VvZmxvLnRvdWNoQ2xpY2spIHJldHVybiBudWxsO1xuXG4gICAgICAgIGZlYXR1cmUgPSBmZWF0dXJlIHx8IGdlb2Zsby5zbmFwRmVhdHVyZTtcbiAgICAgICAgXG4gICAgICAgIGlmICghZmVhdHVyZSAmJiBjb29yZHMpIHJldHVybiBzZXRGZWF0dXJlKHR1cmYucG9pbnQoY29vcmRzKSk7XG4gICAgICAgIGlmICghZmVhdHVyZSkgcmV0dXJuIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNOQVApLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpLCBudWxsO1xuXG4gICAgICAgIHZhciBzbmFwQ29vcmRzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgdmFyIGxhc3RDbGljayA9IGNvb3JkcyB8fCBnZW9mbG8ubGFzdENsaWNrLmNvb3JkcztcbiAgICAgICAgdmFyIGZpcnN0Q2xpY2sgPSBnZW9mbG8uZmlyc3RDbGljay5jb29yZHM7XG4gICAgICAgIHZhciBpc1BvbHlnb24gPSB0aGlzLnR5cGUgPT09ICdQb2x5Z29uJyB8fCBmZWF0dXJlLnByb3BlcnRpZXMudHlwZSA9PT0gJ1BvbHlnb24nO1xuICAgICAgICB2YXIgaXNQb2x5bGluZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCI7XG5cbiAgICAgICAgaWYgKCFpc1BvbHlsaW5lIHx8IHNuYXBDb29yZHMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgZmVhdHVyZSA9IHNldEZlYXR1cmUoaXNQb2x5Z29uID8gdHVyZi5saW5lU3RyaW5nKFtmaXJzdENsaWNrLCBsYXN0Q2xpY2tdKSA6IHR1cmYucG9pbnQobGFzdENsaWNrKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvZmxvLmhvdEZlYXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBob3RDb29yZHMgPSBnZW9mbG8uaG90RmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgICAgIGlmIChpc1BvbHlnb24pIHNuYXBDb29yZHMucG9wKCk7XG4gICAgICAgICAgICBob3RDb29yZHMuc3BsaWNlLmFwcGx5KGhvdENvb3JkcywgWy0xLCAxXS5jb25jYXQoZ2VvZmxvLlV0aWxpdGllcy5jb25zdW1hYmxlQXJyYXkoc25hcENvb3JkcykpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdlb2Zsby5ob3RGZWF0dXJlID0gdHVyZi5saW5lU3RyaW5nKHNuYXBDb29yZHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2VvZmxvLlV0aWxpdGllcy5zZXRQcm9wZXJ0eShnZW9mbG8uaG90RmVhdHVyZSwgJ3R5cGUnLCB0aGlzLnR5cGUpO1xuXG4gICAgICAgIGZlYXR1cmUgPSBzZXRGZWF0dXJlKGlzUG9seWdvbiA/IHR1cmYubGluZVN0cmluZyhbZmlyc3RDbGljaywgbGFzdENsaWNrXSkgOiB0dXJmLnBvaW50KGxhc3RDbGljaykpO1xuICAgICAgICBnZW9mbG8uc25hcEZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICByZXR1cm4gZ2VvZmxvLnNuYXBGZWF0dXJlO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uU25hcHBpbmdcblx0ICogQG5hbWUgc2V0VmVydGV4XG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgdGhlIHZlcnRleCBiYXNlZCBvbiBzbmFwcGluZyBhbmQgcm91dGluZyBzZXR0aW5ncy4gSXQgc2V0cyB0aGUgY2xvc2VzdCBmZWF0dXJlIHdoZW4gc25hcHBpbmcgaXMgZW5hYmxlZCBhbmQgY2FsY3VsYXRlcyB0aGUgcm91dGUgaWYgcm91dGluZyBpcyBlbmFibGVkLiBJdCB1cGRhdGVzIHRoZSBtYXAgc291cmNlcyBhY2NvcmRpbmdseSBhbmQgdHJpZ2dlcnMgZXZlbnRzIHJlbGF0ZWQgdG8gdmVydGV4IGRyYWdnaW5nIGFuZCBzbmFwcGluZy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGdlb2ZsbyAtIFRoZSBjb250ZXh0IG9iamVjdCBjb250YWluaW5nIHZhcmlvdXMgc2V0dGluZ3MgYW5kIGRhdGEuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIHNuYXBwaW5nIGlzIGRpc2FibGVkIG9yIG5vIHNuYXBwZWQgdmVydGV4IGlzIGF2YWlsYWJsZS5cblx0ICovXG4gICAgdGhpcy5zZXRWZXJ0ZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzbmFwVG9GZWF0dXJlID0gZ2VvZmxvLlNuYXBwaW5nLmVuYWJsZWQ7XG4gICAgICAgIGlmIChnZW9mbG8uYnlwYXNzU25hcHBpbmcpIHNuYXBUb0ZlYXR1cmUgPSBmYWxzZTtcblxuICAgICAgICB2YXIgY2FsY3VsYXRlUm91dGUgPSBnZW9mbG8uUm91dGluZy5lbmFibGVkO1xuICAgICAgICBpZiAoZ2VvZmxvLmJ5cGFzc1JvdXRpbmcpIGNhbGN1bGF0ZVJvdXRlID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFzbmFwVG9GZWF0dXJlIHx8ICFnZW9mbG8uc25hcHBlZFZlcnRleCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGdlb2Zsby5zbmFwRmVhdHVyZSA9IHRoaXMuc2V0Q2xvc2VzdChnZW9mbG8uc25hcHBlZFZlcnRleCwgdHJ1ZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGNhbGN1bGF0ZVJvdXRlKSBnZW9mbG8uc25hcEZlYXR1cmUgPSBnZW9mbG8uUm91dGluZy5nZXRDbG9zZXN0KCkgfHwgZ2VvZmxvLnNuYXBGZWF0dXJlO1xuICAgICAgICBpZiAoIWdlb2Zsby5zbmFwRmVhdHVyZSkgcmV0dXJuIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNOQVApLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuXG4gICAgICAgIGdlb2Zsby5VdGlsaXRpZXMuc2V0UHJvcGVydHkoZ2VvZmxvLnNuYXBGZWF0dXJlLCAndHlwZScsIGdlb2Zsby5jdXJyZW50TW9kZS50eXBlKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXNbY2FsY3VsYXRlUm91dGUgPyAnUk9VVEUnIDogJ1NOQVAnXSkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtnZW9mbG8uc25hcEZlYXR1cmVdKSk7XG5cbiAgICAgICAgZ2VvZmxvLmhvdEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbZ2VvZmxvLmRyYWdJbmRleF0gPSBnZW9mbG8uc25hcEZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIGdlb2Zsby5tYXAuZ2V0U291cmNlKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkhPVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtnZW9mbG8uaG90RmVhdHVyZV0pKTtcbiAgICAgICAgZ2VvZmxvLmZpcmUoJ3ZlcnRleC5kcmFnc25hcCcsIHsgZmVhdHVyZTogZ2VvZmxvLmhvdEZlYXR1cmUsIHZlcnRleDogdHVyZi5wb2ludChnZW9mbG8uc25hcHBlZFZlcnRleCkgfSk7XG4gICAgfVxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlNuYXBwaW5nXG5cdCAqIEBuYW1lIGFkZEZlYXR1cmVcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gYWRkcyBhIGZlYXR1cmUgdG8gdGhlIG1hcCBieSBzZXR0aW5nIHRoZSBkYXRhIG9mIHRoZSBzcGVjaWZpZWQgc291cmNlIHdpdGggdGhlIHByb3ZpZGVkIGZlYXR1cmUuIEl0IGFsc28gdXBkYXRlcyB0aGUgcHJvcGVydGllcyBvZiB0aGUgZmVhdHVyZSBpZiBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgLSBUaGUgZmVhdHVyZSB0byBiZSBhZGRlZCB0byB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIC0gQWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRvIGJlIGFzc2lnbmVkIHRvIHRoZSBmZWF0dXJlLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtkb250QWRkXSAtIEZsYWcgdG8gcHJldmVudCBhZGRpbmcgdGhlIGZlYXR1cmUgaWYgc2V0IHRvIHRydWUuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIHRoZSBmZWF0dXJlIGlzIG5vdCBwcm92aWRlZCBvciBpZiBkb250QWRkIGZsYWcgaXMgc2V0LlxuXHQgKi9cbiAgICB0aGlzLmFkZEZlYXR1cmUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgcHJvcGVydGllcz17fSwgZG9udEFkZCkge1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlc1snU05BUCddKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXNbJ1JPVVRFJ10pLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuICAgICAgICBpZiAoIWZlYXR1cmUgfHwgZG9udEFkZCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAocHJvcGVydGllcykgZmVhdHVyZS5wcm9wZXJ0aWVzID0gZ2VvZmxvLlV0aWxpdGllcy5hc3NpZ25EZWVwKGdlb2Zsby5VdGlsaXRpZXMuY2xvbmVEZWVwKHByb3BlcnRpZXMpLCBmZWF0dXJlLnByb3BlcnRpZXMpO1xuICAgICAgICBnZW9mbG8uc25hcEZlYXR1cmUgPSBmZWF0dXJlO1xuICAgICAgICBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlc1tmZWF0dXJlLnByb3BlcnRpZXMucm91dGluZyA/ICdST1VURScgOiAnU05BUCddKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2dlb2Zsby5zbmFwRmVhdHVyZV0pKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlNuYXBwaW5nXG5cdCAqIEBuYW1lIHVwZGF0ZUZlYXR1cmVcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdXBkYXRlcyBhIGZlYXR1cmUgYmFzZWQgb24gdGhlIGV2ZW50IGNvb3JkaW5hdGVzIHByb3ZpZGVkLiBJdCBkZXRlcm1pbmVzIHRoZSB0eXBlIG9mIGZlYXR1cmUsIGNhbGN1bGF0ZXMgdGhlIG5lY2Vzc2FyeSBjb29yZGluYXRlcywgY3JlYXRlcyBhIGxpbmUgZmVhdHVyZSB3aXRoIGhpbnQgcHJvcGVydGllcywgYW5kIGNvbnZlcnRzIHVuaXRzIGlmIG5lZWRlZC5cblx0ICogQHBhcmFtIHtBcnJheX0gZXZ0Q29vcmRzIC0gVGhlIGV2ZW50IGNvb3JkaW5hdGVzIHRvIHVwZGF0ZSB0aGUgZmVhdHVyZS5cblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHVwZGF0ZWQgZmVhdHVyZSBiYXNlZCBvbiB0aGUgZXZlbnQgY29vcmRpbmF0ZXMuXG5cdCAqL1xuICAgIHRoaXMudXBkYXRlRmVhdHVyZSA9IGZ1bmN0aW9uIChldnRDb29yZHMpIHtcbiAgICAgICAgZ2VvZmxvLmNsb3Nlc3RQb2ludCA9IG51bGw7XG4gICAgICAgIGlmICghZ2VvZmxvLmxhc3RDbGljaykgcmV0dXJuIG51bGw7XG4gICAgICAgIGlmICghZ2VvZmxvLmZpcnN0Q2xpY2sgfHwgZ2VvZmxvLm1vdXNlSXNEb3duKSByZXR1cm4gbnVsbDtcbiAgICBcbiAgICAgICAgdmFyIHR5cGUgPSBnZW9mbG8uRmVhdHVyZXMuZ2V0VHlwZShnZW9mbG8uaG90RmVhdHVyZSkgfHwgZ2VvZmxvLmN1cnJlbnRNb2RlLnR5cGU7XG4gICAgICAgIHZhciBjb29yZHMgPSBnZW9mbG8uaG90RmVhdHVyZSA/IGdlb2Zsby5VdGlsaXRpZXMuZ2V0TGFzdEluZGV4Q29vcmRzKGdlb2Zsby5ob3RGZWF0dXJlKSA6IGdlb2Zsby5sYXN0Q2xpY2suY29vcmRzO1xuICAgICAgICB2YXIgdmVydGV4ID0gdHVyZi5wb2ludChldnRDb29yZHMpO1xuICAgICAgICB2YXIgaGludENvb3JkcyA9IHR5cGUgJiYgdHlwZSA9PT0gXCJQb2x5Z29uXCIgJiYgZ2VvZmxvLmhvdEZlYXR1cmUgPyBbY29vcmRzLCBldnRDb29yZHMsIGdlb2Zsby5maXJzdENsaWNrLmNvb3Jkc10gOiBbY29vcmRzLCBldnRDb29yZHNdO1xuICAgICAgICB2YXIgZmVhdHVyZSA9IHR1cmYubGluZVN0cmluZyhoaW50Q29vcmRzKTtcblxuICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMudHlwZSA9IHR5cGU7XG4gICAgICAgIGZlYXR1cmUucHJvcGVydGllcy5oaW50ID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIHZhciB1bml0ID0gJ2ZlZXQnO1xuICAgICAgICB2YXIgdW5pdHMgPSBnZW9mbG8uRmVhdHVyZXMuY29udmVydFVuaXRzKGdlb2Zsby5ob3RGZWF0dXJlLCAwLCB1bml0KTtcbiAgICAgICAgdW5pdHMgKz0gZ2VvZmxvLkZlYXR1cmVzLmNvbnZlcnRVbml0cyhmZWF0dXJlLCAwLCB1bml0KTtcbiAgICAgICAgdmVydGV4ID0gdXBkYXRlVmVydGV4KHZlcnRleCwgeyB1bml0czogdW5pdHMsIHVuaXQ6IHVuaXQgfSk7XG5cbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgfVxuXG5cblxuXG4gICAgaWYgKGdlb2Zsby5vcHRpb25zWydzbmFwcGluZyddLmVuYWJsZSkgdGhpcy5hY3RpdmF0ZSgpO1xuXG5cblxuXG4gICAgZnVuY3Rpb24gY2hlYXBSdWxlciAobGF0LCB1bml0cykge1xuICAgICAgICBmdW5jdGlvbiBjaGVhcHJ1bGVyKGxhdCwgdW5pdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlYXBSdWxlcihsYXQsdW5pdHMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjaGVhcHJ1bGVyLmZyb21UaWxlID0gZnVuY3Rpb24oeSwgeiwgdW5pdHMpIHtcbiAgICAgICAgICAgIHZhciBuID0gTWF0aC5QSSAqICgxIC0gMiAqICh5ICsgMC41KSAvIE1hdGgucG93KDIsIHopKTtcbiAgICAgICAgICAgIHZhciBsYXQgPSBNYXRoLmF0YW4oMC41ICogKE1hdGguZXhwKG4pIC0gTWF0aC5leHAoLW4pKSkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaGVhcFJ1bGVyKGxhdCx1bml0cyk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBjaGVhcHJ1bGVyLnVuaXRzID0ge1xuICAgICAgICAgICAga2lsb21ldGVyczogMSxcbiAgICAgICAgICAgIG1pbGVzOiAxMDAwIC8gMTYwOS4zNDQsXG4gICAgICAgICAgICBuYXV0aWNhbG1pbGVzOiAxMDAwIC8gMTg1MixcbiAgICAgICAgICAgIG1ldGVyczogMTAwMCxcbiAgICAgICAgICAgIG1ldHJlczogMTAwMCxcbiAgICAgICAgICAgIHlhcmRzOiAxMDAwIC8gMC45MTQ0LFxuICAgICAgICAgICAgZmVldDogMTAwMCAvIDAuMzA0OCxcbiAgICAgICAgICAgIGluY2hlczogMTAwMCAvIDAuMDI1NFxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gQ2hlYXBSdWxlcihsYXQsIHVuaXRzKSB7XG4gICAgICAgICAgICB2YXIgZmFjdG9ycyA9IHtcbiAgICAgICAgICAgICAgICBraWxvbWV0ZXJzOiAxLFxuICAgICAgICAgICAgICAgIG1pbGVzOiAxMDAwIC8gMTYwOS4zNDQsXG4gICAgICAgICAgICAgICAgbmF1dGljYWxtaWxlczogMTAwMCAvIDE4NTIsXG4gICAgICAgICAgICAgICAgbWV0ZXJzOiAxMDAwLFxuICAgICAgICAgICAgICAgIG1ldHJlczogMTAwMCxcbiAgICAgICAgICAgICAgICB5YXJkczogMTAwMCAvIDAuOTE0NCxcbiAgICAgICAgICAgICAgICBmZWV0OiAxMDAwIC8gMC4zMDQ4LFxuICAgICAgICAgICAgICAgIGluY2hlczogMTAwMCAvIDAuMDI1NFxuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIGlmIChsYXQgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGxhdGl0dWRlIGdpdmVuLicpO1xuICAgICAgICAgICAgaWYgKHVuaXRzICYmICFmYWN0b3JzW3VuaXRzXSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdW5pdCAnICsgdW5pdHMgKyAnLiBVc2Ugb25lIG9mOiAnICsgT2JqZWN0LmtleXMoZmFjdG9ycykpO1xuICAgICAgICBcbiAgICAgICAgICAgIHZhciBtID0gdW5pdHMgPyBmYWN0b3JzW3VuaXRzXSA6IDE7XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGxhdCAqIE1hdGguUEkgLyAxODApO1xuICAgICAgICAgICAgdmFyIGNvczIgPSAyICogY29zICogY29zIC0gMTtcbiAgICAgICAgICAgIHZhciBjb3MzID0gMiAqIGNvcyAqIGNvczIgLSBjb3M7XG4gICAgICAgICAgICB2YXIgY29zNCA9IDIgKiBjb3MgKiBjb3MzIC0gY29zMjtcbiAgICAgICAgICAgIHZhciBjb3M1ID0gMiAqIGNvcyAqIGNvczQgLSBjb3MzO1xuICAgICAgICBcbiAgICAgICAgICAgIHRoaXMua3ggPSBtICogKDExMS40MTUxMyAqIGNvcyAtIDAuMDk0NTUgKiBjb3MzICsgMC4wMDAxMiAqIGNvczUpO1xuICAgICAgICAgICAgdGhpcy5reSA9IG0gKiAoMTExLjEzMjA5IC0gMC41NjYwNSAqIGNvczIgKyAwLjAwMTIgKiBjb3M0KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgQ2hlYXBSdWxlci5wcm90b3R5cGUgPSB7XG4gICAgICAgICAgICBlcXVhbHM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFbMF0gPT09IGJbMF0gJiYgYVsxXSA9PT0gYlsxXTtcbiAgICAgICAgICAgIH0sXG4gICAgICBcbiAgICAgICAgICAgIGludGVycG9sYXRlOiBmdW5jdGlvbiAoYSwgYiwgdCkge1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IGJbMF0gLSBhWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IGJbMV0gLSBhWzFdO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYVswXSArIGR4ICogdCwgYVsxXSArIGR5ICogdF07XG4gICAgICAgICAgICB9LFxuICAgICAgXG4gICAgICAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICAgIHZhciBkeCA9IChhWzBdIC0gYlswXSkgKiB0aGlzLmt4O1xuICAgICAgICAgICAgICAgIHZhciBkeSA9IChhWzFdIC0gYlsxXSkgKiB0aGlzLmt5O1xuICAgICAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgICAgICBiZWFyaW5nOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGR4ID0gKGJbMF0gLSBhWzBdKSAqIHRoaXMua3g7XG4gICAgICAgICAgICAgICAgdmFyIGR5ID0gKGJbMV0gLSBhWzFdKSAqIHRoaXMua3k7XG4gICAgICAgICAgICAgICAgaWYgKCFkeCAmJiAhZHkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIHZhciBiZWFyaW5nID0gTWF0aC5hdGFuMigtZHksIGR4KSAqIDE4MCAvIE1hdGguUEkgKyA5MDtcbiAgICAgICAgICAgICAgICBpZiAoYmVhcmluZyA+IDE4MClcbiAgICAgICAgICAgICAgICAgICAgYmVhcmluZyAtPSAzNjA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJlYXJpbmc7XG4gICAgICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBmdW5jdGlvbihwLCBkaXN0LCBiZWFyaW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAoOTAgLSBiZWFyaW5nKSAqIE1hdGguUEkgLyAxODA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub2Zmc2V0KHAsIE1hdGguY29zKGEpICogZGlzdCwgTWF0aC5zaW4oYSkgKiBkaXN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAgICAgb2Zmc2V0OiBmdW5jdGlvbihwLCBkeCwgZHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3BbMF0gKyBkeCAvIHRoaXMua3gsIHBbMV0gKyBkeSAvIHRoaXMua3ldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgICAgICBsaW5lRGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50cykge1xuICAgICAgICAgICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvdGFsICs9IHRoaXMuZGlzdGFuY2UocG9pbnRzW2ldLCBwb2ludHNbaSArIDFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgICAgICBhcmVhOiBmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seWdvbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmluZyA9IHBvbHlnb25baV07XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gcmluZy5sZW5ndGgsIGsgPSBsZW4gLSAxOyBqIDwgbGVuOyBrID0gaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdW0gKz0gKHJpbmdbal1bMF0gLSByaW5nW2tdWzBdKSAqIChyaW5nW2pdWzFdICsgcmluZ1trXVsxXSkgKiAoaSA/IC0xIDogMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiAoTWF0aC5hYnMoc3VtKSAvIDIpICogdGhpcy5reCAqIHRoaXMua3k7XG4gICAgICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgICAgIGFsb25nOiBmdW5jdGlvbihsaW5lLCBkaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1bSA9IDA7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChkaXN0IDw9IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsaW5lWzBdO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMCA9IGxpbmVbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMSA9IGxpbmVbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGlzdGFuY2UocDAsIHAxKTtcbiAgICAgICAgICAgICAgICAgICAgc3VtICs9IGQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdW0gPiBkaXN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJwb2xhdGUocDAsIHAxLCAoZGlzdCAtIChzdW0gLSBkKSkgLyBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHJldHVybiBsaW5lW2xpbmUubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgICAgIHBvaW50T25MaW5lOiBmdW5jdGlvbihsaW5lLCBwKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1pbkRpc3QgPSBJbmZpbml0eTtcbiAgICAgICAgICAgICAgICB2YXIgbWluWCwgbWluWSwgbWluSSwgbWluVDtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIHggPSBsaW5lW2ldWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgeSA9IGxpbmVbaV1bMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBkeCA9IChsaW5lW2kgKyAxXVswXSAtIHgpICogdGhpcy5reDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gKGxpbmVbaSArIDFdWzFdIC0geSkgKiB0aGlzLmt5O1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSAoKHBbMF0gLSB4KSAqIHRoaXMua3ggKiBkeCArIChwWzFdIC0geSkgKiB0aGlzLmt5ICogZHkpIC8gKGR4ICogZHggKyBkeSAqIGR5KTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gbGluZVtpICsgMV1bMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGxpbmVbaSArIDFdWzFdO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ICs9IChkeCAvIHRoaXMua3gpICogdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5ICs9IChkeSAvIHRoaXMua3kpICogdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZHggPSAocFswXSAtIHgpICogdGhpcy5reDtcbiAgICAgICAgICAgICAgICAgICAgZHkgPSAocFsxXSAtIHkpICogdGhpcy5reTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBzcURpc3QgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNxRGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkRpc3QgPSBzcURpc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5YID0geDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pblkgPSB5O1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluSSA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5UID0gdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IFttaW5YLCBtaW5ZXSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IG1pbkksXG4gICAgICAgICAgICAgICAgICAgIHQ6IG1pblRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgICAgICBsaW5lU2xpY2U6IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBsaW5lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAxID0gdGhpcy5wb2ludE9uTGluZShsaW5lLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgdmFyIHAyID0gdGhpcy5wb2ludE9uTGluZShsaW5lLCBzdG9wKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHAxLmluZGV4ID4gcDIuaW5kZXggfHwgKHAxLmluZGV4ID09PSBwMi5pbmRleCAmJiBwMS50ID4gcDIudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHAxO1xuICAgICAgICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgICAgICAgICBwMiA9IHRtcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBzbGljZSA9IFtwMS5wb2ludF07XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBsID0gcDEuaW5kZXggKyAxO1xuICAgICAgICAgICAgICAgIHZhciByID0gcDIuaW5kZXg7XG4gICAgICAgIFxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5lcXVhbHMobGluZVtsXSwgc2xpY2VbMF0pICYmIGwgPD0gcilcbiAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaChsaW5lW2xdKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IGwgKyAxOyBpIDw9IHI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKGxpbmVbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmVxdWFscyhsaW5lW3JdLCBwMi5wb2ludCkpXG4gICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2gocDIucG9pbnQpO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICBcbiAgICAgICAgICAgIGxpbmVTbGljZUFsb25nOiBmdW5jdGlvbihzdGFydCwgc3RvcCwgbGluZSkge1xuICAgICAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgICAgIHZhciBzbGljZSA9IFtdO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmUubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMCA9IGxpbmVbaV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBwMSA9IGxpbmVbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuZGlzdGFuY2UocDAsIHAxKTtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHN1bSArPSBkO1xuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1bSA+IHN0YXJ0ICYmIHNsaWNlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xpY2UucHVzaCh0aGlzLmludGVycG9sYXRlKHAwLCBwMSwgKHN0YXJ0IC0gKHN1bSAtIGQpKSAvIGQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN1bSA+PSBzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGljZS5wdXNoKHRoaXMuaW50ZXJwb2xhdGUocDAsIHAxLCAoc3RvcCAtIChzdW0gLSBkKSkgLyBkKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xpY2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdW0gPiBzdGFydClcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWNlLnB1c2gocDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNsaWNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgICAgICBidWZmZXJQb2ludDogZnVuY3Rpb24ocCwgYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBidWZmZXIgLyB0aGlzLmt5O1xuICAgICAgICAgICAgICAgIHZhciBoID0gYnVmZmVyIC8gdGhpcy5reDtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3BbMF0gLSBoLCBwWzFdIC0gdiwgcFswXSArIGgsIHBbMV0gKyB2XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAgICAgYnVmZmVyQkJveDogZnVuY3Rpb24oYmJveCwgYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIHYgPSBidWZmZXIgLyB0aGlzLmt5O1xuICAgICAgICAgICAgICAgIHZhciBoID0gYnVmZmVyIC8gdGhpcy5reDtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Jib3hbMF0gLSBoLCBiYm94WzFdIC0gdiwgYmJveFsyXSArIGgsIGJib3hbM10gKyB2XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIFxuICAgICAgICAgICAgaW5zaWRlQkJveDogZnVuY3Rpb24ocCwgYmJveCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwWzBdID49IGJib3hbMF0gJiYgcFswXSA8PSBiYm94WzJdICYmIHBbMV0gPj0gYmJveFsxXSAmJiBwWzFdIDw9IGJib3hbM107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIFxuICAgICAgICByZXR1cm4gY2hlYXBydWxlcihsYXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kQ2xvc2VzdFBvaW50ICh1bmlxdWVGZWF0dXJlcywgZXZ0Q29vcmRzLCByYWRpdXNJbkttLCBwaXhlbERpc3RhbmNlKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IGNhbGN1bGF0ZVBvaW50c09uTGluZSh1bmlxdWVGZWF0dXJlcywgZXZ0Q29vcmRzKTtcbiAgXG4gICAgICAgIGxldCBjbG9zZXN0VmVydGV4ID0gbnVsbDtcbiAgICAgICAgbGV0IGNsb3Nlc3RMaW5lcG9pbnQgPSBudWxsO1xuICAgICAgICBsZXQgYm9yZGVycztcbiAgICAgICAgbGV0IGlkID0gZ2VvZmxvLmlkIHx8ICdpZCc7XG4gIFxuICAgICAgICBjb29yZHMuZm9yRWFjaCgocG9pbnRUeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXN0ID0gcG9pbnRUeXBlLmRpc3Q7XG4gIFxuICAgICAgICAgICAgaWYgKGRpc3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRUeXBlLnR5cGUgPT09IFwidmVydGV4XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RWZXJ0ZXggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RWZXJ0ZXggPSBwb2ludFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocGl4ZWxEaXN0YW5jZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdCAqIDEwMDAgPCBwaXhlbERpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3Nlc3RWZXJ0ZXggJiYgY2xvc2VzdFZlcnRleC5saW5lRWRnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0VmVydGV4ID0gcG9pbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0IDw9IGNsb3Nlc3RWZXJ0ZXguZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRpc3QgPT09IGNsb3Nlc3RWZXJ0ZXguZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0VmVydGV4LmxpbmVFZGdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RWZXJ0ZXggPSBwb2ludFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0VmVydGV4ID0gcG9pbnRUeXBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0IDwgcmFkaXVzSW5LbSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdExpbmVwb2ludCAhPT0gbnVsbCAmJiBkaXN0ID09PSBjbG9zZXN0TGluZXBvaW50LmRpc3QgJiYgY2xvc2VzdExpbmVwb2ludFtpZF0gIT09IHBvaW50VHlwZVtpZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbG9zZXN0TGluZXBvaW50LnR5cGUgPT09IFwibGluZXBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKHBvaW50VHlwZS5kaXN0YW5jZTEgPD0gY2xvc2VzdExpbmVwb2ludC5kaXN0YW5jZTEgJiYgcG9pbnRUeXBlLmRpc3RhbmNlMiA8PSBjbG9zZXN0TGluZXBvaW50LmRpc3RhbmNlMikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKHBvaW50VHlwZS5kaXN0YW5jZTIgPD0gY2xvc2VzdExpbmVwb2ludC5kaXN0YW5jZTEgJiYgcG9pbnRUeXBlLmRpc3RhbmNlMSA8PSBjbG9zZXN0TGluZXBvaW50LmRpc3RhbmNlMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJzd2l0Y2ggY2xvc2VzdCBwb2ludHNcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3RMaW5lcG9pbnQgPSBwb2ludFR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gIFxuICAgICAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdExpbmVwb2ludCA9PT0gbnVsbCB8fCBkaXN0IDwgY2xvc2VzdExpbmVwb2ludC5kaXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0TGluZXBvaW50ID0gcG9pbnRUeXBlO1xuICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwb2ludFR5cGUuYm9yZGVyMSAmJiBwb2ludFR5cGUuYm9yZGVyMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcnMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlcjE6IHBvaW50VHlwZS5ib3JkZXIxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXIyOiBwb2ludFR5cGUuYm9yZGVyMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UxOiBwb2ludFR5cGUuZGlzdGFuY2UxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXN0YW5jZTI6IHBvaW50VHlwZS5kaXN0YW5jZTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3JkZXJzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gIFxuICAgICAgICBpZiAoY2xvc2VzdFZlcnRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGNsb3Nlc3RMaW5lcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2xvc2VzdFZlcnRleC5kaXN0IDwgcmFkaXVzSW5LbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGJvcmRlcnM6IG51bGwgfSwgY2xvc2VzdFZlcnRleCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBib3JkZXJzOiBib3JkZXJzIH0sIGNsb3Nlc3RMaW5lcG9pbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBib3JkZXJzOiBudWxsIH0sIGNsb3Nlc3RWZXJ0ZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNsb3Nlc3RMaW5lcG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsgYm9yZGVyczogYm9yZGVycyB9LCBjbG9zZXN0TGluZXBvaW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvc2VzdFBvaW50cyAocnVsZXIsIGNvb3JkaW5hdGVzLCBldnRDb29yZHMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGNvbnN0IHBvaW50T25MaW5lID0gcnVsZXIucG9pbnRPbkxpbmUoY29vcmRpbmF0ZXMsIGV2dENvb3Jkcyk7XG4gICAgICAgIGNvbnN0IHBvaW50Q29vcmRzID0gcG9pbnRPbkxpbmUucG9pbnQ7XG4gICAgICAgIGNvbnN0IHBvaW50SW5kZXggPSBwb2ludE9uTGluZS5pbmRleDtcbiAgICAgICAgY29uc3QgbGluZVBvaW50ID0geyB0eXBlOiBcImxpbmVwb2ludFwiLCBjb29yZHM6IHBvaW50Q29vcmRzIH07XG4gICAgICAgIGNvbnN0IHAxID0gY29vcmRpbmF0ZXNbcG9pbnRJbmRleF07XG4gICAgICAgIGNvbnN0IHAyID0gY29vcmRpbmF0ZXNbcG9pbnRJbmRleCArIDFdO1xuICAgICAgICBjb25zdCBkaXN0YW5jZTEgPSBydWxlci5kaXN0YW5jZShwMSwgZXZ0Q29vcmRzKTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UyID0gcnVsZXIuZGlzdGFuY2UocDIsIGV2dENvb3Jkcyk7XG5cbiAgICAgICAgbGV0IGxpbmVFZGdlID0gZmFsc2U7XG4gICAgICAgIGxldCB2ZXJ0ZXggPSBudWxsO1xuICAgIFxuICAgICAgICBpZiAoZGlzdGFuY2UxIDwgZGlzdGFuY2UyKSB7XG4gICAgICAgICAgICBsaW5lRWRnZSA9IHBvaW50SW5kZXggPT09IDA7XG4gICAgICAgICAgICB2ZXJ0ZXggPSBwMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVFZGdlID0gcG9pbnRJbmRleCArIDEgPT09IGNvb3JkaW5hdGVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2ZXJ0ZXggPSBwMjtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBsaW5lUG9pbnQuYm9yZGVyMSA9IHAxO1xuICAgICAgICBsaW5lUG9pbnQuZGlzdGFuY2UxID0gZGlzdGFuY2UxO1xuICAgICAgICBsaW5lUG9pbnQuYm9yZGVyMiA9IHAyO1xuICAgICAgICBsaW5lUG9pbnQuZGlzdGFuY2UyID0gZGlzdGFuY2UyO1xuICAgIFxuICAgICAgICByZXN1bHQucHVzaChsaW5lUG9pbnQpO1xuICAgICAgICByZXN1bHQucHVzaCh7IHR5cGU6IFwidmVydGV4XCIsIGNvb3JkczogdmVydGV4LCBsaW5lRWRnZTogbGluZUVkZ2UgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsY3VsYXRlUG9pbnRzT25MaW5lICh1bmlxdWVGZWF0dXJlcywgZXZ0Q29vcmRzKSB7XG4gICAgICAgIGNvbnN0IGNvb3JkcyA9IFtdO1xuICAgICAgICBjb25zdCBrbm93bklkcyA9IHt9O1xuICAgICAgICBjb25zdCBydWxlciA9IGNoZWFwUnVsZXIoZXZ0Q29vcmRzWzFdKTtcbiAgICBcbiAgICAgICAgdW5pcXVlRmVhdHVyZXMuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBmZWF0dXJlLmlkIHx8IGZlYXR1cmUucHJvcGVydGllcy5pZDtcbiAgICAgICAgICAgIHZhciBjbG9zZXN0ID0gW107XG4gICAgXG4gICAgICAgICAgICBpZiAoa25vd25JZHNbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBrbm93bklkc1tpZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0ID0gY2xvc2VzdFBvaW50cyhydWxlciwgZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcywgZXZ0Q29vcmRzKTtcbiAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjbG9zZXN0LmZvckVhY2goKHBvaW50VHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50VHlwZS5pZCA9IGlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50VHlwZS5kaXN0ID0gcnVsZXIuZGlzdGFuY2UocG9pbnRUeXBlLmNvb3JkcywgZXZ0Q29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHMucHVzaChwb2ludFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIm5vIGNvb3JkaW5hdGVzOiBcIiwgZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwiUG9pbnRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwb2ludFR5cGUgPSB7IGlkOiBpZCwgdHlwZTogXCJ2ZXJ0ZXhcIiwgY29vcmRzOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBsaW5lRWRnZTogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgICAgICBwb2ludFR5cGUuZGlzdCA9IHJ1bGVyLmRpc3RhbmNlKHBvaW50VHlwZS5jb29yZHMsIGV2dENvb3Jkcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoKHBvaW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSBcIlBvbHlnb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHVyZi5ib29sZWFuV2l0aGluKHR1cmYucG9pbnQoZXZ0Q29vcmRzKSwgZmVhdHVyZSkpIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaCgoZmVhdHVyZUNvb3JkcywgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QgPSBjbG9zZXN0UG9pbnRzKHJ1bGVyLCBmZWF0dXJlQ29vcmRzLCBldnRDb29yZHMpO1xuICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb3Nlc3QuZm9yRWFjaCgocG9pbnRUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRUeXBlLmlkID0gaWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRUeXBlLnBvbHlnb25Db29yZHNBcnJheSA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50VHlwZS5kaXN0ID0gcnVsZXIuZGlzdGFuY2UocG9pbnRUeXBlLmNvb3JkcywgZXZ0Q29vcmRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb29yZHMucHVzaChwb2ludFR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgXG4gICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVmVydGV4IChzdGFydFBvaW50LCBlbmRQb2ludCwgbGVuZ3RoLCBkYXRhKSB7XG4gICAgICAgIHZhciBzdGFydERhdGEgPSBkYXRhW3N0YXJ0UG9pbnRdO1xuICAgIFxuICAgICAgICBpZiAoIXN0YXJ0RGF0YSkge1xuICAgICAgICAgICAgc3RhcnREYXRhID0ge307XG4gICAgICAgICAgICBkYXRhW3N0YXJ0UG9pbnRdID0gc3RhcnREYXRhO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmICghc3RhcnREYXRhW2VuZFBvaW50XSkge1xuICAgICAgICAgICAgc3RhcnREYXRhW2VuZFBvaW50XSA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFZlcnRleFBvaW50VHdvV2F5IChzdGFydENvb3JkLCBlbmRDb29yZHMsIGxlbmd0aCwgZGF0YSkge1xuICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHN0YXJ0Q29vcmQuam9pbihcIiNcIik7XG4gICAgICAgIHZhciBlbmRQb2ludCA9IGVuZENvb3Jkcy5qb2luKFwiI1wiKTtcbiAgICAgICAgYWRkVmVydGV4KHN0YXJ0UG9pbnQsIGVuZFBvaW50LCBsZW5ndGgsIGRhdGEpO1xuICAgICAgICBhZGRWZXJ0ZXgoZW5kUG9pbnQsIHN0YXJ0UG9pbnQsIGxlbmd0aCwgZGF0YSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIG1ldGVyc1BlclBpeGVsIChsYXRpdHVkZSwgem9vbUxldmVsKSB7XG4gICAgICAgIHJldHVybiAoKGdlb2Zsby5zdGF0aWNzLmNvbnN0YW50cy5DSVJDVU0gKiBNYXRoLmNvcygobGF0aXR1ZGUgKiAoTWF0aC5QSSAvIDE4MCkpKSkgLyBNYXRoLnBvdygyLCB6b29tTGV2ZWwgKyA4KSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHNldEZlYXR1cmUgKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlKSByZXR1cm4gZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU05BUCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtdKSksIGdlb2Zsby5zbmFwRmVhdHVyZTtcbiAgICAgICAgZ2VvZmxvLlV0aWxpdGllcy5zZXRQcm9wZXJ0eShmZWF0dXJlLCAndHlwZScsIGdlb2Zsby5jdXJyZW50TW9kZS50eXBlKTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU05BUCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtmZWF0dXJlXSkpO1xuICAgICAgICByZXR1cm4gZmVhdHVyZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVWZXJ0ZXggKHZlcnRleCwgb3B0aW9ucz17fSkge1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSBnZW9mbG8ubWFwLmdldFNvdXJjZShnZW9mbG8uc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5IT1RURVhUKS5fZGF0YS5mZWF0dXJlcztcbiAgICAgICAgaWYgKGZlYXR1cmVzLmxlbmd0aCAmJiBmZWF0dXJlc1tmZWF0dXJlcy5sZW5ndGggLSAxXS5wcm9wZXJ0aWVzLm1vdXNlTGluZSkgZmVhdHVyZXMucG9wKCk7XG5cbiAgICAgICAgdmVydGV4LnByb3BlcnRpZXMudW5pdHMgPSBvcHRpb25zLnVuaXRzO1xuICAgICAgICB2ZXJ0ZXgucHJvcGVydGllcy51bml0ID0gb3B0aW9ucy51bml0O1xuICAgICAgICB2ZXJ0ZXgucHJvcGVydGllcy50ZXh0ID0gYCR7b3B0aW9ucy51bml0c30gJHtvcHRpb25zLnVuaXR9YDtcbiAgICAgICAgdmVydGV4LnByb3BlcnRpZXMudHJhbnNmb3JtID0gJ3VwcGVyY2FzZSc7XG4gICAgICAgIHZlcnRleC5wcm9wZXJ0aWVzLmFuY2hvciA9ICd0b3AtbGVmdCc7XG4gICAgICAgIHZlcnRleC5wcm9wZXJ0aWVzLm1vdXNlTGluZSA9IHRydWU7XG4gICAgXG4gICAgICAgIGZlYXR1cmVzLnB1c2godmVydGV4KTtcbiAgICAgICAgZ2VvZmxvLm1hcC5nZXRTb3VyY2UoZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuSE9UVEVYVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKSk7XG4gICAgICAgIHJldHVybiB2ZXJ0ZXg7XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgU25hcHBpbmc7IiwiY29uc3QgRGV2ID0gJ3NvbHV0ZWdyYXRlJztcbmNvbnN0IElkID0gJ2dlb2Zsbyc7XG5cbmNvbnN0IFN0YXRpY3MgPSB7XG4gICAgZGV2ZWxvcGVyOiBEZXYsXG4gICAgaWQ6IElkLFxuICAgIGxvZ286IHtcbiAgICAgICAgZnVsbDogYGh0dHBzOi8vJHtJZH0uczMuYW1hem9uYXdzLmNvbS9sb2dvcy9sb2dvX2Z1bGxfd2hpdGUucG5nYCxcbiAgICAgICAgaWNvbjogYGh0dHBzOi8vJHtJZH0uczMuYW1hem9uYXdzLmNvbS9sb2dvcy9sb2dvX2ljb25fd2hpdGUuc3ZnYCxcbiAgICAgICAgZnVsbENsYXNzOiBJZCArICctbG9nbycsXG4gICAgICAgIGljb25DbGFzczogSWQgKyAnLWljb24nXG4gICAgfSxcbiAgICBjb250cm9sczogW1xuICAgICAgICAvLyBUT1AgLy9cbiAgICAgICAgW3tcbiAgICAgICAgICAgIHR5cGU6ICd1dGlscycsXG4gICAgICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogJ3RvcC1jZW50ZXInLFxuICAgICAgICAgICAgZ3JvdXA6ICdhY3Rpb24nLFxuICAgICAgICAgICAgZGl2aWRlcjogdHJ1ZSxcbiAgICAgICAgICAgIHNob3c6IHRydWUsXG4gICAgICAgICAgICBidXR0b25zOiB7XG4gICAgICAgICAgICAgICAgcmVwZWF0OiB0cnVlLFxuICAgICAgICAgICAgICAgIHpvb206IHRydWUsXG4gICAgICAgICAgICAgICAgcmVmcmVzaDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBsb2NhdGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogJ21vZGVzJyxcbiAgICAgICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdyb3VwOiAnY29udHJvbCcsXG4gICAgICAgICAgICBkaXZpZGVyOiB0cnVlLFxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgZWRpdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzYXZlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6ICdvcHRpb25zJyxcbiAgICAgICAgICAgIGVuYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGdyb3VwOiAnYWN0aW9uJyxcbiAgICAgICAgICAgIGRpdmlkZXI6IGZhbHNlLFxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICBpbXBvcnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGNsZWFyOiB0cnVlLFxuICAgICAgICAgICAgICAgIHVuZG86IHRydWUsXG4gICAgICAgICAgICAgICAgcmVkbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWw6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV0sXG5cbiAgICAgICAgLy8gQk9UVE9NIC8vXG4gICAgICAgIFt7XG4gICAgICAgICAgICB0eXBlOiAndHlwZXMnLFxuICAgICAgICAgICAgZW5hYmxlOiB0cnVlLFxuICAgICAgICAgICAgcG9zaXRpb246ICd0b3AtY2VudGVyJyxcbiAgICAgICAgICAgIGdyb3VwOiAnY29udHJvbCcsXG4gICAgICAgICAgICBkaXZpZGVyOiB0cnVlLFxuICAgICAgICAgICAgc2hvdzogdHJ1ZSxcbiAgICAgICAgICAgIGJ1dHRvbnM6IHtcbiAgICAgICAgICAgICAgICBwb2x5bGluZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBwb2x5Z29uOiB0cnVlLFxuICAgICAgICAgICAgICAgIHJlY3RhbmdsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjaXJjbGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdGV4dDogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAnYWN0aW9ucycsXG4gICAgICAgICAgICBlbmFibGU6IHRydWUsXG4gICAgICAgICAgICBncm91cDogJ2NvbnRyb2wnLFxuICAgICAgICAgICAgZGl2aWRlcjogZmFsc2UsXG4gICAgICAgICAgICBzaG93OiB0cnVlLFxuICAgICAgICAgICAgYnV0dG9uczoge1xuICAgICAgICAgICAgICAgIHNuYXBwaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBpbm5pbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcm91dGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleHBsb3Jpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgcGFpbnRpbmc6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfV1cbiAgICBdLFxuICAgIGNvbnN0YW50czoge1xuICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgICBQUkVERUZJTkVEX0NPTlRST0xfQkFTRTogXCJtYXBib3hnbC1jdHJsXCIsXG4gICAgICAgICAgICBQUkVERUZJTkVEX0NPTlRST0xfR1JPVVA6IFwibWFwYm94Z2wtY3RybC1ncm91cFwiLFxuICAgICAgICAgICAgQ09OVFJPTF9QUkVGSVg6IFwibWFwYm94Z2wtY3RybC1cIixcbiAgICAgICAgICAgIEFDVElPTl9CVVRUT046IElkICsgXCItYWN0aW9uLWJ0blwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT046IFwibWFwYm94LWdsLWRyYXdfY3RybC1kcmF3LWJ0blwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fTElORTogXCJtYXBib3gtZ2wtZHJhd19saW5lXCIsXG4gICAgICAgICAgICBDT05UUk9MX0JVVFRPTl9QT0xZR09OOiBcIm1hcGJveC1nbC1kcmF3X3BvbHlnb25cIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX1JFQ1RBTkdMRTogXCJtYXBib3gtZ2wtZHJhd19yZWN0YW5nbGVcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX1BPSU5UOiBcIm1hcGJveC1nbC1kcmF3X3BvaW50XCIsXG4gICAgICAgICAgICBDT05UUk9MX0JVVFRPTl9URVhUOiBcIm1hcGJveC1nbC1kcmF3X3RleHRcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX0lDT046IFwibWFwYm94LWdsLWRyYXdfaWNvblwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fQ0xFQVI6IElkICsgXCItZGVsZXRlLWRhdGFcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX0RFTEVURV9TTkFQOiBJZCArIFwiLWRlbGV0ZS1zbmFwLWRhdGFcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX0xPQ0FURTogSWQgKyBcIi1sb2NhdGVcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX1pPT01fSU5fRkVBVFVSRVM6IElkICsgXCItem9vbS1pbi1mZWF0dXJlc1wiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fSElERV9TRUxFQ1RFRDogSWQgKyBcIi1oaWRlLXNlbGVjdGVkXCIsXG4gICAgICAgICAgICBDT05UUk9MX0JVVFRPTl9BRERfRkVBVFVSRV9UT19HUklEOiBJZCArIFwiLWFkZC1mZWF0dXJlLXRvLWdyaWRcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX0NSRUFURV9QT0xZR09OOiBJZCArIFwiLWNyZWF0ZS1wb2x5Z29uXCIsXG4gICAgICAgICAgICBDT05UUk9MX0JVVFRPTl9DT01CSU5FX0ZFQVRVUkVTOiBcIm1hcGJveC1nbC1kcmF3X2NvbWJpbmVcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX1VOQ09NQklORV9GRUFUVVJFUzogXCJtYXBib3gtZ2wtZHJhd191bmNvbWJpbmVcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX0dST1VQX0ZFQVRVUkVTOiBJZCArIFwiLWdyb3VwLWZlYXR1cmVzXCIsXG4gICAgICAgICAgICBDT05UUk9MX0JVVFRPTl9VTkdST1VQX0ZFQVRVUkVTOiBJZCArIFwiLXVuZ3JvdXAtZmVhdHVyZXNcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX0RPV05MT0FEX1dBWVM6IElkICsgXCItZG93bmxvYWQtd2F5c1wiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fRE9XTkxPQURfQlVJTERJTkdTOiBJZCArIFwiLWRvd25sb2FkLWJ1aWxkaW5nc1wiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fUkVGUkVTSDogSWQgKyBcIi1yZWZyZXNoXCIsXG4gICAgICAgICAgICBDT05UUk9MX0JVVFRPTl9FRElUOiBJZCArIFwiLWVkaXRcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX0NVVDogSWQgKyBcIi1jdXRcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX1NFTEVDVDogSWQgKyBcIi1zZWxlY3RcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX0RPV05MT0FEX0RBVEE6IElkICsgXCItZG93bmxvYWQtZGF0YVwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fRVhQT1JUOiBJZCArIFwiLWV4cG9ydFwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fU0FWRV9BU19HSVNUOiBJZCArIFwiLXNhdmUtYXMtZ2lzdFwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fU0FWRV9BU19HRU9KU09OOiBJZCArIFwiLXNhdmUtYXMtZ2VvanNvblwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fU0FWRV9BU19LTUw6IElkICsgXCItc2F2ZS1hcy1rbWxcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX0VYUEFORF9FRElUT1I6IElkICsgXCItZXhwYW5kLWVkaXRvclwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fSU1QT1JUOiBJZCArIFwiLWltcG9ydFwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fRklOU0lIOiBJZCArIFwiLWZpbmlzaFwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fQ0FOQ0VMOiBJZCArIFwiLWNhbmNlbFwiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fVU5ETzogSWQgKyBcIi11bmRvXCIsXG4gICAgICAgICAgICBDT05UUk9MX0JVVFRPTl9SRURPOiBJZCArIFwiLXJlZG9cIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX1NOQVBQSU5HOiBJZCArIFwiLXNuYXBwaW5nXCIsXG4gICAgICAgICAgICBDT05UUk9MX0JVVFRPTl9QSU5OSU5HOiBJZCArIFwiLXBpbm5pbmdcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX1JPVVRJTkc6IElkICsgXCItcm91dGluZ1wiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fRVhQTE9SSU5HOiBJZCArIFwiLWV4cGxvcmluZ1wiLFxuICAgICAgICAgICAgQ09OVFJPTF9CVVRUT05fUEFJTlRJTkc6IElkICsgXCItcGFpbnRpbmdcIixcbiAgICAgICAgICAgIENPTlRST0xfQlVUVE9OX1JFUEVBVDogSWQgKyBcIi1yZXBlYXRcIixcbiAgICAgICAgICAgIENPTlRST0xfR1JPVVA6IElkICsgXCItY3RybC1ncm91cFwiLFxuICAgICAgICAgICAgRFJPUERPV05fR1JPVVA6IElkICsgXCItZHJvcGRvd24tZ3JvdXBcIixcbiAgICAgICAgICAgIERJVklERVI6IElkICsgXCItZGl2aWRlclwiLFxuICAgICAgICAgICAgQUNUSU9OX0dST1VQOiBJZCArIFwiLWFjdGlvbi1ncm91cFwiLFxuICAgICAgICAgICAgQVRUUklCVVRJT046IFwibWFwYm94Z2wtY3RybC1hdHRyaWJcIixcbiAgICAgICAgICAgIEFDVElWRV9CVVRUT046IFwiYWN0aXZlXCIsXG4gICAgICAgICAgICBCT1hfU0VMRUNUOiBcIm1hcGJveC1nbC1kcmF3X2JveHNlbGVjdFwiLFxuICAgICAgICB9LFxuICAgICAgICBzb3VyY2VzOiB7XG4gICAgICAgICAgICBTRUxFQ1Q6IElkICsgXCItc2VsZWN0XCIsXG4gICAgICAgICAgICBTTkFQOiBJZCArIFwiLXNuYXBcIixcbiAgICAgICAgICAgIFJPVVRFOiBJZCArIFwiLXJvdXRlXCIsXG4gICAgICAgICAgICBIT1Q6IElkICsgXCItaG90XCIsXG4gICAgICAgICAgICBDT0xEOiBJZCArIFwiLWNvbGRcIixcbiAgICAgICAgICAgIE1FU0g6IElkICsgXCItbWVzaFwiLFxuICAgICAgICAgICAgVkVSVEVYOiBJZCArIFwiLXZlcnRleFwiLFxuICAgICAgICAgICAgSE9UVEVYVDogSWQgKyBcIi10ZXh0XCIsXG4gICAgICAgICAgICBDT0xEVEVYVDogSWQgKyBcIi1jb2xkdGV4dFwiLFxuICAgICAgICAgICAgR0FNRVBBRDogSWQgKyBcIi1nYW1lcGFkXCJcbiAgICAgICAgfSxcbiAgICAgICAgbGF5ZXJzOiB7XG4gICAgICAgICAgICBNRVNIOiBJZCArIFwiLW1lc2hcIlxuICAgICAgICB9LFxuICAgICAgICBjdXJzb3JzOiB7XG4gICAgICAgICAgICBBREQ6IFwiYWRkXCIsXG4gICAgICAgICAgICBNT1ZFOiBcIm1vdmVcIixcbiAgICAgICAgICAgIERSQUc6IFwiZHJhZ1wiLFxuICAgICAgICAgICAgUE9JTlRFUjogXCJwb2ludGVyXCIsXG4gICAgICAgICAgICBOT05FOiBcIm5vbmVcIixcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZXM6IHtcbiAgICAgICAgICAgIFBPTFlHT046IFwicG9seWdvblwiLFxuICAgICAgICAgICAgTElORTogXCJsaW5lX3N0cmluZ1wiLFxuICAgICAgICAgICAgUE9JTlQ6IFwicG9pbnRcIixcbiAgICAgICAgfSxcbiAgICAgICAgZ2VvanNvblR5cGVzOiB7XG4gICAgICAgICAgICBGRUFUVVJFOiBcIkZlYXR1cmVcIixcbiAgICAgICAgICAgIFBPTFlHT046IFwiUG9seWdvblwiLFxuICAgICAgICAgICAgTElORV9TVFJJTkc6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICAgICAgUE9JTlQ6IFwiUG9pbnRcIixcbiAgICAgICAgICAgIEZFQVRVUkVfQ09MTEVDVElPTjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICAgICAgICAgICAgTVVMVElfUFJFRklYOiBcIk11bHRpXCIsXG4gICAgICAgICAgICBNVUxUSV9QT0lOVDogXCJNdWx0aVBvaW50XCIsXG4gICAgICAgICAgICBNVUxUSV9MSU5FX1NUUklORzogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgICAgICAgIE1VTFRJX1BPTFlHT046IFwiTXVsdGlQb2x5Z29uXCIsXG4gICAgICAgIH0sXG4gICAgICAgIG1vZGVzOiB7XG4gICAgICAgICAgICBEUkFXOiBcImRyYXdcIixcbiAgICAgICAgICAgIENVVDogXCJjdXRcIixcbiAgICAgICAgICAgIFNFTEVDVDogXCJzZWxlY3RcIixcbiAgICAgICAgICAgIERFTEVURTogXCJkZWxldGVcIixcbiAgICAgICAgICAgIEVESVQ6IFwiZWRpdFwiXG4gICAgICAgIH0sXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgICAgQ1JFQVRFOiBcImRyYXcuY3JlYXRlXCIsXG4gICAgICAgICAgICBERUxFVEU6IFwiZHJhdy5kZWxldGVcIixcbiAgICAgICAgICAgIFVQREFURTogXCJkcmF3LnVwZGF0ZVwiLFxuICAgICAgICAgICAgU0VMRUNUSU9OX0NIQU5HRTogXCJkcmF3LnNlbGVjdGlvbmNoYW5nZVwiLFxuICAgICAgICAgICAgTU9ERV9DSEFOR0U6IFwiZHJhdy5tb2RlY2hhbmdlXCIsXG4gICAgICAgICAgICBBQ1RJT05BQkxFOiBcImRyYXcuYWN0aW9uYWJsZVwiLFxuICAgICAgICAgICAgUkVOREVSOiBcImRyYXcucmVuZGVyXCIsXG4gICAgICAgICAgICBDT01CSU5FX0ZFQVRVUkVTOiBcImRyYXcuY29tYmluZVwiLFxuICAgICAgICAgICAgVU5DT01CSU5FX0ZFQVRVUkVTOiBcImRyYXcudW5jb21iaW5lXCIsXG4gICAgICAgIH0sXG4gICAgICAgIHVwZGF0ZUFjdGlvbnM6IHtcbiAgICAgICAgICAgIE1PVkU6IFwibW92ZVwiLFxuICAgICAgICAgICAgQ0hBTkdFX0NPT1JESU5BVEVTOiBcImNoYW5nZV9jb29yZGluYXRlc1wiLFxuICAgICAgICB9LFxuICAgICAgICBtZXRhOiB7XG4gICAgICAgICAgICBGRUFUVVJFOiBcImZlYXR1cmVcIixcbiAgICAgICAgICAgIE1JRFBPSU5UOiBcIm1pZHBvaW50XCIsXG4gICAgICAgICAgICBWRVJURVg6IFwidmVydGV4XCIsXG4gICAgICAgIH0sXG4gICAgICAgIGFjdGl2ZVN0YXRlczoge1xuICAgICAgICAgICAgQUNUSVZFOiBcInRydWVcIixcbiAgICAgICAgICAgIElOQUNUSVZFOiBcImZhbHNlXCIsXG4gICAgICAgIH0sXG4gICAgICAgIExBVF9NSU46IC05MCxcbiAgICAgICAgTEFUX1JFTkRFUkVEX01JTjogLTg1LFxuICAgICAgICBMQVRfTUFYOiA5MCxcbiAgICAgICAgTEFUX1JFTkRFUkVEX01BWDogODUsXG4gICAgICAgIExOR19NSU46IC0yNzAsXG4gICAgICAgIExOR19NQVg6IDI3MCxcbiAgICAgICAgTUlOX1NFR01FTlRfTEVOR1RIOiAwLjAwMDAwMSxcbiAgICAgICAgTUlOX0RJU1RBTkNFOiAwLjAwMDAxLCAvLyAwLjAwMDAwMVxuICAgICAgICBDSVJDVU06IDQwMDc1MDE3XG4gICAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgU3RhdGljczsiLCIvKipcbiAqIEBtaXhpblxuICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG9cbiAqIEBuYW1lIFN0eWxlc1xuICogQGRlc2NyaXB0aW9uIFRoaXMgbW9kdWxlIHByb3ZpZGVzIHRoZSBzdHlsaW5nIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBHZW9mbG8gYXBwbGljYXRpb24uIEl0IGFsbG93cyB1c2VycyB0byBjaGFuZ2UgdGhlIG1hcCBzdHlsZSBieSBzZWxlY3RpbmcgZnJvbSBhIGxpc3Qgb2YgcHJlZGVmaW5lZCBzdHlsZXMuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBjb250YWluaW5nIHRoZSBzdHlsZXMgYW5kIHNlbGVjdGVkIHN0eWxlLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgU3R5bGVzIG9iamVjdC5cbiAqL1xuY29uc3QgU3R5bGVzID0gZnVuY3Rpb24gKG9wdGlvbnM9e30pIHtcbiAgICBjb25zdCBnZW9mbG8gPSB0aGlzLmdlb2ZsbztcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIFxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5TdHlsZXNcbiAgICAgKiBAbmFtZSBpbml0XG4gICAgICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBTdHlsZXMgb2JqZWN0IGJ5IGV4dGVuZGluZyB0aGUgb3B0aW9ucyBvYmplY3Qgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucywgc2V0dGluZyB0aGUgc3R5bGVzLCBkZWZhdWx0U3R5bGUsIGFuZCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyB0aGUgc3R5bGVzIGFuZCBzZWxlY3RlZCBzdHlsZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBTdHlsZXMgb2JqZWN0LlxuICAgICAqL1xuICAgIHRoaXMuaW5pdCA9IGZ1bmN0aW9uIChvcHRpb25zPXt9KSB7XG4gICAgICAgIGdlb2Zsby5VdGlsaXRpZXMuZXh0ZW5kKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5zdHlsZXMgPSB0aGlzLm9wdGlvbnMuc3R5bGVzIHx8IFtcbiAgICAgICAgICAgIHsgdGl0bGU6IFwiU3RhbmRhcmRcIiwgdXJpOiBcIm1hcGJveDovL3N0eWxlcy9zb2x1dGVncmF0ZS9jbHhkb2VjOHgwMDY5MDFxajd3amY4dXhvXCIgfSxcbiAgICAgICAgICAgIHsgdGl0bGU6IFwiU2F0ZWxsaXRlXCIsIHVyaTogXCJtYXBib3g6Ly9zdHlsZXMvbWFwYm94L3NhdGVsbGl0ZS1zdHJlZXRzLXYxMVwiIH0sXG4gICAgICAgICAgICB7IHRpdGxlOiBcIlN0YW5kYXJkXCIsIHVyaTogXCJtYXBib3g6Ly9zdHlsZXMvbWFwYm94L3N0YW5kYXJkXCIgfSxcbiAgICAgICAgICAgIHsgdGl0bGU6IFwiRGFya1wiLCB1cmk6IFwibWFwYm94Oi8vc3R5bGVzL21hcGJveC9kYXJrLXYxMVwiIH0sXG4gICAgICAgICAgICB7IHRpdGxlOiBcIkxpZ2h0XCIsIHVyaTogXCJtYXBib3g6Ly9zdHlsZXMvbWFwYm94L2xpZ2h0LXYxMVwiIH0sXG4gICAgICAgICAgICB7IHRpdGxlOiBcIk91dGRvb3JzXCIsIHVyaTogXCJtYXBib3g6Ly9zdHlsZXMvbWFwYm94L291dGRvb3JzLXYxMVwiIH1cbiAgICAgICAgXTtcbiAgICBcbiAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMub3B0aW9ucy5zZWxlY3RlZCB8fCBcIlN0YW5kYXJkXCI7XG4gICAgICAgIHRoaXMub25Eb2N1bWVudENsaWNrID0gdGhpcy5vbkRvY3VtZW50Q2xpY2suYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5ldmVudHMgPSB0aGlzLm9wdGlvbnMuZXZlbnRMaXN0ZW5lcnM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5TdHlsZXNcbiAgICAgKiBAbmFtZSBzZWxlY3RcbiAgICAgKiBAZGVzY3JpcHRpb24gU2VsZWN0cyB0aGUgc3R5bGUgd2l0aCB0aGUgcHJvdmlkZWQgbmFtZSBieSBzZXR0aW5nIHRoZSBtYXAgc3R5bGUgdG8gdGhlIHN0eWxlJ3MgdXJpLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHN0eWxlIHRvIHNlbGVjdC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5tYXBTdHlsZUNvbnRhaW5lciB8fCAhdGhpcy5tYXBTdHlsZUNvbnRhaW5lci5jaGVja1Zpc2liaWxpdHkoKSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZXMuZmluZChzdHlsZSA9PiBzdHlsZS50aXRsZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBpZiAoc3R5bGUpIHRoaXMubWFwLnNldFN0eWxlKHN0eWxlLnVyaSksIHRoaXMuc2VsZWN0ZWQgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzICYmIHRoaXMuZXZlbnRzLm9uQ2hhbmdlICYmIHRoaXMuZXZlbnRzLm9uQ2hhbmdlKHsgc3R5bGU6IHN0eWxlIH0sIHN0eWxlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGVsbXMgPSB0aGlzLm1hcFN0eWxlQ29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUobmFtZSk7XG4gICAgICAgIGlmIChlbG1zLmxlbmd0aCA+IDApIGVsbXNbMF0uY2xpY2soKTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uU3R5bGVzXG4gICAgICogQG5hbWUgaGlkZVxuICAgICAqIEBkZXNjcmlwdGlvbiBIaWRlcyB0aGUgc3R5bGUgY29udHJvbCBjb250YWluZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdGhpcy5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jb250cm9sQ29udGFpbmVyKSB0aGlzLmNvbnRyb2xDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlN0eWxlc1xuICAgICAqIEBuYW1lIHNob3dcbiAgICAgKiBAZGVzY3JpcHRpb24gU2hvd3MgdGhlIHN0eWxlIGNvbnRyb2wgY29udGFpbmVyLlxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbENvbnRhaW5lcikgdGhpcy5jb250cm9sQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcImJsb2NrXCI7XG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlN0eWxlc1xuICAgICAqIEBuYW1lIGdldERlZmF1bHRQb3NpdGlvblxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBkZWZhdWx0IHBvc2l0aW9uIGZvciB0aGUgc3R5bGUgY29udHJvbCBjb250YWluZXIuXG4gICAgICogQHJldHVybnMge1N0cmluZ30gVGhlIGRlZmF1bHQgcG9zaXRpb24gZm9yIHRoZSBzdHlsZSBjb250cm9sIGNvbnRhaW5lci5cbiAgICAgKi9cbiAgICB0aGlzLmdldERlZmF1bHRQb3NpdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFBvc2l0aW9uID0gXCJ0b3AtcmlnaHRcIjtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uU3R5bGVzXG4gICAgICogQG5hbWUgb25BZGRcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkcyB0aGUgc3R5bGUgY29udHJvbCBjb250YWluZXIgdG8gdGhlIG1hcC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWFwIC0gVGhlIG1hcCBvYmplY3QgdG8gYWRkIHRoZSBzdHlsZSBjb250cm9sIGNvbnRhaW5lciB0by5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgc3R5bGUgY29udHJvbCBjb250YWluZXIuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgbWFwIG9iamVjdCBpcyBub3QgcHJvdmlkZWQuXG4gICAgICovXG4gICAgdGhpcy5vbkFkZCA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG4gICAgICAgIHRoaXMuY29udHJvbENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgIHRoaXMuY29udHJvbENvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtY3RybFwiKTtcbiAgICAgICAgdGhpcy5jb250cm9sQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJtYXBib3hnbC1jdHJsLWdyb3VwXCIpO1xuICAgICAgICB0aGlzLm1hcFN0eWxlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgdGhpcy5zdHlsZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gICAgICAgIHRoaXMuc3R5bGVCdXR0b24udHlwZSA9IFwiYnV0dG9uXCI7XG4gICAgICAgIHRoaXMubWFwU3R5bGVDb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLXN0eWxlLWxpc3RcIik7XG5cbiAgICAgICAgZm9yIChjb25zdCBzdHlsZSBvZiB0aGlzLnN0eWxlcykge1xuICAgICAgICAgICAgY29uc3Qgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcblxuICAgICAgICAgICAgc3R5bGVFbGVtZW50LnR5cGUgPSBcImJ1dHRvblwiO1xuICAgICAgICAgICAgc3R5bGVFbGVtZW50LmNsYXNzTGlzdC5hZGQoc3R5bGUudGl0bGUucmVwbGFjZSgvW15hLXowLTktXS9naSwgJ18nKSk7XG4gICAgICAgICAgICBzdHlsZUVsZW1lbnQuZGF0YXNldC51cmkgPSBKU09OLnN0cmluZ2lmeShzdHlsZS51cmkpO1xuXG4gICAgICAgICAgICBzdHlsZUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzcmNFbGVtZW50ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZU1vZGFsKCk7XG4gICAgICAgICAgICAgICAgaWYgKHNyY0VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzICYmIHRoaXMuZXZlbnRzLm9uT3BlbiAmJiB0aGlzLmV2ZW50cy5vbk9wZW4oZXZlbnQpKSByZXR1cm47XG4gICAgICAgICAgICAgICAgY29uc3Qgc3R5bGUgPSBKU09OLnBhcnNlKHNyY0VsZW1lbnQuZGF0YXNldC51cmkpO1xuICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbG1zID0gdGhpcy5tYXBTdHlsZUNvbnRhaW5lci5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChlbG1zWzBdKSBlbG1zWzBdLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICAgICAgc3JjRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmV2ZW50cyAmJiB0aGlzLmV2ZW50cy5vbkNoYW5nZSAmJiB0aGlzLmV2ZW50cy5vbkNoYW5nZShldmVudCwgc3R5bGUpKSByZXR1cm47XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKHN0eWxlLnRpdGxlID09PSB0aGlzLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVFbGVtZW50LmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMubWFwU3R5bGVDb250YWluZXIuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc3R5bGVCdXR0b24uY2xhc3NMaXN0LmFkZChcIm1hcGJveGdsLWN0cmwtaWNvblwiKTtcbiAgICAgICAgdGhpcy5zdHlsZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwibWFwYm94Z2wtc3R5bGUtc3dpdGNoZXJcIik7XG5cbiAgICAgICAgdGhpcy5zdHlsZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzICYmIHRoaXMuZXZlbnRzLm9uU2VsZWN0ICYmIHRoaXMuZXZlbnRzLm9uU2VsZWN0KGV2ZW50KSkgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5vcGVuTW9kYWwoKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMub25Eb2N1bWVudENsaWNrKTtcblxuICAgICAgICB0aGlzLmNvbnRyb2xDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zdHlsZUJ1dHRvbik7XG4gICAgICAgIHRoaXMuY29udHJvbENvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1hcFN0eWxlQ29udGFpbmVyKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY2xvc2VNb2RhbCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9sQ29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5TdHlsZXNcbiAgICAgKiBAbmFtZSBvblJlbW92ZVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHRoZSBzdHlsZSBjb250cm9sIGNvbnRhaW5lciBmcm9tIHRoZSBtYXAuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgY29udHJvbCBjb250YWluZXIsIGNvbnRyb2wgY29udGFpbmVyIHBhcmVudCBub2RlLCBtYXAsIG9yIHN0eWxlIGJ1dHRvbiBpcyBub3QgcHJvdmlkZWQuXG4gICAgICogQHRocm93cyB7RXJyb3J9IFRocm93cyBhbiBlcnJvciBpZiB0aGUgc3R5bGUgYnV0dG9uIGV2ZW50IGxpc3RlbmVyIGlzIG5vdCByZW1vdmVkLlxuICAgICAqIEB0aHJvd3Mge0Vycm9yfSBUaHJvd3MgYW4gZXJyb3IgaWYgdGhlIGRvY3VtZW50IGV2ZW50IGxpc3RlbmVyIGlzIG5vdCByZW1vdmVkLlxuICAgICAqL1xuICAgIHRoaXMub25SZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250cm9sQ29udGFpbmVyIHx8ICF0aGlzLmNvbnRyb2xDb250YWluZXIucGFyZW50Tm9kZSB8fCAhdGhpcy5tYXAgfHwgIXRoaXMuc3R5bGVCdXR0b24pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0eWxlQnV0dG9uLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICAgIHRoaXMuY29udHJvbENvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuY29udHJvbENvbnRhaW5lcik7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLm9uRG9jdW1lbnRDbGljayk7XG4gICAgICAgIHRoaXMubWFwID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5TdHlsZXNcbiAgICAgKiBAbmFtZSBjbG9zZU1vZGFsXG4gICAgICogQGRlc2NyaXB0aW9uIENsb3NlcyB0aGUgc3R5bGUgY29udHJvbCBjb250YWluZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdGhpcy5jbG9zZU1vZGFsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tYXBTdHlsZUNvbnRhaW5lciAmJiB0aGlzLnN0eWxlQnV0dG9uKSB7XG4gICAgICAgICAgICB0aGlzLm1hcFN0eWxlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlN0eWxlc1xuICAgICAqIEBuYW1lIG9wZW5Nb2RhbFxuICAgICAqIEBkZXNjcmlwdGlvbiBPcGVucyB0aGUgc3R5bGUgY29udHJvbCBjb250YWluZXIuXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgdGhpcy5vcGVuTW9kYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcFN0eWxlQ29udGFpbmVyICYmIHRoaXMuc3R5bGVCdXR0b24pIHtcbiAgICAgICAgICAgIHRoaXMubWFwU3R5bGVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgIHRoaXMuc3R5bGVCdXR0b24uc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5vbkRvY3VtZW50Q2xpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbENvbnRhaW5lciAmJiAhdGhpcy5jb250cm9sQ29udGFpbmVyLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHRoaXMuY2xvc2VNb2RhbCgpO1xuICAgIH1cblxuICAgIHRoaXMuaW5pdCgpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU3R5bGVzOyIsIi8qKlxuICogQG1peGluXG4gKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsb1xuICogQG5hbWUgVXRpbGl0aWVzXG4gKiBAZGVzY3JpcHRpb24gVGhpcyBtb2R1bGUgcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHRoZSBHZW9mbG8gYXBwbGljYXRpb24uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBVdGlsaXRpZXMgb2JqZWN0LlxuICovXG5jb25zdCBVdGlsaXRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZ2VvZmxvID0gdGhpcy5nZW9mbG87XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBwb2ludEluQ29vcmRpbmF0ZXNcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBsaW5lIHN0cmluZyBhbmQgYSBwb2ludCdzIGNvb3JkaW5hdGVzIGFzIGlucHV0IGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIGluZGljZXMgd2hlcmUgdGhlIHBvaW50IGlzIGZvdW5kIGluIHRoZSBsaW5lIHN0cmluZydzIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbGluZVN0cmluZyAtIFRoZSBsaW5lIHN0cmluZyBvYmplY3QgY29udGFpbmluZyBnZW9tZXRyeSBjb29yZGluYXRlcy5cblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRDb29yZHMgLSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIHBvaW50IHRvIHNlYXJjaCBmb3IgaW4gdGhlIGxpbmUgc3RyaW5nLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGluZGljZXMgb2YgdGhlIHBvaW50IGluIHRoZSBsaW5lIHN0cmluZydzIGNvb3JkaW5hdGVzLlxuXHQgKi9cbiAgICB0aGlzLnBvaW50SW5Db29yZGluYXRlcyA9IGZ1bmN0aW9uIChsaW5lU3RyaW5nLCBwb2ludENvb3Jkcykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgbGluZVN0cmluZy5nZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uKGNvb3JkcywgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gMCAmJiBpbmRleCAhPT0gbGluZVN0cmluZy5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvb3Jkc1swXSA9PT0gcG9pbnRDb29yZHNbMF0gJiYgY29vcmRzWzFdID09PSBwb2ludENvb3Jkc1sxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIHNhbWVCb3JkZXJzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNvbXBhcmVzIHR3byBzZXRzIG9mIGJvcmRlcnMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlIHRoZSBzYW1lLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZnJvbUJvcmRlcnMgLSBUaGUgZmlyc3Qgc2V0IG9mIGJvcmRlcnMgdG8gY29tcGFyZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IHRvQm9yZGVycyAtIFRoZSBzZWNvbmQgc2V0IG9mIGJvcmRlcnMgdG8gY29tcGFyZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgYm9yZGVycyBhcmUgdGhlIHNhbWUsIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5zYW1lQm9yZGVycyA9IGZ1bmN0aW9uIChmcm9tQm9yZGVycywgdG9Cb3JkZXJzKSB7XG4gICAgICAgIGlmIChmcm9tQm9yZGVycyAmJiB0b0JvcmRlcnMpIHtcbiAgICAgICAgICAgIHJldHVybiBmcm9tQm9yZGVycy5ib3JkZXIxWzBdID09PSB0b0JvcmRlcnMuYm9yZGVyMVswXSAmJiBmcm9tQm9yZGVycy5ib3JkZXIxWzFdID09PSB0b0JvcmRlcnMuYm9yZGVyMVsxXSAmJiBmcm9tQm9yZGVycy5ib3JkZXIyWzBdID09PSB0b0JvcmRlcnMuYm9yZGVyMlswXSAmJiBmcm9tQm9yZGVycy5ib3JkZXIyWzFdID09PSB0b0JvcmRlcnMuYm9yZGVyMlsxXSB8fCBmcm9tQm9yZGVycy5ib3JkZXIxWzBdID09PSB0b0JvcmRlcnMuYm9yZGVyMlswXSAmJiBmcm9tQm9yZGVycy5ib3JkZXIxWzFdID09PSB0b0JvcmRlcnMuYm9yZGVyMlsxXSAmJiBmcm9tQm9yZGVycy5ib3JkZXIyWzBdID09PSB0b0JvcmRlcnMuYm9yZGVyMVswXSAmJiBmcm9tQm9yZGVycy5ib3JkZXIyWzFdID09PSB0b0JvcmRlcnMuYm9yZGVyMVsxXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIGdldFJhbmRvbUNvbG9yXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGdlbmVyYXRlcyBhIHJhbmRvbSBjb2xvciBieSByYW5kb21seSBzZWxlY3RpbmcgaGV4YWRlY2ltYWwgdmFsdWVzIGZvciBlYWNoIGRpZ2l0IG9mIHRoZSBjb2xvciBjb2RlLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSBBIHJhbmRvbSBjb2xvciBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG5cdCAqL1xuICAgIHRoaXMuZ2V0UmFuZG9tQ29sb3IgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZXR0ZXJzID0gJzAxMjM0NTY3ODlBQkNERUYnO1xuICAgICAgICB2YXIgY29sb3IgPSAnIyc7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgICAgICBjb2xvciArPSBsZXR0ZXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIGNyZWF0ZVJhbmRvbVN0cm9rZVxuXHQgKiBAZGVzY3JpcHRpb24gR2VuZXJhdGVzIGEgcmFuZG9tIHN0cm9rZSBjb2xvciBmb3IgYSBzaGFwZS5cblx0ICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJhbmRvbWx5IGdlbmVyYXRlZCBzdHJva2UgY29sb3IuXG5cdCAqL1xuICAgIHRoaXMuY3JlYXRlUmFuZG9tU3Ryb2tlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3Ryb2tlOiB0aGlzLmdldFJhbmRvbUNvbG9yKClcbiAgICAgICAgfTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBjcmVhdGVMaW5lQW5kU2F2ZUxlbmd0aFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSBvZiBsaW5lIGNvb3JkaW5hdGVzIGFuZCBwcm9wZXJ0aWVzLCBjcmVhdGVzIGEgbGluZSBzdHJpbmcgd2l0aCByYW5kb20gc3Ryb2tlIHByb3BlcnRpZXMsIGNhbGN1bGF0ZXMgdGhlIGxlbmd0aCBvZiB0aGUgbGluZSwgYW5kIHNhdmVzIGl0IGluIHRoZSBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBsaW5lQ29vcmRzIC0gQXJyYXkgb2YgY29vcmRpbmF0ZXMgZm9yIHRoZSBsaW5lIHN0cmluZy5cblx0ICogQHBhcmFtIHtPYmplY3R9IHByb3BzIC0gUHJvcGVydGllcyBvYmplY3QgZm9yIHRoZSBsaW5lIHN0cmluZy5cblx0ICogQHJldHVybnMge09iamVjdH0gLSBUaGUgY3JlYXRlZCBsaW5lIHN0cmluZyB3aXRoIHNhdmVkIGxlbmd0aCBpbiBwcm9wZXJ0aWVzLlxuXHQgKi9cbiAgICB0aGlzLmNyZWF0ZUxpbmVBbmRTYXZlTGVuZ3RoID0gZnVuY3Rpb24gKGxpbmVDb29yZHMsIHByb3BzKSB7XG4gICAgICAgIHZhciBjb3B5UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCBwcm9wcywgdGhpcy5jcmVhdGVSYW5kb21TdHJva2UoKSk7XG4gICAgICAgIHZhciBsaW5lID0gdHVyZi5saW5lU3RyaW5nKGxpbmVDb29yZHMsIGNvcHlQcm9wcyk7XG4gICAgICAgIGNvcHlQcm9wcy5sZW5ndGggPSB0dXJmLmxpbmVEaXN0YW5jZShsaW5lKTtcbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgbGluZVNwbGl0XG5cdCAqIEBkZXNjcmlwdGlvbiBTcGxpdHMgYSBsaW5lIHN0cmluZyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcG9pbnQgaW5kZXhlcyBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiBzcGxpdCBsaW5lIHN0cmluZ3MuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsaW5lU3RyaW5nIC0gVGhlIGxpbmUgc3RyaW5nIG9iamVjdCB0byBzcGxpdC5cblx0ICogQHBhcmFtIHtBcnJheX0gcG9pbnRJbmRleGVzIC0gQW4gYXJyYXkgb2YgaW5kZXhlcyB3aGVyZSB0aGUgbGluZSBzdHJpbmcgc2hvdWxkIGJlIHNwbGl0LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgb2Ygc3BsaXQgbGluZSBzdHJpbmdzLlxuXHQgKi9cbiAgICB0aGlzLmxpbmVTcGxpdCA9IGZ1bmN0aW9uIChsaW5lU3RyaW5nLCBwb2ludEluZGV4ZXMpIHtcbiAgICAgICAgdmFyIHByb3BzID0gbGluZVN0cmluZy5wcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgbGluZUNvb3JkcyA9IFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobGluZVN0cmluZy5nZW9tZXRyeS5jb29yZGluYXRlcykpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBkZWx0YSA9IDA7XG5cbiAgICAgICAgcG9pbnRJbmRleGVzLmZvckVhY2goZnVuY3Rpb24ocG9pbnRJbmRleCkge1xuICAgICAgICAgICAgcG9pbnRJbmRleCAtPSBkZWx0YTtcbiAgICAgICAgICAgIGlmIChwb2ludEluZGV4IDwgbGluZUNvb3Jkcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlY29uZFBhcnQgPSBsaW5lQ29vcmRzLnNwbGljZShwb2ludEluZGV4LCBsaW5lQ29vcmRzLmxlbmd0aCAtIHBvaW50SW5kZXgpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChsaW5lQ29vcmRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZUNvb3Jkcy5wdXNoKHNlY29uZFBhcnRbMF0pO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNyZWF0ZUxpbmVBbmRTYXZlTGVuZ3RoKGxpbmVDb29yZHMsIHByb3BzKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGluZUNvb3JkcyA9IHNlY29uZFBhcnQ7XG4gICAgICAgICAgICAgICAgZGVsdGEgKz0gcG9pbnRJbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgaWYgKGxpbmVDb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jcmVhdGVMaW5lQW5kU2F2ZUxlbmd0aChsaW5lQ29vcmRzLCBwcm9wcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBzcGxpdExpbmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIHR3byBsaW5lIHN0cmluZ3MgYW5kIHNwbGl0cyB0aGVtIGF0IHRoZWlyIGludGVyc2VjdGlvbiBwb2ludHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsaW5lU3RyaW5nMSAtIFRoZSBmaXJzdCBsaW5lIHN0cmluZyBvYmplY3QuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsaW5lU3RyaW5nMiAtIFRoZSBzZWNvbmQgbGluZSBzdHJpbmcgb2JqZWN0LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl8bnVsbH0gLSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBzcGxpdCBsaW5lIHN0cmluZ3Mgb3IgbnVsbCBpZiBubyBpbnRlcnNlY3Rpb24gcG9pbnRzIGFyZSBmb3VuZC5cblx0ICovXG4gICAgdGhpcy5zcGxpdExpbmVzID0gZnVuY3Rpb24gKGxpbmVTdHJpbmcxLCBsaW5lU3RyaW5nMikge1xuICAgICAgICB2YXIgbGluZTFDdXRQb2ludHMgPSBbXTtcbiAgICAgICAgdmFyIGxpbmUyQ3V0UG9pbnRzID0gW107XG5cbiAgICAgICAgbGluZVN0cmluZzEuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbihjb29yZHMsIGluZGV4KSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5wb2ludEluQ29vcmRpbmF0ZXMobGluZVN0cmluZzIsIGNvb3Jkcyk7XG4gICAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBsaW5lMkN1dFBvaW50cy5wdXNoLmFwcGx5KGxpbmUyQ3V0UG9pbnRzLCBfdG9Db25zdW1hYmxlQXJyYXkocG9pbnRzKSk7XG4gICAgICAgICAgICAgICAgbGluZTFDdXRQb2ludHMucHVzaChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgIGlmIChsaW5lMUN1dFBvaW50cy5sZW5ndGggPT09IDAgJiYgbGluZTJDdXRQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMubGluZVNwbGl0KGxpbmVTdHJpbmcxLCBsaW5lMUN1dFBvaW50cykpKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMubGluZVNwbGl0KGxpbmVTdHJpbmcyLCBsaW5lMkN1dFBvaW50cykpKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBjcmVhdGVTaW1wbGVNZXNoXG5cdCAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgc2ltcGxlIG1lc2ggYnkgcHJvY2Vzc2luZyBhIGxpc3Qgb2YgZmVhdHVyZXMgY29udGFpbmluZyBsaW5lIHN0cmluZ3MuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZlYXR1cmVzIC0gQW4gYXJyYXkgb2YgbGluZSBzdHJpbmcgZmVhdHVyZXMgdG8gYmUgcHJvY2Vzc2VkLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgb2YgcHJvY2Vzc2VkIGxpbmUgc2VnbWVudHMgZm9ybWluZyB0aGUgbWVzaC5cblx0ICovXG4gICAgdGhpcy5jcmVhdGVTaW1wbGVNZXNoID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmVTdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGxpbmVTdHJpbmcucHJvcGVydGllcztcbiAgICAgICAgICAgIHZhciBjb29yZHMgPSBsaW5lU3RyaW5nLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgdmFyIGZpcnN0UG9pbnQgPSBjb29yZHNbMF07XG4gICAgICAgICAgICB2YXIgc2Vjb25kUG9pbnQgPSBudWxsO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgY29vcmRzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHNlY29uZFBvaW50ID0gY29vcmRzW2luZGV4XTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aGlzLmNyZWF0ZUxpbmVBbmRTYXZlTGVuZ3RoKFtmaXJzdFBvaW50LCBzZWNvbmRQb2ludF0sIHByb3BzKSk7XG4gICAgICAgICAgICAgICAgZmlyc3RQb2ludCA9IHNlY29uZFBvaW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIGNyZWF0ZU1lc2hcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdGFrZXMgYW4gYXJyYXkgb2YgbGluZSBzdHJpbmcgZmVhdHVyZXMgYW5kIHNwbGl0cyB0aGVtIGF0IGludGVyc2VjdGlvbiBwb2ludHMgdG8gY3JlYXRlIGEgbWVzaC5cblx0ICogQHBhcmFtIHtBcnJheX0gZmVhdHVyZXMgLSBBbiBhcnJheSBvZiBsaW5lIHN0cmluZyBmZWF0dXJlcyB0byBjcmVhdGUgdGhlIG1lc2ggZnJvbS5cblx0ICogQHJldHVybnMge0FycmF5fSAtIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgbWVzaCBjcmVhdGVkIGJ5IHNwbGl0dGluZyB0aGUgbGluZSBzdHJpbmdzIGF0IGludGVyc2VjdGlvbiBwb2ludHMuXG5cdCAqL1xuICAgIHRoaXMuY3JlYXRlTWVzaCA9IGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgICAgICB2YXIgbWVzaCA9IFtdO1xuXG4gICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24obGluZVN0cmluZzEpIHtcbiAgICAgICAgICAgIHZhciBsaW5lMUN1dFBvaW50cyA9IGxpbmVTdHJpbmcxLnByb3BlcnRpZXMuY3V0UG9pbnRzO1xuXG4gICAgICAgICAgICBpZiAoIWxpbmUxQ3V0UG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgbGluZTFDdXRQb2ludHMgPSBbXTtcbiAgICAgICAgICAgICAgICBsaW5lU3RyaW5nMS5wcm9wZXJ0aWVzLmN1dFBvaW50cyA9IGxpbmUxQ3V0UG9pbnRzO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmVTdHJpbmcyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmVTdHJpbmcxICE9PSBsaW5lU3RyaW5nMikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGluZTJDdXRQb2ludHMgPSBsaW5lU3RyaW5nMi5wcm9wZXJ0aWVzLmN1dFBvaW50cztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxpbmUyQ3V0UG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lMkN1dFBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZVN0cmluZzIucHJvcGVydGllcy5jdXRQb2ludHMgPSBsaW5lMkN1dFBvaW50cztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxpbmVTdHJpbmcxLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goZnVuY3Rpb24oY29vcmRzLCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IHRoaXMucG9pbnRJbkNvb3JkaW5hdGVzKGxpbmVTdHJpbmcyLCBjb29yZHMpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMuZm9yRWFjaChmdW5jdGlvbihjdXRQb2ludCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGluZTJDdXRQb2ludHMuaW5kZXhPZihjdXRQb2ludCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lMkN1dFBvaW50cy5wdXNoKGN1dFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAwICYmIGluZGV4ICE9PSBsaW5lU3RyaW5nMS5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsaW5lMUN1dFBvaW50cy5pbmRleE9mKGluZGV4KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmUxQ3V0UG9pbnRzLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihsaW5lU3RyaW5nKSB7XG4gICAgICAgICAgICBsaW5lU3RyaW5nLnByb3BlcnRpZXMuY3V0UG9pbnRzLnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gYSAtIGI7IH0pO1xuICAgICAgICAgICAgbWVzaC5wdXNoLmFwcGx5KG1lc2gsIF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmxpbmVTcGxpdChsaW5lU3RyaW5nLCBsaW5lU3RyaW5nLnByb3BlcnRpZXMuY3V0UG9pbnRzKSkpO1xuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gbWVzaDtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBzZXRQcm9wZXJ0eVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBzZXRzIGEgcHJvcGVydHkgdmFsdWUgZm9yIGEgZ2l2ZW4gZmVhdHVyZS4gSWYgdGhlIGZlYXR1cmUgZG9lcyBub3QgaGF2ZSBwcm9wZXJ0aWVzLCBpdCBjcmVhdGVzIGEgbmV3IHByb3BlcnRpZXMgb2JqZWN0LiBJZiB0aGUgcHJvcGVydHkgbmFtZSBpbmNsdWRlcyBhIGRvdCAoLiksIGl0IGNyZWF0ZXMgbmVzdGVkIG9iamVjdHMgdG8gc2V0IHRoZSB2YWx1ZS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgLSBUaGUgZmVhdHVyZSBvYmplY3QgdG8gc2V0IHRoZSBwcm9wZXJ0eSBmb3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BlcnR5IHRvIHNldC5cblx0ICogQHBhcmFtIHthbnl9IHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldCBmb3IgdGhlIHByb3BlcnR5LlxuXHQgKi9cbiAgICB0aGlzLnNldFByb3BlcnR5ID0gZnVuY3Rpb24gKGZlYXR1cmUsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGlmICghZmVhdHVyZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgdmFyIHByb3BzID0gZmVhdHVyZS5wcm9wZXJ0aWVzO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFwcm9wcykge1xuICAgICAgICAgICAgcHJvcHMgPSB7fTtcbiAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcyA9IHByb3BzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5hbWUuaW5jbHVkZXMoJy4nKSkge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGlmICghcHJvcHNbbmFtZVswXV0pIHByb3BzW25hbWVbMF1dID0ge307XG4gICAgICAgICAgICBwcm9wc1tuYW1lWzBdXVtuYW1lWzFdXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIHNldFByb3BlcnRpZXNcblx0ICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBmZWF0dXJlIG9iamVjdCB3aXRoIG5ldyBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZSAtIFRoZSBmZWF0dXJlIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIHdpbGwgYmUgdXBkYXRlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG5ld1Byb3BzIC0gVGhlIG5ldyBwcm9wZXJ0aWVzIHRvIGJlIG1lcmdlZCB3aXRoIHRoZSBleGlzdGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBmZWF0dXJlLlxuXHQgKi9cbiAgICB0aGlzLnNldFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZmVhdHVyZSwgbmV3UHJvcHMpIHtcbiAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbihmZWF0dXJlLnByb3BlcnRpZXMgfHwge30sIG5ld1Byb3BzKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBmaW5kQ2xvc2VzdEZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGluZGV4RGF0YSBvYmplY3QsIGEgcG9pbnQgb2JqZWN0LCBhbmQgYSByYWRpdXMgdmFsdWUgYXMgcGFyYW1ldGVycy4gSXQgdGhlbiByZXRyaWV2ZXMgdGhlIGZlYXR1cmUgSURzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhZGl1cyBmcm9tIHRoZSBwb2ludCBpbmRleCBpbiB0aGUgaW5kZXhEYXRhIG9iamVjdC4gSXQgZW5zdXJlcyB1bmlxdWUgZmVhdHVyZXMgYXJlIGluY2x1ZGVkIGluIHRoZSByZXN1bHQgYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgY2xvc2VzdCBmZWF0dXJlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGluZGV4RGF0YSAtIFRoZSBpbmRleCBkYXRhIG9iamVjdCBjb250YWluaW5nIHBvaW50SW5kZXgsIHBvaW50RmVhdHVyZU1hcCwgYW5kIGZlYXR1cmVCeUlkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcG9pbnQgLSBUaGUgcG9pbnQgb2JqZWN0IHdpdGggbG5nIChsb25naXR1ZGUpIGFuZCBsYXQgKGxhdGl0dWRlKSBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzIC0gVGhlIHJhZGl1cyB3aXRoaW4gd2hpY2ggdG8gc2VhcmNoIGZvciBmZWF0dXJlcy5cblx0ICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBjbG9zZXN0IGZlYXR1cmVzIHRvIHRoZSBnaXZlbiBwb2ludCB3aXRoaW4gdGhlIHNwZWNpZmllZCByYWRpdXMuXG5cdCAqL1xuICAgIHRoaXMuZmluZENsb3Nlc3RGZWF0dXJlcyA9IGZ1bmN0aW9uIChpbmRleERhdGEsIHBvaW50LCByYWRpdXMpIHtcbiAgICAgICAgdmFyIGZlYXR1cmVJZHNXaXRoaW4gPSBpbmRleERhdGEucG9pbnRJbmRleC53aXRoaW4ocG9pbnQubG5nLCBwb2ludC5sYXQsIHJhZGl1cyk7XG4gICAgICAgIHZhciBhc3NlcnRVbmlxdWVGZWF0dXJlcyA9IHt9O1xuICAgICAgICB2YXIgZmVhdHVyZVJlc3VsdCA9IFtdO1xuXG4gICAgICAgIGZlYXR1cmVJZHNXaXRoaW4uZm9yRWFjaChmdW5jdGlvbihwb2ludElkKSB7XG4gICAgICAgICAgICB2YXIgZmVhdHVyZUlkID0gaW5kZXhEYXRhLnBvaW50RmVhdHVyZU1hcFtwb2ludElkXTtcbiAgICAgICAgICAgIGlmICghYXNzZXJ0VW5pcXVlRmVhdHVyZXNbZmVhdHVyZUlkXSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVSZXN1bHQucHVzaChpbmRleERhdGEuZmVhdHVyZUJ5SWRbZmVhdHVyZUlkXSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VW5pcXVlRmVhdHVyZXNbZmVhdHVyZUlkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVSZXN1bHQ7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgaXNQb2ludEVxdWFsXG5cdCAqIEBkZXNjcmlwdGlvbiBDaGVja3MgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWwgYmFzZWQgb24gdGhlaXIgY29vcmRpbmF0ZXMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkczEgLSBUaGUgY29vcmRpbmF0ZXMgb2YgdGhlIGZpcnN0IHBvaW50IFt4LCB5XS5cblx0ICogQHBhcmFtIHtBcnJheX0gY29vcmRzMiAtIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgc2Vjb25kIHBvaW50IFt4LCB5XS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnRzIGhhdmUgdGhlIHNhbWUgY29vcmRpbmF0ZXMsIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5pc1BvaW50RXF1YWwgPSBmdW5jdGlvbiAoY29vcmRzMSwgY29vcmRzMikge1xuICAgICAgICByZXR1cm4gY29vcmRzMVswXSA9PT0gY29vcmRzMlswXSAmJiBjb29yZHMxWzFdID09PSBjb29yZHMyWzFdO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIGlzUG9pbnRcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBmZWF0dXJlIG9iamVjdCBhbmQgZGV0ZXJtaW5lcyBpZiBpdCByZXByZXNlbnRzIGEgUG9pbnQgZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmIC0gVGhlIGZlYXR1cmUgb2JqZWN0IHRvIGJlIGNoZWNrZWQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGZlYXR1cmUgaXMgYSBQb2ludCBnZW9tZXRyeSwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cbiAgICB0aGlzLmlzUG9pbnQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICByZXR1cm4gIWYgPyBmYWxzZSA6IGYuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50JztcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBpc1BvbHlnb25cblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBhIGZlYXR1cmUgcmVwcmVzZW50cyBhIHBvbHlnb24gYnkgY29tcGFyaW5nIGl0cyBmaXJzdCBhbmQgbGFzdCBjb29yZGluYXRlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgLSBUaGUgZmVhdHVyZSBvYmplY3QgdG8gYmUgY2hlY2tlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZmVhdHVyZSBpcyBhIHBvbHlnb24sIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5pc1BvbHlnb24gPSBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICB2YXIgY29vcmRzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgdmFyIGZpcnN0Q29vcmRzID0gY29vcmRzWzBdO1xuICAgICAgICB2YXIgbGFzdENvb3JkcyA9IGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB0aGlzLmlzUG9pbnRFcXVhbChmaXJzdENvb3JkcywgbGFzdENvb3Jkcyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgaXNMaW5lU3RyaW5nXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgR2VvSlNPTiBmZWF0dXJlIG9iamVjdCBhbmQgZGV0ZXJtaW5lcyBpZiBpdCByZXByZXNlbnRzIGEgTGluZVN0cmluZyBnZW9tZXRyeS5cblx0ICogQHBhcmFtIHtPYmplY3R9IGYgLSBUaGUgR2VvSlNPTiBmZWF0dXJlIG9iamVjdCB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlIGlzIGEgTGluZVN0cmluZywgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cbiAgICB0aGlzLmlzTGluZVN0cmluZyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiAhZiA/IGZhbHNlIDogZi5nZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZyc7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgaXNWYWxpZExpbmVTdHJpbmdcblx0ICogQGRlc2NyaXB0aW9uIENoZWNrcyBpZiB0aGUgaW5wdXQgZmVhdHVyZSBpcyBhIHZhbGlkIExpbmVTdHJpbmcgYnkgdmVyaWZ5aW5nIGl0cyBnZW9tZXRyeSBjb29yZGluYXRlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGYgLSBUaGUgaW5wdXQgZmVhdHVyZSB0byBiZSB2YWxpZGF0ZWQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGlucHV0IGZlYXR1cmUgaXMgYSB2YWxpZCBMaW5lU3RyaW5nLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuICAgIHRoaXMuaXNWYWxpZExpbmVTdHJpbmcgPSBmdW5jdGlvbiAoZikge1xuICAgICAgICBpZiAoIXRoaXMuaXNMaW5lU3RyaW5nKGYpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHZhciBjb29yZHMgPSBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICBpZiAoY29vcmRzLmxlbmd0aCA8IDIpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgaXNMYXN0SW5kZXhcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiB0aGUgcHJvdmlkZWQgaW5kZXggaXMgdGhlIGxhc3QgaW5kZXggaW4gdGhlIGNvb3JkaW5hdGVzIGFycmF5IG9mIGEgZmVhdHVyZS5cblx0ICogQHBhcmFtIHtudW1iZXJ9IGkgLSBUaGUgaW5kZXggdG8gY2hlY2suXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBmIC0gVGhlIGZlYXR1cmUgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIGFycmF5LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBpbmRleCBpcyB0aGUgbGFzdCBpbmRleCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cbiAgICB0aGlzLmlzTGFzdEluZGV4ID0gZnVuY3Rpb24gKGksIGYpIHtcbiAgICAgICAgcmV0dXJuICFmID8gZmFsc2UgOlxuICAgICAgICB0aGlzLmlzTGluZVN0cmluZyhmKSA/IGkgPT0gZi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAxIDpcbiAgICAgICAgdGhpcy5pc1BvbHlnb24oZikgPyBpID09IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0ubGVuZ3RoIC0gMSA6XG4gICAgICAgIGkgPT0gMCA/IHRydWUgOlxuICAgICAgICBmYWxzZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBnZXRMYXN0SW5kZXhDb29yZHNcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGUgbGFzdCBjb29yZGluYXRlcyBvZiBhIGdpdmVuIGdlb21ldHJ5IG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGYgLSBUaGUgZ2VvbWV0cnkgb2JqZWN0IHRvIGV4dHJhY3QgdGhlIGxhc3QgY29vcmRpbmF0ZXMgZnJvbS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbGFzdCBjb29yZGluYXRlcyBvZiB0aGUgZ2VvbWV0cnkgb2JqZWN0LlxuXHQgKi9cbiAgICB0aGlzLmdldExhc3RJbmRleENvb3JkcyA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTGluZVN0cmluZyhmKSA/IGYuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbZi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAxXSA6XG4gICAgICAgIHRoaXMuaXNQb2x5Z29uKGYpID8gZi5nZW9tZXRyeS5jb29yZGluYXRlc1swXVtmLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCAtIDFdIDpcbiAgICAgICAgZi5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBpc0VtcHR5TGluZVN0cmluZ1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBkZXRlcm1pbmVzIGlmIHRoZSBwcm92aWRlZCBmZWF0dXJlIGlzIGEgTGluZVN0cmluZyB3aXRoIG9ubHkgdHdvIGlkZW50aWNhbCBwb2ludHMsIG1ha2luZyBpdCBhbiBlbXB0eSBMaW5lU3RyaW5nLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZSAtIFRoZSBmZWF0dXJlIG9iamVjdCB0byBiZSBjaGVja2VkLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlIGlzIGFuIGVtcHR5IExpbmVTdHJpbmcsIG90aGVyd2lzZSBmYWxzZS5cblx0ICovXG4gICAgdGhpcy5pc0VtcHR5TGluZVN0cmluZyA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgY29vcmRzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICAgICAgaWYgKGNvb3Jkcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RDb29yZHMgPSBjb29yZHNbMF07XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RDb29yZHMgPSBjb29yZHNbY29vcmRzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzUG9pbnRFcXVhbChmaXJzdENvb3JkcywgbGFzdENvb3Jkcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgaXNQb2ludEF0VmVydGV4XG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGRldGVybWluZXMgaWYgYSBwb2ludCBpcyBhdCB0aGUgZmlyc3Qgb3IgbGFzdCB2ZXJ0ZXggb2YgYSBnZW9tZXRyeSBieSBjb21wYXJpbmcgaXQgd2l0aCB0aGUgZmlyc3QgYW5kIGxhc3QgY29vcmRpbmF0ZXMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGdlb21ldHJ5Q29vcmRzIC0gVGhlIGFycmF5IG9mIGNvb3JkaW5hdGVzIHJlcHJlc2VudGluZyB0aGUgZ2VvbWV0cnkuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IHBvaW50Q29vcmRzIC0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludCB0byBjaGVjay5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcG9pbnQgaXMgYXQgdGhlIGZpcnN0IG9yIGxhc3QgdmVydGV4LCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuICAgIHRoaXMuaXNQb2ludEF0VmVydGV4ID0gZnVuY3Rpb24gKGdlb21ldHJ5Q29vcmRzLCBwb2ludENvb3Jkcykge1xuICAgICAgICB2YXIgZmlyc3RQb2ludCA9IGdlb21ldHJ5Q29vcmRzWzBdO1xuICAgICAgICB2YXIgbGFzdFBvaW50ID0gZ2VvbWV0cnlDb29yZHNbZ2VvbWV0cnlDb29yZHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHJldHVybiB0aGlzLmlzUG9pbnRFcXVhbChmaXJzdFBvaW50LCBwb2ludENvb3JkcykgfHwgdGhpcy5pc1BvaW50RXF1YWwobGFzdFBvaW50LCBwb2ludENvb3Jkcyk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgaXNQb2ludE5vdFRvb0Nsb3NlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cyBhbmQgY2hlY2tzIGlmIGl0IGV4Y2VlZHMgYSBtaW5pbXVtIGRpc3RhbmNlIHRocmVzaG9sZC5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZHMxIC0gVGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBmaXJzdCBwb2ludCBbeCwgeV0uXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRzMiAtIFRoZSBjb29yZGluYXRlcyBvZiB0aGUgc2Vjb25kIHBvaW50IFt4LCB5XS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnRzIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgbWluaW11bSBkaXN0YW5jZSB0aHJlc2hvbGQsIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5pc1BvaW50Tm90VG9vQ2xvc2UgPSBmdW5jdGlvbiAoY29vcmRzMSwgY29vcmRzMikge1xuICAgICAgICB2YXIgbGluZSA9IHR1cmYubGluZVN0cmluZyhbY29vcmRzMSwgY29vcmRzMl0pO1xuICAgICAgICB2YXIgbGVuZ3RoID0gdHVyZi5saW5lRGlzdGFuY2UobGluZSk7XG5cbiAgICAgICAgaWYgKGxlbmd0aCA+PSBzdGF0aWNzLmNvbnN0YW50cy5NSU5fRElTVEFOQ0UpIHtcbiAgICAgICAgICAgIHJldHVybiAhKGNvb3JkczFbMF0gPT09IGNvb3JkczJbMF0gJiYgY29vcmRzMVsxXSA9PT0gY29vcmRzMlsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBpc092ZXJsYXBwaW5nXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIHR3byBmZWF0dXJlcyBhbmQgZGV0ZXJtaW5lcyBpZiB0aGV5IG92ZXJsYXAgYnkgY29tcGFyaW5nIHRoZWlyIGJvdW5kaW5nIGJveGVzLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZTEgLSBUaGUgZmlyc3QgZmVhdHVyZSBvYmplY3Qgd2l0aCBnZW9tZXRyeS5jb29yZGluYXRlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUyIC0gVGhlIHNlY29uZCBmZWF0dXJlIG9iamVjdCB3aXRoIGdlb21ldHJ5LmNvb3JkaW5hdGVzLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBmZWF0dXJlcyBvdmVybGFwLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuICAgIHRoaXMuaXNPdmVybGFwcGluZyA9IGZ1bmN0aW9uIChmZWF0dXJlMSwgZmVhdHVyZTIpIHtcbiAgICAgICAgdmFyIGNvb3JkczEgPSBmZWF0dXJlMS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAgICAgdmFyIGNvb3JkczIgPSBmZWF0dXJlMi5nZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICBpZiAoY29vcmRzMS5sZW5ndGggPT09IDIgJiYgY29vcmRzMi5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICAgIHZhciBiYm94MSA9IHRoaXMuY3JlYXRlQmJveChjb29yZHMxKTtcbiAgICAgICAgICAgIHZhciBiYm94MiA9IHRoaXMuY3JlYXRlQmJveChjb29yZHMyKTtcbiAgICAgICAgICAgIGlmIChiYm94MS5lYXN0IDwgYmJveDIud2VzdCB8fCBiYm94MS53ZXN0ID4gYmJveDIuZWFzdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYmJveDEubm9ydGggPCBiYm94Mi5zb3V0aCB8fCBiYm94MS5zb3V0aCA+IGJib3gyLm5vcnRoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ3cm9uZyBudW1iZXIgb2YgY29vcmRpbmF0ZXMsIGV4cGVjdGVkIDJcIik7XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBjcmVhdGVMaW5lV2l0aExlbmd0aFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSBvZiBjb29yZGluYXRlcyBhbmQgY3JlYXRlcyBhIGxpbmUgc3RyaW5nIHVzaW5nIFR1cmYuanMuIEl0IHRoZW4gY2FsY3VsYXRlcyB0aGUgbGVuZ3RoIG9mIHRoZSBsaW5lIGFuZCBzZXRzIGl0IGFzIGEgcHJvcGVydHkgb2YgdGhlIGxpbmUuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkcyAtIEFuIGFycmF5IG9mIGNvb3JkaW5hdGVzIFsgW3gxLCB5MV0sIFt4MiwgeTJdLCAuLi4gXS5cblx0ICogQHJldHVybnMge09iamVjdH0gLSBBIFR1cmYuanMgbGluZSBzdHJpbmcgd2l0aCB0aGUgY2FsY3VsYXRlZCBsZW5ndGggcHJvcGVydHkuXG5cdCAqL1xuICAgIHRoaXMuY3JlYXRlTGluZVdpdGhMZW5ndGggPSBmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgIHZhciBsaW5lID0gdHVyZi5saW5lU3RyaW5nKGNvb3Jkcyk7XG4gICAgICAgIHZhciBsZW5ndGggPSB0dXJmLmxpbmVEaXN0YW5jZShsaW5lKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wZXJ0aWVzKGxpbmUsIHsgbGVuZ3RoOiBsZW5ndGggfSk7XG4gICAgICAgIHJldHVybiBsaW5lO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIHJlZHVjZVByZWNpc2lvblxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiByZWR1Y2VzIHRoZSBwcmVjaXNpb24gb2YgdGhlIGNvb3JkaW5hdGVzIHRvIDcgZGVjaW1hbCBwbGFjZXMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvb3JkcyAtIEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGNvb3JkaW5hdGVzIHRvIGJlIHByb2Nlc3NlZC5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgY29vcmRpbmF0ZXMgd2l0aCByZWR1Y2VkIHByZWNpc2lvbiB0byA3IGRlY2ltYWwgcGxhY2VzLlxuXHQgKi9cbiAgICB0aGlzLnJlZHVjZVByZWNpc2lvbiA9IGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgY29vcmRzWzBdID0gTnVtYmVyKE51bWJlcihjb29yZHNbMF0pLnRvRml4ZWQoNykpO1xuICAgICAgICBjb29yZHNbMV0gPSBOdW1iZXIoTnVtYmVyKGNvb3Jkc1sxXSkudG9GaXhlZCg3KSk7XG4gICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgY3JlYXRlQmJveFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSBvZiB0d28gY29vcmRpbmF0ZXMgYW5kIGNvbnN0cnVjdHMgYSBib3VuZGluZyBib3ggb2JqZWN0IHdpdGggd2VzdCwgZWFzdCwgc291dGgsIGFuZCBub3J0aCBwcm9wZXJ0aWVzLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb29yZHMgLSBBbiBhcnJheSBvZiB0d28gY29vcmRpbmF0ZXMgaW4gdGhlIGZvcm1hdCBbW2xvbjEsIGxhdDFdLCBbbG9uMiwgbGF0Ml1dLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYm91bmRpbmcgYm94IG9iamVjdCB3aXRoIHdlc3QsIGVhc3QsIHNvdXRoLCBhbmQgbm9ydGggcHJvcGVydGllcy5cblx0ICovXG4gICAgdGhpcy5jcmVhdGVCYm94ID0gZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICB2YXIgYmJveDEgPSB7fTtcbiAgICAgICAgaWYgKGNvb3Jkc1swXVswXSA8IGNvb3Jkc1sxXVswXSkge1xuICAgICAgICAgICAgYmJveDEud2VzdCA9IGNvb3Jkc1swXVswXTtcbiAgICAgICAgICAgIGJib3gxLmVhc3QgPSBjb29yZHNbMV1bMF07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYm94MS53ZXN0ID0gY29vcmRzWzFdWzBdO1xuICAgICAgICAgICAgYmJveDEuZWFzdCA9IGNvb3Jkc1swXVswXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29vcmRzWzBdWzFdIDwgY29vcmRzWzFdWzFdKSB7XG4gICAgICAgICAgICBiYm94MS5zb3V0aCA9IGNvb3Jkc1swXVsxXTtcbiAgICAgICAgICAgIGJib3gxLm5vcnRoID0gY29vcmRzWzFdWzFdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmJveDEuc291dGggPSBjb29yZHNbMV1bMV07XG4gICAgICAgICAgICBiYm94MS5ub3J0aCA9IGNvb3Jkc1swXVsxXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmJveDE7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgc3RyaW5nVG9ET01cblx0ICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgRE9NIG9iamVjdCB1c2luZyBET01QYXJzZXIuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzdHIgLSBUaGUgaW5wdXQgc3RyaW5nIHRvIGJlIGNvbnZlcnRlZCB0byBhIERPTSBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtEb2N1bWVudH0gLSBUaGUgRE9NIG9iamVjdCBjcmVhdGVkIGZyb20gdGhlIGlucHV0IHN0cmluZy5cblx0ICovXG4gICAgdGhpcy5zdHJpbmdUb0RPTSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgdmFyIHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5wYXJzZUZyb21TdHJpbmcoc3RyLCBcInRleHQveG1sXCIpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIHByb2Nlc3NGaWxlc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiByZWFkcyBlYWNoIGZpbGUgaW4gdGhlIGlucHV0IGFycmF5LCBleHRyYWN0cyB0aGUgZmlsZSBuYW1lIGFuZCBleHRlbnNpb24sIGFuZCB0aGVuIHJlYWRzIHRoZSBmaWxlIGNvbnRlbnQgdXNpbmcgRmlsZVJlYWRlci4gVGhlIGNvbnRlbnQgaXMgcGFzc2VkIHRvIHRoZSBoYW5kbGVyIGZ1bmN0aW9uIGFsb25nIHdpdGggdGhlIGZpbGUgbmFtZSBhbmQgZXh0ZW5zaW9uLlxuXHQgKiBAcGFyYW0ge0ZpbGVbXX0gZmlsZXMgLSBBbiBhcnJheSBvZiBGaWxlIG9iamVjdHMgdG8gYmUgcHJvY2Vzc2VkLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIC0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoIGZpbGUgd2l0aCB0aGUgZmlsZSBjb250ZW50LCBuYW1lLCBhbmQgZXh0ZW5zaW9uIGFzIHBhcmFtZXRlcnMuXG5cdCAqL1xuICAgIHRoaXMucHJvY2Vzc0ZpbGVzID0gZnVuY3Rpb24gKGZpbGVzLCBoYW5kbGVyKSB7XG4gICAgICAgIGZpbGVzLmZvckVhY2goZnVuY3Rpb24oZmlsZSkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBmaWxlLm5hbWU7XG4gICAgICAgICAgICB2YXIgZXh0ID0gbmFtZS5zdWJzdHJpbmcobmFtZS5sYXN0SW5kZXhPZignLicpICsgMSwgbmFtZS5sZW5ndGgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cbiAgICAgICAgICAgIGZpbGVSZWFkZXIub25sb2FkZW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbGVSZWFkZXIucmVhZHlTdGF0ZSA9PT0gRmlsZVJlYWRlci5ET05FKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyKGZpbGVSZWFkZXIucmVzdWx0LCBuYW1lLCBleHQpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIEpTT04gZGF0YVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNUZXh0KGZpbGUpO1xuICAgICAgICB9KTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBjb21iaW5lU2FtZVR5cGVGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB0YWtlcyBhbiBhcnJheSBvZiBsaW5lIGZlYXR1cmVzIGFuZCBjb21iaW5lcyB0aGVtIGJ5IGNvbm5lY3RpbmcgdGhlbSBiYXNlZCBvbiB0aGVpciBjb29yZGluYXRlcy4gSXQgY2hlY2tzIHRoZSBlbmRwb2ludHMgb2YgZWFjaCBsaW5lIGZlYXR1cmUgYW5kIGNvbm5lY3RzIHRoZW0gYWNjb3JkaW5nbHkgdG8gZm9ybSBhIGNvbnRpbnVvdXMgbGluZS5cblx0ICogQHBhcmFtIHtBcnJheX0gZmVhdHVyZXMgLSBBbiBhcnJheSBvZiBsaW5lIGZlYXR1cmVzIHRvIGJlIGNvbWJpbmVkLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IC0gQW4gYXJyYXkgb2YgY29vcmRpbmF0ZXMgcmVwcmVzZW50aW5nIHRoZSBjb21iaW5lZCBsaW5lIGZlYXR1cmVzLlxuXHQgKi9cbiAgICB0aGlzLmNvbWJpbmVTYW1lVHlwZUZlYXR1cmVzID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBbXTtcblxuICAgICAgICBmZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGxpbmVTdHJpbmcpIHtcbiAgICAgICAgICAgIGlmIChjb29yZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzLnB1c2guYXBwbHkoY29vcmRzLCBfdG9Db25zdW1hYmxlQXJyYXkobGluZVN0cmluZy5nZW9tZXRyeS5jb29yZGluYXRlcykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZmlyc3RQb2ludCA9IGNvb3Jkc1swXTtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFBvaW50ID0gY29vcmRzW2Nvb3Jkcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudEZpcnN0UG9pbnQgPSBsaW5lU3RyaW5nLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50TGFzdFBvaW50ID0gbGluZVN0cmluZy5nZW9tZXRyeS5jb29yZGluYXRlc1tsaW5lU3RyaW5nLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQb2ludEVxdWFsKGxhc3RQb2ludCwgY3VycmVudEZpcnN0UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoLmFwcGx5KGNvb3JkcywgX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVTdHJpbmcuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuc2xpY2UoMSwgbGluZVN0cmluZy5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGgpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzUG9pbnRFcXVhbChsYXN0UG9pbnQsIGN1cnJlbnRMYXN0UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoLmFwcGx5KGNvb3JkcywgX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVTdHJpbmcuZ2VvbWV0cnkuY29vcmRpbmF0ZXMuc2xpY2UoMCwgbGluZVN0cmluZy5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggLSAxKS5yZXZlcnNlKCkpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNQb2ludEVxdWFsKGZpcnN0UG9pbnQsIGN1cnJlbnRMYXN0UG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5zcGxpY2UuYXBwbHkoY29vcmRzLCBbMCwgMF0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShsaW5lU3RyaW5nLmdlb21ldHJ5LmNvb3JkaW5hdGVzLnNsaWNlKDAsIGxpbmVTdHJpbmcuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoIC0gMSkpKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmlzUG9pbnRFcXVhbChmaXJzdFBvaW50LCBjdXJyZW50Rmlyc3RQb2ludCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRzLnNwbGljZS5hcHBseShjb29yZHMsIFswLCAxXS5jb25jYXQoX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVTdHJpbmcuZ2VvbWV0cnkuY29vcmRpbmF0ZXMucmV2ZXJzZSgpKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZVRvRmlyc3RQb2ludCA9IHR1cmYuZGlzdGFuY2UobGFzdFBvaW50LCBjdXJyZW50Rmlyc3RQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXN0YW5jZVRvTGFzdFBvaW50ID0gdHVyZi5kaXN0YW5jZShsYXN0UG9pbnQsIGN1cnJlbnRMYXN0UG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChkaXN0YW5jZVRvRmlyc3RQb2ludCA8IGRpc3RhbmNlVG9MYXN0UG9pbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoLmFwcGx5KGNvb3JkcywgX3RvQ29uc3VtYWJsZUFycmF5KGxpbmVTdHJpbmcuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvb3Jkcy5wdXNoLmFwcGx5KGNvb3JkcywgX3RvQ29uc3VtYWJsZUFycmF5KFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkobGluZVN0cmluZy5nZW9tZXRyeS5jb29yZGluYXRlcykpLnJldmVyc2UoKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIGRlZ3JlZXMybWV0ZXJzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgaW4gZGVncmVlcyBhbmQgY29udmVydHMgaXQgdG8gbWV0ZXJzIHVzaW5nIHRoZSBNZXJjYXRvciBwcm9qZWN0aW9uIGZvcm11bGEuXG5cdCAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcHggLSBBbiBhcnJheSBjb250YWluaW5nIGxhdGl0dWRlIGFuZCBsb25naXR1ZGUgaW4gZGVncmVlcyBbbG9uZ2l0dWRlLCBsYXRpdHVkZV0uXG5cdCAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBjb252ZXJ0ZWQgeCBhbmQgeSBjb29yZGluYXRlcyBpbiBtZXRlcnMuXG5cdCAqL1xuICAgIHRoaXMuZGVncmVlczJtZXRlcnMgPSBmdW5jdGlvbiAocHgpIHtcbiAgICAgICAgY29uc3QgeCA9IHB4WzBdICogMjAwMzc1MDguMzQgLyAxODA7XG4gICAgICAgIGxldCB5ID0gTWF0aC5sb2coTWF0aC50YW4oKDkwICsgcHhbMV0pICogTWF0aC5QSSAvIDM2MCkpIC8gKE1hdGguUEkgLyAxODApO1xuICAgICAgICB5ID0geSAqIDIwMDM3NTA4LjM0IC8gMTgwO1xuICAgICAgICByZXR1cm4gW3gsIHldXG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgbWV0ZXJzMmRlZ3JlZXNcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBwaXhlbCB2YWx1ZSBhbmQgY29udmVydHMgaXQgdG8gbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSBpbiBkZWdyZWVzLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBweCAtIFRoZSBwaXhlbCB2YWx1ZSB0byBiZSBjb252ZXJ0ZWQsIGluIHRoZSBmb3JtYXQgW3gsIHldLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgaW4gZGVncmVlcywgW2xvbiwgbGF0XS5cblx0ICovXG4gICAgdGhpcy5tZXRlcnMyZGVncmVlcyA9IGZ1bmN0aW9uIChweCkge1xuICAgICAgICBjb25zdCBsb24gPSBweFswXSAqIDE4MCAvIDIwMDM3NTA4LjM0O1xuICAgICAgICBjb25zdCBsYXQgPSBNYXRoLmF0YW4oTWF0aC5leHAocHhbMV0gKiBNYXRoLlBJIC8gMjAwMzc1MDguMzQpKSAqIDM2MCAvIE1hdGguUEkgLSA5MDtcbiAgICAgICAgcmV0dXJuIFtsb24sIGxhdF1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBleHRlbmRcblx0ICogQGRlc2NyaXB0aW9uIEV4dGVuZHMgdGhlIHByb3BlcnRpZXMgb2YgdGhlIGZpcnN0IG9iamVjdCB3aXRoIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdWJzZXF1ZW50IG9iamVjdHMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkLlxuXHQgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyAtIFRoZSBvYmplY3RzIHdob3NlIHByb3BlcnRpZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgdGFyZ2V0IG9iamVjdC5cblx0ICogQHJldHVybiB7T2JqZWN0fSBUaGUgZXh0ZW5kZWQgb2JqZWN0LlxuXHQgKi9cbiAgICB0aGlzLmV4dGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZm9yKHZhciBpPTE7IGk8YXJndW1lbnRzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgZm9yKHZhciBrZXkgaW4gYXJndW1lbnRzW2ldKVxuICAgICAgICAgICAgICAgIGlmKGFyZ3VtZW50c1tpXS5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNbMF1ba2V5XSA9IGFyZ3VtZW50c1tpXVtrZXldO1xuICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uVXRpbGl0aWVzXG5cdCAqIEBuYW1lIGNsb25lXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHJlY3Vyc2l2ZWx5IGNsb25lcyB0aGUgaW5wdXQgb2JqZWN0IG9yIGFycmF5LCBwcmVzZXJ2aW5nIHRoZSBzdHJ1Y3R1cmUgYW5kIHR5cGVzIG9mIHRoZSBlbGVtZW50cy5cblx0ICogQHBhcmFtIHtPYmplY3R8QXJyYXl8RGF0ZXxSZWdFeHB8RnVuY3Rpb258U3ltYm9sfSB0aGluZyAtIFRoZSBvYmplY3Qgb3IgYXJyYXkgdG8gYmUgY2xvbmVkLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIE9wdGlvbmFsIHNldHRpbmdzIGZvciBjbG9uaW5nIGZ1bmN0aW9ucyBhbmQgc3ltYm9scy5cblx0ICogQHJldHVybnMge09iamVjdHxBcnJheXxEYXRlfFJlZ0V4cHxGdW5jdGlvbnxTeW1ib2x9IC0gQSBkZWVwIGNsb25lIG9mIHRoZSBpbnB1dCBvYmplY3Qgb3IgYXJyYXkuXG5cdCAqL1xuICAgIHRoaXMuY2xvbmUgPSBmdW5jdGlvbih0aGluZywgb3B0cykge1xuICAgICAgICB2YXIgbmV3T2JqZWN0ID0ge307XG5cbiAgICAgICAgaWYgKHRoaW5nIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGluZy5tYXAoZnVuY3Rpb24gKGkpIHsgcmV0dXJuIHRoaXMuY2xvbmUoaSwgb3B0cyk7IH0sIHRoaXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaW5nIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHRoaW5nKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGluZyBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAodGhpbmcpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaW5nIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRzICYmIG9wdHMubmV3Rm5zID9cbiAgICAgICAgICAgIG5ldyBGdW5jdGlvbigncmV0dXJuICcgKyB0aGluZy50b1N0cmluZygpKSgpIDpcbiAgICAgICAgICAgIHRoaW5nO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaW5nIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0aGluZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IG5ld09iamVjdFtrZXldID0gdGhpcy5jbG9uZSh0aGluZ1trZXldLCBvcHRzKTsgfSwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3T2JqZWN0O1xuICAgICAgICB9IGVsc2UgaWYgKFsgdW5kZWZpbmVkLCBudWxsIF0uaW5kZXhPZih0aGluZykgPiAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaW5nLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdTeW1ib2wnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFN5bWJvbCh0aGluZy50b1N0cmluZygpLnJlcGxhY2UoL15TeW1ib2xcXCgvLCAnJykuc2xpY2UoMCwgLTEpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaW5nLl9fcHJvdG9fXy5jb25zdHJ1Y3Rvcih0aGluZyk7XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLlV0aWxpdGllc1xuXHQgKiBAbmFtZSBjbG9uZURlZXBcblx0ICogQGRlc2NyaXB0aW9uIFJlY3Vyc2l2ZWx5IGNsb25lcyBhIHZhbHVlLCBpbmNsdWRpbmcgb2JqZWN0cyBhbmQgYXJyYXlzLCBwcmVzZXJ2aW5nIHRoZSBvcmlnaW5hbCBzdHJ1Y3R1cmUgZGVlcGx5LlxuXHQgKiBAcGFyYW0ge2FueX0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gYmUgY2xvbmVkLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnN0YW5jZSAtIEEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCB0byBjbG9uZSBjdXN0b20gaW5zdGFuY2VzLlxuXHQgKiBAcmV0dXJucyB7YW55fSAtIFRoZSBkZWVwbHkgY2xvbmVkIHZhbHVlLlxuXHQgKi9cbiAgICB0aGlzLmNsb25lRGVlcCA9IGZ1bmN0aW9uKHZhbHVlLCBpbnN0YW5jZSkge1xuICAgICAgICB2YXIgaGFzT3duID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgICAgICAgdmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBcbiAgICAgICAgZnVuY3Rpb24gX2Nsb25lRGVlcCh2YWwsIGluc3RhbmNlQ2xvbmUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoa2luZE9mKHZhbCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNsb25lT2JqZWN0RGVlcCh2YWwsIGluc3RhbmNlQ2xvbmUpO1xuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5RGVlcCh2YWwsIGluc3RhbmNlQ2xvbmUpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZSh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBjbG9uZU9iamVjdERlZXAob2JqLCBpbnN0YW5jZUNsb25lKSB7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qob2JqKSkge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBmb3JPd24ob2JqLCBmdW5jdGlvbihvYmosIGtleSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW2tleV0gPSBfY2xvbmVEZWVwKG9iaiwgaW5zdGFuY2VDbG9uZSk7XG4gICAgICAgICAgICAgICAgfSwgcmVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbnN0YW5jZUNsb25lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlQ2xvbmUob2JqKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBjbG9uZUFycmF5RGVlcChhcnIsIGluc3RhbmNlQ2xvbmUpIHtcbiAgICAgICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoXG4gICAgICAgICAgICAsIHJlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgICAgIHdoaWxlICgrK2kgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICByZXNbaV0gPSBfY2xvbmVEZWVwKGFycltpXSwgaW5zdGFuY2VDbG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCAhPSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkodmFsKSA9PT0gZmFsc2U7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gaXNPYmplY3RPYmplY3Qobykge1xuICAgICAgICAgICAgcmV0dXJuIGlzT2JqZWN0KG8pID09PSB0cnVlICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gICAgICAgICAgICB2YXIgY3RvciwgcHJvdDtcbiAgICBcbiAgICAgICAgICAgIGlmIChpc09iamVjdE9iamVjdChvKSA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIFxuICAgICAgICAgICAgLy8gSWYgaGFzIG1vZGlmaWVkIGNvbnN0cnVjdG9yXG4gICAgICAgICAgICBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3RvciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgXG4gICAgICAgICAgICAvLyBJZiBoYXMgbW9kaWZpZWQgcHJvdG90eXBlXG4gICAgICAgICAgICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3RPYmplY3QocHJvdCkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBcbiAgICAgICAgICAgIC8vIElmIGNvbnN0cnVjdG9yIGRvZXMgbm90IGhhdmUgYW4gT2JqZWN0LXNwZWNpZmljIG1ldGhvZFxuICAgICAgICAgICAgaWYgKHByb3QuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyBNb3N0IGxpa2VseSBhIHBsYWluIE9iamVjdFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gZm9ySW4ob2JqLCBmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChmbi5jYWxsKHRoaXNBcmcsIG9ialtrZXldLCBrZXksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBmb3JPd24ob2JqLCBmbiwgdGhpc0FyZykge1xuICAgICAgICAgICAgZm9ySW4ob2JqLCBmdW5jdGlvbih2YWwsIGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuLmNhbGwodGhpc0FyZywgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBraW5kT2YodmFsKSB7XG4gICAgICAgICAgICAvLyBwcmltaXRpdmllc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICd1bmRlZmluZWQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsID09PSB0cnVlIHx8IHZhbCA9PT0gZmFsc2UgfHwgdmFsIGluc3RhbmNlb2YgQm9vbGVhbikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYm9vbGVhbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdmFsIGluc3RhbmNlb2YgU3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInIHx8IHZhbCBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbnVtYmVyJztcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgfHwgdmFsIGluc3RhbmNlb2YgRnVuY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Z1bmN0aW9uJztcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIGFycmF5XG4gICAgICAgICAgICBpZiAodHlwZW9mIEFycmF5LmlzQXJyYXkgIT09ICd1bmRlZmluZWQnICYmIEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYXJyYXknO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGluc3RhbmNlcyBvZiBSZWdFeHAgYW5kIERhdGUgYmVmb3JlIGNhbGxpbmcgYHRvU3RyaW5nYFxuICAgICAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIG90aGVyIG9iamVjdHNcbiAgICAgICAgICAgIHZhciB0eXBlID0gdG9TdHJpbmcuY2FsbCh2YWwpO1xuICAgIFxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgQXJndW1lbnRzXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FyZ3VtZW50cyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZXJyb3InO1xuICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgLy8gYnVmZmVyXG4gICAgICAgICAgICBpZiAoaXNCdWZmZXIodmFsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnYnVmZmVyJztcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIGVzNjogTWFwLCBXZWFrTWFwLCBTZXQsIFdlYWtTZXRcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBTZXRdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnc2V0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBXZWFrU2V0XScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3dlYWtzZXQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IE1hcF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdtYXAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFdlYWtNYXBdJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnd2Vha21hcCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ1tvYmplY3QgU3ltYm9sXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAvLyB0eXBlZCBhcnJheXNcbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQ4QXJyYXldJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnaW50OGFycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBVaW50OEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3VpbnQ4YXJyYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3VpbnQ4Y2xhbXBlZGFycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQxNkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2ludDE2YXJyYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQxNkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3VpbnQxNmFycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBJbnQzMkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2ludDMyYXJyYXknO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGUgPT09ICdbb2JqZWN0IFVpbnQzMkFycmF5XScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3VpbnQzMmFycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBGbG9hdDMyQXJyYXldJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvYXQzMmFycmF5JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlID09PSAnW29iamVjdCBGbG9hdDY0QXJyYXldJykge1xuICAgICAgICAgICAgICAgIHJldHVybiAnZmxvYXQ2NGFycmF5JztcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIC8vIG11c3QgYmUgYSBwbGFpbiBvYmplY3RcbiAgICAgICAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmdW5jdGlvbiBpc0J1ZmZlcihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiBvYmogIT0gbnVsbCAmJiAoX2lzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIF9pc0J1ZmZlcihvYmopIHtcbiAgICAgICAgICAgIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gaXNTbG93QnVmZmVyKG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gaXNFeHRlbmRhYmxlKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgIT09ICd1bmRlZmluZWQnICYmIHZhbCAhPT0gbnVsbCAmJiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgZnVuY3Rpb24gbWl4aW4odGFyZ2V0LCBvYmplY3RzKSB7XG4gICAgICAgICAgICBpZiAoIWlzRXh0ZW5kYWJsZSh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWl4aW4tb2JqZWN0IGV4cGVjdHMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIGJlIGFuIG9iamVjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgICAgICAgICAsIGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzRXh0ZW5kYWJsZShvYmopKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvckluKG9iaiwgY29weSwgdGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGZ1bmN0aW9uIGNsb25lKHZhbCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBraW5kT2YodmFsKTtcbiAgICBcbiAgICAgICAgICAgIGlmIChjbG9uZS5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZVt0eXBlXSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBjbG9uZS5hcnJheSA9IGZ1bmN0aW9uIGNsb25lQXJyYXkoYXJyKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyLnNsaWNlKCk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgY2xvbmUuZGF0ZSA9IGZ1bmN0aW9uIGNsb25lRGF0ZShkYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoK2RhdGUpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGNsb25lLm9iamVjdCA9IGZ1bmN0aW9uIGNsb25lT2JqZWN0KG9iaikge1xuICAgICAgICAgICAgaWYgKGlzRXh0ZW5kYWJsZShvYmopKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1peGluKHt9LCBvYmopO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgXG4gICAgICAgIGNsb25lLnJlZ2V4cCA9IGZ1bmN0aW9uIGNsb25lUmVnRXhwKHJlKSB7XG4gICAgICAgICAgICB2YXIgZmxhZ3MgPSAnJztcbiAgICAgICAgICAgIGZsYWdzICs9IHJlLm11bHRpbGluZSA/ICdtJyA6ICcnO1xuICAgICAgICAgICAgZmxhZ3MgKz0gcmUuZ2xvYmFsID8gJ2cnIDogJyc7XG4gICAgICAgICAgICBmbGFncyArPSByZS5pZ25vcmVjYXNlID8gJ2knIDogJyc7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChyZS5zb3VyY2UsZmxhZ3MpO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHJldHVybiBfY2xvbmVEZWVwKHZhbHVlLCBpbnN0YW5jZSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgYXNzaWduRGVlcFxuXHQgKiBAZGVzY3JpcHRpb24gUmVjdXJzaXZlbHkgYXNzaWducyBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3QgdG8gdGFyZ2V0IG9iamVjdCBkZWVwbHkuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCB0byB3aGljaCBwcm9wZXJ0aWVzIHdpbGwgYmUgYXNzaWduZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgLSBUaGUgc291cmNlIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIHRhcmdldC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgYXNzaWdubWVudCBwcm9jZXNzLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzTXV0YXRpbmdPaz1mYWxzZV0gLSBGbGFnIHRvIGFsbG93IG11dGF0aW5nIHRoZSB0YXJnZXQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmlzU3RyaWN0bHlTYWZlPWZhbHNlXSAtIEZsYWcgdG8gZW5mb3JjZSBzdHJpY3Qgc2FmZXR5IGNoZWNrcyBkdXJpbmcgYXNzaWdubWVudC5cblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIHRhcmdldCBvYmplY3Qgd2l0aCBhc3NpZ25lZCBwcm9wZXJ0aWVzIGZyb20gdGhlIHNvdXJjZSBvYmplY3QuXG5cdCAqL1xuICAgIHRoaXMuYXNzaWduRGVlcCA9IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSwge2lzTXV0YXRpbmdPayA9IGZhbHNlLCBpc1N0cmljdGx5U2FmZSA9IGZhbHNlfSA9IHt9KSB7XG4gICAgICAgIHRhcmdldCA9IGlzTXV0YXRpbmdPayA/IHRhcmdldCA6IHRoaXMuY2xvbmVEZWVwKHRhcmdldCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGlmICh2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gYG9iamVjdGApIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W2tleV0gPT09IHVuZGVmaW5lZCkgdGFyZ2V0W2tleV0gPSB7fTsgICAgXG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSB0aGlzLmFzc2lnbkRlZXAodGFyZ2V0W2tleV0sIHZhbCwge2lzTXV0YXRpbmdPazogdHJ1ZX0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgY29tcGFyZURlZXBcblx0ICogQGRlc2NyaXB0aW9uIFJlY3Vyc2l2ZWx5IGNvbXBhcmVzIHR3byBvYmplY3RzIGRlZXBseSB0byBjaGVjayBpZiB0aGV5IGFyZSBlcXVhbC5cblx0ICogQHBhcmFtIHtPYmplY3R9IHggLSBUaGUgZmlyc3Qgb2JqZWN0IHRvIGNvbXBhcmUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSB5IC0gVGhlIHNlY29uZCBvYmplY3QgdG8gY29tcGFyZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgb2JqZWN0cyBhcmUgZGVlcGx5IGVxdWFsLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuICAgIHRoaXMuY29tcGFyZURlZXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGksIGwsIGxlZnRDaGFpbiwgcmlnaHRDaGFpbjtcbiAgICAgIFxuICAgICAgICBmdW5jdGlvbiBjb21wYXJlMk9iamVjdHMgKHgsIHkpIHtcbiAgICAgICAgICB2YXIgcDtcbiAgICAgIFxuICAgICAgICAgIC8vIHJlbWVtYmVyIHRoYXQgTmFOID09PSBOYU4gcmV0dXJucyBmYWxzZVxuICAgICAgICAgIC8vIGFuZCBpc05hTih1bmRlZmluZWQpIHJldHVybnMgdHJ1ZVxuICAgICAgICAgIGlmIChpc05hTih4KSAmJiBpc05hTih5KSAmJiB0eXBlb2YgeCA9PT0gJ251bWJlcicgJiYgdHlwZW9mIHkgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICAvLyBDb21wYXJlIHByaW1pdGl2ZXMgYW5kIGZ1bmN0aW9ucy4gICAgIFxuICAgICAgICAgIC8vIENoZWNrIGlmIGJvdGggYXJndW1lbnRzIGxpbmsgdG8gdGhlIHNhbWUgb2JqZWN0LlxuICAgICAgICAgIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBzdGVwIHdoZXJlIHdlIGNvbXBhcmUgcHJvdG90eXBlc1xuICAgICAgICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgIC8vIFdvcmtzIGluIGNhc2Ugd2hlbiBmdW5jdGlvbnMgYXJlIGNyZWF0ZWQgaW4gY29uc3RydWN0b3IuXG4gICAgICAgICAgLy8gQ29tcGFyaW5nIGRhdGVzIGlzIGEgY29tbW9uIHNjZW5hcmlvLiBBbm90aGVyIGJ1aWx0LWlucz9cbiAgICAgICAgICAvLyBXZSBjYW4gZXZlbiBoYW5kbGUgZnVuY3Rpb25zIHBhc3NlZCBhY3Jvc3MgaWZyYW1lc1xuICAgICAgICAgIGlmICgodHlwZW9mIHggPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHkgPT09ICdmdW5jdGlvbicpIHx8XG4gICAgICAgICAgICAgKHggaW5zdGFuY2VvZiBEYXRlICYmIHkgaW5zdGFuY2VvZiBEYXRlKSB8fFxuICAgICAgICAgICAgICh4IGluc3RhbmNlb2YgUmVnRXhwICYmIHkgaW5zdGFuY2VvZiBSZWdFeHApIHx8XG4gICAgICAgICAgICAgKHggaW5zdGFuY2VvZiBTdHJpbmcgJiYgeSBpbnN0YW5jZW9mIFN0cmluZykgfHxcbiAgICAgICAgICAgICAoeCBpbnN0YW5jZW9mIE51bWJlciAmJiB5IGluc3RhbmNlb2YgTnVtYmVyKSkge1xuICAgICAgICAgICAgICByZXR1cm4geC50b1N0cmluZygpID09PSB5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgXG4gICAgICAgICAgLy8gQXQgbGFzdCBjaGVja2luZyBwcm90b3R5cGVzIGFzIGdvb2QgYXMgd2UgY2FuXG4gICAgICAgICAgaWYgKCEoeCBpbnN0YW5jZW9mIE9iamVjdCAmJiB5IGluc3RhbmNlb2YgT2JqZWN0KSkge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgXG4gICAgICAgICAgaWYgKHguaXNQcm90b3R5cGVPZih5KSB8fCB5LmlzUHJvdG90eXBlT2YoeCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgIGlmICh4LmNvbnN0cnVjdG9yICE9PSB5LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICBpZiAoeC5wcm90b3R5cGUgIT09IHkucHJvdG90eXBlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICAvLyBDaGVjayBmb3IgaW5maW5pdGl2ZSBsaW5raW5nIGxvb3BzXG4gICAgICAgICAgaWYgKGxlZnRDaGFpbi5pbmRleE9mKHgpID4gLTEgfHwgcmlnaHRDaGFpbi5pbmRleE9mKHkpID4gLTEpIHtcbiAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICAvLyBRdWljayBjaGVja2luZyBvZiBvbmUgb2JqZWN0IGJlaW5nIGEgc3Vic2V0IG9mIGFub3RoZXIuXG4gICAgICAgICAgLy8gdG9kbzogY2FjaGUgdGhlIHN0cnVjdHVyZSBvZiBhcmd1bWVudHNbMF0gZm9yIHBlcmZvcm1hbmNlXG4gICAgICAgICAgZm9yIChwIGluIHkpIHtcbiAgICAgICAgICAgICAgaWYgKHkuaGFzT3duUHJvcGVydHkocCkgIT09IHguaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgeVtwXSAhPT0gdHlwZW9mIHhbcF0pIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgIGZvciAocCBpbiB4KSB7XG4gICAgICAgICAgICAgIGlmICh5Lmhhc093blByb3BlcnR5KHApICE9PSB4Lmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHlbcF0gIT09IHR5cGVvZiB4W3BdKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgICAgICBzd2l0Y2ggKHR5cGVvZiAoeFtwXSkpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBsZWZ0Q2hhaW4ucHVzaCh4KTtcbiAgICAgICAgICAgICAgICAgICAgICByaWdodENoYWluLnB1c2goeSk7XG4gICAgICBcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUyT2JqZWN0cyAoeFtwXSwgeVtwXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgIGxlZnRDaGFpbi5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICByaWdodENoYWluLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgXG4gICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgIGlmICh4W3BdICE9PSB5W3BdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkgcmV0dXJuIHRydWU7XG4gICAgICBcbiAgICAgICAgZm9yIChpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIFxuICAgICAgICAgICAgbGVmdENoYWluID0gW107IC8vVG9kbzogdGhpcyBjYW4gYmUgY2FjaGVkXG4gICAgICAgICAgICByaWdodENoYWluID0gW107XG4gICAgICBcbiAgICAgICAgICAgIGlmICghY29tcGFyZTJPYmplY3RzKGFyZ3VtZW50c1swXSwgYXJndW1lbnRzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICBcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5VdGlsaXRpZXNcblx0ICogQG5hbWUgY29uc3VtYWJsZUFycmF5XG5cdCAqIEBkZXNjcmlwdGlvbiBDcmVhdGVzIGEgY29uc3VtYWJsZSBjb3B5IG9mIGFuIGFycmF5IG9yIGFycmF5LWxpa2Ugb2JqZWN0LlxuXHQgKiBAcGFyYW0ge0FycmF5fEFycmF5LWxpa2V9IGFyciAtIFRoZSBpbnB1dCBhcnJheSBvciBhcnJheS1saWtlIG9iamVjdCB0byBiZSBjb3BpZWQuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBjb25zdW1hYmxlIGNvcHkgb2YgdGhlIGlucHV0IGFycmF5IG9yIGFycmF5LWxpa2Ugb2JqZWN0LlxuXHQgKi9cbiAgICB0aGlzLmNvbnN1bWFibGVBcnJheSA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBBcnJheShhcnIubGVuZ3RoKTsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBBcnJheS5mcm9tKGFycik7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFycjJbaV0gPSBhcnJbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20oYXJyKTtcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFV0aWxpdGllczsiLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsImltcG9ydCBTdGF0aWNzIGZyb20gJy4vc3JjL1N0YXRpY3MuanMnO1xuaW1wb3J0IE9wdGlvbnMgZnJvbSAnLi9zcmMvT3B0aW9ucy5qcyc7XG5pbXBvcnQgVXRpbGl0aWVzIGZyb20gJy4vc3JjL1V0aWxpdGllcy5qcyc7XG5pbXBvcnQgU3R5bGVzIGZyb20gJy4vc3JjL1N0eWxlcy5qcyc7XG5pbXBvcnQgTGF5ZXJzIGZyb20gJy4vc3JjL0xheWVycy5qcyc7XG5pbXBvcnQgRmVhdHVyZXMgZnJvbSAnLi9zcmMvRmVhdHVyZXMuanMnO1xuaW1wb3J0IE1lc2ggZnJvbSAnLi9zcmMvTWVzaC5qcyc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vc3JjL0V2ZW50cy5qcyc7XG5pbXBvcnQgU2VsZWN0IGZyb20gJy4vc3JjL1NlbGVjdC5qcyc7XG5pbXBvcnQgRHJhdyBmcm9tICcuL3NyYy9EcmF3LmpzJztcbmltcG9ydCBMb2NhdGUgZnJvbSAnLi9zcmMvTG9jYXRlLmpzJztcbmltcG9ydCBTbmFwcGluZyBmcm9tICcuL3NyYy9TbmFwcGluZy5qcyc7XG5pbXBvcnQgUGlubmluZyBmcm9tICcuL3NyYy9QaW5uaW5nLmpzJztcbmltcG9ydCBSb3V0aW5nIGZyb20gJy4vc3JjL1JvdXRpbmcuanMnO1xuaW1wb3J0IEV4cGxvcmluZyBmcm9tICcuL3NyYy9FeHBsb3JpbmcuanMnO1xuaW1wb3J0IFBhaW50aW5nIGZyb20gJy4vc3JjL1BhaW50aW5nLmpzJztcbmltcG9ydCBDb250cm9sIGZyb20gJy4vc3JjL0NvbnRyb2wuanMnO1xuaW1wb3J0IEdhbWVwYWQgZnJvbSAnLi9zcmMvR2FtZXBhZC5qcyc7XG5cbi8qKlxuICogQG1vZHVsZSBnZW9mbG9cbiAqIEBuYW1lIGdlb2Zsb1xuICogQGRlc2NyaXB0aW9uIFJlcHJlc2VudHMgdGhlIEdlb0ZsbyBvYmplY3QgdGhhdCBtYW5hZ2VzIGFsbCBtb2R1bGVzLlxuICogQHJldHVybnMge09iamVjdH0gVGhlIEdlb0ZsbyBvYmplY3Qgd2l0aCB2YXJpb3VzIG1ldGhvZHMgZm9yIG1hbmFnaW5nIHRoZSBlbnRpcmUgYXBwLlxuICovXG5jb25zdCBHZW9GbG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgZ2VvZmxvID0gdGhpcztcbiAgICBcbiAgICB0aGlzLnN0YXRpY3MgPSBTdGF0aWNzO1xuICAgIHRoaXMub3B0aW9ucyA9IE9wdGlvbnM7XG4gICAgdGhpcy5kZXYgPSB0aGlzLnN0YXRpY3MuZGV2ZWxvcGVyO1xuICAgIHRoaXMuaWQgPSB0aGlzLnN0YXRpY3MuaWQ7XG5cbiAgICB0aGlzLm1vZGVzID0gW107XG4gICAgdGhpcy5wbHVnaW5zID0ge307XG4gICAgdGhpcy5nYW1lcGFkcyA9IHt9O1xuICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMubW9iaWxlID0gaXNNb2JpbGUoKTtcblxuICAgIHZhciBzZWxlY3RlZEZlYXR1cmVzID0gW107XG4gICAgdmFyIGhpZGRlbkZlYXR1cmVzID0gW107XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGluaXRpYWxpemVcblx0ICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIHRoZSBvYmplY3QgYW5kIG9wdGlvbmFsbHkgYXNzaWducyBpdCB0byB0aGUgZ2xvYmFsIHdpbmRvdyBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBpbml0aWFsaXplZCBvYmplY3QuXG5cdCAqL1xuICAgIHRoaXMuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5pdGlhbGl6ZWQpIHJldHVybiB0aGlzO1xuICAgICAgICB3aW5kb3dbdGhpcy5pZF0gPSB0aGlzO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIFxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgaW5pdFxuXHQgKiBAZGVzY3JpcHRpb24gSW5pdGlhbGl6ZXMgdGhlIG1hcCBjb21wb25lbnQgd2l0aCB0aGUgcHJvdmlkZWQgb3B0aW9ucyBhbmQgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIHJlYWR5LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlIG9wdGlvbnMgb2JqZWN0IGZvciBjb25maWd1cmluZyB0aGUgbWFwIGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gb25SZWFkeSAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBtYXAgaXMgcmVhZHkuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG1hcCBjb21wb25lbnQgaW5zdGFuY2UuXG5cdCAqL1xuICAgIHRoaXMuaW5pdCA9IGFzeW5jIGZ1bmN0aW9uIChhY2Nlc3NUb2tlbiwgb3B0aW9ucz17fSwgb25SZWFkeSkge1xuICAgICAgICB2YXIgb25SZWFkeVJldHVybjtcblxuICAgICAgICB0aGlzLlV0aWxpdGllcyA9IG5ldyBVdGlsaXRpZXMoKTtcblxuICAgICAgICBpZiAoIWFjY2Vzc1Rva2VuKSB0aHJvdyBuZXcgRXJyb3IoJ05vIE1hcGJveCBBY2Nlc3MgVG9rZW4gUHJvdmlkZWQhJyk7XG4gICAgICAgIGlmICh0aGlzLmlzUmVhZHkpIHJldHVybiB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmNvbnRhaW5lciB8fCB0aGlzLm9wdGlvbnMubWFwLmNvbnRhaW5lcjtcbiAgICAgICAgaWYgKCFpZCkgdGhyb3cgbmV3IEVycm9yKCdFbGVtZW50IGlkIGlzIHJlcXVpcmVkIGluIHRoZSBET00gZm9yIHRoZSBtYXAhJyk7XG5cbiAgICAgICAgYXdhaXQgbG9hZFN0eWxlc2hlZXQoXCJodHRwczovL2FwaS5tYXBib3guY29tL21hcGJveC1nbC1qcy92My40LjAvbWFwYm94LWdsLmNzc1wiKTtcbiAgICAgICAgYXdhaXQgbG9hZFNjcmlwdChcImh0dHBzOi8vYXBpLm1hcGJveC5jb20vbWFwYm94LWdsLWpzL3YzLjQuMC9tYXBib3gtZ2wuanNcIik7XG4gICAgICAgIGF3YWl0IGxvYWRTY3JpcHQoXCJodHRwczovL3VucGtnLmNvbS9AdHVyZi90dXJmQDcvdHVyZi5taW4uanNcIik7XG4gICAgICAgIGF3YWl0IGxvYWRTY3JpcHQoXCJodHRwczovL2FwaS50aWxlcy5tYXBib3guY29tL21hcGJveC5qcy9wbHVnaW5zL2xlYWZsZXQtb21uaXZvcmUvdjAuMy4xL2xlYWZsZXQtb21uaXZvcmUubWluLmpzXCIpO1xuICAgICAgICBhd2FpdCBsb2FkU2NyaXB0KFwiaHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L25wbS9qc3ppcEAzLjEwLjEvZGlzdC9qc3ppcC5taW4uanNcIik7XG4gICAgICAgIGF3YWl0IGxvYWRTY3JpcHQoXCJodHRwczovL2FwaS5tYXBib3guY29tL3NlYXJjaC1qcy92MS4wLjAtYmV0YS4xOC9jb3JlLmpzXCIpO1xuXG4gICAgICAgIHRoaXMuc3R5bGVzID0gdGhpcy5vcHRpb25zLm1hcC5zdHlsZXM7XG4gICAgICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgXG4gICAgICAgIHZhciBjb250YWluZXIgPSBhd2FpdCByZWFkeShpZCk7XG4gICAgICAgIHZhciBzdHlsZSA9IHRoaXMuc3R5bGVzLmZpbmQoc3R5bGUgPT4gc3R5bGUudGl0bGUgPT09IHRoaXMub3B0aW9ucy5tYXAuc3R5bGUpLnVyaTtcblxuICAgICAgICB0aGlzLmlzUmVhZHkgPSBjb250YWluZXIgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgIGlmICghdGhpcy5pc1JlYWR5KSB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgaWQgaXMgcmVxdWlyZWQgaW4gdGhlIERPTSBmb3IgdGhlIG1hcCEnKTtcblxuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLnN0YXRpY3MuaWQpO1xuXG4gICAgICAgIGJ1aWxkTWFwYm94LmNhbGwodGhpcyk7XG5cbiAgICAgICAgdHVyZi5kaXN0YW5jZVRvRGVncmVlcyA9IGZ1bmN0aW9uIGRpc3RhbmNlVG9EZWdyZWVzKGRpc3RhbmNlSW5LbSkgeyByZXR1cm4gZGlzdGFuY2VJbkttIC8gMTExLjMyOyB9XG5cbiAgICAgICAgdGhpcy5tYXBib3ggPSBuZXcgbWFwYm94Z2wuTWFwKHtcbiAgICAgICAgICAgIGFjY2Vzc1Rva2VuOiBhY2Nlc3NUb2tlbixcbiAgICAgICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICAgICAgc3R5bGU6IHN0eWxlLFxuICAgICAgICAgICAgY2VudGVyOiB0aGlzLm9wdGlvbnMubWFwLmNlbnRlcixcbiAgICAgICAgICAgIHpvb206IHRoaXMub3B0aW9ucy5tYXAuem9vbSxcbiAgICAgICAgICAgIGhhc2g6IHRydWUsXG4gICAgICAgICAgICBwcm9qZWN0aW9uOiAnbWVyY2F0b3InLFxuICAgICAgICAgICAgZXh0ZW50OiB0aGlzLm9wdGlvbnMubWFwLmV4dGVudFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMudmlld3BvcnRIZWlnaHRPZmZzZXQgPSAxMTA7XG4gICAgICAgIHRoaXMudmlld3BvcnRXaWR0aE9mZnNldCA9IDIwO1xuICAgICAgICB0aGlzLnZpZXdwb3J0TGVmdCA9ICcxMHB4JztcbiAgICAgICAgdGhpcy52aWV3cG9ydEJvdHRvbSA9ICc1JSc7XG4gICAgICAgIHRoaXMubm9TZWxlY3QgPSBvcHRpb25zLm5vU2VsZWN0IHx8IGZhbHNlO1xuICAgICAgICB0aGlzLm1hcGJveC5vbignbG9hZCcsIHRoaXMub25Mb2FkLmJpbmQodGhpcykpO1xuXG4gICAgICAgIGF3YWl0IGxvYWRlZCh0aGlzKTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWRyYXcoKTtcblxuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KCk7XG4gICAgICAgIC8vdGhpcy5zZXRFeHRlbnQoZmFsc2UsIHRydWUpO1xuICAgICAgICB0aGlzLnNldE9wYWNpdHkodGhpcy5vcHRpb25zLm1hcC5vcGFjaXR5KTtcblxuICAgICAgICB0aGlzLmZpcmUoJ3Nkay5yZWFkeScsIHsgZW5hYmxlZDogdGhpcy5lbmFibGVkLCBtYXA6IHRoaXMubWFwLCByZWFkeTogdGhpcy5pc0xvYWRlZCB9KTtcblxuICAgICAgICBpZiAob25SZWFkeSAmJiB0eXBlb2Ygb25SZWFkeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKG9uUmVhZHkuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FzeW5jRnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgb25SZWFkeVJldHVybiA9IGF3YWl0IG9uUmVhZHkuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb25SZWFkeVJldHVybiA9IG9uUmVhZHkuY2FsbCh0aGlzLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChvblJlYWR5UmV0dXJuKSB7XG4gICAgICAgICAgICBpZiAoIW9uUmVhZHlSZXR1cm4uZGlzYWJsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVuYWJsZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBsb2FkXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGxvYWRzIHRoZSBNYXBib3hHTCBTREsgd2l0aCB0aGUgZ2l2ZW4gTWFwYm94R0wgbWFwIG9iamVjdCBhbmQgc2V0cyB1cCBuZWNlc3NhcnkgY29tcG9uZW50cyBmb3IgaW50ZXJhY3Rpb24uIExvYWRzIHRoZSBVc2VyLCBMYXllcnMsIGFuZCBGZWF0dXJlcyBjb21wb25lbnRzLCBhbmQgaW5pdGlhbGl6ZXMgZXZlbnQgbGlzdGVuZXJzLiBDYWxscyB0aGUgb25SZWFkeSBjYWxsYmFjayBpZiBwcm92aWRlZC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG1hcCAtIFRoZSBNYXBib3hHTCBtYXAgb2JqZWN0IHRvIGJlIHVzZWQgYnkgdGhlIFNESy5cblx0ICogQHJldHVybnMge09iamVjdH0gLSBSZXR1cm5zIHRoZSBTREsgaW5zdGFuY2UgYWZ0ZXIgbG9hZGluZyBhbmQgaW5pdGlhbGl6YXRpb24uXG5cdCAqL1xuICAgIHRoaXMubG9hZCA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgaWYgKHRoaXMuaXNMb2FkZWQgfHwgIXRoaXMuaXNSZWFkeSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdGhpcy5tYXAgPSBtYXA7XG5cbiAgICAgICAgdGhpcy5sb2NhdGUgPSBuZXcgTG9jYXRlKCk7XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gbmV3IG1hcGJveGdsLk5hdmlnYXRpb25Db250cm9sKHsgdmlzdWFsaXplUGl0Y2g6IHRydWUsIHNob3dab29tOiB0cnVlLCBzaG93Q29tcGFzczogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uLmhpZGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnIH0uYmluZCh0aGlzLm5hdmlnYXRpb24pO1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24uc2hvdyA9IGZ1bmN0aW9uICgpIHsgdGhpcy5fY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snIH0uYmluZCh0aGlzLm5hdmlnYXRpb24pO1xuICAgICAgICB0aGlzLm1hcC5hZGRDb250cm9sKHRoaXMubmF2aWdhdGlvbiwgJ3RvcC1yaWdodCcpO1xuXG4gICAgICAgIGlmICghdGhpcy5tb2JpbGUpIHtcbiAgICAgICAgICAgIHRoaXMuZnVsbHNjcmVlbiA9IG5ldyBtYXBib3hnbC5GdWxsc2NyZWVuQ29udHJvbCh7IGNvbnRhaW5lcjogZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpIH0pO1xuICAgICAgICAgICAgdGhpcy5mdWxsc2NyZWVuLmhpZGUgPSBmdW5jdGlvbiAoKSB7IHRoaXMuX2NvbnRyb2xDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJyB9LmJpbmQodGhpcy5mdWxsc2NyZWVuKTtcbiAgICAgICAgICAgIHRoaXMuZnVsbHNjcmVlbi5zaG93ID0gZnVuY3Rpb24gKCkgeyB0aGlzLl9jb250cm9sQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snIH0uYmluZCh0aGlzLmZ1bGxzY3JlZW4pO1xuICAgICAgICAgICAgdGhpcy5tYXAuYWRkQ29udHJvbCh0aGlzLmZ1bGxzY3JlZW4sICd0b3AtcmlnaHQnKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICB0aGlzLnN0eWxlcyA9IG5ldyBTdHlsZXModGhpcywgeyBzdHlsZXM6IHRoaXMuc3R5bGVzLCBzZWxlY3RlZDogdGhpcy5vcHRpb25zLm1hcC5zdHlsZSB9KTtcbiAgICAgICAgdGhpcy5MYXllcnMgPSBuZXcgTGF5ZXJzKHRoaXMpO1xuICAgICAgICB0aGlzLkZlYXR1cmVzID0gbmV3IEZlYXR1cmVzKHRoaXMpO1xuXG4gICAgICAgIHRoaXMubWFwLmFkZENvbnRyb2wodGhpcy5zdHlsZXMpO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5FdmVudHMgPSBFdmVudHModGhpcyk7XG4gICAgICAgIHRoaXMuRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZW5hYmxlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGVuYWJsZXMgdGhlIG1hcCBpbnRlcmFjdGlvbiBtb2RlIGJhc2VkIG9uIHRoZSBwcm92aWRlZCB0eXBlIGFuZCBvcHRpb25zLiBJdCBzZXRzIHRoZSBtb2RlIHRvICdzZWxlY3QnIG9yICdkcmF3JyBkZXBlbmRpbmcgb24gdGhlIHR5cGUgcGFyYW1ldGVyLCBpbml0aWFsaXplcyBvcHRpb25zLCBjb250cm9scywgbW9kZXMsIGFuZCB0cmlnZ2VycyBldmVudHMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgaW50ZXJhY3Rpb24gbW9kZSB0byBlbmFibGUgKCdzZWxlY3QnIG9yICdkcmF3JykuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciB0aGUgaW50ZXJhY3Rpb24gbW9kZSAoZGVmYXVsdDoge30pLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSAtIFRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBtYXAgd2l0aCB0aGUgZW5hYmxlZCBpbnRlcmFjdGlvbiBtb2RlLlxuXHQgKi9cbiAgICB0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uICh0eXBlLCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICh0aGlzLmVuYWJsZWQpIHJldHVybiB0aGlzO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5tb2RlID0gIXR5cGUgfHwgdHlwZSA9PT0gJ3NlbGVjdCcgPyAnc2VsZWN0JyA6ICdkcmF3JztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcblxuICAgICAgICB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIHRoaXMuc2V0Q29udHJvbHMoKTtcblxuICAgICAgICB0aGlzLlNlbGVjdCA9IG5ldyBTZWxlY3QodGhpcyk7XG4gICAgICAgIHRoaXMuRHJhdyA9IG5ldyBEcmF3KHRoaXMpO1xuXG4gICAgICAgIHRoaXMubW9kZXMgPSBbIHRoaXMuU2VsZWN0LCB0aGlzLkRyYXcgXTtcbiAgICAgICAgdGhpcy5lbmFibGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLnNldE1vZGUoeyBtb2RlOiB0aGlzLm1vZGUsIHR5cGU6IHRoaXMudHlwZX0pO1xuICAgICAgICB0aGlzLmZpcmUoJ21hcC5lbmFibGUnLCB7IGVuYWJsZWQ6IHRoaXMuZW5hYmxlZCwgbW9kZTogdGhpcy5tb2RlLCB0eXBlOiB0aGlzLnR5cGUgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZGlzYWJsZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBkaXNhYmxlcyB0aGUgbWFwIGJ5IGNsZWFyaW5nIG1vZGVzLCBzZXR0aW5nIGVuYWJsZWQgdG8gZmFsc2UsIHJlc2V0dGluZyBtb2RlIHRvIG51bGwsIHJlc2V0dGluZyBvcHRpb25zIHRvIGRlZmF1bHQsIGZpcmluZyBhICdtYXAuZGlzYWJsZScgZXZlbnQsIGVuYWJsaW5nIGRvdWJsZSBjbGljayB6b29tLCByZW1vdmluZyBldmVudCBsaXN0ZW5lcnMsIGxheWVycywgYW5kIGNvbnRyb2xzLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjdXJyZW50IGluc3RhbmNlIG9mIHRoZSBtYXAgb2JqZWN0LlxuXHQgKi9cbiAgICB0aGlzLmRpc2FibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm4gdGhpcztcblxuICAgICAgICB0aGlzLm1vZGVzID0gW107XG4gICAgICAgIHRoaXMuZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLm1vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPcHRpb25zO1xuICAgICAgICB0aGlzLmRvdWJsZUNsaWNrWm9vbS5lbmFibGUodGhpcy5tYXApO1xuICAgICAgICB0aGlzLkxheWVycy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLkV2ZW50cy5yZW1vdmVFdmVudExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLkxheWVycy5yZW1vdmVMYXllcnMoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVDb250cm9scygpO1xuICAgICAgICB0aGlzLmZpcmUoJ21hcC5kaXNhYmxlJywgeyBlbmFibGVkOiB0aGlzLmVuYWJsZWQsIG1vZGU6IHRoaXMubW9kZSB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSByZWRyYXdcblx0ICogQGRlc2NyaXB0aW9uIFJlZHJhd3MgdGhlIG1hcCBieSByZWZyZXNoaW5nIGxheWVycywgdXBkYXRpbmcgZXZlbnQgbGlzdGVuZXJzLCBhbmQgZGlzYWJsaW5nIGRvdWJsZSBjbGljayB6b29tLlxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHRoZSBtYXAgaXMgc3VjY2Vzc2Z1bGx5IHJlZHJhd24sIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5yZWRyYXcgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5FdmVudHMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgYXdhaXQgdGhpcy5MYXllcnMucmVmcmVzaCgpO1xuICAgICAgICBjb25zb2xlLmxvZyh0aGlzLkxheWVycy5nZXRTb3VyY2VzKCkpXG4gICAgICAgIHRoaXMuRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuRmVhdHVyZXMudXBkYXRlU291cmNlKCk7XG4gICAgICAgIHRoaXMuZG91YmxlQ2xpY2tab29tLmRpc2FibGUodGhpcy5tYXApO1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KCk7XG4gICAgICAgIHRoaXMubWFwLnN0eWxlLmdseXBoTWFuYWdlci51cmxzW1wiXCJdID0gYG1hcGJveDovL2ZvbnRzLyR7dGhpcy5kZXZ9L3tmb250c3RhY2t9L3tyYW5nZX0ucGJmYFxuICAgICAgICB0aGlzLmZpcmUoJ21hcC5yZWRyYXcnLCB7IGVuYWJsZWQ6IHRoaXMuZW5hYmxlZCwgbW9kZTogdGhpcy5tb2RlIH0pXG4gICAgICAgIGlmICh0aGlzLm9uUmVhZHkpIGF3YWl0IHRoaXMub25SZWFkeSh0aGlzKSwgZGVsZXRlIHRoaXMub25SZWFkeTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHJlZnJlc2hcblx0ICogQGRlc2NyaXB0aW9uIFJlZnJlc2hlcyB0aGUgY29udGVudCBieSByZWRyYXdpbmcgaXQgYXN5bmNocm9ub3VzbHkuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSBSZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgYm9vbGVhbiB2YWx1ZS5cblx0ICovXG4gICAgdGhpcy5yZWZyZXNoID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5ub1JlZnJlc2gpIHJldHVybiBmYWxzZTtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWRyYXcoKTtcbiAgICAgICAgdGhpcy5maXJlKCdtYXAucmVmcmVzaCcsIHsgZW5hYmxlZDogdGhpcy5lbmFibGVkLCBtb2RlOiB0aGlzLm1vZGUgfSlcbiAgICB9XG5cblxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIG9uY2Vcblx0ICogQGRlc2NyaXB0aW9uIFJlZ2lzdGVycyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIG9ubHkgb25jZSBmb3IgYSBzcGVjaWZpYyBHZW9GbG8gZXZlbnQgdHlwZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgdHlwZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIHRoZSBldmVudCBvY2N1cnMuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIGNhbGxiYWNrIGlzIHN1Y2Nlc3NmdWxseSByZWdpc3RlcmVkIHRvIGJlIGV4ZWN1dGVkIG9uY2UsIG90aGVyd2lzZSBmYWxzZS5cblx0ICovXG4gICAgdGhpcy5vbmNlID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcCAmJiB0eXBlID8gdGhpcy5tYXAub25jZSh0aGlzLmlkICsgJzonICsgdHlwZSwgY2FsbGJhY2spIDogZmFsc2U7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBvblxuXHQgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXJzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgZm9yIGEgc3BlY2lmaWMgR2VvRmxvIGV2ZW50IHR5cGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdG8gbGlzdGVuIGZvci5cblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiB0aGUgZXZlbnQgb2NjdXJzLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBldmVudCBsaXN0ZW5lciB3YXMgc3VjY2Vzc2Z1bGx5IGF0dGFjaGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuICAgIHRoaXMub24gPSBmdW5jdGlvbiAodHlwZSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjay5uYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ0Z1bmN0aW9uIG11c3QgaGF2ZSBhIG5hbWUhJylcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwICYmIHR5cGUgPyB0aGlzLm1hcC5vbih0aGlzLmlkICsgJzonICsgdHlwZSwgY2FsbGJhY2spIDogZmFsc2U7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBvZmZcblx0ICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSB0aGUgbWFwIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBHZW9GbG8gZXZlbnQgdHlwZSBhbmQgY2FsbGJhY2suIENhbGxiYWNrIGZ1bmN0aW9uIG11c3QgaGF2ZSBhIG5hbWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgZXZlbnQgdG8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tLlxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSByZW1vdmVkIGFzIHRoZSBldmVudCBsaXN0ZW5lci5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZXZlbnQgbGlzdGVuZXIgd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCAqL1xuICAgIHRoaXMub2ZmID0gZnVuY3Rpb24gKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghY2FsbGJhY2submFtZSkgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBtdXN0IGhhdmUgYSBuYW1lIScpXG4gICAgICAgIHJldHVybiB0aGlzLm1hcCAmJiB0eXBlID8gdGhpcy5tYXAub2ZmKHRoaXMuaWQgKyAnOicgKyB0eXBlLCBjYWxsYmFjaykgOiBmYWxzZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGZpcmVcblx0ICogQGRlc2NyaXB0aW9uIEZpcmVzIGFuIGV2ZW50IHdpdGggdGhlIHNwZWNpZmllZCBHZW9GbG8gdHlwZSBhbmQgZGV0YWlsLiBEZXRhaWwgaXMgYW4gT2JqZWN0IHR5cGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIC0gVGhlIHR5cGUgb2YgdGhlIGV2ZW50IHRvIGZpcmUuXG5cdCAqIEBwYXJhbSB7YW55fSBkZXRhaWwgLSBBZGRpdGlvbmFsIGRldGFpbHMgdG8gaW5jbHVkZSB3aXRoIHRoZSBldmVudC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBmaXJlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cbiAgICB0aGlzLmZpcmUgPSBmdW5jdGlvbiAodHlwZSwgZGV0YWlsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcCAmJiB0eXBlID8gdGhpcy5tYXAuZmlyZSh0aGlzLmlkICsgJzonICsgdHlwZSwgeyBkZXRhaWw6IGRldGFpbCB9KSA6IGZhbHNlO1xuICAgIH1cblxuXG5cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgc2V0T3B0aW9uc1xuXHQgKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgb3B0aW9ucyBmb3IgdGhlIG9iamVjdCBieSBtZXJnaW5nIHRoZSBwcm92aWRlZCBvcHRpb25zIHdpdGggdGhlIGV4aXN0aW5nIG9uZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgdG8gYmUgbWVyZ2VkIHdpdGggdGhlIGV4aXN0aW5nIG9wdGlvbnMuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSB1cGRhdGVkIG9wdGlvbnMgb2JqZWN0IGFmdGVyIG1lcmdpbmcuXG5cdCAqL1xuICAgIHRoaXMuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnM9e30pIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5VdGlsaXRpZXMuYXNzaWduRGVlcCh0aGlzLm9wdGlvbnMgfHwge30sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgc2V0TW9kZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBhbGxvd3MgdGhlIHVzZXIgdG8gc2V0IHRoZSBtb2RlIG9mIHRoZSBtYXAgZWRpdG9yIHdpdGggdmFyaW91cyBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdCBmb3Igc2V0dGluZyB0aGUgbW9kZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm1vZGU9J3NlbGVjdCddIC0gVGhlIG1vZGUgdG8gc2V0IChkZWZhdWx0OiBzZWxlY3QpLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudHlwZT0nTGluZVN0cmluZyddIC0gVGhlIHR5cGUgb2YgdGhlIG1vZGUgKGRlZmF1bHQ6IExpbmVTdHJpbmcpLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuZmVhdHVyZV0gLSBUaGUgZmVhdHVyZSB0byBlZGl0IGluIHRoZSBtb2RlLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgY3VycmVudCBtb2RlIGFmdGVyIHNldHRpbmcgaXQgYmFzZWQgb24gdGhlIG9wdGlvbnMuXG5cdCAqL1xuICAgIHRoaXMuc2V0TW9kZSA9IGZ1bmN0aW9uIChvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5tb2RlKSBvcHRpb25zLm1vZGUgPSB0aGlzLnN0YXRpY3MuY29uc3RhbnRzLm1vZGVzLlNFTEVDVDtcbiAgICAgICAgaWYgKCFvcHRpb25zLnR5cGUpIG9wdGlvbnMudHlwZSA9ICdQb2x5bGluZSc7XG5cbiAgICAgICAgdmFyIGNsYXNzZXNUb1JlbW92ZSA9IFtdO1xuICAgICAgICB2YXIgc2VsZWN0ZWRNb2RlID0gbnVsbDtcbiAgICAgICAgdmFyIGVkaXRNb2RlID0gb3B0aW9ucy5tb2RlID09PSB0aGlzLnN0YXRpY3MuY29uc3RhbnRzLm1vZGVzLkVESVQ7XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1vZGUgJiYgb3B0aW9ucy5tb2RlID09PSB0aGlzLm1vZGUgJiYgb3B0aW9ucy50eXBlID09PSB0aGlzLmN1cnJlbnRNb2RlLnR5cGUpIHJldHVybiB0aGlzLmN1cnJlbnRNb2RlO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVkaXRNb2RlKSB7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5mZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5mZWF0dXJlID0gZ2VvZmxvLlV0aWxpdGllcy5jbG9uZURlZXAob3B0aW9ucy5mZWF0dXJlKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm1vZGUgPSB0aGlzLnN0YXRpY3MuY29uc3RhbnRzLm1vZGVzLkRSQVc7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gb3B0aW9ucy50eXBlIHx8IG9wdGlvbnMuZmVhdHVyZS5wcm9wZXJ0aWVzLnR5cGU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmVkaXRpbmcgPSBnZW9mbG8uVXRpbGl0aWVzLmNsb25lRGVlcChvcHRpb25zLmZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vdGhpcy53YW50aW5nVG9FZGl0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TW9kZSkgdGhpcy5jdXJyZW50TW9kZS5kZWFjdGl2YXRlKG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE1vZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNb2RlICYmIHRoaXMuY3VycmVudE1vZGUuYWN0aXZhdGVkKSB0aGlzLmN1cnJlbnRNb2RlLmRlYWN0aXZhdGUob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmZvckVhY2goZnVuY3Rpb24oY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lLmluZGV4T2YoXCJtb3VzZS1cIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgY2xhc3Nlc1RvUmVtb3ZlLnB1c2goY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKGNsYXNzZXNUb1JlbW92ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgX21hcCRjb250YWluZXIkY2xhc3NMO1xuICAgICAgICAgICAgKF9tYXAkY29udGFpbmVyJGNsYXNzTCA9IHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdCkucmVtb3ZlLmFwcGx5KF9tYXAkY29udGFpbmVyJGNsYXNzTCwgY2xhc3Nlc1RvUmVtb3ZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0TWFwQ2xhc3MoJ3BvaW50ZXInKTtcblxuICAgICAgICB0aGlzLm1vZGVzLmZvckVhY2goZnVuY3Rpb24obSkgeyBpZiAobS5jYW5IYW5kbGUgJiYgbS5jYW5IYW5kbGUob3B0aW9ucy5tb2RlKSkgeyBzZWxlY3RlZE1vZGUgPSBtOyB9IH0pO1xuXG4gICAgICAgIGlmIChzZWxlY3RlZE1vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuZmlyZSgnbW9kZS5jaGFuZ2UnLCB7XG4gICAgICAgICAgICAgICAgb2xkOiB0aGlzLm1vZGUsXG4gICAgICAgICAgICAgICAgbmV3OiBvcHRpb25zLm1vZGUsXG4gICAgICAgICAgICAgICAgbW9kZTogc2VsZWN0ZWRNb2RlLFxuICAgICAgICAgICAgICAgIHR5cGU6IG9wdGlvbnMudHlwZVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50TW9kZSA9IHNlbGVjdGVkTW9kZTtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IG9wdGlvbnMubW9kZTtcbiAgICAgICAgICAgIHNlbGVjdGVkTW9kZS5hY3RpdmF0ZShvcHRpb25zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuU25hcHBpbmcgPSBuZXcgU25hcHBpbmcodGhpcy5jdXJyZW50TW9kZSk7XG4gICAgICAgIHRoaXMuUGlubmluZyA9IG5ldyBQaW5uaW5nKHRoaXMuY3VycmVudE1vZGUpO1xuICAgICAgICB0aGlzLlJvdXRpbmcgPSBuZXcgUm91dGluZyh0aGlzLmN1cnJlbnRNb2RlKTtcbiAgICAgICAgdGhpcy5FeHBsb3JpbmcgPSBuZXcgRXhwbG9yaW5nKHRoaXMuY3VycmVudE1vZGUpO1xuICAgICAgICB0aGlzLlBhaW50aW5nID0gbmV3IFBhaW50aW5nKHRoaXMuY3VycmVudE1vZGUpO1xuICAgICAgICB0aGlzLkxheWVycy5tb3ZlTGF5ZXJzKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRNb2RlO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgc2V0Q29udHJvbHNcblx0ICogQGRlc2NyaXB0aW9uIEluaXRpYWxpemVzIGFuZCBzZXRzIHRoZSBjb250cm9scyBmb3IgdGhlIG1hcC4gQWRkcyB0aGUgZnVsbHNjcmVlbiBhbmQgbmF2aWdhdGlvbiBjb250cm9scywgYW5kIGluaXRpYWxpemVzIHRoZSBjdXN0b20gY29udHJvbHMuXG5cdCAqIEBwYXJhbXMge25vbmV9IC0gTm8gcGFyYW1ldGVycyBuZWVkZWQgZm9yIHRoaXMgZnVuY3Rpb24uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gLSBBbiBhcnJheSBvZiBpbml0aWFsaXplZCBjb250cm9scyBmb3IgdGhlIG1hcC5cblx0ICovXG4gICAgdGhpcy5zZXRDb250cm9scyA9IGZ1bmN0aW9uIChjb250cm9scz1bXSkge1xuICAgICAgICBpZiAodGhpcy5jb250cm9scyAmJiB0aGlzLmNvbnRyb2xzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uKGNvbnRyb2wpIHsgY29udHJvbC5lbmFibGUoKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xzO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuY29udHJvbHMpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB0aGlzLmNvbnRyb2xzID0gW107XG4gICAgICAgIGNvbnRyb2xzID0gY29udHJvbHMubGVuZ3RoID8gY29udHJvbHMgOiB0aGlzLnN0YXRpY3MuY29udHJvbHM7XG4gICAgICAgIGNvbnRyb2xzLmZvckVhY2goZnVuY3Rpb24oY29udHJvbCkgeyB0aGlzLmNvbnRyb2xzLnB1c2gobmV3IENvbnRyb2woY29udHJvbCkpIH0sIHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb250cm9scztcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHNldEljb25cblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyB0aGUgYXBwcm9wcmlhdGUgaWNvbiB0byBkaXNwbGF5IGJhc2VkIG9uIHRoZSB1c2VyJ3MgZm9sbG93aW5nIHN0YXR1cyBhbmQgbmF2aWdhdGlvbiBjb21wYXNzIGljb24uXG4gICAgICogQGRlcHJlY2F0ZWRcblx0ICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZm9yIHdoaWNoIHRoZSBpY29uIGlzIGJlaW5nIHNldC5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMuc2V0SWNvbiA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgaWNvbiA9IHRoaXMubmF2aWdhdGlvbiA/IHRoaXMubmF2aWdhdGlvbi5fY29tcGFzc0ljb24gOiBmYWxzZTtcbiAgICAgICAgdmFyIGZvbGxvd2luZyA9IHRoaXMuTG9jYXRlICYmIHRoaXMuTG9jYXRlLmZvbGxvd2luZztcblxuICAgICAgICBpZiAoZm9sbG93aW5nKSB7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpY29uKSB7XG4gICAgICAgICAgICAvL2NvbnRyb2wuc3R5bGUudHJhbnNmb3JtID0gaWNvbi5zdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHNldENlbnRlck1hcmtlclxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBzZXRzIGEgbWFya2VyIGF0IHRoZSBjZW50ZXIgb2YgdGhlIG1hcC4gSXQgYWxsb3dzIGN1c3RvbWl6YXRpb24gb2YgdGhlIG1hcmtlciBpY29uIGFuZCBiZWhhdmlvci5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIG9iamVjdCBmb3IgY3VzdG9taXppbmcgdGhlIGNlbnRlciBtYXJrZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMucmVtb3ZlXSAtIElmIHRydWUsIHJlbW92ZXMgdGhlIGNlbnRlciBtYXJrZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhbnNmb3JtXSAtIElmIHRydWUsIGFwcGxpZXMgdHJhbnNmb3JtYXRpb24gdG8gdGhlIGNlbnRlciBtYXJrZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZ2FtZXBhZF0gLSBJZiB0cnVlLCBhcHBsaWVzIGdhbWVwYWQgc2V0dGluZ3MgdG8gdGhlIGNlbnRlciBtYXJrZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuZG9udEFkZF0gLSBJZiB0cnVlLCBkb2VzIG5vdCBhZGQgdGhlIGNlbnRlciBtYXJrZXIuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubm9SZW1vdmVdIC0gSWYgdHJ1ZSwgcHJldmVudHMgdGhlIGNlbnRlciBtYXJrZXIgZnJvbSBiZWluZyByZW1vdmVkLlxuXHQgKiBAcmV0dXJuIHtPYmplY3R8Ym9vbGVhbn0gUmV0dXJucyB0aGUgY2VudGVyIG1hcmtlciBvYmplY3QgaWYgc3VjY2Vzc2Z1bGx5IGFkZGVkIG9yIHVwZGF0ZWQsIG9yIGZhbHNlIGlmIG5vdCBhcHBsaWNhYmxlLlxuXHQgKi9cbiAgICB0aGlzLnNldENlbnRlck1hcmtlciA9IGZ1bmN0aW9uIChvcHRpb25zPXt9KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzLm1vYmlsZSB8fCB0aGlzLm5vQ2VudGVyTWFya2VyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICB2YXIgZm9sbG93aW5nID0gdGhpcy5Mb2NhdGUgJiYgdGhpcy5Mb2NhdGUuZm9sbG93aW5nO1xuICAgICAgICB2YXIgaWNvbiA9IHRoaXMuc3RhdGljcy5sb2dvLmljb247XG4gICAgICAgIHZhciBlbDtcblxuICAgICAgICBpZiAob3B0aW9ucy5yZW1vdmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNlbnRlck1hcmtlciAmJiAhdGhpcy5jZW50ZXJNYXJrZXIubm9SZW1vdmUpIHJldHVybiB0aGlzLmNlbnRlck1hcmtlci5yZW1vdmUoKSwgZGVsZXRlIHRoaXMuY2VudGVyTWFya2VyO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgXG4gICAgICAgIGlmICh0aGlzLmNlbnRlck1hcmtlcikge1xuICAgICAgICAgICAgdGhpcy5jZW50ZXJNYXJrZXIuc2V0TG5nTGF0KHRoaXMubWFwLmdldENlbnRlcigpKS5hZGRUbyh0aGlzLm1hcCk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy50cmFuc2Zvcm0gfHwgb3B0aW9ucy5nYW1lcGFkKSB0aGlzLmNlbnRlck1hcmtlci5zZXRQaXRjaEFsaWdubWVudCgnbWFwJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXJNYXJrZXI7XG4gICAgICAgIH0gZWxzZSBpZiAob3B0aW9ucy5kb250QWRkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuY2VudGVyTWFya2VySWNvbikge1xuICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGVsLmNsYXNzTmFtZSA9IHRoaXMuaWQgKyAnLWNlbnRlci1tYXJrZXInO1xuICAgICAgICAgICAgc2V0SWNvbihlbCwgaWNvbik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuY2VudGVyTWFya2VySWNvbiA9IGVsO1xuICAgICAgICB0aGlzLmNlbnRlck1hcmtlciA9IG5ldyBtYXBib3hnbC5NYXJrZXIodGhpcy5jZW50ZXJNYXJrZXJJY29uKTtcbiAgICAgICAgdGhpcy5jZW50ZXJNYXJrZXIuc2V0TG5nTGF0KHRoaXMubWFwLmdldENlbnRlcigpKS5hZGRUbyh0aGlzLm1hcCkuc2V0T2Zmc2V0KFswLDBdKTtcbiAgICAgICAgdGhpcy5jZW50ZXJNYXJrZXIubm9SZW1vdmUgPSBvcHRpb25zLm5vUmVtb3ZlO1xuXG4gICAgICAgIGlmIChmb2xsb3dpbmcpIHRoaXMuY2VudGVyTWFya2VyLnNldE9mZnNldChbMCwtMjBdKTtcblxuICAgICAgICBmdW5jdGlvbiBzZXRJY29uKG1hcmtlciwgaWNvbikge1xuICAgICAgICAgICAgbWFya2VyLnN0eWxlLmJhY2tncm91bmRJbWFnZSA9IGB1cmwoXCIke2ljb259XCIpYDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlck1hcmtlcjtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHNldEJ1dHRvbnNcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gcmVzZXRzIHRoZSBhY3RpdmUgYnV0dG9ucyBhbmQgYWN0aXZhdGVzIHRoZSBTZWxlY3QgYnV0dG9uLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIFNlbGVjdCBidXR0b24gaXMgc3VjY2Vzc2Z1bGx5IHNldCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQgKi9cbiAgICB0aGlzLnNldEJ1dHRvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1dHRvbnMoJ3NlbGVjdCcpID8gdGhpcy5nZXRCdXR0b25zKCdzZWxlY3QnKS5hZGQoKSA6IGZhbHNlO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgc2V0QWN0aXZlQnV0dG9uXG5cdCAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSBhY3RpdmUgYnV0dG9uIHdpdGggdGhlIHNwZWNpZmllZCBpZCBpbiB0aGUgY29udHJvbHMgYXJyYXkuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBpZCBvZiB0aGUgYnV0dG9uIHRvIHNldCBhcyBhY3RpdmUuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGlmIHRoZSBjb250cm9scyBhcnJheSBpcyBlbXB0eSBvciB1bmRlZmluZWQuXG5cdCAqL1xuICAgIHRoaXMuc2V0QWN0aXZlQnV0dG9uID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5jb250cm9scyB8fCAhdGhpcy5jb250cm9scy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250cm9scy5mb3JFYWNoKGZ1bmN0aW9uKGNvbnRyb2wpIHsgY29udHJvbC5zZXRBY3RpdmVCdXR0b24oaWQudG9Mb3dlckNhc2UoKSkgfSlcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHNldFRoZW1lXG5cdCAqIEBkZXNjcmlwdGlvbiBTZXRzIHRoZSB0aGVtZSBjb2xvcnMgZm9yIHRoZSBjb250cm9sLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gY29sb3JzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHRoZW1lIGNvbG9ycy5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMuc2V0VGhlbWUgPSBmdW5jdGlvbiAoY29sb3JzKSB7XG4gICAgICAgIHRoaXMuQ29udHJvbCA/IHRoaXMuQ29udHJvbC5zZXRUaGVtZShjb2xvcnMpIDogZmFsc2U7XG4gICAgfVxuXHRcbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbmFtZSBzZXRMYXllcnNcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsb1xuICAgICAqIEBkZXNjcmlwdGlvbiBTZXRzIGN1c3RvbSBsYXllcnMgYW5kIG9wdGlvbmFsbHkgcmVzZXRzIGZlYXR1cmVzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gbGF5ZXJzIC0gQW4gYXJyYXkgb2YgbGF5ZXJzIHRvIGJlIHNldC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIG9wdGlvbnMgZm9yIHNldHRpbmcgbGF5ZXJzLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0aW9ucy5yZXNldCAtIEluZGljYXRlcyB3aGV0aGVyIHRvIHJlc2V0IGZlYXR1cmVzIGJlZm9yZSBzZXR0aW5nIGxheWVycy5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgY3VzdG9tIGxheWVycyBoYXZlIGJlZW4gc2V0LlxuICAgICAqIFxuICAgICAqIEBhdXRob3IgU29sdXRlZ3JhdGVcbiAgICAgKiBAY29weXJpZ2h0IDIwMjVcbiAgICAgKi9cbiAgICB0aGlzLnNldExheWVycyA9IGFzeW5jIGZ1bmN0aW9uIChsYXllcnM9W10sIG9wdGlvbnM9e30pIHtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVzZXQpIHRoaXMucmVtb3ZlRmVhdHVyZXMobGF5ZXJzLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuTGF5ZXJzLnNldEN1c3RvbUxheWVycyhsYXllcnMsIG9wdGlvbnMpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgc2V0U2VsZWN0ZWRGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBzZWxlY3RlZCBmZWF0dXJlcyBvbiB0aGUgbWFwIHdpdGggdGhlIHByb3ZpZGVkIGFycmF5IG9mIGZlYXR1cmVzLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBmZWF0dXJlcyAtIEFuIGFycmF5IG9mIGZlYXR1cmVzIHRvIHNldCBhcyBzZWxlY3RlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgdGhlIGZlYXR1cmVzIGFycmF5IGlzIGVtcHR5LlxuXHQgKi9cbiAgICB0aGlzLnNldFNlbGVjdGVkRmVhdHVyZXMgPSBmdW5jdGlvbiAoZmVhdHVyZXM9W10pIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZXMgPSBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGVjdGVkRmVhdHVyZXMuc3BsaWNlKDAsIHNlbGVjdGVkRmVhdHVyZXMubGVuZ3RoLCAuLi5mZWF0dXJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLm1hcC5nZXRTb3VyY2UodGhpcy5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNFTEVDVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKHRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlcygpKSk7XG4gICAgICAgIHRoaXMubWFwLmdldFNvdXJjZSh0aGlzLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuVkVSVEVYKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24odGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkpKTtcblxuICAgICAgICB0aGlzLmZpcmUoJ3NlbGVjdC5sb2FkJywge1xuICAgICAgICAgICAgZmVhdHVyZXM6IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24odGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkpLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLm1hcC5nZXRTb3VyY2UodGhpcy5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNFTEVDVClcbiAgICAgICAgfSlcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHNldE1lc2hGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gVXBkYXRlcyB0aGUgbWVzaCBkYXRhIHdpdGggdGhlIHByb3ZpZGVkIGZlYXR1cmVzIGFuZCByZXR1cm5zIHRoZSB1cGRhdGVkIG1lc2guIEFkZHMgYSBtZXNoIGluZGV4IGlmIGl0IGRvZXMgbm90IGV4aXN0LlxuXHQgKiBAcGFyYW0ge0FycmF5fSBmZWF0dXJlcyAtIEFuIGFycmF5IG9mIGZlYXR1cmVzIHRvIHVwZGF0ZSB0aGUgbWVzaCB3aXRoLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdXBkYXRlZCBtZXNoIGFmdGVyIHNldHRpbmcgdGhlIGZlYXR1cmVzLlxuXHQgKi9cbiAgICB0aGlzLnNldE1lc2hGZWF0dXJlcyA9IGZ1bmN0aW9uIChmZWF0dXJlcz1bXSkge1xuICAgICAgICBpZiAoIWZlYXR1cmVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hEYXRhKGZlYXR1cmVzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzaEluZGV4LmdldEZlYXR1cmVzKCk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBzZXRNYXBDbGFzc1xuXHQgKiBAZGVzY3JpcHRpb24gU2V0cyBhIHNwZWNpZmljIG1vdXNlIGNsYXNzIG9uIHRoZSBtYXAgY29udGFpbmVyIGVsZW1lbnQgYmFzZWQgb24gdGhlIHByb3ZpZGVkIG5hbWUuIFJlbW92ZXMgYW55IGV4aXN0aW5nIGNsYXNzZXMgc3RhcnRpbmcgd2l0aCBcIm1vdXNlLVwiIGJlZm9yZSBhZGRpbmcgdGhlIG5ldyBjbGFzcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY2xhc3MgdG8gYmUgYWRkZWQgKHdpdGhvdXQgdGhlIFwibW91c2UtXCIgcHJlZml4KS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgdGhlIG5hbWUgaXMgZW1wdHksIG90aGVyd2lzZSBhZGRzIHRoZSBjbGFzcyBhbmQgcmV0dXJucyB1bmRlZmluZWQuXG5cdCAqL1xuICAgIHRoaXMuc2V0TWFwQ2xhc3MgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuZm9yRWFjaChmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUuaW5kZXhPZihcIm1vdXNlLVwiKSAhPT0gLTEpIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKVxuICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICBpZiAoIW5hbWUpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1vdXNlLVwiICsgbmFtZSk7XG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLk1hcFxuXHQgKiBAbmFtZSBzZXRWaWV3cG9ydFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBzZXRzIHRoZSBzdHlsZSBvZiB0aGUgdmlld3BvcnQgYmFzZWQgb24gdGhlIG9wdGlvbnMgcHJvdmlkZWQuIEl0IHJlc2l6ZXMgdGhlIG1hcCwgY2FsY3VsYXRlcyB0aGUgaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgY29udGFpbmVyLCBhZGp1c3RzIHRoZSBoZWlnaHQgYW5kIHdpZHRoIG9mIHRoZSB2aWV3cG9ydCwgZXh0ZW5kcyB0aGUgdmlld3BvcnQgc3R5bGUsIHNldHMgcGFkZGluZywgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgdmlld3BvcnQgZWxlbWVudC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QgY29udGFpbmluZyBzdHlsZSBwcm9wZXJ0aWVzIGZvciB0aGUgdmlld3BvcnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5wb3NpdGlvbj0nYWJzb2x1dGUnXSAtIFRoZSBwb3NpdGlvbiBwcm9wZXJ0eSBmb3IgdGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubWFyZ2luPSdhdXRvJ10gLSBUaGUgbWFyZ2luIHByb3BlcnR5IGZvciB0aGUgdmlld3BvcnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy50b3A9JyddIC0gVGhlIHRvcCBwcm9wZXJ0eSBmb3IgdGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMubGVmdD10aGlzLnZpZXdwb3J0TGVmdF0gLSBUaGUgbGVmdCBwcm9wZXJ0eSBmb3IgdGhlIHZpZXdwb3J0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYm90dG9tPXRoaXMudmlld3BvcnRCb3R0b21dIC0gVGhlIGJvdHRvbSBwcm9wZXJ0eSBmb3IgdGhlIHZpZXdwb3J0LlxuXHQgKiBAcmV0dXJucyB7RWxlbWVudH0gVGhlIHVwZGF0ZWQgdmlld3BvcnQgZWxlbWVudC5cblx0ICovXG4gICAgdGhpcy5zZXRWaWV3cG9ydCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBzdHlsZSA9IG9wdGlvbnMgfHwge1xuICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICAgICAgICBtYXJnaW46ICdhdXRvJyxcbiAgICAgICAgICAgIHRvcDogJycsXG4gICAgICAgICAgICBsZWZ0OiB0aGlzLnZpZXdwb3J0TGVmdCxcbiAgICAgICAgICAgIGJvdHRvbTogdGhpcy52aWV3cG9ydEJvdHRvbVxuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgICAgIHZhciB3aWR0aCA9IHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuXG4gICAgICAgIHN0eWxlLmhlaWdodCA9IGAke051bWJlci5wYXJzZUludChoZWlnaHQpIC0gdGhpcy52aWV3cG9ydEhlaWdodE9mZnNldH1weGA7XG4gICAgICAgIHN0eWxlLndpZHRoID0gYCR7TnVtYmVyLnBhcnNlSW50KHdpZHRoKSAtIHRoaXMudmlld3BvcnRXaWR0aE9mZnNldH1weGA7XG5cbiAgICAgICAgdGhpcy5VdGlsaXRpZXMuZXh0ZW5kKHRoaXMudmlld3BvcnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgICAgdGhpcy5zZXRQYWRkaW5nKCk7XG4gICAgICAgIHRoaXMubWFwLnJlc2l6ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy52aWV3cG9ydDtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJvZiBtb2R1bGU6Z2VvZmxvLk1hcFxuXHQgKiBAbmFtZSBzZXRQYWRkaW5nXG5cdCAqIEBkZXNjcmlwdGlvbiBDYWxjdWxhdGVzIHRoZSBwYWRkaW5nIHZhbHVlcyBmb3IgdGhlIGNvbnRhaW5lciBieSBjb21wYXJpbmcgaXRzIHBvc2l0aW9uIHdpdGggdGhlIHZpZXdwb3J0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcGFkZGluZyBvYmplY3QgY29udGFpbmluZyBsZWZ0LCByaWdodCwgdG9wLCBhbmQgYm90dG9tIHBhZGRpbmcgdmFsdWVzLlxuXHQgKiBAcGFyYW1zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLnNldFBhZGRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBsZWZ0ID0gKHRoaXMuY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQpIC0gKHRoaXMudmlld3BvcnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCk7XG4gICAgICAgIHZhciByaWdodCA9ICh0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCkgLSAodGhpcy52aWV3cG9ydC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5yaWdodCk7XG4gICAgICAgIHZhciB0b3AgPSAodGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKSAtICh0aGlzLnZpZXdwb3J0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCk7XG4gICAgICAgIHZhciBib3R0b20gPSAodGhpcy5jb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuYm90dG9tKSAtICh0aGlzLnZpZXdwb3J0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmJvdHRvbSk7XG4gICAgICAgIHZhciBub1BhZGRpbmcgPSB0aGlzLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCA8IDIwO1xuXG4gICAgICAgIHRoaXMucGFkZGluZyA9IHtcbiAgICAgICAgICAgIGxlZnQ6IG5vUGFkZGluZyA/IDAgOiBNYXRoLmFicyhsZWZ0KSxcbiAgICAgICAgICAgIHJpZ2h0OiBub1BhZGRpbmcgPyAwIDogTWF0aC5hYnMocmlnaHQpLFxuICAgICAgICAgICAgdG9wOiBub1BhZGRpbmcgPyAwIDogTWF0aC5hYnModG9wKSxcbiAgICAgICAgICAgIGJvdHRvbTogbm9QYWRkaW5nID8gMCA6IE1hdGguYWJzKGJvdHRvbSlcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1hcC5zZXRQYWRkaW5nKHRoaXMucGFkZGluZyk7ICAgIFxuICAgICAgICByZXR1cm4gdGhpcy5wYWRkaW5nO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsby5NYXBcblx0ICogQG5hbWUgc2V0U3R5bGVcblx0ICogQGRlc2NyaXB0aW9uIFNldHMgdGhlIHN0eWxlIG9mIHRoZSBtYXAgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgc3R5bGUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBzdHlsZSAtIFRoZSBzdHlsZSBvYmplY3QgdG8gYmUgYXBwbGllZCB0byB0aGUgbWFwLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdXBkYXRlZCBzdHlsZSBvYmplY3Qgb2YgdGhlIG1hcC5cblx0ICovXG4gICAgdGhpcy5zZXRTdHlsZSA9IGZ1bmN0aW9uIChzdHlsZSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIXN0eWxlKSB7IHJldHVybiBmYWxzZSB9O1xuICAgICAgICB0aGlzLm1hcC5zZXRTdHlsZShzdHlsZSwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXRTdHlsZSgpO1xuICAgIH1cblxuICAgIC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gU2V0cyB0aGUgZXh0ZW50IG9mIHRoZSBtYXAgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGZlYXR1cmVzIG9yIGEgZ2l2ZW4gZXh0ZW50LiBJZiBubyBmZWF0dXJlcyBhcmUgcHJvdmlkZWQsIGl0IHVzZXMgdGhlIHJlbmRlcmVkIGRyYXduIGZlYXR1cmVzLiBJZiBleHRlbnQgaXMgc3BlY2lmaWVkLCBpdCBzZXRzIHRoZSBtYXAgZXh0ZW50IHRvIHRoZSBleHRlbnQgcG9seWdvbi4gSWYgY2VudGVyIGlzIG5vdCBzcGVjaWZpZWQgYW5kIGlzUG9pbnQgaXMgdHJ1ZSwgaXQgY2VudGVycyB0aGUgbWFwIGF0IHRoZSBjZW50cm9pZCBvZiB0aGUgZXh0ZW50LiBJZiBjZW50ZXIgaXMgZmFsc2UsIGl0IGZpdHMgdGhlIG1hcCB0byB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBmZWF0dXJlcy4gSWYgY2VudGVyIGlzIHRydWUsIGl0IGNlbnRlcnMgdGhlIG1hcCBhdCB0aGUgY2VudHJvaWQgb2YgdGhlIGJvdW5kaW5nIGJveC5cblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlcm9mIG1vZHVsZTpnZW9mbG8uTWFwXG5cdCAqIEBuYW1lIHNldEV4dGVudFxuXHQgKiBAcGFyYW0ge0FycmF5fSBmZWF0dXJlcyAtIEFycmF5IG9mIGZlYXR1cmVzIHRvIHNldCB0aGUgZXh0ZW50IGJhc2VkIG9uLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBleHRlbnQgLSBFeHRlbnQgcG9seWdvbiB0byBzZXQgdGhlIG1hcCBleHRlbnQgdG8uXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gQWRkaXRpb25hbCBvcHRpb25zIGZvciBzZXR0aW5nIHRoZSBleHRlbnQgKGNlbnRlciwgaXNQb2ludCkuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IC0gVGhlIG1hcCBvYmplY3QgYWZ0ZXIgc2V0dGluZyB0aGUgZXh0ZW50LlxuXHQgKi9cbiAgICB0aGlzLnNldEV4dGVudCA9IGZ1bmN0aW9uIChmZWF0dXJlcywgZXh0ZW50LCBvcHRpb25zPXt9KSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ0V4dGVudCA9IHRydWU7XG5cbiAgICAgICAgdmFyIG5vRmVhdHVyZXMgPSAhZmVhdHVyZXMgfHwgIWZlYXR1cmVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNlbnRlciA9IG9wdGlvbnMuY2VudGVyO1xuICAgICAgICAhY2VudGVyICYmIG9wdGlvbnMuaXNQb2ludCA/IGNlbnRlciA9IHRydWUgOiBmYWxzZTtcblxuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZlYXR1cmVzID0gIXRoaXMub3B0aW9ucy5tYXAuZXh0ZW50ID8gW10gOiBbdHVyZi5wb2x5Z29uKHRoaXMub3B0aW9ucy5tYXAuZXh0ZW50KV07XG4gICAgICAgIH0gZWxzZSBpZiAobm9GZWF0dXJlcykge1xuICAgICAgICAgICAgZmVhdHVyZXMgPSB0aGlzLmdldERyYXduRmVhdHVyZXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBqdW1wVG8gPSB7XG4gICAgICAgICAgICBiZWFyaW5nOiBvcHRpb25zLmJlYXJpbmcgfHwgdGhpcy5vcHRpb25zLm1hcC5iZWFyaW5nIHx8IHRoaXMubWFwLmdldEJlYXJpbmcoKSxcbiAgICAgICAgICAgIGNlbnRlcjogdGhpcy5vcHRpb25zLm1hcC5jZW50ZXIgfHwgdGhpcy5tYXAuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgICB6b29tOiBvcHRpb25zLnpvb20gfHwgdGhpcy5vcHRpb25zLm1hcC56b29tIHx8IHRoaXMubWFwLmdldFpvb20oKSxcbiAgICAgICAgICAgIHBpdGNoOiBvcHRpb25zLnBpdGNoIHx8IHRoaXMub3B0aW9ucy5tYXAucGl0Y2ggfHwgdGhpcy5tYXAuZ2V0UGl0Y2goKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmZWF0dXJlcykgcmV0dXJuIHRoaXMubWFwLmp1bXBUbyhqdW1wVG8pO1xuICAgICAgICBpZiAoIWZlYXR1cmVzLmxlbmd0aCkgcmV0dXJuO1xuXG4gICAgICAgIHZhciBiYm94ID0gdHVyZi5iYm94KHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMpKVxuXG4gICAgICAgIGlmIChjZW50ZXIpIHtcbiAgICAgICAgICAgIHZhciBwb2x5Z29uID0gdHVyZi5iYm94UG9seWdvbihiYm94KTtcbiAgICAgICAgICAgIHZhciBjZW50cm9pZCA9IHR1cmYuY2VudHJvaWQocG9seWdvbik7XG4gICAgICAgICAgICBqdW1wVG8uY2VudGVyID0geyBsYXQ6IGNlbnRyb2lkLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLCBsbmc6IGNlbnRyb2lkLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdIH07XG4gICAgICAgICAgICBqdW1wVG8uem9vbSA9IG9wdGlvbnMuem9vbSB8fCB0aGlzLm1hcC5nZXRab29tKCk7XG4gICAgICAgICAgICBqdW1wVG8ucGl0Y2ggPSBvcHRpb25zLnBpdGNoIHx8IHRoaXMubWFwLmdldFBpdGNoKCk7XG4gICAgICAgICAgICBqdW1wVG8uYmVhcmluZyA9IG9wdGlvbnMuYmVhcmluZyB8fCB0aGlzLm1hcC5nZXRCZWFyaW5nKCk7XG4gICAgICAgICAgICB0aGlzLm1hcC5qdW1wVG8oanVtcFRvKTtcbiAgICAgICAgfSBlbHNlIGlmIChiYm94KSB7XG4gICAgICAgICAgICB2YXIgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICAgICAgcGFkZGluZzogdGhpcy5tYXAuZ2V0UGFkZGluZygpLFxuICAgICAgICAgICAgICAgIGxpbmVhcjogdHJ1ZVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAob3B0aW9ucy5iZWFyaW5nKSBzZXR0aW5ncy5iZWFyaW5nID0gb3B0aW9ucy5iZWFyaW5nO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucGl0Y2gpIHNldHRpbmdzLnBpdGNoID0gb3B0aW9ucy5waXRjaDtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLm1heFpvb20pIHNldHRpbmdzLm1heFpvb20gPSBvcHRpb25zLm1heFpvb207XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMubWFwLmZpdEJvdW5kcyhiYm94LCBzZXR0aW5ncyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmZpcmUoJ2ZlYXR1cmVzLnpvb20nLCB7IGZlYXR1cmVzOiBmZWF0dXJlcywgY2VudGVyOiB0aGlzLm1hcC5nZXRDZW50ZXIoKSwgYmJveDogYmJveCB9KTtcbiAgICAgICAgdGhpcy5zZXR0aW5nRXh0ZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyb2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAZnVuY3Rpb25cblx0ICogQG5hbWUgc2V0T3BhY2l0eVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG51bWVyaWMgdmFsdWUgYW5kIHNldHMgdGhlIG9wYWNpdHkgb2Ygc3BlY2lmaWVkIGxheWVycyBvbiB0aGUgbWFwIHRvIHRoYXQgdmFsdWUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFRoZSBvcGFjaXR5IHZhbHVlIHRvIHNldCBmb3IgdGhlIGxheWVycy5cblx0ICovXG4gICAgdGhpcy5zZXRPcGFjaXR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gdGhpcy5vcGFjaXR5ID0gTnVtYmVyKHZhbHVlIHx8IDEpO1xuICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5tYXAuZ2V0U3R5bGUoKS5sYXllcnM7XG5cbiAgICAgICAgbGF5ZXJzLm1hcCgobGF5ZXIpID0+IHtcbiAgICAgICAgICAgIGlmICghbGF5ZXIuaWQuaW5jbHVkZXMoJ2dlb2ZsbycpIHx8IGxheWVyLnR5cGUgPT09ICdiYWNrZ3JvdW5kJykge1xuICAgICAgICAgICAgICAgIGlmIChsYXllci5tZXRhZGF0YSAmJiBsYXllci5tZXRhZGF0YS5jdXN0b20pIHJldHVybjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIudHlwZSA9PT0gJ3N5bWJvbCcpICB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldFBhaW50UHJvcGVydHkobGF5ZXIuaWQsIGBpY29uLW9wYWNpdHlgLCBvcGFjaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAuc2V0UGFpbnRQcm9wZXJ0eShsYXllci5pZCwgYHRleHQtb3BhY2l0eWAsIG9wYWNpdHkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFwLnNldFBhaW50UHJvcGVydHkobGF5ZXIuaWQsIGAke2xheWVyLnR5cGV9LW9wYWNpdHlgLCBvcGFjaXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5zZXRDb2xvcnMgPSBhc3luYyBmdW5jdGlvbiAoY29sb3JzPXt9KSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5jb2xvcnMgPSBPYmplY3QuYXNzaWduKHRoaXMub3B0aW9ucy5jb2xvcnMsIGNvbG9ycyk7XG4gICAgICAgIHRoaXMuc2V0VGhlbWUodGhpcy5vcHRpb25zLmNvbG9ycyk7XG4gICAgICAgIGF3YWl0IHRoaXMuTGF5ZXJzLnJlZnJlc2goKTtcbiAgICAgICAgdGhpcy5GZWF0dXJlcy51cGRhdGVTb3VyY2UoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29sb3JzKCk7XG4gICAgfVxuXG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBoYXNDb250cm9sc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlIG9iamVjdCBoYXMgY29udHJvbHMgYnkgdmVyaWZ5aW5nIHRoZSBleGlzdGVuY2UgYW5kIGxlbmd0aCBvZiB0aGUgY29udHJvbHMgYXJyYXkuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCBoYXMgY29udHJvbHMsIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5oYXNDb250cm9scyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbHMgJiYgdGhpcy5jb250cm9scy5sZW5ndGg7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBoYXNTZWxlY3Rpb25cblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZXJlIGlzIGEgc2VsZWN0aW9uIG9mIGZlYXR1cmVzLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZXJlIGlzIGEgc2VsZWN0aW9uIG9mIGZlYXR1cmVzLCBvdGhlcndpc2UgZmFsc2UuXG5cdCAqL1xuICAgIHRoaXMuaGFzU2VsZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkubGVuZ3RoID4gMDtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGhhc1NpbmdsZVNlbGVjdGlvblxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjaGVja3MgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0ZWQgZmVhdHVyZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGVyZSBpcyBhIHNpbmdsZSBzZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5oYXNTaW5nbGVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMoKS5sZW5ndGggPT09IDE7XG4gICAgfVxuXG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBhY3RpdmF0ZVNuYXBwaW5nXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGFjdGl2YXRlcyBzbmFwcGluZyBieSBnZXR0aW5nIHRoZSBzbmFwcGluZyBidXR0b25zLCBhY3RpdmF0aW5nIHRoZW0sIGFuZCB0cmlnZ2VyaW5nIHRoZSBzbmFwcGluZyBhY3RpdmF0aW9uIGV2ZW50LiBGaXJlcyBhIGN1c3RvbSBldmVudCAnc25hcHBpbmcuYWN0aXZhdGUnIHdpdGggdGhlIGVuYWJsZWQgc3RhdHVzIGFuZCB0aGUgc25hcHBpbmcgb2JqZWN0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgYWN0aXZhdGVkIFNuYXBwaW5nIG9iamVjdC5cblx0ICovXG4gICAgdGhpcy5hY3RpdmF0ZVNuYXBwaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuZ2V0QnV0dG9ucygnc25hcHBpbmcnKTtcbiAgICAgICAgaWYgKCFidXR0b25zKSByZXR1cm47XG4gICAgICAgIGJ1dHRvbnMuYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5TbmFwcGluZy5hY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLmZpcmUoJ3NuYXBwaW5nLmFjdGl2YXRlJywgeyBlbmFibGVkOiB0cnVlLCBtZXNoOiB0aGlzLm1lc2hJbmRleCwgc25hcHBpbmc6IHRoaXMuU25hcHBpbmcgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMuU25hcHBpbmc7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBhY3RpdmF0ZVBpbm5pbmdcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gYWN0aXZhdGVzIHBpbm5pbmcgYnkgZ2V0dGluZyB0aGUgcGlubmluZyBidXR0b25zLCBhY3RpdmF0aW5nIHRoZW0sIGVuYWJsaW5nIHNuYXBwaW5nLCBhY3RpdmF0aW5nIHBpbm5pbmcsIGFuZCBmaXJpbmcgYW4gZXZlbnQuIEZpcmVzIGEgY3VzdG9tIGV2ZW50ICdwaW5uaW5nLmFjdGl2YXRlJyB3aXRoIHRoZSBlbmFibGVkIHN0YXR1cyBhbmQgdGhlIHBpbm5pbmcgb2JqZWN0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgYWN0aXZhdGVkIHBpbm5pbmcgb2JqZWN0LlxuXHQgKi9cbiAgICB0aGlzLmFjdGl2YXRlUGlubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1dHRvbnMgPSB0aGlzLmdldEJ1dHRvbnMoJ3Bpbm5pbmcnKTtcbiAgICAgICAgaWYgKCFidXR0b25zKSByZXR1cm47XG4gICAgICAgIGJ1dHRvbnMuYWN0aXZhdGUoKTtcbiAgICAgICAgLy90aGlzLmRlYWN0aXZhdGVSb3V0aW5nKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVTbmFwcGluZygpO1xuICAgICAgICB0aGlzLlBpbm5pbmcuYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5maXJlKCdwaW5uaW5nLmFjdGl2YXRlJywgeyBlbmFibGVkOiB0cnVlLCBwaW5uaW5nOiB0aGlzLlBpbm5pbmcgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLlBpbm5pbmc7XG4gICAgfVxuXG5cdC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGFjdGl2YXRlcyB0aGUgcm91dGluZyBmZWF0dXJlIGJ5IGdldHRpbmcgdGhlIHJvdXRpbmcgYnV0dG9ucywgYWN0aXZhdGluZyB0aGVtLCBlbmFibGluZyBzbmFwcGluZywgZGVhY3RpdmF0aW5nIHBhaW50aW5nLCBhbmQgYWN0aXZhdGluZyB0aGUgcm91dGluZyBpdHNlbGYuIEZpcmVzIGEgY3VzdG9tIGV2ZW50ICdyb3V0aW5nLmFjdGl2YXRlJyB3aXRoIHRoZSBlbmFibGVkIHN0YXR1cyBhbmQgdGhlIHJvdXRpbmcgb2JqZWN0LlxuXHQgKiBAbmFtZSBhY3RpdmF0ZVJvdXRpbmdcblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGFjdGl2YXRlZCBSb3V0aW5nIG9iamVjdC5cblx0ICovXG4gICAgdGhpcy5hY3RpdmF0ZVJvdXRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidXR0b25zID0gdGhpcy5nZXRCdXR0b25zKCdyb3V0aW5nJyk7XG4gICAgICAgIGlmICghYnV0dG9ucykgcmV0dXJuO1xuICAgICAgICBidXR0b25zLmFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVTbmFwcGluZygpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGVQYWludGluZygpO1xuICAgICAgICB0aGlzLlJvdXRpbmcuYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5maXJlKCdyb3V0aW5nLmFjdGl2YXRlJywgeyBlbmFibGVkOiB0cnVlLCByb3V0aW5nOiB0aGlzLlJvdXRpbmcgfSlcbiAgICAgICAgcmV0dXJuIHRoaXMuUm91dGluZztcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGFjdGl2YXRlRXhwbG9yaW5nXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGFjdGl2YXRlcyB0aGUgZXhwbG9yaW5nIG1vZGUgYnkgYWN0aXZhdGluZyB0aGUgZXhwbG9yaW5nIGJ1dHRvbnMsIGZ1bmN0aW9uYWxpdGllcywgYW5kIGV2ZW50cy4gRmlyZXMgYSBjdXN0b20gZXZlbnQgJ2V4cGxvcmluZy5hY3RpdmF0ZScgd2l0aCB0aGUgZW5hYmxlZCBzdGF0dXMgYW5kIHRoZSBleHBsb3Jpbmcgb2JqZWN0LlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgYWN0aXZhdGVkIGV4cGxvcmluZyBvYmplY3QuXG5cdCAqL1xuICAgIHRoaXMuYWN0aXZhdGVFeHBsb3JpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidXR0b25zID0gdGhpcy5nZXRCdXR0b25zKCdleHBsb3JpbmcnKTtcbiAgICAgICAgaWYgKCFidXR0b25zKSByZXR1cm47XG4gICAgICAgIGJ1dHRvbnMuYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5kZWFjdGl2YXRlUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5FeHBsb3JpbmcuYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5maXJlKCdleHBsb3JpbmcuYWN0aXZhdGUnLCB7IGVuYWJsZWQ6IHRydWUsIGV4cGxvcmluZzogdGhpcy5FeHBsb3JpbmcgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLkV4cGxvcmluZztcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGFjdGl2YXRlUGFpbnRpbmdcblx0ICogQGRlc2NyaXB0aW9uIEFjdGl2YXRlcyB0aGUgcGFpbnRpbmcgZnVuY3Rpb25hbGl0eSBieSBzZXR0aW5nIHRoZSBkcmF3IG1vZGUsIGFjdGl2YXRpbmcgdGhlIHBhaW50aW5nIGJ1dHRvbnMsIGRlYWN0aXZhdGluZyByb3V0aW5nIGFuZCBleHBsb3JpbmcsIGFuZCBmaXJpbmcgYW4gZXZlbnQuIEZpcmVzIGEgY3VzdG9tIGV2ZW50ICdwYWludGluZy5hY3RpdmF0ZScgd2l0aCB0aGUgZW5hYmxlZCBzdGF0dXMgYW5kIHRoZSBwYWludGluZyBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBhY3RpdmF0ZWQgUGFpbnRpbmcgb2JqZWN0LlxuXHQgKi9cbiAgICB0aGlzLmFjdGl2YXRlUGFpbnRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidXR0b25zID0gdGhpcy5nZXRCdXR0b25zKCdwYWludGluZycpO1xuICAgICAgICBpZiAoIWJ1dHRvbnMpIHJldHVybjtcbiAgICAgICAgYnV0dG9ucy5hY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLmRlYWN0aXZhdGVSb3V0aW5nKCk7XG4gICAgICAgIHRoaXMuZGVhY3RpdmF0ZUV4cGxvcmluZygpO1xuICAgICAgICB0aGlzLlBhaW50aW5nLmFjdGl2YXRlKHRoaXMuZHJhd01vZGUpO1xuICAgICAgICB0aGlzLmZpcmUoJ3BhaW50aW5nLmFjdGl2YXRlJywgeyBlbmFibGVkOiB0cnVlLCBwYWludGluZzogdGhpcy5QYWludGluZyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuUGFpbnRpbmc7XG4gICAgfVxuXG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBkZWFjdGl2YXRlU25hcHBpbmdcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZGVhY3RpdmF0ZXMgdGhlIHNuYXBwaW5nIGZlYXR1cmUgYnkgcGVyZm9ybWluZyB2YXJpb3VzIGFjdGlvbnMuIERlbGV0ZXMgbWVzaCBkYXRhLCBkZWFjdGl2YXRlcyB0aGUgc25hcHBpbmcgYnV0dG9ucywgZGVhY3RpdmF0ZXMgdGhlIFNuYXBwaW5nIG9iamVjdCwgYW5kIGZpcmVzIGEgJ3NuYXBwaW5nLmRlYWN0aXZhdGUnIGV2ZW50LlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBhZnRlciBkZWFjdGl2YXRpbmcgdGhlIHNuYXBwaW5nIGZlYXR1cmUuXG5cdCAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZVNuYXBwaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuZ2V0QnV0dG9ucygnc25hcHBpbmcnKTtcbiAgICAgICAgaWYgKCFidXR0b25zKSByZXR1cm47XG4gICAgICAgIGJ1dHRvbnMuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLmRlbGV0ZU1lc2hEYXRhKCk7XG4gICAgICAgIHRoaXMuU25hcHBpbmcuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLmZpcmUoJ3NuYXBwaW5nLmRlYWN0aXZhdGUnLCB7IGVuYWJsZTogZmFsc2UgfSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZGVhY3RpdmF0ZVBpbm5pbmdcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZGVhY3RpdmF0ZXMgdGhlIHBpbm5pbmcgZmVhdHVyZSBieSBkZWFjdGl2YXRpbmcgdGhlIHBpbm5pbmcgYnV0dG9ucywgdGhlIFBpbm5pbmcgb2JqZWN0LCBhbmQgZmlyaW5nIGEgJ3Bpbm5pbmcuZGVhY3RpdmF0ZScgZXZlbnQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGFmdGVyIGRlYWN0aXZhdGluZyBwaW5uaW5nLlxuXHQgKi9cbiAgICB0aGlzLmRlYWN0aXZhdGVQaW5uaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuZ2V0QnV0dG9ucygncGlubmluZycpO1xuICAgICAgICBpZiAoIWJ1dHRvbnMpIHJldHVybjtcbiAgICAgICAgYnV0dG9ucy5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuUGlubmluZy5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuZmlyZSgncGlubmluZy5kZWFjdGl2YXRlJywgeyBlbmFibGU6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gRGVhY3RpdmF0ZXMgdGhlIHJvdXRpbmcgZnVuY3Rpb25hbGl0eSBieSBkZWFjdGl2YXRpbmcgdGhlIHJvdXRpbmcgYnV0dG9ucyBhbmQgdGhlIFJvdXRpbmcgbW9kdWxlLiBUcmlnZ2VycyBhIGN1c3RvbSBldmVudCAncm91dGluZy5kZWFjdGl2YXRlJyB3aXRoIGVuYWJsZSBzZXQgdG8gZmFsc2UuXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGRlYWN0aXZhdGVSb3V0aW5nXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGFmdGVyIGRlYWN0aXZhdGluZyB0aGUgcm91dGluZyBmdW5jdGlvbmFsaXR5LlxuXHQgKi9cbiAgICB0aGlzLmRlYWN0aXZhdGVSb3V0aW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYnV0dG9ucyA9IHRoaXMuZ2V0QnV0dG9ucygncm91dGluZycpO1xuICAgICAgICBpZiAoIWJ1dHRvbnMpIHJldHVybjtcbiAgICAgICAgYnV0dG9ucy5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuUm91dGluZy5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuZmlyZSgncm91dGluZy5kZWFjdGl2YXRlJywgeyBlbmFibGU6IGZhbHNlIH0pXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGRlYWN0aXZhdGVFeHBsb3Jpbmdcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZGVhY3RpdmF0ZXMgdGhlIGV4cGxvcmluZyBtb2RlIGJ5IGRlYWN0aXZhdGluZyBidXR0b25zLCBkZWxldGluZyBtZXNoIGRhdGEsIGRlYWN0aXZhdGluZyB0aGUgZXhwbG9yaW5nIG1vZGUsIGFuZCBmaXJpbmcgYW4gZXZlbnQuIEZpcmVzIGEgY3VzdG9tIGV2ZW50ICdleHBsb3JpbmcuZGVhY3RpdmF0ZScgd2l0aCB0aGUgZW5hYmxlIHN0YXR1cyBzZXQgdG8gZmFsc2UuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGZhbHNlIGFmdGVyIGRlYWN0aXZhdGluZyB0aGUgZXhwbG9yaW5nIG1vZGUuXG5cdCAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZUV4cGxvcmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJ1dHRvbnMgPSB0aGlzLmdldEJ1dHRvbnMoJ2V4cGxvcmluZycpO1xuICAgICAgICBpZiAoIWJ1dHRvbnMpIHJldHVybjtcbiAgICAgICAgYnV0dG9ucy5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuZGVsZXRlTWVzaERhdGEoKTtcbiAgICAgICAgdGhpcy5FeHBsb3JpbmcuZGVhY3RpdmF0ZSgpO1xuICAgICAgICB0aGlzLmZpcmUoJ2V4cGxvcmluZy5kZWFjdGl2YXRlJywgeyBlbmFibGU6IGZhbHNlIH0pO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBkZWFjdGl2YXRlUGFpbnRpbmdcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gZGVhY3RpdmF0ZXMgdGhlIHBhaW50aW5nIG1vZGUgYnkgZGVhY3RpdmF0aW5nIHRoZSBidXR0b25zLCB0aGUgcGFpbnRpbmcgdG9vbCwgYW5kIGZpcmluZyBhbiBldmVudC4gRmlyZXMgYSBjdXN0b20gZXZlbnQgJ3BhaW50aW5nLmRlYWN0aXZhdGUnIHdpdGggdGhlIGVuYWJsZSBzdGF0dXMgc2V0IHRvIGZhbHNlLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZS5cblx0ICovXG4gICAgdGhpcy5kZWFjdGl2YXRlUGFpbnRpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBidXR0b25zID0gdGhpcy5nZXRCdXR0b25zKCdwYWludGluZycpO1xuICAgICAgICBpZiAoIWJ1dHRvbnMpIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMubW9iaWxlICYmICF0aGlzLmN1cnJlbnRNb2RlLmZpbmlzaGVkICYmIHRoaXMuY3VycmVudE1vZGUuaWQgPT09ICdkcmF3JyAmJiB0aGlzLmN1cnJlbnRNb2RlLnR5cGUgJiYgdGhpcy5jdXJyZW50TW9kZS50eXBlID09PSAnUmVjdGFuZ2xlJykgcmV0dXJuO1xuICAgICAgICBidXR0b25zLmRlYWN0aXZhdGUoKTtcbiAgICAgICAgdGhpcy5QYWludGluZy5kZWFjdGl2YXRlKCk7XG4gICAgICAgIHRoaXMuZmlyZSgncGFpbnRpbmcuZGVhY3RpdmF0ZScsIHsgZW5hYmxlOiBmYWxzZSB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIFxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGdldE1hcFxuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBtYXAgcHJvcGVydHkgZnJvbSB0aGUgTWFwIG9iamVjdC5cblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIG1hcCBwcm9wZXJ0eSBvZiB0aGUgTWFwIG9iamVjdC5cblx0ICovXG4gICAgdGhpcy5nZXRNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcDtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGdldE1vZGVzXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgdGhlIG1vZGVzIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBtb2RlIHBhcmFtZXRlci4gSWYgYSBtb2RlIGlzIHNwZWNpZmllZCwgaXQgcmV0dXJucyB0aGUgbW9kZSB0aGF0IGNhbiBoYW5kbGUgdGhlIGlucHV0IG1vZGUuIElmIG5vIG1vZGUgaXMgc3BlY2lmaWVkLCBpdCByZXR1cm5zIGFsbCBhdmFpbGFibGUgbW9kZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtb2RlIC0gVGhlIG1vZGUgdG8gYmUgY2hlY2tlZCBhZ2FpbnN0IGF2YWlsYWJsZSBtb2Rlcy5cblx0ICogQHJldHVybnMge0FycmF5fE9iamVjdH0gLSBBbiBhcnJheSBvZiBhbGwgYXZhaWxhYmxlIG1vZGVzIGlmIG5vIG1vZGUgaXMgc3BlY2lmaWVkLCBvciB0aGUgbW9kZSBvYmplY3QgdGhhdCBjYW4gaGFuZGxlIHRoZSBpbnB1dCBtb2RlLlxuXHQgKi9cbiAgICB0aGlzLmdldE1vZGVzID0gZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG1vZGUgPyB0aGlzLm1vZGVzLmZpbmQoZnVuY3Rpb24obSkgeyBpZiAobS5jYW5IYW5kbGUgJiYgbS5jYW5IYW5kbGUobW9kZSkpIHsgcmV0dXJuIG07IH0gfSkgOiB0aGlzLm1vZGVzO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZ2V0TW9kZVxuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIG9iamVjdC4gRWl0aGVyICdHZW9GbG8uU2VsZWN0JyBvciAnR2VvRmxvLkRyYXcnLlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBjdXJyZW50IG1vZGUgb2YgdGhlIG9iamVjdC5cblx0ICovXG4gICAgdGhpcy5nZXRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50TW9kZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGdldENvbG9yc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiByZXRyaWV2ZXMgdGhlIGNvbG9ycyBmcm9tIHRoZSBvcHRpb25zIG9iamVjdC5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgY29sb3JzIGFycmF5IGZyb20gdGhlIG9wdGlvbnMgb2JqZWN0LlxuXHQgKi9cbiAgICB0aGlzLmdldENvbG9ycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb2xvcnM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBidXR0b25zIGFzc29jaWF0ZWQgd2l0aCBhIHNwZWNpZmljIGNvbnRyb2wgb3IgYWxsIGJ1dHRvbnMgZnJvbSB0aGUgY29udHJvbHMuXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGdldEJ1dHRvbnNcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIElEIG9mIHRoZSBidXR0b24gdG8gcmV0cmlldmUuIElmIG5vdCBwcm92aWRlZCwgcmV0cmlldmVzIGFsbCBidXR0b25zLlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fGJvb2xlYW59IC0gUmV0dXJucyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYnV0dG9ucyBpZiBmb3VuZCwgb3IgZmFsc2UgaWYgY29udHJvbHMgYXJlIG5vdCBhdmFpbGFibGUuXG5cdCAqL1xuICAgIHRoaXMuZ2V0QnV0dG9ucyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ29udHJvbHMoKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHZhciBidXR0b25zO1xuXG4gICAgICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSBjLmdldEJ1dHRvbk9wdGlvbnMoKTtcblxuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFidXR0b25zICYmIG9wdGlvbnNbaWRdKSBidXR0b25zID0gb3B0aW9uc1tpZF07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghYnV0dG9ucykgYnV0dG9ucyA9IHt9O1xuXG4gICAgICAgICAgICAgICAgT2JqZWN0LmVudHJpZXMob3B0aW9ucykuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gZW50cnlbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uc1trZXldID0gdmFsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgfSlcblxuICAgICAgICByZXR1cm4gYnV0dG9ucztcbiAgICB9XG5cblxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGdldEZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHJldHJpZXZlcyBib3RoIHRoZSBkcmF3biBhbmQgc2VsZWN0ZWQgZmVhdHVyZXMgYW5kIHJldHVybnMgdGhlbSBhcyBhIHNpbmdsZSBhcnJheS5cblx0ICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgYm90aCB0aGUgZHJhd24gYW5kIHNlbGVjdGVkIGZlYXR1cmVzLlxuXHQgKi9cbiAgICB0aGlzLmdldEZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW3RoaXMuZ2V0RHJhd25GZWF0dXJlcygpLCB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMoKV0uZmxhdCgpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZ2V0RHJhd25GZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBkcmF3biBmZWF0dXJlcyBmcm9tIHRoZSBGZWF0dXJlcyBvYmplY3QuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQW4gYXJyYXkgb2YgZHJhd24gZmVhdHVyZXMuXG5cdCAqL1xuICAgIHRoaXMuZ2V0RHJhd25GZWF0dXJlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRmVhdHVyZXMuZ2V0Q29sZEZlYXR1cmVzKCk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBnZXRSZW5kZXJlZEZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgcmVuZGVyZWQgZmVhdHVyZXMgd2l0aGluIGEgc3BlY2lmaWVkIHJhZGl1cyBhcm91bmQgYSBnaXZlbiBsb25naXR1ZGUgYW5kIGxhdGl0dWRlLCBiYXNlZCBvbiBhIGZpbHRlci5cblx0ICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBsbmdMYXQgLSBBbiBhcnJheSBjb250YWluaW5nIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzSW5LbSAtIFRoZSByYWRpdXMgaW4ga2lsb21ldGVycyB3aXRoaW4gd2hpY2ggdG8gc2VhcmNoIGZvciBmZWF0dXJlcy5cblx0ICogQHBhcmFtIHtvYmplY3R9IGZpbHRlciAtIEFuIG9wdGlvbmFsIGZpbHRlciBvYmplY3QgdG8gYXBwbHkgd2hlbiByZXRyaWV2aW5nIGZlYXR1cmVzLlxuXHQgKiBAcmV0dXJucyB7QXJyYXk8b2JqZWN0Pn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgZmVhdHVyZXMgdGhhdCBtYXRjaCB0aGUgY3JpdGVyaWEuXG5cdCAqL1xuICAgIHRoaXMuZ2V0UmVuZGVyZWRGZWF0dXJlcyA9IGZ1bmN0aW9uIChsbmdMYXQsIHJhZGl1c0luS20sIGZpbHRlcikge1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSBbdGhpcy5nZXRSZW5kZXJlZERyYXduRmVhdHVyZXMobG5nTGF0LCByYWRpdXNJbkttLCBmaWx0ZXIpLCB0aGlzLmdldFJlbmRlcmVkU25hcEZlYXR1cmVzKGxuZ0xhdCwgcmFkaXVzSW5LbSwgZmlsdGVyKV0uZmxhdCgpO1xuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBnZXRSZW5kZXJlZERyYXduRmVhdHVyZXNcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gcXVlcmllcyB0aGUgbWFwIGZvciByZW5kZXJlZCBkcmF3biBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgcGFyYW1ldGVycy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGxuZ0xhdCAtIFRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIGNvb3JkaW5hdGVzLlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzSW5LbSAtIFRoZSByYWRpdXMgaW4ga2lsb21ldGVycyBmb3IgdGhlIHNlYXJjaC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZpbHRlciAtIE9wdGlvbmFsIGZpbHRlciBvYmplY3QgdG8gYXBwbHkgdG8gdGhlIHF1ZXJ5LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGZlYXR1cmVzIHdpdGhpbiB0aGUgc3BlY2lmaWVkIHJhZGl1cyBhcm91bmQgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuXHQgKi9cbiAgICB0aGlzLmdldFJlbmRlcmVkRHJhd25GZWF0dXJlcyA9IGZ1bmN0aW9uIChsbmdMYXQsIHJhZGl1c0luS20sIGZpbHRlcikge1xuICAgICAgICB2YXIgYmJveDtcbiAgICAgICAgdmFyIGlkID0gdGhpcy5pZDtcblxuICAgICAgICB2YXIgcHJlbGF5ZXJzID0gW1xuICAgICAgICAgICAgaWQgKyBcIi1saW5lLWNvbGRcIixcbiAgICAgICAgICAgIGlkICsgXCItZmlsbC1jb2xkXCIsXG4gICAgICAgICAgICBpZCArIFwiLWNpcmNsZS1jb2xkXCIsXG4gICAgICAgICAgICBpZCArIFwiLWljb24tY29sZFwiXG4gICAgICAgIF07XG5cbiAgICAgICAgdmFyIGxheWVycyA9IFtdO1xuXG4gICAgICAgIHByZWxheWVycy5mb3JFYWNoKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5tYXAuZ2V0TGF5ZXIobGF5ZXIpKSBsYXllcnMucHVzaChsYXllcik7XG4gICAgICAgIH0sIHRoaXMpXG5cbiAgICAgICAgdGhpcy5MYXllcnMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgaWYgKGxheWVyLmlkLmluY2x1ZGVzKGlkKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHRoaXMubWFwLmdldExheWVyKGxheWVyLmlkKSkgbGF5ZXJzLnB1c2gobGF5ZXIuaWQpO1xuICAgICAgICB9LCB0aGlzKVxuXG4gICAgICAgIHZhciBvcHRpb25zID0geyBsYXllcnM6IGxheWVycyB9O1xuXG4gICAgICAgIGlmIChyYWRpdXNJbkttKSB7XG4gICAgICAgICAgICB2YXIgcmFkaXVzID0gdHVyZi5kaXN0YW5jZVRvRGVncmVlcyhyYWRpdXNJbkttKTtcbiAgICAgICAgICAgIGJib3ggPSBbdGhpcy5tYXAucHJvamVjdChbbG5nTGF0LmxuZyAtIHJhZGl1cywgbG5nTGF0LmxhdCAtIHJhZGl1c10pLCB0aGlzLm1hcC5wcm9qZWN0KFtsbmdMYXQubG5nICsgcmFkaXVzLCBsbmdMYXQubGF0ICsgcmFkaXVzXSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHBvaW50ID0gbG5nTGF0ID8gdGhpcy5tYXAucHJvamVjdChbbG5nTGF0LmxuZywgbG5nTGF0LmxhdF0pIDogbnVsbDtcbiAgICAgICAgICAgIGJib3ggPSBwb2ludCA/IFtbcG9pbnQueCAtIDUsIHBvaW50LnkgLSA1XSwgW3BvaW50LnggKyA1LCBwb2ludC55ICsgNV1dIDogbnVsbFxuICAgICAgICB9XG5cbiAgICAgICAgZmlsdGVyID8gb3B0aW9ucy5maWx0ZXIgPSBmaWx0ZXIgOiBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMubWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhiYm94LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGlkcyA9IGZlYXR1cmVzLm1hcChmdW5jdGlvbihmZWF0dXJlKSB7IHJldHVybiBmZWF0dXJlLnBhcmVudCB8fCBmZWF0dXJlLnByb3BlcnRpZXMucGFyZW50IHx8IGZlYXR1cmUuaWQgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkOyB9KTtcblxuICAgICAgICByZXR1cm4gZmVhdHVyZXMgJiYgZmVhdHVyZXMubGVuZ3RoID8gdGhpcy5GZWF0dXJlcy5nZXRGZWF0dXJlc0J5SWQoaWRzKSA6IFtdOztcbiAgICB9XG4gICAgXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBnZXRSZW5kZXJlZFNuYXBGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHJlbmRlcmVkIG1lc2ggaW5kZXggZmVhdHVyZXMgd2l0aGluIGEgc3BlY2lmaWVkIHJhZGl1cyBhcm91bmQgYSBnaXZlbiBwb2ludCBvbiB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gbG5nTGF0IC0gVGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciBwb2ludC5cblx0ICogQHBhcmFtIHtudW1iZXJ9IHJhZGl1c0luS20gLSBUaGUgcmFkaXVzIGluIGtpbG9tZXRlcnMgd2l0aGluIHdoaWNoIHRvIHNlYXJjaCBmb3IgZmVhdHVyZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBmaWx0ZXIgLSBPcHRpb25hbCBmaWx0ZXIgdG8gYXBwbHkgdG8gdGhlIHF1ZXJ5LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGZlYXR1cmVzIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHNwZWNpZmllZCByYWRpdXMgYXJvdW5kIHRoZSBnaXZlbiBwb2ludC5cblx0ICovXG4gICAgdGhpcy5nZXRSZW5kZXJlZFNuYXBGZWF0dXJlcyA9IGZ1bmN0aW9uIChsbmdMYXQsIHJhZGl1c0luS20sIGZpbHRlcikge1xuICAgICAgICBpZiAoIXRoaXMubWVzaEluZGV4KSByZXR1cm4gW107XG5cbiAgICAgICAgdmFyIHJhZGl1cyA9IHR1cmYuZGlzdGFuY2VUb0RlZ3JlZXMocmFkaXVzSW5LbSk7XG4gICAgICAgIHZhciBiYm94ID0gW3RoaXMubWFwLnByb2plY3QoW2xuZ0xhdC5sbmcgLSByYWRpdXMsIGxuZ0xhdC5sYXQgLSByYWRpdXNdKSwgdGhpcy5tYXAucHJvamVjdChbbG5nTGF0LmxuZyArIHJhZGl1cywgbG5nTGF0LmxhdCArIHJhZGl1c10pXTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7IGxheWVyczogW10gfTtcblxuICAgICAgICBnZW9mbG8uTGF5ZXJzLmdldExheWVycygpLmZvckVhY2goZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGlmICghbGF5ZXIuaWQuaW5jbHVkZXMoJ01FU0gnKSkgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGxheWVyLnR5cGUgPT09ICdmaWxsJykgcmV0dXJuO1xuICAgICAgICAgICAgb3B0aW9ucy5sYXllcnMucHVzaChsYXllci5pZCk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgZmlsdGVyID8gb3B0aW9ucy5maWx0ZXIgPSBmaWx0ZXIgOiBmYWxzZTtcblxuICAgICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLm1hcC5xdWVyeVJlbmRlcmVkRmVhdHVyZXMoYmJveCwgb3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlcyAmJiBmZWF0dXJlcy5sZW5ndGggPyB0aGlzLm1lc2hJbmRleC5nZXRGZWF0dXJlc0Zyb21JbmRleChmZWF0dXJlcykgOiBbXTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGdldEZlYXR1cmVCeUlkXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgYSBmZWF0dXJlIGJ5IGl0cyBJRCBmcm9tIHRoZSBGZWF0dXJlcyBvYmplY3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBJRCBvZiB0aGUgZmVhdHVyZSB0byByZXRyaWV2ZS5cblx0ICogQHJldHVybnMge2Jvb2xlYW58b2JqZWN0fSBSZXR1cm5zIHRoZSBmZWF0dXJlIG9iamVjdCBpZiBmb3VuZCwgb3RoZXJ3aXNlIGZhbHNlLlxuXHQgKi9cbiAgICB0aGlzLmdldEZlYXR1cmVCeUlkID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmICghaWQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuRmVhdHVyZXMuZ2V0RmVhdHVyZUJ5SWQoaWQpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZ2V0RmVhdHVyZXNCeUxheWVyXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHF1ZXJpZXMgdGhlIG1hcCBmb3IgZmVhdHVyZXMgd2l0aGluIGEgc3BlY2lmaWVkIHJhZGl1cyBhcm91bmQgYSBnaXZlbiBsb2NhdGlvbiBmcm9tIGEgc3BlY2lmaWMgc291cmNlIGxheWVyLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gc291cmNlIC0gVGhlIHNvdXJjZSBsYXllciB0byBxdWVyeSBmZWF0dXJlcyBmcm9tLlxuXHQgKiBAcGFyYW0ge0xuZ0xhdH0gbG5nTGF0IC0gVGhlIGxvbmdpdHVkZSBhbmQgbGF0aXR1ZGUgY29vcmRpbmF0ZXMgb2YgdGhlIGNlbnRlciBwb2ludCBmb3IgdGhlIHF1ZXJ5LlxuXHQgKiBAcGFyYW0ge251bWJlcn0gcmFkaXVzSW5LbSAtIFRoZSByYWRpdXMgaW4ga2lsb21ldGVycyB3aXRoaW4gd2hpY2ggdG8gc2VhcmNoIGZvciBmZWF0dXJlcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZpbHRlciAtIE9wdGlvbmFsIGZpbHRlciBvYmplY3QgdG8gYXBwbHkgdG8gdGhlIHF1ZXJ5LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IG9mIGZlYXR1cmVzIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5IGNyaXRlcmlhLlxuXHQgKi9cbiAgICB0aGlzLmdldEZlYXR1cmVzQnlMYXllciA9IGZ1bmN0aW9uIChzb3VyY2UsIGxuZ0xhdCwgcmFkaXVzSW5LbSwgZmlsdGVyKSB7XG4gICAgICAgIHZhciBsYXllcnMgPSBbXTtcbiAgICAgICAgdmFyIGJib3g7XG5cbiAgICAgICAgdGhpcy5MYXllcnMuZ2V0TGF5ZXJzKCkuZm9yRWFjaChmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgaWYgKCFsYXllci5pZC5pbmNsdWRlcyhzb3VyY2UpKSByZXR1cm47XG4gICAgICAgICAgICBsYXllcnMucHVzaChsYXllci5pZCk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7IGxheWVyczogbGF5ZXJzIH07XG5cbiAgICAgICAgaWYgKHJhZGl1c0luS20pIHtcbiAgICAgICAgICAgIHZhciByYWRpdXMgPSB0dXJmLmRpc3RhbmNlVG9EZWdyZWVzKHJhZGl1c0luS20pO1xuICAgICAgICAgICAgYmJveCA9IFt0aGlzLm1hcC5wcm9qZWN0KFtsbmdMYXQubG5nIC0gcmFkaXVzLCBsbmdMYXQubGF0IC0gcmFkaXVzXSksIHRoaXMubWFwLnByb2plY3QoW2xuZ0xhdC5sbmcgKyByYWRpdXMsIGxuZ0xhdC5sYXQgKyByYWRpdXNdKV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcG9pbnQgPSBsbmdMYXQgPyB0aGlzLm1hcC5wcm9qZWN0KFtsbmdMYXQubG5nLCBsbmdMYXQubGF0XSkgOiBudWxsO1xuICAgICAgICAgICAgYmJveCA9IHBvaW50ID8gW1twb2ludC54IC0gNSwgcG9pbnQueSAtIDVdLCBbcG9pbnQueCArIDUsIHBvaW50LnkgKyA1XV0gOiBudWxsXG4gICAgICAgIH1cblxuICAgICAgICBmaWx0ZXIgPyBvcHRpb25zLmZpbHRlciA9IGZpbHRlciA6IGZhbHNlO1xuXG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMubWFwLnF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyhiYm94LCBvcHRpb25zKTtcbiAgICAgICAgdmFyIGlkcyA9IGZlYXR1cmVzLm1hcChmdW5jdGlvbihmZWF0dXJlKSB7IHJldHVybiBmZWF0dXJlLnBhcmVudCB8fCBmZWF0dXJlLnByb3BlcnRpZXMucGFyZW50IHx8IGZlYXR1cmUuaWQgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkOyB9KTtcblxuICAgICAgICByZXR1cm4gZmVhdHVyZXMgJiYgZmVhdHVyZXMubGVuZ3RoID8gdGhpcy5GZWF0dXJlcy5nZXRGZWF0dXJlc0J5SWQoaWRzKSA6IFtdOztcbiAgICB9XG5cblxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGdldFNlbGVjdGVkRmVhdHVyZXNcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMgc3RvcmVkIGluIHRoZSBzZWxlY3RlZEZlYXR1cmVzIGFycmF5LlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkIGZlYXR1cmVzLlxuXHQgKi9cbiAgICB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZEZlYXR1cmVzO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZ2V0U2VsZWN0ZWRGZWF0dXJlSWRzXG5cdCAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgdGhlIElEcyBvZiBzZWxlY3RlZCBmZWF0dXJlcy5cblx0ICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBmZWF0dXJlIElEcy5cblx0ICovXG4gICAgdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVJZHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMoKS5tYXAoKGZlYXR1cmUpID0+IHsgcmV0dXJuIGZlYXR1cmUucGFyZW50IHx8IGZlYXR1cmUucHJvcGVydGllcy5wYXJlbnQgfHwgZmVhdHVyZS5pZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQ7IH0pO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZ2V0U2VsZWN0ZWRGZWF0dXJlc0Jib3hcblx0ICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSBzZWxlY3RlZCBmZWF0dXJlcy5cblx0ICogQHJldHVybnMge0FycmF5PG51bWJlcj59IFRoZSBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgW21pblgsIG1pblksIG1heFgsIG1heFldLlxuXHQgKi9cbiAgICB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXNCYm94ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKCkpIHJldHVybiBudWxsO1xuICAgICAgICByZXR1cm4gdHVyZi5iYm94KHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24odGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkpKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGdldFNlbGVjdGVkUHJvcGVydHlOYW1lc1xuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSB1bmlxdWUgcHJvcGVydHkgbmFtZXMgb2Ygc2VsZWN0ZWQgZmVhdHVyZXMgZXhjbHVkaW5nIHRoZSBJRCBwcm9wZXJ0eS5cblx0ICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiB1bmlxdWUgcHJvcGVydHkgbmFtZXMuXG5cdCAqL1xuICAgIHRoaXMuZ2V0U2VsZWN0ZWRQcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuaWQ7XG4gICAgICAgIGNvbnN0IG5hbWVzID0gW107XG5cbiAgICAgICAgdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoZmVhdHVyZS5wcm9wZXJ0aWVzKS5mb3JFYWNoKChwcm9wZXJ0eU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZXMuaW5kZXhPZihwcm9wZXJ0eU5hbWUpID09PSAtMSAmJiBwcm9wZXJ0eU5hbWUgIT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gocHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG5hbWVzO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZ2V0U2VsZWN0ZWRQcm9wZXJ0eVZhbHVlc1xuXHQgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBwcm9wZXJ0aWVzIG9mIHNlbGVjdGVkIGZlYXR1cmVzIGV4Y2x1ZGluZyB0aGUgcHJvcGVydHkgd2l0aCB0aGUgc3BlY2lmaWVkIElELlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgcHJvcGVydGllcyBvZiBzZWxlY3RlZCBmZWF0dXJlcy5cblx0ICovXG4gICAgdGhpcy5nZXRTZWxlY3RlZFByb3BlcnR5VmFsdWVzID0gZnVuY3Rpb24gICgpIHtcbiAgICAgICAgY29uc3QgaWQgPSB0aGlzLmlkO1xuICAgICAgICB2YXIgcHJvcHMgPSB7fTtcblxuICAgICAgICB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMoKS5mb3JFYWNoKGZ1bmN0aW9uIChmZWF0dXJlKSB7IE9iamVjdC5hc3NpZ24ocHJvcHMsIGZlYXR1cmUucHJvcGVydGllcyk7IH0pO1xuICAgICAgICBpZiAocHJvcHNbaWRdICE9PSB1bmRlZmluZWQpIHsgZGVsZXRlIHByb3BzW2lkXTsgfVxuICAgICAgICByZXR1cm4gcHJvcHM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSBjb21tb24gZ2VvbWV0cnkgdHlwZSBvZiB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMuIElmIGFsbCBzZWxlY3RlZCBmZWF0dXJlcyBoYXZlIHRoZSBzYW1lIGdlb21ldHJ5IHR5cGUsIGl0IHJldHVybnMgdGhhdCB0eXBlLiBJZiB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMgaGF2ZSBkaWZmZXJlbnQgZ2VvbWV0cnkgdHlwZXMsIGl0IHJldHVybnMgXCJpbGxlZ2FsXCIuXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGdldENvbW1vbkdlb21ldHJ5VHlwZVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9IFRoZSBjb21tb24gZ2VvbWV0cnkgdHlwZSBvciBudWxsIGlmIGRpZmZlcmVudCB0eXBlcyBhcmUgcHJlc2VudC5cblx0ICovXG4gICAgdGhpcy5nZXRDb21tb25HZW9tZXRyeVR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCBhbGxGZWF0dXJlc1R5cGUgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlcygpLmZvckVhY2goKGZlYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGlmIChhbGxGZWF0dXJlc1R5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhbGxGZWF0dXJlc1R5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSAhPT0gYWxsRmVhdHVyZXNUeXBlKSB7XG4gICAgICAgICAgICAgICAgYWxsRmVhdHVyZXNUeXBlID0gXCJpbGxlZ2FsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChhbGxGZWF0dXJlc1R5cGUgPT09IFwiaWxsZWdhbFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhbGxGZWF0dXJlc1R5cGU7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgc2VsZWN0RmVhdHVyZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG4gICAgICogQGRlc2NyaXB0aW9uIFNlbGVjdHMgYSBmZWF0dXJlIGJ5IGl0cyBJRCBhbmQgcmV0dXJucyB0aGUgc2VsZWN0aW9uIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBJRCBvZiB0aGUgZmVhdHVyZSB0byBiZSBzZWxlY3RlZC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnxPYmplY3R9IFJldHVybnMgZmFsc2UgaWYgdGhlIGZlYXR1cmUgaXMgbm90IGZvdW5kLCBvdGhlcndpc2UgcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgdGhpcy5zZWxlY3RGZWF0dXJlID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gdGhpcy5nZXRGZWF0dXJlQnlJZChpZCk7XG4gICAgICAgIGlmICghZmVhdHVyZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0aGlzLkZlYXR1cmVzLnNlbGVjdEZlYXR1cmVzKFtmZWF0dXJlXSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2VsZWN0ZWQ7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBlZGl0RmVhdHVyZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBhbGxvd3MgZWRpdGluZyBhIGZlYXR1cmUgYnkgcHJvdmlkaW5nIGl0cyBJRCBvciB1c2luZyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGZlYXR1cmUuIEl0IHRyaWdnZXJzIGEgJ2ZlYXR1cmUuZWRpdCcgZXZlbnQgYW5kIHNldHMgdGhlIG1vZGUgdG8gJ2VkaXQnLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgSUQgb2YgdGhlIGZlYXR1cmUgdG8gZWRpdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIGVkaXRpbmcgdGhlIGZlYXR1cmUuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmZlYXR1cmUgLSBUaGUgZmVhdHVyZSBvYmplY3QgdG8gZWRpdC5cblx0ICogQHJldHVybnMge09iamVjdH0gVGhlIGVkaXRlZCBmZWF0dXJlLlxuXHQgKi9cbiAgICB0aGlzLmVkaXRGZWF0dXJlID0gZnVuY3Rpb24gKGlkLCBvcHRpb25zPXt9KSB7XG4gICAgICAgIHZhciBmZWF0dXJlID0gb3B0aW9ucy5mZWF0dXJlIHx8IHRoaXMuZ2V0RmVhdHVyZUJ5SWQoaWQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFmZWF0dXJlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaGFzU2luZ2xlU2VsZWN0aW9uKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGZlYXR1cmUgPSB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMoKVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9wdGlvbnMuaWQgPSBmZWF0dXJlLmlkO1xuICAgICAgICBvcHRpb25zLm1vZGUgPSAnZWRpdCc7XG4gICAgICAgIG9wdGlvbnMuZmVhdHVyZSA9IGZlYXR1cmU7XG5cbiAgICAgICAgdGhpcy5maXJlKCdmZWF0dXJlLmVkaXQnLCB7IGZlYXR1cmU6IGZlYXR1cmUsIGlkOiBmZWF0dXJlLmlkIH0pO1xuICAgICAgICB0aGlzLnNldE1vZGUob3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgY2FuY2VsRWRpdFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBjYW5jZWxzIHRoZSBjdXJyZW50IGVkaXQgbW9kZSBpZiBpdCBpcyBpbiAnZHJhdycgbW9kZSBhbmQgZGVhY3RpdmF0ZXMgdGhlIGVkaXRpbmcgZmVhdHVyZS5cblx0ICogQHBhcmFtIHtib29sZWFufSBzdGFuZGJ5IC0gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGNhbmNlbCBvcGVyYXRpb24gaXMgc3RhbmRieS5cblx0ICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmUgLSBUaGUgZmVhdHVyZSB0byBiZSBkZWFjdGl2YXRlZC4gSWYgbm90IHByb3ZpZGVkLCB0aGUgZWRpdGluZyBmZWF0dXJlIHdpbGwgYmUgdXNlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgdGhlIGN1cnJlbnQgbW9kZSBpcyBub3QgJ2RyYXcnLCBvdGhlcndpc2UgZGVhY3RpdmF0ZXMgdGhlIGVkaXRpbmcgZmVhdHVyZS5cblx0ICovXG4gICAgdGhpcy5jYW5jZWxFZGl0ID0gZnVuY3Rpb24gKHN0YW5kYnksIGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1vZGUuaWQgIT09ICdkcmF3JykgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50TW9kZS5kZWFjdGl2YXRlKHsgY2FuY2VsOiB0cnVlLCBzdGFuZGJ5OiBzdGFuZGJ5LCBmZWF0dXJlOiBmZWF0dXJlIHx8IHRoaXMuZWRpdGluZyB9KTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHNhdmVFZGl0XG5cdCAqIEBkZXNjcmlwdGlvbiBTYXZlcyB0aGUgZWRpdGVkIGZlYXR1cmUgdXNpbmcgdGhlIGN1cnJlbnRNb2RlcyBzYXZlRWRpdCBtZXRob2QuXG5cdCAqIEByZXR1cm4ge2FueX0gVGhlIHJlc3VsdCBvZiB0aGUgc2F2ZUVkaXQgbWV0aG9kIG9mIHRoZSBjdXJyZW50IG1vZGUuXG5cdCAqL1xuICAgIHRoaXMuc2F2ZUVkaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRNb2RlLnNhdmVFZGl0KCk7XG4gICAgfVxuXG5cblxuXG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGFkZEZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBBZGRzIGZlYXR1cmVzIHRvIHRoZSBtYXAgYW5kIG9wdGlvbmFsbHkgem9vbXMgdG8gdGhlbS5cblx0ICogQHBhcmFtIHtBcnJheX0gZmVhdHVyZXMgLSBBcnJheSBvZiBmZWF0dXJlcyB0byBiZSBhZGRlZCB0byB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IG5vWm9vbSAtIEZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciB0byB6b29tIHRvIHRoZSBhZGRlZCBmZWF0dXJlcy5cblx0ICovXG4gICAgdGhpcy5hZGRGZWF0dXJlcyA9IGZ1bmN0aW9uIChmZWF0dXJlcywgbm9ab29tKSB7XG4gICAgICAgIGlmICghZmVhdHVyZXMpIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGZlYXR1cmVzLmZlYXR1cmVzKSBmZWF0dXJlcyA9IGZlYXR1cmVzLmZlYXR1cmVzO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmVhdHVyZXMpKSBmZWF0dXJlcyA9IFtmZWF0dXJlc107XG4gICAgICAgIGlmICghZmVhdHVyZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5GZWF0dXJlcy5hZGRGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICAgICFub1pvb20gPyB0aGlzLnpvb21Ub0ZlYXR1cmVzKCkgOiBmYWxzZTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIGFkZEZlYXR1cmVzVG9TZWxlY3RlZFxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBhZGRzIHRoZSBwcm92aWRlZCBmZWF0dXJlcyB0byB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMgbGlzdCwgdXBkYXRlcyB0aGUgbWFwIHNvdXJjZXMsIHNldHMgYnV0dG9ucyBhbmQgdXBkYXRlcyB0aGUgdGV4dC5cblx0ICogQHBhcmFtIHtBcnJheX0gZmVhdHVyZXMgLSBUaGUgZmVhdHVyZXMgdG8gYmUgYWRkZWQgdG8gdGhlIHNlbGVjdGVkIGZlYXR1cmVzIGxpc3QuXG5cdCAqL1xuICAgIHRoaXMuYWRkRmVhdHVyZXNUb1NlbGVjdGVkID0gZnVuY3Rpb24gKGZlYXR1cmVzLCBvcHRpb25zPXt9KSB7XG4gICAgICAgIGlmICghZmVhdHVyZXMgfHwgIWZlYXR1cmVzLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIHRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlcygpLnB1c2goLi4uZmVhdHVyZXMpO1xuICAgICAgICB0aGlzLnNldFZpZXdwb3J0KCk7XG4gICAgICAgIHRoaXMuc2V0QnV0dG9ucygpO1xuICAgICAgICB0aGlzLm1hcC5nZXRTb3VyY2UodGhpcy5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLlNFTEVDVCkuc2V0RGF0YSh0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKHRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlcygpKSk7XG4gICAgICAgIHRoaXMubWFwLmdldFNvdXJjZSh0aGlzLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuVkVSVEVYKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24odGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkpKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuTGF5ZXJzLnJlZnJlc2goeyBzZWxlY3Q6IHRydWUgfSk7XG5cbiAgICAgICAgdGhpcy5GZWF0dXJlcy5zZXRUZXh0KGZlYXR1cmVzKTtcbiAgICAgICAgdGhpcy5GZWF0dXJlcy51cGRhdGVGZWF0dXJlcyhmZWF0dXJlcyk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuem9vbSkgdGhpcy56b29tVG9GZWF0dXJlcyhmZWF0dXJlcywgeyBjZW50ZXI6IG9wdGlvbnMuY2VudGVyIH0pO1xuXG4gICAgICAgIGlmIChvcHRpb25zLnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuTGF5ZXJzLmFkZFRleHRMYXllcih7XG4gICAgICAgICAgICAgICAgc2VsZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIGlkczogb3B0aW9ucy50ZXh0LmlkcyxcbiAgICAgICAgICAgICAgICBmaWVsZDogb3B0aW9ucy50ZXh0LmZpZWxkIHx8ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICBsYXlvdXQ6IG9wdGlvbnMudGV4dC5sYXlvdXQgfHwge1xuICAgICAgICAgICAgICAgICAgICAndGV4dC10cmFuc2Zvcm0nOiAndXBwZXJjYXNlJyxcbiAgICAgICAgICAgICAgICAgICAgJ3RleHQtc2l6ZSc6IDEwLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1vZmZzZXQnOiBbMCwgMC41XVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBhZGRGZWF0dXJlc1RvTWVzaFxuXHQgKiBAZGVzY3JpcHRpb24gQWRkcyBmZWF0dXJlcyB0byB0aGUgbWVzaCBpbmRleCBhbmQgdXBkYXRlcyBpdHMgZGF0YS5cblx0ICogQHBhcmFtIHtBcnJheX0gZmVhdHVyZXMgLSBBbiBhcnJheSBvZiBmZWF0dXJlcyB0byBiZSBhZGRlZCB0byB0aGUgbWVzaC5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgYXJyYXkgb2YgZmVhdHVyZXMgdGhhdCB3ZXJlIGFkZGVkIHRvIHRoZSBtZXNoLlxuXHQgKi9cbiAgICB0aGlzLmFkZEZlYXR1cmVzVG9NZXNoID0gZnVuY3Rpb24gKGZlYXR1cmVzPVtdKSB7XG4gICAgICAgIGlmICghZmVhdHVyZXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMudXBkYXRlTWVzaERhdGEoZmVhdHVyZXMpO1xuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBhZGRHYW1lcGFkXG5cdCAqIEBkZXNjcmlwdGlvbiBBZGRzIGEgZ2FtZXBhZCB0byB0aGUgbGlzdCBvZiBhdmFpbGFibGUgZ2FtZXBhZHMgYW5kIGZpcmVzIGFuIGV2ZW50LiBGaXJlcyBhIGN1c3RvbSBldmVudCAnZ2FtZXBhZC5hZGQnIHdpdGggdGhlIGdhbWVwYWQgb2JqZWN0LlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZ2FtZXBhZCAtIFRoZSBnYW1lcGFkIG9iamVjdCB0byBiZSBhZGRlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgdGhlICdHYW1lcGFkJyBwbHVnaW4gaXMgbm90IGF2YWlsYWJsZS5cblx0ICovXG4gICAgdGhpcy5hZGRHYW1lcGFkID0gZnVuY3Rpb24gKGdhbWVwYWQpIHtcbiAgICAgICAgdGhpcy5nYW1lcGFkc1tnYW1lcGFkLmluZGV4XSA9IG5ldyBHYW1lcGFkKGdhbWVwYWQpO1xuICAgICAgICB0aGlzLmZpcmUoJ2dhbWVwYWQuYWRkJywgeyBnYW1lcGFkOiBnYW1lcGFkIH0pO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgYWRkVG9vbHRpcFxuXHQgKiBAZGVzY3JpcHRpb24gQXR0YWNoZXMgYSB0b29sdGlwIGJ5IGNhbGxpbmcgc2V0VG9vbHRpcCB0byBhIHNwZWNpZmllZCBlbGVtZW50IHdpdGhpbiBhIHBhcmVudCBlbGVtZW50LlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudCAtIFRoZSBwYXJlbnQgZWxlbWVudCB0byB3aGljaCB0aGUgdG9vbHRpcCB3aWxsIGJlIGF0dGFjaGVkLlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB3aGljaCB0aGUgdG9vbHRpcCB3aWxsIGJlIGFwcGxpZWQuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIGN1c3RvbWl6aW5nIHRoZSB0b29sdGlwLlxuXHQgKiBAcGFyYW0ge0VsZW1lbnR9IGFwcGVuZFRvIC0gVGhlIGVsZW1lbnQgdG8gd2hpY2ggdGhlIHRvb2x0aXAgd2lsbCBiZSBhcHBlbmRlZC5cblx0ICovXG4gICAgdGhpcy5hZGRUb29sdGlwID0gZnVuY3Rpb24gKHBhcmVudCwgZWxlbWVudCwgb3B0aW9ucywgYXBwZW5kVG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLnNldFRvb2x0aXApIHJldHVybiBmYWxzZTtcblxuICAgICAgICB0aGlzLnNldFRvb2x0aXAoZWxlbWVudCwge1xuICAgICAgICAgICAgcGFyZW50OiBwYXJlbnQsXG4gICAgICAgICAgICBhcHBlbmRUbzogYXBwZW5kVG8sXG4gICAgICAgICAgICBvcHRpb25zOiBvcHRpb25zXG4gICAgICAgIH0pXG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBhZGRQbHVnaW5cblx0ICogQGRlc2NyaXB0aW9uIEFkZHMgYSBwbHVnaW4gdG8gdGhlIHBsdWdpbnMgb2JqZWN0IG9mIHRoZSBjdXJyZW50IGluc3RhbmNlLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gVGhlIHBsdWdpbiBvYmplY3QgdG8gYmUgYWRkZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwbHVnaW4uaWQgLSBUaGUgdW5pcXVlIGlkZW50aWZpZXIgb2YgdGhlIHBsdWdpbi5cblx0ICogQHRocm93cyB7RXJyb3J9IElmIG5vIFBsdWdpbiBJRCBpcyBwcm92aWRlZC5cblx0ICovXG4gICAgdGhpcy5hZGRQbHVnaW4gPSBmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICAgIGlmICghcGx1Z2luLmlkKSB0aHJvdyBuZXcgRXJyb3IoJ05vIFBsdWdpbiBJRCBwcm92aWRlZCcpXG4gICAgICAgIHZhciBpZCA9IHBsdWdpbi5pZDtcbiAgICAgICAgdGhpcy5wbHVnaW5zW2lkXSA9IHBsdWdpbjtcbiAgICB9XG5cblxuXG4gICAgXG5cblx0LyoqXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHRoZSBzZWxlY3Rpb24gb2YgZmVhdHVyZXMgYmFzZWQgb24gdGhlIHByb3ZpZGVkIGZlYXR1cmUgSUQuIElmIG5vIElEIGlzIHByb3ZpZGVkLCBhbGwgc2VsZWN0ZWQgZmVhdHVyZXMgYXJlIGRlc2VsZWN0ZWQuXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHJlbW92ZVNlbGVjdGlvblxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgLSBUaGUgSUQgb2YgdGhlIGZlYXR1cmUgdG8gYmUgZGVzZWxlY3RlZC5cblx0ICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBmZWF0dXJlcyB0aGF0IHdlcmUgZGVzZWxlY3RlZC5cblx0ICovXG4gICAgdGhpcy5yZW1vdmVTZWxlY3Rpb24gPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnM9e30pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQb3B1cCgpO1xuICAgICAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKCkpIHJldHVybiB0aGlzLkZlYXR1cmVzLnNldFRleHQoKSwgdGhpcy51cGRhdGVGZWF0dXJlcygpO1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSB0aGlzLlV0aWxpdGllcy5jbG9uZSh0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMoKSk7XG4gICAgICAgIHRoaXMuRmVhdHVyZXMuYWRkRmVhdHVyZXMoZmVhdHVyZXMsIHRydWUsIGlkKTtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkuc3BsaWNlKDAsIGZlYXR1cmVzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubWFwLmdldFNvdXJjZSh0aGlzLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU0VMRUNUKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pKTtcbiAgICAgICAgdGhpcy5tYXAuZ2V0U291cmNlKHRoaXMuc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5WRVJURVgpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuICAgICAgICB0aGlzLkZlYXR1cmVzLnNldFRleHQoKTtcbiAgICAgICAgdGhpcy51cGRhdGVGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICAgIHRoaXMuc2V0QnV0dG9ucygpO1xuICAgICAgICBpZiAob3B0aW9ucy5leHRlbnQpIHRoaXMuc2V0Vmlld3BvcnQoKSwgdGhpcy5zZXRFeHRlbnQoKTtcbiAgICAgICAgaWYgKG9wdGlvbnMucmVtb3ZlVGV4dCkgdGhpcy5MYXllcnMucmVtb3ZlVGV4dExheWVyKCk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlcy5sZW5ndGg7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSByZW1vdmVDb250cm9sc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBpcyByZXNwb25zaWJsZSBmb3IgcmVtb3ZpbmcgY29udHJvbHMuXG5cdCAqIEBwYXJhbXMge25vbmV9IE5vIHBhcmFtZXRlcnMgbmVlZGVkLlxuXHQgKi9cbiAgICB0aGlzLnJlbW92ZUNvbnRyb2xzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuY29udHJvbHMgfHwgIXRoaXMuY29udHJvbHMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuY29udHJvbHMuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbCkgeyBjb250cm9sLmRpc2FibGUoKTsgfSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSByZW1vdmVHYW1lcGFkXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIGEgZ2FtZXBhZCBmcm9tIHRoZSBsaXN0IG9mIGNvbm5lY3RlZCBnYW1lcGFkcyBhbmQgdHJpZ2dlcnMgdGhlIG9uRGlzY29ubmVjdCBldmVudC4gRmlyZXMgYSBjdXN0b20gZXZlbnQgJ2dhbWVwYWQucmVtb3ZlJyB3aXRoIHRoZSBnYW1lcGFkIG9iamVjdC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGdhbWVwYWQgLSBUaGUgZ2FtZXBhZCBvYmplY3QgdG8gYmUgcmVtb3ZlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgZmFsc2UgaWYgdGhlIGdhbWVwYWQgaXMgbm90IGZvdW5kIGluIHRoZSBsaXN0LlxuXHQgKi9cbiAgICB0aGlzLnJlbW92ZUdhbWVwYWQgPSBmdW5jdGlvbiAoZ2FtZXBhZCkge1xuICAgICAgICBpZiAoIXRoaXMuZ2FtZXBhZHNbZ2FtZXBhZC5pbmRleF0pIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5nYW1lcGFkc1tnYW1lcGFkLmluZGV4XS5vbkRpc2Nvbm5lY3QoZ2FtZXBhZCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLmdhbWVwYWRzW2dhbWVwYWQuaW5kZXhdXG4gICAgICAgIHRoaXMuZmlyZSgnZ2FtZXBhZC5yZW1vdmUnLCB7IGdhbWVwYWQ6IGdhbWVwYWQgfSk7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSByZW1vdmVGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBzcGVjaWZpZWQgZmVhdHVyZXMgZnJvbSB0aGUgbWFwLiBJZiBubyBsYXllcnMgYXJlIHByb3ZpZGVkLCBhbGwgZmVhdHVyZXMgYXJlIHJlbW92ZWQuIElmIHRoZSBsYXllcnMgcGFyYW1ldGVyIGlzIG5vdCBhbiBhcnJheSwgdGhlIGZ1bmN0aW9uIHJldHVybnMgZmFsc2UuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGxheWVycyAtIEFuIGFycmF5IG9mIGxheWVycyB0byByZW1vdmUgZmVhdHVyZXMgZnJvbS5cblx0ICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBBZGRpdGlvbmFsIG9wdGlvbnMgZm9yIHJlbW92aW5nIGZlYXR1cmVzLlxuXHQgKi9cbiAgICB0aGlzLnJlbW92ZUZlYXR1cmVzID0gZnVuY3Rpb24gKGxheWVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWxheWVycykgcmV0dXJuIHRoaXMuRmVhdHVyZXMuZGVsZXRlRmVhdHVyZXMoKTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGxheWVycykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5GZWF0dXJlcy5yZW1vdmVGZWF0dXJlcyhsYXllcnMsIHRydWUpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgcmVtb3ZlRmVhdHVyZVxuXHQgKiBAZGVzY3JpcHRpb24gUmVtb3ZlcyBhIGZlYXR1cmUgZnJvbSB0aGUgRmVhdHVyZXMgY29sbGVjdGlvbiBhbmQgZmlyZXMgYW4gZXZlbnQgaWYgZWRpdCBtb2RlIGlzIG5vdCBlbmFibGVkLiBGaXJlcyBhIGN1c3RvbSBldmVudCAnZmVhdHVyZS5kZWxldGUnIHdpdGggdGhlIElEIGFuZCBmZWF0dXJlIG9iamVjdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gVGhlIElEIG9mIHRoZSBmZWF0dXJlIHRvIGJlIHJlbW92ZWQuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gZWRpdCAtIEEgZmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgZWRpdCBtb2RlIGlzIGVuYWJsZWQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmVhdHVyZSB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQsIG90aGVyd2lzZSBmYWxzZS5cblx0ICovXG4gICAgdGhpcy5yZW1vdmVGZWF0dXJlID0gZnVuY3Rpb24gKGlkLCBlZGl0KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gaWQgPyB0aGlzLkZlYXR1cmVzLnJlbW92ZUZlYXR1cmVzKGlkLCBlZGl0KSA6IGZhbHNlO1xuICAgICAgICAhZWRpdCA/IHRoaXMuZmlyZSgnZmVhdHVyZS5kZWxldGUnLCB7IGlkOiBpZCwgZmVhdHVyZTogcmVtb3ZlZCB9KSA6IGZhbHNlO1xuICAgICAgICByZXR1cm4gcmVtb3ZlZDtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHJlbW92ZVBvcHVwXG5cdCAqIEBkZXNjcmlwdGlvbiBSZW1vdmVzIHRoZSBwb3B1cCBlbGVtZW50IGZyb20gdGhlIERPTS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwb3B1cCB3YXMgc3VjY2Vzc2Z1bGx5IHJlbW92ZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0ICovXG4gICAgdGhpcy5yZW1vdmVQb3B1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdXAgJiYgdGhpcy5wb3B1cC5yZW1vdmUgPyB0aGlzLnBvcHVwLnJlbW92ZSgpIDogdGhpcy5jdXJyZW50TW9kZS5wb3B1cCAmJiB0aGlzLmN1cnJlbnRNb2RlLnBvcHVwLnJlbW92ZSA/IHRoaXMuY3VycmVudE1vZGUucG9wdXAucmVtb3ZlKCkgOiBmYWxzZTtcbiAgICB9XG5cblxuXG5cblxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSB1cGRhdGVNZXNoRGF0YVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiB1cGRhdGVzIHRoZSBtZXNoIGRhdGEgb24gdGhlIG1hcCBieSBhZGRpbmcgbmV3IGZlYXR1cmVzIHRvIHRoZSBtZXNoIGluZGV4IGFuZCB1cGRhdGluZyB0aGUgbWFwIHNvdXJjZSB3aXRoIHRoZSBuZXcgZGF0YS4gSWYgdGhlIG1lc2ggaW5kZXggaXMgbm90IGF2YWlsYWJsZSBvciB0aGUgcmVzZXQgZmxhZyBpcyBzZXQgdG8gdHJ1ZSwgdGhlIG1lc2ggaW5kZXggaXMgcmVzZXQgYmVmb3JlIGFkZGluZyBuZXcgZmVhdHVyZXMuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGZlYXR1cmVzIC0gQW4gYXJyYXkgb2YgZmVhdHVyZXMgdG8gYmUgYWRkZWQgdG8gdGhlIG1lc2ggaW5kZXguXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVzZXQgLSBBIGZsYWcgaW5kaWNhdGluZyB3aGV0aGVyIHRvIHJlc2V0IHRoZSBtZXNoIGluZGV4IGJlZm9yZSBhZGRpbmcgbmV3IGZlYXR1cmVzLlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgdXBkYXRlZCBmZWF0dXJlIGNvbGxlY3Rpb24gdGhhdCB3YXMgc2V0IG9uIHRoZSBtYXAgc291cmNlLlxuXHQgKi9cbiAgICB0aGlzLnVwZGF0ZU1lc2hEYXRhID0gZnVuY3Rpb24gKGZlYXR1cmVzPVtdLCByZXNldCkge1xuICAgICAgICBpZiAoIXRoaXMubWVzaEluZGV4IHx8IHJlc2V0KSB0aGlzLm1lc2hJbmRleCA9IG5ldyBNZXNoKFtdKTtcbiAgICAgICAgdGhpcy5tZXNoSW5kZXguYWRkTmV3RmVhdHVyZXMoZmVhdHVyZXMpO1xuXG4gICAgICAgIHZhciBzb3VyY2UgPSB0aGlzLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuTUVTSDtcbiAgICAgICAgdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbih0aGlzLm1lc2hJbmRleC5nZXRGZWF0dXJlcygpKTtcblxuICAgICAgICB0aGlzLm1hcC5nZXRTb3VyY2Uoc291cmNlKS5zZXREYXRhKGZlYXR1cmVzKTtcbiAgICAgICAgdGhpcy5maXJlKCdtZXNoLnVwZGF0ZScsIHsgZmVhdHVyZXM6IGZlYXR1cmVzIH0pO1xuICAgICAgICByZXR1cm4gZmVhdHVyZXM7XG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSB1cGRhdGVTZWxlY3RlZFByb3BlcnRpZXNcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gdXBkYXRlcyB0aGUgc2VsZWN0ZWQgcHJvcGVydGllcyBvZiBmZWF0dXJlcyBiYXNlZCBvbiB0aGUgbmV3IHByb3BlcnRpZXMgcHJvdmlkZWQgd2hpbGUga2VlcGluZyBzcGVjaWZpZWQgcHJvcGVydGllcy5cblx0ICogQHBhcmFtIHtPYmplY3R9IG5ld1Byb3BlcnRpZXMgLSBUaGUgbmV3IHByb3BlcnRpZXMgdG8gdXBkYXRlIHRoZSBmZWF0dXJlcyB3aXRoLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBwcm9wZXJ0aWVzVG9LZWVwIC0gQW4gYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgdG8ga2VlcCB3aGlsZSB1cGRhdGluZyB0aGUgZmVhdHVyZXMuXG5cdCAqL1xuICAgIHRoaXMudXBkYXRlU2VsZWN0ZWRQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG5ld1Byb3BlcnRpZXMsIHByb3BlcnRpZXNUb0tlZXApIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkuZm9yRWFjaCgoZmVhdHVyZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZWRJZCA9IGZlYXR1cmUucGFyZW50IHx8IGZlYXR1cmUucHJvcGVydGllcy5wYXJlbnQgfHwgZmVhdHVyZS5pZCB8fCBmZWF0dXJlLnByb3BlcnRpZXMuaWQ7XG4gICAgICAgICAgICBjb25zdCBiYXNlUHJvcGVydGllcyA9IHt9O1xuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzVG9LZWVwLmZvckVhY2goKHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLnByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSkgYmFzZVByb3BlcnRpZXNbcHJvcGVydHlOYW1lXSA9IGZlYXR1cmUucHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcyA9IE9iamVjdC5hc3NpZ24oYmFzZVByb3BlcnRpZXMsIG5ld1Byb3BlcnRpZXMsIHsgaWQ6IHNhdmVkSWQgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgdXBkYXRlT3JpZW50YXRpb25cblx0ICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIG9yaWVudGF0aW9uIG9mIHRoZSB1c2VyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBvcHRpb25zLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvcHRpb25zIGZvciB1cGRhdGluZyB0aGUgb3JpZW50YXRpb24uXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBsb2NhdGlvbiBvZiB0aGUgdXNlciBhZnRlciB1cGRhdGluZyB0aGUgb3JpZW50YXRpb24uXG5cdCAqL1xuICAgIHRoaXMudXBkYXRlT3JpZW50YXRpb24gPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBpZiAoIXRoaXMuTG9jYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXMuTG9jYXRlLnVwZGF0ZShvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuTG9jYXRlLmxvY2F0ZTtcbiAgICB9XG5cbiAgICAvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cbiAgICAgKiBAbmFtZSB1cGRhdGVGZWF0dXJlc1xuICAgICAqIEBkZXNjcmlwdGlvbiBVcGRhdGVzIHRoZSBmZWF0dXJlcyBvZiBhIGxheWVyIGJhc2VkIG9uIHRoZSBwcm92aWRlZCBmZWF0dXJlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBmZWF0dXJlcyAtIEFuIGFycmF5IG9mIGZlYXR1cmVzIHRvIHVwZGF0ZSB0aGUgbGF5ZXIgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSB1cGRhdGVkIGZlYXR1cmVzIG9mIHRoZSBsYXllci5cbiAgICAgKi9cbiAgICB0aGlzLnVwZGF0ZUZlYXR1cmVzID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkZlYXR1cmVzLnVwZGF0ZUZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICB9XG5cbiAgICBcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgc2F2ZUZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIHRoZSBmZWF0dXJlcyBvZiBhIGxheWVyIGZvciBleHBvcnQgaW4gZGlmZmVyZW50IGZvcm1hdHMgc3VjaCBhcyBLTVosIEdQWCwgYW5kIEdlb0pTT04uIEl0IHN0eWxlcyB0aGUgZmVhdHVyZXMsIGNyZWF0ZXMgbmVjZXNzYXJ5IG1ldGFkYXRhLCBhbmQgZ2VuZXJhdGVzIHRoZSBleHBvcnQgZmlsZXMuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciAtIFRoZSBsYXllciBvYmplY3QgY29udGFpbmluZyB0aGUgZmVhdHVyZXMgdG8gYmUgZXhwb3J0ZWQuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLnNhdmVGZWF0dXJlcyA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgICBjb25zdCBpZCA9IHRoaXMuaWQ7XG4gICAgICAgIHZhciBmYywgZm9sZGVyTmFtZTtcblxuICAgICAgICBpZiAoIWxheWVyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTZWxlY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgIGZvbGRlck5hbWUgPSAnU2VsZWN0ZWQgRmVhdHVyZXMnO1xuICAgICAgICAgICAgICAgIGZjID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbih0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMoKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvbGRlck5hbWUgPSBmb2xkZXJOYW1lID0gJ0FsbCBGZWF0dXJlcyc7XG4gICAgICAgICAgICAgICAgZmMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKHRoaXMuRmVhdHVyZXMuZ2V0Q29sZEZlYXR1cmVzKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFsYXllci5pZCB8fCAhbGF5ZXIubmFtZSkgcmV0dXJuIHdpbmRvdy5hbGVydCgnTGF5ZXIgSUQgYW5kIE5hbWUgYXJlIHJlcXVpcmVkIScpO1xuICAgICAgICAgICAgZm9sZGVyTmFtZSA9IGxheWVyLm5hbWUgKyAnLScgKyBsYXllci5pZDtcbiAgICAgICAgICAgIGZjID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbih0aGlzLkZlYXR1cmVzLmdldEZlYXR1cmVzQnlMYXllcihsYXllcikpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFmYy5mZWF0dXJlcy5sZW5ndGgpIHJldHVybiB3aW5kb3cuYWxlcnQoJ05vIEZlYXR1cmVzIHRvIEV4cG9ydCEnKTtcblxuICAgICAgICB2YXIgZmVhdHVyZXMgPSBnZW9mbG8uVXRpbGl0aWVzLmNsb25lRGVlcChmYy5mZWF0dXJlcyk7XG5cblx0XHRmZWF0dXJlcyA9IGZlYXR1cmVzLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgZi5zdHlsZSA9IHt9O1xuICAgICAgICAgICAgZi5zdHlsZVsnc3Ryb2tlJ10gPSBmLnByb3BlcnRpZXMuc3R5bGUgJiYgZi5wcm9wZXJ0aWVzLnN0eWxlLnByaW1hcnlDb2xvciA/IGYucHJvcGVydGllcy5zdHlsZS5wcmltYXJ5Q29sb3IgOiB0aGlzLm9wdGlvbnMuY29sb3JzLnByaW1hcnlDb2xvcjtcbiAgICAgICAgICAgIGYuc3R5bGVbJ3N0cm9rZS13aWR0aCddID0gMztcbiAgICAgICAgICAgIGYuc3R5bGVbJ2ZpbGwnXSA9IGYucHJvcGVydGllcy5zdHlsZSAmJiBmLnByb3BlcnRpZXMuc3R5bGUuc2Vjb25kYXJ5Q29sb3IgPyBmLnByb3BlcnRpZXMuc3R5bGUuc2Vjb25kYXJ5Q29sb3IgOiB0aGlzLm9wdGlvbnMuY29sb3JzLnNlY29uZGFyeUNvbG9yO1xuICAgICAgICAgICAgZi5zdHlsZVsnZmlsbC1vcGFjaXR5J10gPSAxO1xuXHRcdFx0XG4gICAgICAgICAgICBmLnByb3BlcnRpZXMuaWQgPSBmLmlkO1xuICAgICAgICAgICAgZi5wcm9wZXJ0aWVzLnVuaXQgPSBmLmdlb21ldHJ5LnVuaXQ7XG4gICAgICAgICAgICBmLnByb3BlcnRpZXMudW5pdHMgPSBmLmdlb21ldHJ5LnVuaXRzO1xuXG4gICAgICAgICAgICBkZWxldGUgZi5wcm9wZXJ0aWVzLnN0eWxlO1xuICAgICAgICAgICAgZGVsZXRlIGYuZ2VvbWV0cnkudW5pdDtcbiAgICAgICAgICAgIGRlbGV0ZSBmLmdlb21ldHJ5LnVuaXRzO1xuXG5cdFx0XHRyZXR1cm4gZjtcblx0XHR9LCB0aGlzKTtcblxuICAgICAgICBmYyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMpO1xuXG4gICAgICAgIHZhciBkID0gbmV3IERhdGUoKTtcbiAgICAgICAgdmFyIG5hbWUgPSBpZCArIFwiX2V4cG9ydCAtIFwiICsgKGQuZ2V0TW9udGgoKSArIDEpICsgXCIuXCIgKyBkLmdldERhdGUoKSArIFwiLlwiICsgZC5nZXRGdWxsWWVhcigpICsgXCJfXCIgKyBkLmdldEhvdXJzKCkgKyBkLmdldE1pbnV0ZXMoKTtcblxuICAgICAgICBjb25zdCBleHRlbnNpb25zID0gWydrbXonLCAnZ3B4JywgJ2dlb2pzb24nXTtcbiAgICAgICAgY29uc3QgemlwID0gbmV3IHdpbmRvdy5KU1ppcCgpO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHtcblx0XHRcdElkOiB0aGlzLmlkLFxuICAgICAgICAgICAgVmVyc2lvbjogdGhpcy52ZXJzaW9uLFxuXHRcdFx0RmVhdHVyZXM6IGZjLmZlYXR1cmVzLmxlbmd0aFxuXHRcdH1cblxuICAgICAgICBleHRlbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvbGRlciA9IHppcC5mb2xkZXIoZm9sZGVyTmFtZSArICcgJyArIHQudG9VcHBlckNhc2UoKSk7XG5cblx0XHRcdHN3aXRjaCAodCkge1xuXHRcdFx0XHRjYXNlICdrbXonOlxuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFibGVCb2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGJvZHknKTtcbiAgICAgICAgICAgICAgICAgICAgdGFibGUuYXBwZW5kQ2hpbGQodGFibGVCb2R5KTtcblxuXHRcdFx0XHRcdE9iamVjdC5lbnRyaWVzKGRlc2NyaXB0aW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChlbnRyeSkge1xuXHRcdFx0XHRcdFx0dmFyIGggPSBlbnRyeVswXTtcblx0XHRcdFx0XHRcdHZhciBkID0gZW50cnlbMV07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0cicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RoJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlci50ZXh0Q29udGVudCA9IGggKyAnOiAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS50ZXh0Q29udGVudCA9IGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZChoZWFkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGRhdGEpO1xuXG5cdFx0XHRcdFx0XHR0YWJsZUJvZHkuYXBwZW5kQ2hpbGQocm93KTtcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdHZhciBrbWwgPSBvbW5pdm9yZS50b0tNTChmYywge1xuXHRcdFx0XHRcdFx0bmFtZTogJ2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpbXBsZXN0eWxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0ZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLklkLFxuXHRcdFx0XHRcdFx0ZG9jdW1lbnROYW1lOiBmb2xkZXJOYW1lLFxuXHRcdFx0XHRcdFx0ZG9jdW1lbnREZXNjcmlwdGlvbjogdGFibGUuaW5uZXJIVE1MXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0XHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtrbWxdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vdm5kLmdvb2dsZS1lYXJ0aC5rbWwreG1sXCIgfSk7XG5cdFx0XHRcdFx0Zm9sZGVyLmZpbGUoZm9sZGVyTmFtZS50b0xvd2VyQ2FzZSgpICsgXCIua21sXCIsIGJsb2IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdncHgnOlxuXHRcdFx0XHRcdGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGYpIHtcblx0XHRcdFx0XHRcdHZhciB0aXRsZSA9IGYuaWQ7XG5cdFx0XHRcdFx0XHR2YXIgZmVhdHVyZSA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW2ZdKTtcblx0XHRcdFx0XHRcdHZhciBncHggPSBvbW5pdm9yZS50b0dQWChmZWF0dXJlLCB7XG5cdFx0XHRcdFx0XHRcdGNyZWF0b3I6IGRlc2NyaXB0aW9uLklkLFxuXHRcdFx0XHRcdFx0XHRmZWF0dXJlVGl0bGU6IGZ1bmN0aW9uIChwKSB7IHJldHVybiBwLmlkOyB9XG5cdFx0XHRcdFx0XHR9KVxuXG5cdFx0XHRcdFx0XHRmb2xkZXIuZmlsZShmb2xkZXJOYW1lLnRvTG93ZXJDYXNlKCkgKyAnXycgKyB0aXRsZSArIFwiLmdweFwiLCBncHgpO1xuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2dlb2pzb24nOlxuXHRcdFx0XHRcdHZhciBnZW9qc29uID0gZmM7XG5cdFx0XHRcdFx0dmFyIGJsb2IgPSBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkoZ2VvanNvbildLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vZ2VvanNvblwiIH0pO1xuXHRcdFx0XHRcdGZvbGRlci5maWxlKGZvbGRlck5hbWUudG9Mb3dlckNhc2UoKSArIFwiLmdlb2pzb25cIiwgYmxvYik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSlcblxuICAgICAgICB6aXAuZ2VuZXJhdGVBc3luYyh7IHR5cGU6IFwiYmxvYlwiIH0pLnRoZW4oZnVuY3Rpb24gKGNvbnRlbnQpIHtcbiAgICAgICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoW2NvbnRlbnRdLCB7IHR5cGU6IFwiYXBwbGljYXRpb24vemlwO2NoYXJzZXQ9dXRmLThcIiB9KTtcblxuICAgICAgICAgICAgd2luZG93Lmdlb2Zsby5maXJlKCdmZWF0dXJlcy5leHBvcnQnLCB7IGZlYXR1cmVzOiBmZWF0dXJlcywgYmxvYjogYmxvYiwgZGF0ZTogZCwgbmFtZTogbmFtZSB9KTtcblxuICAgICAgICAgICAgdmFyIHRlbXBMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgICAgICB0ZW1wTGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKTtcbiAgICAgICAgICAgIHRlbXBMaW5rLnNldEF0dHJpYnV0ZSgnZG93bmxvYWQnLCBuYW1lICsgXCIuemlwXCIpO1xuICAgICAgICAgICAgdGVtcExpbmsuY2xpY2soKTtcbiAgICAgICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGVtcExpbmsuaHJlZik7XG4gICAgICAgIH0pO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgbG9hZEZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgYW4gaW5wdXQgZWxlbWVudCBvZiB0eXBlIGZpbGUsIGFsbG93cyBtdWx0aXBsZSBmaWxlIHNlbGVjdGlvbiwgYW5kIHRyaWdnZXJzIGEgZmlsZSBzZWxlY3Rpb24gZXZlbnQuIEl0IHRoZW4gcHJvY2Vzc2VzIHRoZSBzZWxlY3RlZCBmaWxlcyBieSBjYWxsaW5nIHRoZSBVdGlsaXRpZXMucHJvY2Vzc0ZpbGVzIGZ1bmN0aW9uLlxuXHQgKiBAcGFyYW1zIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IHRyaWdnZXJlZCBieSBmaWxlIHNlbGVjdGlvbi5cblx0ICogQHJldHVybnMge3ZvaWR9XG5cdCAqL1xuICAgIHRoaXMubG9hZEZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIGlucHV0LnR5cGUgPSAnZmlsZSc7XG4gICAgICAgIGlucHV0LnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgaGFuZGxlU2VsZWN0aW9uLCBmYWxzZSk7XG4gICAgICAgIGlucHV0LmNsaWNrKCk7XG5cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlU2VsZWN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBmaWxlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IGV2ZW50LnRhcmdldC5maWxlcy5sZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGZpbGVzLnB1c2goZXZlbnQudGFyZ2V0LmZpbGVzW3hdKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZ2VvZmxvLlV0aWxpdGllcy5wcm9jZXNzRmlsZXMoZmlsZXMsIHByb2Nlc3NGaWxlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwcm9jZXNzRmlsZXMgKGZpbGUsIG5hbWUsIGV4dCkge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgICAgIFxuICAgICAgICAgICAgaWYgKGV4dCA9PT0gJ2dlb2pzb24nIHx8IGV4dCA9PT0gJ2pzb24nKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZXMgPSBKU09OLnBhcnNlKGZpbGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvbW5pdm9yZVtleHRdKSB7XG4gICAgICAgICAgICAgICAgb21uaXZvcmVbZXh0XS5wYXJzZShmaWxlLCBudWxsLCB7IGFkZERhdGE6IGZ1bmN0aW9uIChmZWF0cykgeyBmZWF0dXJlcyA9IGZlYXRzOyB9IH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxlcnQoXCJGaWxlIHR5cGUgbm90IHN1cHBvcnRlZDogXCIgKyBleHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZmVhdHVyZXMuZmVhdHVyZXMpIGZlYXR1cmVzID0gZmVhdHVyZXMuZmVhdHVyZXM7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmVhdHVyZXMpKSBmZWF0dXJlcyA9IFtmZWF0dXJlc107XG5cbiAgICAgICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnByb3BlcnRpZXMuaW1wb3J0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlLnNvdXJjZSA9IGZlYXR1cmUuc291cmNlIHx8IGZlYXR1cmUucHJvcGVydGllcy5zb3VyY2UgfHwgZ2VvZmxvLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuQ09MRDtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGdlb2Zsby5maXJlKCdmZWF0dXJlcy5pbXBvcnQnLCB7IGZlYXR1cmVzOiBmZWF0dXJlcywgZmlsZTogZmlsZSwgZXh0OiBleHQsIG5hbWU6IG5hbWUgfSlcbiAgICAgICAgICAgIGdlb2Zsby5hZGRGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgbW92ZU1hcEFsb25nTGluZVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBhbmltYXRlcyB0aGUgbW92ZW1lbnQgb2YgdGhlIG1hcCBhbG9uZyBhIHNwZWNpZmllZCBsaW5lLiBUaGUgY2FtZXJhIGZvbGxvd3MgdGhlIHJvdXRlLCBlbnN1cmluZyBzeW5jaHJvbml6ZWQgbW92ZW1lbnQuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGxpbmUgLSBUaGUgbGluZSByZXByZXNlbnRpbmcgdGhlIHJvdXRlIG9uIHRoZSBtYXAuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLm1vdmVNYXBBbG9uZ0xpbmUgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgICBpZiAoIWxpbmUpIHJldHVybjtcblxuICAgICAgICBjb25zdCBhbmltYXRpb25EdXJhdGlvbiA9IDgwMDAwO1xuICAgICAgICBjb25zdCBjYW1lcmFBbHRpdHVkZSA9IDQwMDA7XG4gICAgICAgIC8vIGdldCB0aGUgb3ZlcmFsbCBkaXN0YW5jZSBvZiBlYWNoIHJvdXRlIHNvIHdlIGNhbiBpbnRlcnBvbGF0ZSBhbG9uZyB0aGVtXG4gICAgICAgIGNvbnN0IHJvdXRlRGlzdGFuY2UgPSB0dXJmLmxpbmVEaXN0YW5jZShsaW5lKTtcbiAgICAgICAgY29uc3QgY2FtZXJhUm91dGVEaXN0YW5jZSA9IHR1cmYubGluZURpc3RhbmNlKGxpbmUpO1xuXG4gICAgICAgIGxldCBzdGFydDtcblxuICAgICAgICBjb25zb2xlLmxvZyhsaW5lLCByb3V0ZURpc3RhbmNlLCBjYW1lcmFSb3V0ZURpc3RhbmNlKVxuXG4gICAgICAgIGZ1bmN0aW9uIGZyYW1lKHRpbWUpIHtcbiAgICAgICAgICAgIGlmICghc3RhcnQpIHN0YXJ0ID0gdGltZTtcbiAgICAgICAgICAgIC8vIHBoYXNlIGRldGVybWluZXMgaG93IGZhciB0aHJvdWdoIHRoZSBhbmltYXRpb24gd2UgYXJlXG4gICAgICAgICAgICBjb25zdCBwaGFzZSA9ICh0aW1lIC0gc3RhcnQpIC8gYW5pbWF0aW9uRHVyYXRpb247XG5cbiAgICAgICAgICAgIC8vIHBoYXNlIGlzIG5vcm1hbGl6ZWQgYmV0d2VlbiAwIGFuZCAxXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBhbmltYXRpb24gaXMgZmluaXNoZWQsIHJlc2V0IHN0YXJ0IHRvIGxvb3AgdGhlIGFuaW1hdGlvblxuICAgICAgICAgICAgaWYgKHBoYXNlID4gMSkge1xuICAgICAgICAgICAgICAgIC8vIHdhaXQgMS41IHNlY29uZHMgYmVmb3JlIGxvb3BpbmdcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSAwLjA7XG4gICAgICAgICAgICAgICAgfSwgMTUwMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHVzZSB0aGUgcGhhc2UgdG8gZ2V0IGEgcG9pbnQgdGhhdCBpcyB0aGUgYXBwcm9wcmlhdGUgZGlzdGFuY2UgYWxvbmcgdGhlIHJvdXRlXG4gICAgICAgICAgICAvLyB0aGlzIGFwcHJvYWNoIHN5bmNzIHRoZSBjYW1lcmEgYW5kIHJvdXRlIHBvc2l0aW9ucyBlbnN1cmluZyB0aGV5IG1vdmVcbiAgICAgICAgICAgIC8vIGF0IHJvdWdobHkgZXF1YWwgcmF0ZXMgZXZlbiBpZiB0aGV5IGRvbid0IGNvbnRhaW4gdGhlIHNhbWUgbnVtYmVyIG9mIHBvaW50c1xuICAgICAgICAgICAgY29uc3QgYWxvbmdSb3V0ZSA9IHR1cmYuYWxvbmcoIHR1cmYubGluZVN0cmluZyhsaW5lKSwgcm91dGVEaXN0YW5jZSAqIHBoYXNlICkuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBjb25zdCBhbG9uZ0NhbWVyYSA9IHR1cmYuYWxvbmcoIHR1cmYubGluZVN0cmluZyhsaW5lKSwgY2FtZXJhUm91dGVEaXN0YW5jZSAqIHBoYXNlICkuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBjb25zdCBjYW1lcmEgPSBnZW9mbG8ubWFwLmdldEZyZWVDYW1lcmFPcHRpb25zKCk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aGUgcG9zaXRpb24gYW5kIGFsdGl0dWRlIG9mIHRoZSBjYW1lcmFcbiAgICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbiA9IG1hcGJveGdsLk1lcmNhdG9yQ29vcmRpbmF0ZS5mcm9tTG5nTGF0KHsgbG5nOiBhbG9uZ0NhbWVyYVswXSwgbGF0OiBhbG9uZ0NhbWVyYVsxXSB9LCBjYW1lcmFBbHRpdHVkZSApO1xuXG4gICAgICAgICAgICAvLyB0ZWxsIHRoZSBjYW1lcmEgdG8gbG9vayBhdCBhIHBvaW50IGFsb25nIHRoZSByb3V0ZVxuICAgICAgICAgICAgY2FtZXJhLmxvb2tBdFBvaW50KHtcbiAgICAgICAgICAgICAgICBsbmc6IGFsb25nUm91dGVbMF0sXG4gICAgICAgICAgICAgICAgbGF0OiBhbG9uZ1JvdXRlWzFdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgZ2VvZmxvLm1hcC5zZXRGcmVlQ2FtZXJhT3B0aW9ucyhjYW1lcmEpO1xuXG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWUpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgcmVmcmVzaE1lc2hEYXRhXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHJlZnJlc2hlcyB0aGUgbWVzaCBkYXRhIGJ5IHRyaWdnZXJpbmcgYSAnc25hcHBpbmcucmVmcmVzaCcgZXZlbnQgd2l0aCB0aGUgY3VycmVudCBtZXNoIGZlYXR1cmVzLlxuXHQgKiBAcGFyYW1zIHt2b2lkfSAtIE5vIHBhcmFtZXRlcnMgbmVlZGVkIGZvciB0aGlzIGZ1bmN0aW9uLlxuXHQgKi9cbiAgICB0aGlzLnJlZnJlc2hNZXNoRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLm1lc2hJbmRleCkgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5tYXBNb3ZpbmcpIHJldHVybjtcbiAgICAgICAgLy90aGlzLmRlbGV0ZU1lc2hEYXRhKCk7XG4gICAgICAgIC8vdGhpcy5hZGRGZWF0dXJlc1RvTWVzaCh0aGlzLmdldERyYXduRmVhdHVyZXMoKSlcbiAgICAgICAgdGhpcy5maXJlKCdzbmFwcGluZy5yZWZyZXNoJywgeyBmZWF0dXJlczogdGhpcy5tZXNoSW5kZXguZ2V0RmVhdHVyZXMoKSB9KVxuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZGVsZXRlTWVzaERhdGFcblx0ICogQGRlc2NyaXB0aW9uIERlbGV0ZXMgdGhlIG1lc2ggZGF0YSBieSB1cGRhdGluZyBpdCB3aXRoIGFuIGVtcHR5IGFycmF5IGFuZCB0cmlnZ2VyaW5nIGEgJ3NuYXBwaW5nLmRlbGV0ZScgZXZlbnQgd2l0aCB0aGUgZmVhdHVyZXMgZnJvbSB0aGUgbWVzaCBpbmRleC5cblx0ICogQHBhcmFtcyB7QXJyYXl9IGZlYXR1cmVzIC0gVGhlIGZlYXR1cmVzIHRvIHVwZGF0ZSB0aGUgbWVzaCBkYXRhIHdpdGguXG5cdCAqIEBwYXJhbXMge0Jvb2xlYW59IHRyaWdnZXJFdmVudCAtIEEgZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIHRvIHRyaWdnZXIgdGhlICdzbmFwcGluZy5kZWxldGUnIGV2ZW50LlxuXHQgKi9cbiAgICB0aGlzLmRlbGV0ZU1lc2hEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU1lc2hEYXRhKFtdLCB0cnVlKTtcbiAgICAgICAgdGhpcy5maXJlKCdzbmFwcGluZy5kZWxldGUnLCB7IGZlYXR1cmVzOiB0aGlzLm1lc2hJbmRleC5nZXRGZWF0dXJlcygpIH0pXG4gICAgfVxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBkZWxldGVVc2VyRGF0YVxuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBhbGxvd3MgdGhlIHVzZXIgdG8gZGVsZXRlIHNlbGVjdGVkIGZlYXR1cmVzIG9yIGFsbCBmZWF0dXJlcyBiYXNlZCBvbiBjb25maXJtYXRpb24gcHJvbXB0cy4gSXQgdXBkYXRlcyB0aGUgbWFwIGRhdGEgYW5kIHJlc2V0cyB2YXJpb3VzIHByb3BlcnRpZXMuXG5cdCAqIEBwYXJhbXMge3ZvaWR9IC0gTm8gcGFyYW1ldGVycyByZXF1aXJlZC5cblx0ICogQHJldHVybnMge3ZvaWR9IC0gTm8gcmV0dXJuIHZhbHVlLlxuXHQgKi9cbiAgICB0aGlzLmRlbGV0ZVVzZXJEYXRhID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRcblxuICAgICAgICBpZiAodGhpcy5oYXNTaW5nbGVTZWxlY3Rpb24oKSkge1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25maXJtKCdEZWxldGUgU2VsZWN0ZWQgRmVhdHVyZT8nKSkge1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKClbMF07XG4gICAgICAgICAgICAgICAgaWQgPSBmZWF0dXJlLnBhcmVudCB8fCBmZWF0dXJlLnByb3BlcnRpZXMucGFyZW50IHx8IGZlYXR1cmUuaWQgfHwgZmVhdHVyZS5wcm9wZXJ0aWVzLmlkO1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0aW9uKGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLkZlYXR1cmVzLnJlbW92ZUZlYXR1cmVzKGlkLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc2hJbmRleCA/IHRoaXMubWVzaEluZGV4LnJlbW92ZUZlYXR1cmUoaWQpIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdmZWF0dXJlLmRlbGV0ZScsIHsgZmVhdHVyZXM6IHRoaXMuRmVhdHVyZXMuZ2V0Q29sZEZlYXR1cmVzKCksIGlkOiBpZCwgZmVhdHVyZTogZmVhdHVyZSB9KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNvbmZpcm0oJ0RlbGV0ZSBBbGwgRmVhdHVyZXM/JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLkZlYXR1cmVzLmRlbGV0ZUZlYXR1cmVzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlKCdmZWF0dXJlcy5kZWxldGUnLCB7IGZlYXR1cmVzOiB0aGlzLkZlYXR1cmVzLmdldENvbGRGZWF0dXJlcygpIH0pXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5ob3RGZWF0dXJlID0gbnVsbDtcbiAgICAgICAgdGhpcy5zbmFwRmVhdHVyZSA9IG51bGw7XG4gICAgICAgIHRoaXMubGFzdENsaWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5maXJzdENsaWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5kcmF3U3RhcnRlZCA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5tYXAuZ2V0U291cmNlKHRoaXMuc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5TTkFQKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW10pKTtcbiAgICAgICAgdGhpcy5tYXAuZ2V0U291cmNlKHRoaXMuc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5IT1QpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuICAgICAgICB0aGlzLm1hcC5nZXRTb3VyY2UodGhpcy5zdGF0aWNzLmNvbnN0YW50cy5zb3VyY2VzLkhPVFRFWFQpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXSkpO1xuXG4gICAgICAgIGlmICh0aGlzLmVkaXRNb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNldE1vZGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuZG91YmxlQ2xpY2tab29tID0ge1xuICAgICAgICBlbmFibGUobWFwKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hcCB8fCAhbWFwLmRvdWJsZUNsaWNrWm9vbSkgcmV0dXJuO1xuICAgICAgICAgICAgICAgIG1hcC5kb3VibGVDbGlja1pvb20uZW5hYmxlKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGlzYWJsZShtYXApIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghbWFwIHx8ICFtYXAuZG91YmxlQ2xpY2tab29tKSByZXR1cm47XG4gICAgICAgICAgICAgICAgbWFwLmRvdWJsZUNsaWNrWm9vbS5kaXNhYmxlKCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIFxuXG5cdC8qKlxuXHQgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuXHQgKiBAbmFtZSBoaWRlU2VsZWN0ZWRGZWF0dXJlc1xuXHQgKiBAZGVzY3JpcHRpb24gVGhpcyBmdW5jdGlvbiBoaWRlcyB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMgb24gdGhlIG1hcCBieSBtb3ZpbmcgdGhlbSB0byBhIGhpZGRlbiBmZWF0dXJlcyBhcnJheSBhbmQgdXBkYXRpbmcgdGhlIG1hcCBzb3VyY2VzLlxuXHQgKiBAcGFyYW1zIHtBcnJheX0gaGlkZGVuRmVhdHVyZXMgLSBBcnJheSB0byBzdG9yZSB0aGUgaGlkZGVuIGZlYXR1cmVzLlxuXHQgKiBAcGFyYW1zIHtBcnJheX0gc2VsZWN0ZWRGZWF0dXJlcyAtIEFycmF5IG9mIHNlbGVjdGVkIGZlYXR1cmVzIG9uIHRoZSBtYXAuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmhpZGVTZWxlY3RlZEZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoaGlkZGVuRmVhdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkucHVzaCguLi5oaWRkZW5GZWF0dXJlcyk7XG4gICAgICAgICAgICBoaWRkZW5GZWF0dXJlcy5zcGxpY2UoMCwgaGlkZGVuRmVhdHVyZXMubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc1NlbGVjdGlvbigpKSB7XG4gICAgICAgICAgICBoaWRkZW5GZWF0dXJlcy5wdXNoKC4uLnRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlcygpLnNwbGljZSgwLCB0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMoKS5sZW5ndGgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubWFwLmdldFNvdXJjZSh0aGlzLnN0YXRpY3MuY29uc3RhbnRzLnNvdXJjZXMuU0VMRUNUKS5zZXREYXRhKHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24odGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkpKTtcbiAgICAgICAgdGhpcy5tYXAuZ2V0U291cmNlKHRoaXMuc3RhdGljcy5jb25zdGFudHMuc291cmNlcy5WRVJURVgpLnNldERhdGEodHVyZi5mZWF0dXJlQ29sbGVjdGlvbih0aGlzLmdldFNlbGVjdGVkRmVhdHVyZXMoKSkpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgY29tYmluZVNlbGVjdGVkRmVhdHVyZXNcblx0ICogQGRlc2NyaXB0aW9uIENvbWJpbmVzIHNlbGVjdGVkIGZlYXR1cmVzIGJhc2VkIG9uIHRoZWlyIGdlb21ldHJ5IHR5cGUuXG5cdCAqIEBwYXJhbXMge3ZvaWR9XG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmNvbWJpbmVTZWxlY3RlZEZlYXR1cmVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLnN0YXRpY3MuY29uc3RhbnRzLm1vZGVzLlNFTEVDVCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxsRmVhdHVyZXNUeXBlID0gdGhpcy5nZXRDb21tb25HZW9tZXRyeVR5cGUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxGZWF0dXJlc1R5cGUgPT09IFwiUG9seWdvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2x5Z29ucyA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yRWFjaFNlbGVjdGVkRmVhdHVyZShmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2x5Z29ucy5wdXNoLmFwcGx5KHBvbHlnb25zLCBjb25zdW1hYmxlQXJyYXkocG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcykpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocG9seWdvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GZWF0dXJlcy5hZGRGZWF0dXJlcyhbdHVyZi5wb2x5Z29uKHBvbHlnb25zLCB0aGlzLmdldFNlbGVjdGVkUHJvcGVydHlWYWx1ZXMoKSldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlU2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFsbEZlYXR1cmVzVHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGdlb2Zsby5VdGlsaXRpZXMuY29tYmluZVNhbWVUeXBlRmVhdHVyZXModGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5GZWF0dXJlcy5hZGRGZWF0dXJlcyhbdHVyZi5saW5lU3RyaW5nKGNvb3JkcywgdGhpcy5nZXRTZWxlY3RlZFByb3BlcnR5VmFsdWVzKCkpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk9ubHkgb2JqZWN0cyBvZiB0aGUgc2FtZSB0eXBlIGNhbiBiZSBjb21iaW5lZCwgXCIgKyBcImkuZS4gbGluZXMgd2l0aCBsaW5lcyBhbmQgcG9seWdvbnMgd2l0aCBwb2x5Z29uc1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiQ29tYmluZSBjYW4gb25seSBiZSBleGVjdXRlZCBpbiBzZWxlY3Rpb24gbW9kZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgbW92ZVNlbGVjdGVkRmVhdHVyZXNcblx0ICogQGRlc2NyaXB0aW9uIFRoaXMgZnVuY3Rpb24gY2hlY2tzIGlmIG1vdmluZyBpcyBlbmFibGVkIGFuZCBpZiB0aGVyZSBhcmUgc2VsZWN0ZWQgZmVhdHVyZXMgb2YgTGluZVN0cmluZyB0eXBlLiBJZiBzbywgaXQgb2Zmc2V0cyB0aGUgc2VsZWN0ZWQgTGluZVN0cmluZyBmZWF0dXJlcyBieSB0aGUgc3BlY2lmaWVkIGRpc3RhbmNlIGluIHRoZSBwcm92aWRlZCBkaXJlY3Rpb24uXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRvIG1vdmUgdGhlIHNlbGVjdGVkIGZlYXR1cmVzICgxIGZvciBmb3J3YXJkLCAtMSBmb3IgYmFja3dhcmQpLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBtb3ZpbmcgaXMgbm90IGVuYWJsZWQgb3IgdGhlcmUgYXJlIG5vIHNlbGVjdGVkIExpbmVTdHJpbmcgZmVhdHVyZXMuXG5cdCAqL1xuICAgIHRoaXMubW92ZVNlbGVjdGVkRmVhdHVyZXMgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm1vdmluZyB8fCAhdGhpcy5vcHRpb25zLm1vdmluZy5lbmFibGUpIHsgcmV0dXJuIGZhbHNlIH1cbiAgICAgICAgdmFyIGRpc3RhbmNlID0gdGhpcy5vcHRpb25zLm1vdmluZy5kaXN0YW5jZTtcblxuICAgICAgICBpZiAodGhpcy5tb2RlID09PSB0aGlzLnN0YXRpY3MuY29uc3RhbnRzLm1vZGVzLlNFTEVDVCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzU2VsZWN0aW9uKCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWxsRmVhdHVyZXNUeXBlID0gdGhpcy5nZXRDb21tb25HZW9tZXRyeVR5cGUoKTtcblxuICAgICAgICAgICAgICAgIGlmIChhbGxGZWF0dXJlc1R5cGUgPT09IFwiTGluZVN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXdTZWxlY3RlZEZlYXR1cmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yRWFjaFNlbGVjdGVkRmVhdHVyZShmdW5jdGlvbihmZWF0dXJlKSB7IG5ld1NlbGVjdGVkRmVhdHVyZXMucHVzaCh0dXJmLmxpbmVPZmZzZXQoZmVhdHVyZSwgZGlzdGFuY2UgKiBkaXJlY3Rpb24pKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VsZWN0ZWRGZWF0dXJlcyhuZXdTZWxlY3RlZEZlYXR1cmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIG1vdmVGZWF0dXJlXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGNhbGN1bGF0ZXMgdGhlIG5ldyBjb29yZGluYXRlcyBvZiBhIGZlYXR1cmUgYmFzZWQgb24gdGhlIGRpcmVjdGlvbiBhbmQgZGlzdGFuY2UgcHJvdmlkZWQuIE5PVCBXT1JLSU5HIFlFVC5cblx0ICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmUgLSBUaGUgZmVhdHVyZSBvYmplY3QgdG8gYmUgbW92ZWQuXG5cdCAqIEBwYXJhbSB7bnVtYmVyfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIGluIHdoaWNoIHRoZSBmZWF0dXJlIHNob3VsZCBiZSBtb3ZlZCAoMSBmb3IgZm9yd2FyZCwgLTEgZm9yIGJhY2t3YXJkKS5cblx0ICogQHJldHVybnMge0FycmF5fSBBbiBhcnJheSBvZiBuZXcgY29vcmRpbmF0ZXMgZm9yIHRoZSBmZWF0dXJlIGFmdGVyIG1vdmluZy5cblx0ICovXG4gICAgdGhpcy5tb3ZlRmVhdHVyZSA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tb3ZpbmcgfHwgIXRoaXMub3B0aW9ucy5tb3ZpbmcuZW5hYmxlKSByZXR1cm4gZmFsc2VcbiAgICAgICAgXG4gICAgICAgIHZhciBkaXN0YW5jZSA9IHRoaXMub3B0aW9ucy5tb3ZpbmcuZGlzdGFuY2U7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFyIGxhc3REZXN0aW5hdGlvblBvaW50ID0gbnVsbDtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICB2YXIgbW92ZUJlYXJpbmcgPSAwO1xuICAgICAgICAgICAgdmFyIHN0YXJ0UG9pbnQgPSBudWxsO1xuICAgICAgICAgICAgdmFyIG1pZGRsZVBvaW50ID0gY29vcmRpbmF0ZXNbaW5kZXhdO1xuXG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kUG9pbnQgPSBjb29yZGluYXRlc1tpbmRleCArIDFdO1xuICAgICAgICAgICAgICAgIHZhciBzZWNvbmRCZWFyaW5nID0gdHVyZi5iZWFyaW5nKG1pZGRsZVBvaW50LCBlbmRQb2ludCk7XG4gICAgICAgICAgICAgICAgbW92ZUJlYXJpbmcgPSBzZWNvbmRCZWFyaW5nIC0gOTA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vdmVCZWFyaW5nIDwgLTE4MCkge1xuICAgICAgICAgICAgICAgICAgICBtb3ZlQmVhcmluZyArPSAxODA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleCA9PT0gY29vcmRpbmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBjb29yZGluYXRlc1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBmaXJzdEJlYXJpbmcgPSB0dXJmLmJlYXJpbmcobWlkZGxlUG9pbnQsIHN0YXJ0UG9pbnQpO1xuICAgICAgICAgICAgICAgIG1vdmVCZWFyaW5nID0gZmlyc3RCZWFyaW5nIC0gOTA7XG5cbiAgICAgICAgICAgICAgICBpZiAobW92ZUJlYXJpbmcgPCAtMTgwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVCZWFyaW5nICs9IDE4MDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXJ0UG9pbnQgPSBjb29yZGluYXRlc1tpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgIHZhciBfZW5kUG9pbnQgPSBjb29yZGluYXRlc1tpbmRleCArIDFdO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9maXJzdEJlYXJpbmcgPSB0dXJmLmJlYXJpbmcobWlkZGxlUG9pbnQsIHN0YXJ0UG9pbnQpO1xuICAgICAgICAgICAgICAgIHZhciBfc2Vjb25kQmVhcmluZyA9IHR1cmYuYmVhcmluZyhtaWRkbGVQb2ludCwgX2VuZFBvaW50KTtcblxuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IDA7XG5cbiAgICAgICAgICAgICAgICBpZiAoX2ZpcnN0QmVhcmluZyA8IDAgJiYgX3NlY29uZEJlYXJpbmcgPCAwIHx8IF9maXJzdEJlYXJpbmcgPiAwICYmIF9zZWNvbmRCZWFyaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhbmdsZSA9IE1hdGguYWJzKE1hdGguYWJzKF9maXJzdEJlYXJpbmcpIC0gTWF0aC5hYnMoX3NlY29uZEJlYXJpbmcpKTtcbiAgICAgICAgICAgICAgICAgICAgbW92ZUJlYXJpbmcgPSBfZmlyc3RCZWFyaW5nIDwgMCA/IF9maXJzdEJlYXJpbmcgLSBhbmdsZSAvIDIgOiBfZmlyc3RCZWFyaW5nICsgYW5nbGUgLyAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hYnMoTWF0aC5hYnMoX2ZpcnN0QmVhcmluZykgKyBNYXRoLmFicyhfc2Vjb25kQmVhcmluZykpO1xuICAgICAgICAgICAgICAgICAgICBtb3ZlQmVhcmluZyA9IF9maXJzdEJlYXJpbmcgPCAwID8gX2ZpcnN0QmVhcmluZyAtIGFuZ2xlIC8gMiA6IChhbmdsZSAvIDIgLSBfZmlyc3RCZWFyaW5nKSAqIC0xO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRlc3RpbmF0aW9uUG9pbnQgPSB0dXJmLmRlc3RpbmF0aW9uKG1pZGRsZVBvaW50LCBkaXJlY3Rpb24gKiBkaXN0YW5jZSwgbW92ZUJlYXJpbmcpO1xuXG4gICAgICAgICAgICBpZiAobGFzdERlc3RpbmF0aW9uUG9pbnQgJiYgc3RhcnRQb2ludCkge1xuICAgICAgICAgICAgICAgIHZhciBjcm9zc2luZ0xpbmUgPSB0dXJmLmxpbmVTdHJpbmcoW2xhc3REZXN0aW5hdGlvblBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBkZXN0aW5hdGlvblBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzXSk7XG4gICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdEZjID0gdHVyZi5saW5lSW50ZXJzZWN0KHR1cmYubGluZVN0cmluZyhbc3RhcnRQb2ludCwgbWlkZGxlUG9pbnRdKSwgY3Jvc3NpbmdMaW5lKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RGYy5mZWF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uUG9pbnQgPSB0dXJmLmRlc3RpbmF0aW9uKG1pZGRsZVBvaW50LCBkaXJlY3Rpb24gKiAtZGlzdGFuY2UsIG1vdmVCZWFyaW5nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlc3RpbmF0aW9uUG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgbGFzdERlc3RpbmF0aW9uUG9pbnQgPSBkZXN0aW5hdGlvblBvaW50O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBcblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgZm9yRWFjaFNlbGVjdGVkRmVhdHVyZVxuXHQgKiBAZGVzY3JpcHRpb24gSXRlcmF0ZXMgb3ZlciBlYWNoIHNlbGVjdGVkIGZlYXR1cmUgYW5kIGFwcGxpZXMgYSBoYW5kbGVyIGZ1bmN0aW9uIHRvIGl0LlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIC0gVGhlIGZ1bmN0aW9uIHRvIGJlIGFwcGxpZWQgdG8gZWFjaCBzZWxlY3RlZCBmZWF0dXJlLlxuXHQgKiBAcmV0dXJucyB7dm9pZH1cblx0ICovXG4gICAgdGhpcy5mb3JFYWNoU2VsZWN0ZWRGZWF0dXJlID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkuZm9yRWFjaChoYW5kbGVyKTtcbiAgICB9XG5cblx0LyoqXG5cdCAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG5cdCAqIEBuYW1lIHpvb21Ub0ZlYXR1cmVzXG5cdCAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIHpvb21zIHRvIHRoZSBwcm92aWRlZCBmZWF0dXJlcyBvbiB0aGUgbWFwLiBJZiBubyBmZWF0dXJlcyBhcmUgcHJvdmlkZWQsIGl0IHpvb21zIHRvIHRoZSBzZWxlY3RlZCBmZWF0dXJlcywgY29sZCBmZWF0dXJlcywgb3IgdGhlIG1hcCBleHRlbnQgaWYgbm8gb3RoZXIgZmVhdHVyZXMgYXJlIGF2YWlsYWJsZS5cblx0ICogQHBhcmFtIHtBcnJheX0gZmVhdHVyZXMgLSBUaGUgZmVhdHVyZXMgdG8gem9vbSB0byBvbiB0aGUgbWFwLlxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEFkZGl0aW9uYWwgb3B0aW9ucyBmb3Igem9vbWluZyAoZGVmYXVsdDoge30pLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBmYWxzZSBpZiBubyBmZWF0dXJlcyBhcmUgYXZhaWxhYmxlIHRvIHpvb20gdG8uXG5cdCAqL1xuICAgIHRoaXMuem9vbVRvRmVhdHVyZXMgPSBmdW5jdGlvbiAoZmVhdHVyZXMsIG9wdGlvbnM9e30pIHtcbiAgICAgICAgZmVhdHVyZXMgPSBmZWF0dXJlcyB8fCAodGhpcy5oYXNTZWxlY3Rpb24oKSA/IHRoaXMuZ2V0U2VsZWN0ZWRGZWF0dXJlcygpIDogdGhpcy5nZXREcmF3bkZlYXR1cmVzKCkpO1xuICAgICAgICB0aGlzLnNldEV4dGVudChmZWF0dXJlcywgZmFsc2UsIG9wdGlvbnMpO1xuICAgIH1cblxuXHQvKipcblx0ICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cblx0ICogQG5hbWUgY3JlYXRlUG9seWdvblxuXHQgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIHBvbHlnb24gZnJvbSBzZWxlY3RlZCBMaW5lU3RyaW5nIGZlYXR1cmVzIGFuZCBhZGRzIGl0IHRvIHRoZSBtYXAuXG5cdCAqIEBwYXJhbXMge0FycmF5fSBzZWxlY3RlZEZlYXR1cmVzIC0gQW4gYXJyYXkgb2Ygc2VsZWN0ZWQgZmVhdHVyZXMgdG8gYmUgY29tYmluZWQgaW50byBhIHBvbHlnb24uXG5cdCAqIEBwYXJhbXMge09iamVjdH0gc2VsZWN0ZWRQcm9wZXJ0eVZhbHVlcyAtIFByb3BlcnR5IHZhbHVlcyBvZiB0aGUgc2VsZWN0ZWQgZmVhdHVyZXMuXG5cdCAqIEByZXR1cm5zIHt2b2lkfVxuXHQgKi9cbiAgICB0aGlzLmNyZWF0ZVBvbHlnb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vZGUgPT09IHRoaXMuc3RhdGljcy5jb25zdGFudHMubW9kZXMuU0VMRUNUKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNTZWxlY3Rpb24oKSkge1xuICAgICAgICAgICAgICAgIHZhciBhbGxGZWF0dXJlc1R5cGUgPSB0aGlzLmdldENvbW1vbkdlb21ldHJ5VHlwZSgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFsbEZlYXR1cmVzVHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvb3JkcyA9IGdlb2Zsby5VdGlsaXRpZXMuY29tYmluZVNhbWVUeXBlRmVhdHVyZXModGhpcy5nZXRTZWxlY3RlZEZlYXR1cmVzKCkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFnZW9mbG8uVXRpbGl0aWVzLmlzUG9pbnRFcXVhbChjb29yZHNbMF0sIGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRzLnB1c2goY29vcmRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRGZWF0dXJlc1RvU2VsZWN0ZWQoW3R1cmYucG9seWdvbihbY29vcmRzXSwgdGhpcy5nZXRTZWxlY3RlZFByb3BlcnR5VmFsdWVzKCkpXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk9ubHkgb2JqZWN0cyBvZiB0eXBlIExpbmVTdHJpbmcgY2FuIGJlIGNvbWJpbmVkIGludG8gYSBwb2x5Z29uXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJDcmVhdGUgcG9seWdvbiBjYW4gb25seSBiZSBleGVjdXRlZCBpbiBzZWxlY3Rpb24gbW9kZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgb25Mb2FkXG4gICAgICogQG1lbWJlck9mIG1vZHVsZTpnZW9mbG9cbiAgICAgKiBAZGVzY3JpcHRpb24gSGFuZGxlcyB0aGUgbG9hZGluZyBvZiBhIE1hcGJveEdMIG1hcCBvYmplY3QsIHNldHRpbmcgdXAgdGhlIGNvbnRhaW5lciBhbmQgZXZlbnQgbGlzdGVuZXJzLCBhbmQgY29uZmlndXJpbmcgbWFwIG9wdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IHRyaWdnZXJlZCBvbiBsb2FkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC50YXJnZXQgLSBUaGUgdGFyZ2V0IG9iamVjdCB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnQsIGV4cGVjdGVkIHRvIGJlIGEgTWFwYm94R0wgbWFwIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtYXAgaGFzIGZpbmlzaGVkIGxvYWRpbmcuXG4gICAgICovXG4gICAgdGhpcy5vbkxvYWQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFldmVudC50YXJnZXQgfHwgIWV2ZW50LnRhcmdldC5nZXRDb250YWluZXIpIHRocm93IG5ldyBFcnJvcignTWFwYm94R0wgbWFwIG9iamVjdCBpcyByZXF1aXJlZCEnKTtcblxuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGV2ZW50LnRhcmdldC5fY29udGFpbmVyO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID8gdGhpcy5jb250YWluZXIuaW5zZXJ0QmVmb3JlKHRoaXMudmlld3BvcnQsIHRoaXMuY29udGFpbmVyLmZpcnN0Q2hpbGQpIDogZmFsc2U7XG5cbiAgICAgICAgZXZlbnQudGFyZ2V0Lm9mZignc3R5bGUubG9hZCcsIHRoaXMub25TdHlsZUxvYWQuYmluZCh0aGlzKSk7XG4gICAgICAgIGV2ZW50LnRhcmdldC5vbignc3R5bGUubG9hZCcsIHRoaXMub25TdHlsZUxvYWQuYmluZCh0aGlzKSk7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXAubWF4UGl0Y2gpIGV2ZW50LnRhcmdldC5zZXRNYXhQaXRjaCh0aGlzLm9wdGlvbnMubWFwLm1heFBpdGNoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXAubWF4Wm9vbSkgZXZlbnQudGFyZ2V0LnNldE1heFpvb20odGhpcy5vcHRpb25zLm1hcC5tYXhab29tKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXAubWluUGl0Y2gpIGV2ZW50LnRhcmdldC5zZXRNaW5QaXRjaCh0aGlzLm9wdGlvbnMubWFwLm1pblBpdGNoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXAubWluWm9vbSkgZXZlbnQudGFyZ2V0LnNldE1pblpvb20odGhpcy5vcHRpb25zLm1hcC5taW5ab29tKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5sb2FkKGV2ZW50LnRhcmdldCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG5hbWUgb25TdHlsZUxvYWRcbiAgICAgKiBAbWVtYmVyT2YgbW9kdWxlOmdlb2Zsb1xuICAgICAqIEBkZXNjcmlwdGlvbiBIYW5kbGVzIHRoZSBzdHlsZSBsb2FkIGV2ZW50IGFuZCB0cmlnZ2VycyBhIHJlZHJhdyBhZnRlciBhIGRlbGF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGFzc29jaWF0ZWQgd2l0aCB0aGUgc3R5bGUgbG9hZC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLm9uU3R5bGVMb2FkID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGdlb2Zsby5yZWRyYXcoKTsgfSwgNTAwKVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBuYW1lIG9uTWFwTW92ZVxuICAgICAqIEBtZW1iZXJPZiBtb2R1bGU6Z2VvZmxvXG4gICAgICogQGRlc2NyaXB0aW9uIEhhbmRsZXMgdGhlIGV2ZW50IHRyaWdnZXJlZCB3aGVuIHRoZSBtYXAgaXMgbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBUaGUgZXZlbnQgb2JqZWN0IGNvbnRhaW5pbmcgaW5mb3JtYXRpb24gYWJvdXQgdGhlIG1hcCBtb3ZlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7dm9pZH0gVGhpcyBmdW5jdGlvbiBkb2VzIG5vdCByZXR1cm4gYSB2YWx1ZS5cbiAgICAgKi9cbiAgICB0aGlzLm9uTWFwTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuXG4gICAgfVxuXG4gICAgdGhpcy5pbml0aWFsaXplKCk7XG59O1xuXG5jb25zdCBnZW9mbG8gPSBuZXcgR2VvRmxvKCk7XG5cblV0aWxpdGllcy5wcm90b3R5cGUuZ2VvZmxvID0gZ2VvZmxvO1xuRmVhdHVyZXMucHJvdG90eXBlLmdlb2ZsbyA9IGdlb2ZsbztcbkxheWVycy5wcm90b3R5cGUuZ2VvZmxvID0gZ2VvZmxvO1xuQ29udHJvbC5wcm90b3R5cGUuZ2VvZmxvID0gZ2VvZmxvO1xuTG9jYXRlLnByb3RvdHlwZS5nZW9mbG8gPSBnZW9mbG87XG5NZXNoLnByb3RvdHlwZS5nZW9mbG8gPSBnZW9mbG87XG5EcmF3LnByb3RvdHlwZS5nZW9mbG8gPSBnZW9mbG87XG5TZWxlY3QucHJvdG90eXBlLmdlb2ZsbyA9IGdlb2ZsbztcbkdhbWVwYWQucHJvdG90eXBlLmdlb2ZsbyA9IGdlb2ZsbztcblN0eWxlcy5wcm90b3R5cGUuZ2VvZmxvID0gZ2VvZmxvO1xuU25hcHBpbmcucHJvdG90eXBlLmdlb2ZsbyA9IGdlb2ZsbztcblBpbm5pbmcucHJvdG90eXBlLmdlb2ZsbyA9IGdlb2ZsbztcblJvdXRpbmcucHJvdG90eXBlLmdlb2ZsbyA9IGdlb2ZsbztcbkV4cGxvcmluZy5wcm90b3R5cGUuZ2VvZmxvID0gZ2VvZmxvO1xuUGFpbnRpbmcucHJvdG90eXBlLmdlb2ZsbyA9IGdlb2ZsbztcblxuXG5hc3luYyBmdW5jdGlvbiBsb2FkU2NyaXB0KHVybCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godXJsKTtcblxuICAgICAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdFRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgICAgICAgIHNjcmlwdC50ZXh0Q29udGVudCA9IHNjcmlwdFRleHQ7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBzY3JpcHQgZnJvbSAke3VybH0uIFN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nIHNjcmlwdDogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZFN0eWxlc2hlZXQodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuXG4gICAgICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgY29uc3Qgc2NyaXB0VGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBzY3JpcHQudGV4dENvbnRlbnQgPSBzY3JpcHRUZXh0O1xuICAgICAgICAgICAgZG9jdW1lbnQuaGVhZC5wcmVwZW5kKHNjcmlwdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gbG9hZCBzY3JpcHQgZnJvbSAke3VybH0uIFN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBFcnJvciBsb2FkaW5nIHN0eWxlc2hlZXQ6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG59XG5cblxuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gICAgY29uc3QgZSA9IC8oaXBob25lfGlwb2R8aXBhZHxhbmRyb2lkfGllbW9iaWxlfGJsYWNrYmVycnl8YmFkYSkvLnRlc3Qod2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSk7XG4gICAgcmV0dXJuIGUgfHwgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5jbHVkZXMoXCJNYWNcIikgJiYgXCJvbnRvdWNoZW5kXCJpbiBkb2N1bWVudClcbn1cblxuYXN5bmMgZnVuY3Rpb24gcmVhZHkgKGlkKSB7XG4gICAgdmFyIGNvdW50ID0gMDtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHZhciByZWFkeSA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMTAwMDApIHtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHJlYWR5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSByZXR1cm4gY291bnQrKztcblxuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChyZWFkeSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShlbGVtZW50KTtcbiAgICAgICAgfSwgMSk7XG4gICAgfSlcbn1cblxuYXN5bmMgZnVuY3Rpb24gbG9hZGVkIChnZW9mbG8pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVhZHkgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghZ2VvZmxvLmlzTG9hZGVkKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHJlYWR5KTtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKGdlb2Zsby5pc0xvYWRlZCk7XG4gICAgICAgIH0sIDEpO1xuICAgIH0pXG59XG5cbmZ1bmN0aW9uIGJ1aWxkTWFwYm94ICgpIHtcbiAgICBjb25zdCBET00gPSB7XG4gICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gY3JlYXRlICh0YWdOYW1lLCBjbGFzc05hbWUsIGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgZWwgPSB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgIT09IHVuZGVmaW5lZCkgZWwuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcikgY29udGFpbmVyLmFwcGVuZENoaWxkKGVsKTtcbiAgICAgICAgICAgIHJldHVybiBlbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIHRvIGFkZCBhIFRvcC1DZW50ZXJcbiAgICBtYXBib3hnbC5NYXAucHJvdG90eXBlLl9zZXR1cENvbnRhaW5lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xuICAgICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZCgnbWFwYm94Z2wtbWFwJyk7XG5cbiAgICAgICAgY29uc3QgbWlzc2luZ0NTU0NhbmFyeSA9IHRoaXMuX21pc3NpbmdDU1NDYW5hcnkgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtY2FuYXJ5JywgY29udGFpbmVyKTtcbiAgICAgICAgbWlzc2luZ0NTU0NhbmFyeS5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIHRoaXMuX2RldGVjdE1pc3NpbmdDU1MoKTtcblxuICAgICAgICBjb25zdCBjYW52YXNDb250YWluZXIgPSB0aGlzLl9jYW52YXNDb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtY2FudmFzLWNvbnRhaW5lcicsIGNvbnRhaW5lcik7XG4gICAgICAgIGlmICh0aGlzLl9pbnRlcmFjdGl2ZSkge1xuICAgICAgICAgICAgY2FudmFzQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ21hcGJveGdsLWludGVyYWN0aXZlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9jYW52YXMgPSBET00uY3JlYXRlKCdjYW52YXMnLCAnbWFwYm94Z2wtY2FudmFzJywgY2FudmFzQ29udGFpbmVyKTtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgICAgICB0aGlzLl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2ViZ2xjb250ZXh0bG9zdCcsIHRoaXMuX2NvbnRleHRMb3N0LCBmYWxzZSk7XG4gICAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ3dlYmdsY29udGV4dHJlc3RvcmVkJywgdGhpcy5fY29udGV4dFJlc3RvcmVkLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJzAnKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRoaXMuX2dldFVJU3RyaW5nKCdNYXAuVGl0bGUnKSk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAncmVnaW9uJyk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQ29udGFpbmVyRGltZW5zaW9ucygpO1xuICAgICAgICB0aGlzLl9yZXNpemVDYW52YXModGhpcy5fY29udGFpbmVyV2lkdGgsIHRoaXMuX2NvbnRhaW5lckhlaWdodCk7XG5cbiAgICAgICAgY29uc3QgY29udHJvbENvbnRhaW5lciA9IHRoaXMuX2NvbnRyb2xDb250YWluZXIgPSBET00uY3JlYXRlKCdkaXYnLCAnbWFwYm94Z2wtY29udHJvbC1jb250YWluZXInLCBjb250YWluZXIpO1xuICAgICAgICBjb25zdCBwb3NpdGlvbnMgPSB0aGlzLl9jb250cm9sUG9zaXRpb25zID0ge307XG5cbiAgICAgICAgWyd0b3AtbGVmdCcsICd0b3AtcmlnaHQnLCAndG9wLWNlbnRlcicsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXS5mb3JFYWNoKChwb3NpdGlvbk5hbWUpID0+IHtcbiAgICAgICAgICAgIHBvc2l0aW9uc1twb3NpdGlvbk5hbWVdID0gRE9NLmNyZWF0ZSgnZGl2JywgYG1hcGJveGdsLWN0cmwtJHtwb3NpdGlvbk5hbWV9YCwgY29udHJvbENvbnRhaW5lcik7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgdGhpcy5fY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX29uTWFwU2Nyb2xsLCBmYWxzZSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBnZW9mbG8gYXMgZGVmYXVsdCB9Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9